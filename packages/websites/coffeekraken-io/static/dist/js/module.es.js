var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj2, key, value) => key in obj2 ? __defProp2(obj2, key, { enumerable: true, configurable: true, writable: true, value }) : obj2[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/controls/OrbitControls.js";
function plainObject$7(object) {
  if (!object)
    return false;
  if (typeof object !== "object")
    return false;
  if (object.constructor && object.constructor.name !== "Object")
    return false;
  if (Object.prototype.toString.call(object) !== "[object Object]")
    return false;
  if (object !== Object(object))
    return false;
  return true;
}
function __deepMerge$7(...args) {
  function merge2(firstObj, secondObj) {
    const newObj = {};
    if (!firstObj && secondObj)
      return secondObj;
    if (!secondObj && firstObj)
      return firstObj;
    if (!firstObj && !secondObj)
      return {};
    const firstProps = Object.getOwnPropertyNames(firstObj);
    firstProps.forEach((key) => {
      const desc = Object.getOwnPropertyDescriptor(firstObj, key);
      if (desc.set || desc.get) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = firstObj[key];
      }
    });
    const secondProps = Object.getOwnPropertyNames(secondObj);
    secondProps.forEach((key) => {
      const desc = Object.getOwnPropertyDescriptor(secondObj, key);
      if (desc.set || desc.get) {
        Object.defineProperty(newObj, key, desc);
      } else if (plainObject$7(newObj[key]) && plainObject$7(secondObj[key])) {
        newObj[key] = merge2(newObj[key], secondObj[key]);
      } else {
        newObj[key] = secondObj[key];
      }
    });
    return newObj;
  }
  let currentObj = {};
  for (let i2 = 0; i2 < args.length; i2++) {
    const toMergeObj = args[i2];
    currentObj = merge2(currentObj, toMergeObj);
  }
  return currentObj;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function lowerCase(str) {
  return str.toLowerCase();
}
var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
var DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
function noCase(input, options) {
  if (options === void 0) {
    options = {};
  }
  var _a2 = options.splitRegexp, splitRegexp = _a2 === void 0 ? DEFAULT_SPLIT_REGEXP : _a2, _b2 = options.stripRegexp, stripRegexp = _b2 === void 0 ? DEFAULT_STRIP_REGEXP : _b2, _c2 = options.transform, transform = _c2 === void 0 ? lowerCase : _c2, _d2 = options.delimiter, delimiter = _d2 === void 0 ? " " : _d2;
  var result = replace(replace(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
  var start = 0;
  var end = result.length;
  while (result.charAt(start) === "\0")
    start++;
  while (result.charAt(end - 1) === "\0")
    end--;
  return result.slice(start, end).split("\0").map(transform).join(delimiter);
}
function replace(input, re2, value) {
  if (re2 instanceof RegExp)
    return input.replace(re2, value);
  return re2.reduce(function(input2, re3) {
    return input2.replace(re3, value);
  }, input);
}
function dotCase(input, options) {
  if (options === void 0) {
    options = {};
  }
  return noCase(input, __assign({ delimiter: "." }, options));
}
function paramCase(input, options) {
  if (options === void 0) {
    options = {};
  }
  return dotCase(input, __assign({ delimiter: "-" }, options));
}
function dashCase(text) {
  return paramCase(text);
}
function wait$1(timeout = 0) {
  return new Promise((resolve2) => {
    setTimeout(() => {
      resolve2();
    }, timeout);
  });
}
function autoCast$1(string) {
  if (typeof string !== "string")
    return string;
  if (string.substr(0, 1) === "'" && string.substr(-1) === "'") {
    return string.substr(1, string.length - 2);
  }
  const presumedNumber = parseFloat(string);
  if (!isNaN(presumedNumber)) {
    if (presumedNumber.toString() === string) {
      return presumedNumber;
    }
  }
  if (window[string]) {
    return string;
  }
  try {
    const obj = eval(`(${string})`);
    return obj;
  } catch (e20) {
    return string;
  }
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var isClass = { exports: {} };
(function(module2, exports) {
  (function(root) {
    const toString3 = Function.prototype.toString;
    function fnBody(fn2) {
      return toString3.call(fn2).replace(/^[^{]*{\s*/, "").replace(/\s*}[^}]*$/, "");
    }
    function isClass2(fn2) {
      if (typeof fn2 !== "function") {
        return false;
      }
      if (/^class[\s{]/.test(toString3.call(fn2))) {
        return true;
      }
      const body = fnBody(fn2);
      return /classCallCheck\(/.test(body) || /TypeError\("Cannot call a class as a function"\)/.test(body);
    }
    {
      if (module2.exports) {
        exports = module2.exports = isClass2;
      }
      exports.isClass = isClass2;
    }
  })();
})(isClass, isClass.exports);
var __isClass = isClass.exports;
function cls(cls2) {
  if (!Array.isArray(cls2))
    cls2 = [cls2];
  for (let i2 = 0; i2 < cls2.length; i2++) {
    if (!__isClass(cls2[i2]))
      return false;
  }
  return true;
}
const fn$7 = function(cls$1, settings = {}) {
  const stack = {};
  if (!cls(cls$1)) {
    cls$1 = cls$1.constructor;
  }
  if (settings.includeBaseClass === true) {
    stack[cls$1.name] = cls$1;
  }
  let baseClass = cls$1;
  while (baseClass) {
    const newBaseClass = Object.getPrototypeOf(baseClass);
    if (newBaseClass && newBaseClass !== Object && newBaseClass.name) {
      stack[newBaseClass.name] = newBaseClass;
      baseClass = newBaseClass;
    } else {
      break;
    }
  }
  return stack;
};
function unique(array) {
  const a2 = array.concat();
  for (let i2 = 0; i2 < a2.length; ++i2) {
    for (let j2 = i2 + 1; j2 < a2.length; ++j2) {
      if (a2[i2] === a2[j2])
        a2.splice(j2--, 1);
    }
  }
  return a2;
}
var lodash_clone = { exports: {} };
(function(module2, exports) {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", promiseTag = "[object Promise]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reFlags = /\w*$/;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  function addMapEntry(map2, pair) {
    map2.set(pair[0], pair[1]);
    return map2;
  }
  function addSetEntry(set2, value) {
    set2.add(value);
    return set2;
  }
  function arrayEach(array, iteratee) {
    var index = -1, length = array ? array.length : 0;
    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }
  function arrayPush(array, values) {
    var index = -1, length = values.length, offset2 = array.length;
    while (++index < length) {
      array[offset2 + index] = values[index];
    }
    return array;
  }
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1, length = array ? array.length : 0;
    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }
  function baseTimes(n2, iteratee) {
    var index = -1, result = Array(n2);
    while (++index < n2) {
      result[index] = iteratee(index);
    }
    return result;
  }
  function getValue(object, key) {
    return object == null ? void 0 : object[key];
  }
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result = !!(value + "");
      } catch (e20) {
      }
    }
    return result;
  }
  function mapToArray(map2) {
    var index = -1, result = Array(map2.size);
    map2.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  function setToArray(set2) {
    var index = -1, result = Array(set2.size);
    set2.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }
  var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
  var coreJsData = root["__core-js_shared__"];
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  var Buffer2 = moduleExports ? root.Buffer : void 0, Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
  var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
  var DataView2 = getNative(root, "DataView"), Map2 = getNative(root, "Map"), Promise2 = getNative(root, "Promise"), Set2 = getNative(root, "Set"), WeakMap2 = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
  var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }
  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : void 0;
  }
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
  }
  function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
  }
  function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    return true;
  }
  function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? void 0 : data[index][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map2 || ListCache)(),
      "string": new Hash()
    };
  }
  function mapCacheDelete(key) {
    return getMapData(this, key)["delete"](key);
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function Stack(entries) {
    this.__data__ = new ListCache(entries);
  }
  function stackClear() {
    this.__data__ = new ListCache();
  }
  function stackDelete(key) {
    return this.__data__["delete"](key);
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  function stackSet(key, value) {
    var cache = this.__data__;
    if (cache instanceof ListCache) {
      var pairs = cache.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        return this;
      }
      cache = this.__data__ = new MapCache(pairs);
    }
    cache.set(key, value);
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys(value, inherited) {
    var result = isArray2(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
      object[key] = value;
    }
  }
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseAssign(object, source3) {
    return object && copyObject(source3, keys2(source3), object);
  }
  function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
    var result;
    if (customizer) {
      result = object ? customizer(value, key, object, stack) : customizer(value);
    }
    if (result !== void 0) {
      return result;
    }
    if (!isObject2(value)) {
      return value;
    }
    var isArr = isArray2(value);
    if (isArr) {
      result = initCloneArray(value);
      if (!isDeep) {
        return copyArray2(value, result);
      }
    } else {
      var tag2 = getTag(value), isFunc = tag2 == funcTag || tag2 == genTag;
      if (isBuffer2(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag2 == objectTag || tag2 == argsTag || isFunc && !object) {
        if (isHostObject(value)) {
          return object ? value : {};
        }
        result = initCloneObject(isFunc ? {} : value);
        if (!isDeep) {
          return copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag2]) {
          return object ? value : {};
        }
        result = initCloneByTag(value, tag2, baseClone, isDeep);
      }
    }
    stack || (stack = new Stack());
    var stacked = stack.get(value);
    if (stacked) {
      return stacked;
    }
    stack.set(value, result);
    if (!isArr) {
      var props = isFull ? getAllKeys(value) : keys2(value);
    }
    arrayEach(props || value, function(subValue, key2) {
      if (props) {
        key2 = subValue;
        subValue = value[key2];
      }
      assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
    });
    return result;
  }
  function baseCreate(proto2) {
    return isObject2(proto2) ? objectCreate(proto2) : {};
  }
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray2(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  function baseGetTag(value) {
    return objectToString.call(value);
  }
  function baseIsNative(value) {
    if (!isObject2(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction2(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var result = new buffer.constructor(buffer.length);
    buffer.copy(result);
    return result;
  }
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
    return result;
  }
  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }
  function cloneMap(map2, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(mapToArray(map2), true) : mapToArray(map2);
    return arrayReduce(array, addMapEntry, new map2.constructor());
  }
  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }
  function cloneSet(set2, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(setToArray(set2), true) : setToArray(set2);
    return arrayReduce(array, addSetEntry, new set2.constructor());
  }
  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  function copyArray2(source3, array) {
    var index = -1, length = source3.length;
    array || (array = Array(length));
    while (++index < length) {
      array[index] = source3[index];
    }
    return array;
  }
  function copyObject(source3, props, object, customizer) {
    object || (object = {});
    var index = -1, length = props.length;
    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source3[key], key, object, source3) : void 0;
      assignValue(object, key, newValue === void 0 ? source3[key] : newValue);
    }
    return object;
  }
  function copySymbols(source3, object) {
    return copyObject(source3, getSymbols(source3), object);
  }
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys2, getSymbols);
  }
  function getMapData(map2, key) {
    var data = map2.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : void 0;
  }
  var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
  var getTag = baseGetTag;
  if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
    getTag = function(value) {
      var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  function initCloneArray(array) {
    var length = array.length, result = array.constructor(length);
    if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
      result.index = array.index;
      result.input = array.input;
    }
    return result;
  }
  function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
  }
  function initCloneByTag(object, tag2, cloneFunc, isDeep) {
    var Ctor = object.constructor;
    switch (tag2) {
      case arrayBufferTag:
        return cloneArrayBuffer(object);
      case boolTag:
      case dateTag:
        return new Ctor(+object);
      case dataViewTag:
        return cloneDataView(object, isDeep);
      case float32Tag:
      case float64Tag:
      case int8Tag:
      case int16Tag:
      case int32Tag:
      case uint8Tag:
      case uint8ClampedTag:
      case uint16Tag:
      case uint32Tag:
        return cloneTypedArray(object, isDeep);
      case mapTag:
        return cloneMap(object, isDeep, cloneFunc);
      case numberTag:
      case stringTag:
        return new Ctor(object);
      case regexpTag:
        return cloneRegExp(object);
      case setTag:
        return cloneSet(object, isDeep, cloneFunc);
      case symbolTag:
        return cloneSymbol(object);
    }
  }
  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto2;
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e20) {
      }
      try {
        return func + "";
      } catch (e20) {
      }
    }
    return "";
  }
  function clone2(value) {
    return baseClone(value, false, true);
  }
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  }
  var isArray2 = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction2(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  var isBuffer2 = nativeIsBuffer || stubFalse;
  function isFunction2(value) {
    var tag2 = isObject2(value) ? objectToString.call(value) : "";
    return tag2 == funcTag || tag2 == genTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject2(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function keys2(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  function stubArray() {
    return [];
  }
  function stubFalse() {
    return false;
  }
  module2.exports = clone2;
})(lodash_clone, lodash_clone.exports);
var __clone = lodash_clone.exports;
var lodash_clonedeep = { exports: {} };
(function(module2, exports) {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", promiseTag = "[object Promise]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reFlags = /\w*$/;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  function addMapEntry(map2, pair) {
    map2.set(pair[0], pair[1]);
    return map2;
  }
  function addSetEntry(set2, value) {
    set2.add(value);
    return set2;
  }
  function arrayEach(array, iteratee) {
    var index = -1, length = array ? array.length : 0;
    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }
  function arrayPush(array, values) {
    var index = -1, length = values.length, offset2 = array.length;
    while (++index < length) {
      array[offset2 + index] = values[index];
    }
    return array;
  }
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1, length = array ? array.length : 0;
    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }
  function baseTimes(n2, iteratee) {
    var index = -1, result = Array(n2);
    while (++index < n2) {
      result[index] = iteratee(index);
    }
    return result;
  }
  function getValue(object, key) {
    return object == null ? void 0 : object[key];
  }
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result = !!(value + "");
      } catch (e20) {
      }
    }
    return result;
  }
  function mapToArray(map2) {
    var index = -1, result = Array(map2.size);
    map2.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  function setToArray(set2) {
    var index = -1, result = Array(set2.size);
    set2.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }
  var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
  var coreJsData = root["__core-js_shared__"];
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  var Buffer2 = moduleExports ? root.Buffer : void 0, Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
  var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
  var DataView2 = getNative(root, "DataView"), Map2 = getNative(root, "Map"), Promise2 = getNative(root, "Promise"), Set2 = getNative(root, "Set"), WeakMap2 = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
  var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }
  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : void 0;
  }
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
  }
  function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
  }
  function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    return true;
  }
  function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? void 0 : data[index][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map2 || ListCache)(),
      "string": new Hash()
    };
  }
  function mapCacheDelete(key) {
    return getMapData(this, key)["delete"](key);
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function Stack(entries) {
    this.__data__ = new ListCache(entries);
  }
  function stackClear() {
    this.__data__ = new ListCache();
  }
  function stackDelete(key) {
    return this.__data__["delete"](key);
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  function stackSet(key, value) {
    var cache = this.__data__;
    if (cache instanceof ListCache) {
      var pairs = cache.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        return this;
      }
      cache = this.__data__ = new MapCache(pairs);
    }
    cache.set(key, value);
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys(value, inherited) {
    var result = isArray2(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
      object[key] = value;
    }
  }
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseAssign(object, source3) {
    return object && copyObject(source3, keys2(source3), object);
  }
  function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
    var result;
    if (customizer) {
      result = object ? customizer(value, key, object, stack) : customizer(value);
    }
    if (result !== void 0) {
      return result;
    }
    if (!isObject2(value)) {
      return value;
    }
    var isArr = isArray2(value);
    if (isArr) {
      result = initCloneArray(value);
      if (!isDeep) {
        return copyArray2(value, result);
      }
    } else {
      var tag2 = getTag(value), isFunc = tag2 == funcTag || tag2 == genTag;
      if (isBuffer2(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag2 == objectTag || tag2 == argsTag || isFunc && !object) {
        if (isHostObject(value)) {
          return object ? value : {};
        }
        result = initCloneObject(isFunc ? {} : value);
        if (!isDeep) {
          return copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag2]) {
          return object ? value : {};
        }
        result = initCloneByTag(value, tag2, baseClone, isDeep);
      }
    }
    stack || (stack = new Stack());
    var stacked = stack.get(value);
    if (stacked) {
      return stacked;
    }
    stack.set(value, result);
    if (!isArr) {
      var props = isFull ? getAllKeys(value) : keys2(value);
    }
    arrayEach(props || value, function(subValue, key2) {
      if (props) {
        key2 = subValue;
        subValue = value[key2];
      }
      assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
    });
    return result;
  }
  function baseCreate(proto2) {
    return isObject2(proto2) ? objectCreate(proto2) : {};
  }
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray2(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  function baseGetTag(value) {
    return objectToString.call(value);
  }
  function baseIsNative(value) {
    if (!isObject2(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction2(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var result = new buffer.constructor(buffer.length);
    buffer.copy(result);
    return result;
  }
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
    return result;
  }
  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }
  function cloneMap(map2, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(mapToArray(map2), true) : mapToArray(map2);
    return arrayReduce(array, addMapEntry, new map2.constructor());
  }
  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }
  function cloneSet(set2, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(setToArray(set2), true) : setToArray(set2);
    return arrayReduce(array, addSetEntry, new set2.constructor());
  }
  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  function copyArray2(source3, array) {
    var index = -1, length = source3.length;
    array || (array = Array(length));
    while (++index < length) {
      array[index] = source3[index];
    }
    return array;
  }
  function copyObject(source3, props, object, customizer) {
    object || (object = {});
    var index = -1, length = props.length;
    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source3[key], key, object, source3) : void 0;
      assignValue(object, key, newValue === void 0 ? source3[key] : newValue);
    }
    return object;
  }
  function copySymbols(source3, object) {
    return copyObject(source3, getSymbols(source3), object);
  }
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys2, getSymbols);
  }
  function getMapData(map2, key) {
    var data = map2.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : void 0;
  }
  var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
  var getTag = baseGetTag;
  if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
    getTag = function(value) {
      var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  function initCloneArray(array) {
    var length = array.length, result = array.constructor(length);
    if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
      result.index = array.index;
      result.input = array.input;
    }
    return result;
  }
  function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
  }
  function initCloneByTag(object, tag2, cloneFunc, isDeep) {
    var Ctor = object.constructor;
    switch (tag2) {
      case arrayBufferTag:
        return cloneArrayBuffer(object);
      case boolTag:
      case dateTag:
        return new Ctor(+object);
      case dataViewTag:
        return cloneDataView(object, isDeep);
      case float32Tag:
      case float64Tag:
      case int8Tag:
      case int16Tag:
      case int32Tag:
      case uint8Tag:
      case uint8ClampedTag:
      case uint16Tag:
      case uint32Tag:
        return cloneTypedArray(object, isDeep);
      case mapTag:
        return cloneMap(object, isDeep, cloneFunc);
      case numberTag:
      case stringTag:
        return new Ctor(object);
      case regexpTag:
        return cloneRegExp(object);
      case setTag:
        return cloneSet(object, isDeep, cloneFunc);
      case symbolTag:
        return cloneSymbol(object);
    }
  }
  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto2;
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e20) {
      }
      try {
        return func + "";
      } catch (e20) {
      }
    }
    return "";
  }
  function cloneDeep(value) {
    return baseClone(value, true, true);
  }
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  }
  var isArray2 = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction2(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  var isBuffer2 = nativeIsBuffer || stubFalse;
  function isFunction2(value) {
    var tag2 = isObject2(value) ? objectToString.call(value) : "";
    return tag2 == funcTag || tag2 == genTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject2(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function keys2(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  function stubArray() {
    return [];
  }
  function stubFalse() {
    return false;
  }
  module2.exports = cloneDeep;
})(lodash_clonedeep, lodash_clonedeep.exports);
var __deepClone = lodash_clonedeep.exports;
function clone$2(object, settings = {}) {
  settings = Object.assign({ deep: false }, settings);
  if (settings.deep) {
    return __deepClone(object);
  }
  return __clone(object);
}
function deepAssign(referenceObj, ...objects) {
  const settings = {
    array: false,
    object: true,
    cloneChilds: true
  };
  function merge2(refObj, mixWithObj) {
    for (const key of Object.keys(mixWithObj)) {
      if (settings.array === true && Array.isArray(refObj[key]) && Array.isArray(mixWithObj[key])) {
        const newArray = unique([...refObj[key], ...mixWithObj[key]]);
        refObj[key] = newArray;
        continue;
      }
      if (settings.object === true && plainObject$7(refObj[key]) && plainObject$7(mixWithObj[key])) {
        refObj[key] = merge2(refObj[key], mixWithObj[key]);
        continue;
      }
      if (plainObject$7(mixWithObj[key]) && settings.cloneChilds) {
        refObj[key] = clone$2(mixWithObj[key], {
          deep: true
        });
      } else {
        refObj[key] = mixWithObj[key];
      }
    }
    return refObj;
  }
  const potentialSettingsObj = objects[objects.length - 1] || {};
  if (potentialSettingsObj.array && typeof potentialSettingsObj.array === "boolean" || potentialSettingsObj.object && typeof potentialSettingsObj.object === "boolean") {
    if (potentialSettingsObj.array !== void 0)
      settings.array = potentialSettingsObj.array;
    if (potentialSettingsObj.object !== void 0)
      settings.object = potentialSettingsObj.object;
    objects.pop();
  }
  for (let i2 = 0; i2 < objects.length; i2++) {
    const toMergeObj = objects[i2] || {};
    merge2(referenceObj, toMergeObj);
  }
  return referenceObj;
}
function unquote(string2, quotesToRemove = ['"', "'", "\u201D", "`"]) {
  string2 = string2.trim();
  quotesToRemove.forEach((quote) => {
    if (string2.substr(0, 1) === quote && string2.substr(-1) === quote) {
      string2 = string2.substr(1);
      string2 = string2.substr(0, string2.length - 1);
      return;
    }
  });
  return string2;
}
function get$3(obj2, path2, settings = {}) {
  settings = Object.assign({}, settings);
  if (obj2[path2] !== void 0)
    return obj2[path2];
  if (!path2 || path2 === "" || path2 === ".")
    return obj2;
  path2 = path2.replace(/\[(\w+)\]/g, ".$1");
  path2 = path2.replace(/^\./, "");
  let potentialPaths = [path2.replace(/\?/gm, "")];
  const parts = path2.split(".");
  for (let i2 = parts.length - 1; i2 >= 0; i2--) {
    const part = parts[i2];
    if (part.match(/\?$/)) {
      const before = parts.slice(0, i2);
      const after = parts.slice(i2 + 1);
      potentialPaths.push([...before, ...after].join("."));
      potentialPaths.push([...before, ...after.filter((a2) => !a2.match(/\?$/))].join("."));
    }
  }
  potentialPaths = unique(potentialPaths.map((s2) => s2.replace(/\?/gm, "")));
  for (let i2 = 0; i2 < potentialPaths.length; i2++) {
    const path3 = potentialPaths[i2];
    const result = __get(obj2, path3, settings);
    if (result !== void 0)
      return result;
  }
}
function __get(obj2, path2, settings = {}) {
  settings = Object.assign({}, settings);
  if (obj2[path2] !== void 0)
    return obj2[path2];
  if (!path2 || path2 === "" || path2 === ".")
    return obj2;
  const a2 = path2.split(/(?!\B"[^"]*)\.(?![^"]*"\B)/gm).map((p2) => unquote(p2));
  let o2 = obj2;
  while (a2.length) {
    const n2 = a2.shift().replace(/\?$/, "");
    if (typeof o2 !== "object" || !(n2 in o2)) {
      return;
    }
    o2 = o2[n2];
  }
  return o2;
}
var md5$1 = { exports: {} };
var core$1 = { exports: {} };
(function(module2, exports) {
  (function(root, factory) {
    {
      module2.exports = factory();
    }
  })(commonjsGlobal, function() {
    var CryptoJS = CryptoJS || function(Math2, undefined$1) {
      var crypto2;
      if (typeof window !== "undefined" && window.crypto) {
        crypto2 = window.crypto;
      }
      if (typeof self !== "undefined" && self.crypto) {
        crypto2 = self.crypto;
      }
      if (typeof globalThis !== "undefined" && globalThis.crypto) {
        crypto2 = globalThis.crypto;
      }
      if (!crypto2 && typeof window !== "undefined" && window.msCrypto) {
        crypto2 = window.msCrypto;
      }
      if (!crypto2 && typeof commonjsGlobal !== "undefined" && commonjsGlobal.crypto) {
        crypto2 = commonjsGlobal.crypto;
      }
      if (!crypto2 && typeof commonjsRequire === "function") {
        try {
          crypto2 = require("crypto");
        } catch (err) {
        }
      }
      var cryptoSecureRandomInt = function() {
        if (crypto2) {
          if (typeof crypto2.getRandomValues === "function") {
            try {
              return crypto2.getRandomValues(new Uint32Array(1))[0];
            } catch (err) {
            }
          }
          if (typeof crypto2.randomBytes === "function") {
            try {
              return crypto2.randomBytes(4).readInt32LE();
            } catch (err) {
            }
          }
        }
        throw new Error("Native crypto module could not be used to get secure random number.");
      };
      var create2 = Object.create || function() {
        function F2() {
        }
        return function(obj2) {
          var subtype;
          F2.prototype = obj2;
          subtype = new F2();
          F2.prototype = null;
          return subtype;
        };
      }();
      var C2 = {};
      var C_lib = C2.lib = {};
      var Base = C_lib.Base = function() {
        return {
          extend: function(overrides) {
            var subtype = create2(this);
            if (overrides) {
              subtype.mixIn(overrides);
            }
            if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
              subtype.init = function() {
                subtype.$super.init.apply(this, arguments);
              };
            }
            subtype.init.prototype = subtype;
            subtype.$super = this;
            return subtype;
          },
          create: function() {
            var instance = this.extend();
            instance.init.apply(instance, arguments);
            return instance;
          },
          init: function() {
          },
          mixIn: function(properties) {
            for (var propertyName in properties) {
              if (properties.hasOwnProperty(propertyName)) {
                this[propertyName] = properties[propertyName];
              }
            }
            if (properties.hasOwnProperty("toString")) {
              this.toString = properties.toString;
            }
          },
          clone: function() {
            return this.init.prototype.extend(this);
          }
        };
      }();
      var WordArray = C_lib.WordArray = Base.extend({
        init: function(words, sigBytes) {
          words = this.words = words || [];
          if (sigBytes != undefined$1) {
            this.sigBytes = sigBytes;
          } else {
            this.sigBytes = words.length * 4;
          }
        },
        toString: function(encoder) {
          return (encoder || Hex).stringify(this);
        },
        concat: function(wordArray) {
          var thisWords = this.words;
          var thatWords = wordArray.words;
          var thisSigBytes = this.sigBytes;
          var thatSigBytes = wordArray.sigBytes;
          this.clamp();
          if (thisSigBytes % 4) {
            for (var i2 = 0; i2 < thatSigBytes; i2++) {
              var thatByte = thatWords[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              thisWords[thisSigBytes + i2 >>> 2] |= thatByte << 24 - (thisSigBytes + i2) % 4 * 8;
            }
          } else {
            for (var j2 = 0; j2 < thatSigBytes; j2 += 4) {
              thisWords[thisSigBytes + j2 >>> 2] = thatWords[j2 >>> 2];
            }
          }
          this.sigBytes += thatSigBytes;
          return this;
        },
        clamp: function() {
          var words = this.words;
          var sigBytes = this.sigBytes;
          words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
          words.length = Math2.ceil(sigBytes / 4);
        },
        clone: function() {
          var clone2 = Base.clone.call(this);
          clone2.words = this.words.slice(0);
          return clone2;
        },
        random: function(nBytes) {
          var words = [];
          for (var i2 = 0; i2 < nBytes; i2 += 4) {
            words.push(cryptoSecureRandomInt());
          }
          return new WordArray.init(words, nBytes);
        }
      });
      var C_enc = C2.enc = {};
      var Hex = C_enc.Hex = {
        stringify: function(wordArray) {
          var words = wordArray.words;
          var sigBytes = wordArray.sigBytes;
          var hexChars = [];
          for (var i2 = 0; i2 < sigBytes; i2++) {
            var bite = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
            hexChars.push((bite >>> 4).toString(16));
            hexChars.push((bite & 15).toString(16));
          }
          return hexChars.join("");
        },
        parse: function(hexStr) {
          var hexStrLength = hexStr.length;
          var words = [];
          for (var i2 = 0; i2 < hexStrLength; i2 += 2) {
            words[i2 >>> 3] |= parseInt(hexStr.substr(i2, 2), 16) << 24 - i2 % 8 * 4;
          }
          return new WordArray.init(words, hexStrLength / 2);
        }
      };
      var Latin1 = C_enc.Latin1 = {
        stringify: function(wordArray) {
          var words = wordArray.words;
          var sigBytes = wordArray.sigBytes;
          var latin1Chars = [];
          for (var i2 = 0; i2 < sigBytes; i2++) {
            var bite = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
            latin1Chars.push(String.fromCharCode(bite));
          }
          return latin1Chars.join("");
        },
        parse: function(latin1Str) {
          var latin1StrLength = latin1Str.length;
          var words = [];
          for (var i2 = 0; i2 < latin1StrLength; i2++) {
            words[i2 >>> 2] |= (latin1Str.charCodeAt(i2) & 255) << 24 - i2 % 4 * 8;
          }
          return new WordArray.init(words, latin1StrLength);
        }
      };
      var Utf8 = C_enc.Utf8 = {
        stringify: function(wordArray) {
          try {
            return decodeURIComponent(escape(Latin1.stringify(wordArray)));
          } catch (e20) {
            throw new Error("Malformed UTF-8 data");
          }
        },
        parse: function(utf8Str) {
          return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
        }
      };
      var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
        reset: function() {
          this._data = new WordArray.init();
          this._nDataBytes = 0;
        },
        _append: function(data) {
          if (typeof data == "string") {
            data = Utf8.parse(data);
          }
          this._data.concat(data);
          this._nDataBytes += data.sigBytes;
        },
        _process: function(doFlush) {
          var processedWords;
          var data = this._data;
          var dataWords = data.words;
          var dataSigBytes = data.sigBytes;
          var blockSize = this.blockSize;
          var blockSizeBytes = blockSize * 4;
          var nBlocksReady = dataSigBytes / blockSizeBytes;
          if (doFlush) {
            nBlocksReady = Math2.ceil(nBlocksReady);
          } else {
            nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
          }
          var nWordsReady = nBlocksReady * blockSize;
          var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
          if (nWordsReady) {
            for (var offset2 = 0; offset2 < nWordsReady; offset2 += blockSize) {
              this._doProcessBlock(dataWords, offset2);
            }
            processedWords = dataWords.splice(0, nWordsReady);
            data.sigBytes -= nBytesReady;
          }
          return new WordArray.init(processedWords, nBytesReady);
        },
        clone: function() {
          var clone2 = Base.clone.call(this);
          clone2._data = this._data.clone();
          return clone2;
        },
        _minBufferSize: 0
      });
      C_lib.Hasher = BufferedBlockAlgorithm.extend({
        cfg: Base.extend(),
        init: function(cfg) {
          this.cfg = this.cfg.extend(cfg);
          this.reset();
        },
        reset: function() {
          BufferedBlockAlgorithm.reset.call(this);
          this._doReset();
        },
        update: function(messageUpdate) {
          this._append(messageUpdate);
          this._process();
          return this;
        },
        finalize: function(messageUpdate) {
          if (messageUpdate) {
            this._append(messageUpdate);
          }
          var hash = this._doFinalize();
          return hash;
        },
        blockSize: 512 / 32,
        _createHelper: function(hasher) {
          return function(message, cfg) {
            return new hasher.init(cfg).finalize(message);
          };
        },
        _createHmacHelper: function(hasher) {
          return function(message, key) {
            return new C_algo.HMAC.init(hasher, key).finalize(message);
          };
        }
      });
      var C_algo = C2.algo = {};
      return C2;
    }(Math);
    return CryptoJS;
  });
})(core$1);
(function(module2, exports) {
  (function(root, factory) {
    {
      module2.exports = factory(core$1.exports);
    }
  })(commonjsGlobal, function(CryptoJS) {
    (function(Math2) {
      var C2 = CryptoJS;
      var C_lib = C2.lib;
      var WordArray = C_lib.WordArray;
      var Hasher = C_lib.Hasher;
      var C_algo = C2.algo;
      var T2 = [];
      (function() {
        for (var i2 = 0; i2 < 64; i2++) {
          T2[i2] = Math2.abs(Math2.sin(i2 + 1)) * 4294967296 | 0;
        }
      })();
      var MD5 = C_algo.MD5 = Hasher.extend({
        _doReset: function() {
          this._hash = new WordArray.init([
            1732584193,
            4023233417,
            2562383102,
            271733878
          ]);
        },
        _doProcessBlock: function(M2, offset2) {
          for (var i2 = 0; i2 < 16; i2++) {
            var offset_i = offset2 + i2;
            var M_offset_i = M2[offset_i];
            M2[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
          }
          var H2 = this._hash.words;
          var M_offset_0 = M2[offset2 + 0];
          var M_offset_1 = M2[offset2 + 1];
          var M_offset_2 = M2[offset2 + 2];
          var M_offset_3 = M2[offset2 + 3];
          var M_offset_4 = M2[offset2 + 4];
          var M_offset_5 = M2[offset2 + 5];
          var M_offset_6 = M2[offset2 + 6];
          var M_offset_7 = M2[offset2 + 7];
          var M_offset_8 = M2[offset2 + 8];
          var M_offset_9 = M2[offset2 + 9];
          var M_offset_10 = M2[offset2 + 10];
          var M_offset_11 = M2[offset2 + 11];
          var M_offset_12 = M2[offset2 + 12];
          var M_offset_13 = M2[offset2 + 13];
          var M_offset_14 = M2[offset2 + 14];
          var M_offset_15 = M2[offset2 + 15];
          var a2 = H2[0];
          var b2 = H2[1];
          var c2 = H2[2];
          var d2 = H2[3];
          a2 = FF2(a2, b2, c2, d2, M_offset_0, 7, T2[0]);
          d2 = FF2(d2, a2, b2, c2, M_offset_1, 12, T2[1]);
          c2 = FF2(c2, d2, a2, b2, M_offset_2, 17, T2[2]);
          b2 = FF2(b2, c2, d2, a2, M_offset_3, 22, T2[3]);
          a2 = FF2(a2, b2, c2, d2, M_offset_4, 7, T2[4]);
          d2 = FF2(d2, a2, b2, c2, M_offset_5, 12, T2[5]);
          c2 = FF2(c2, d2, a2, b2, M_offset_6, 17, T2[6]);
          b2 = FF2(b2, c2, d2, a2, M_offset_7, 22, T2[7]);
          a2 = FF2(a2, b2, c2, d2, M_offset_8, 7, T2[8]);
          d2 = FF2(d2, a2, b2, c2, M_offset_9, 12, T2[9]);
          c2 = FF2(c2, d2, a2, b2, M_offset_10, 17, T2[10]);
          b2 = FF2(b2, c2, d2, a2, M_offset_11, 22, T2[11]);
          a2 = FF2(a2, b2, c2, d2, M_offset_12, 7, T2[12]);
          d2 = FF2(d2, a2, b2, c2, M_offset_13, 12, T2[13]);
          c2 = FF2(c2, d2, a2, b2, M_offset_14, 17, T2[14]);
          b2 = FF2(b2, c2, d2, a2, M_offset_15, 22, T2[15]);
          a2 = GG(a2, b2, c2, d2, M_offset_1, 5, T2[16]);
          d2 = GG(d2, a2, b2, c2, M_offset_6, 9, T2[17]);
          c2 = GG(c2, d2, a2, b2, M_offset_11, 14, T2[18]);
          b2 = GG(b2, c2, d2, a2, M_offset_0, 20, T2[19]);
          a2 = GG(a2, b2, c2, d2, M_offset_5, 5, T2[20]);
          d2 = GG(d2, a2, b2, c2, M_offset_10, 9, T2[21]);
          c2 = GG(c2, d2, a2, b2, M_offset_15, 14, T2[22]);
          b2 = GG(b2, c2, d2, a2, M_offset_4, 20, T2[23]);
          a2 = GG(a2, b2, c2, d2, M_offset_9, 5, T2[24]);
          d2 = GG(d2, a2, b2, c2, M_offset_14, 9, T2[25]);
          c2 = GG(c2, d2, a2, b2, M_offset_3, 14, T2[26]);
          b2 = GG(b2, c2, d2, a2, M_offset_8, 20, T2[27]);
          a2 = GG(a2, b2, c2, d2, M_offset_13, 5, T2[28]);
          d2 = GG(d2, a2, b2, c2, M_offset_2, 9, T2[29]);
          c2 = GG(c2, d2, a2, b2, M_offset_7, 14, T2[30]);
          b2 = GG(b2, c2, d2, a2, M_offset_12, 20, T2[31]);
          a2 = HH(a2, b2, c2, d2, M_offset_5, 4, T2[32]);
          d2 = HH(d2, a2, b2, c2, M_offset_8, 11, T2[33]);
          c2 = HH(c2, d2, a2, b2, M_offset_11, 16, T2[34]);
          b2 = HH(b2, c2, d2, a2, M_offset_14, 23, T2[35]);
          a2 = HH(a2, b2, c2, d2, M_offset_1, 4, T2[36]);
          d2 = HH(d2, a2, b2, c2, M_offset_4, 11, T2[37]);
          c2 = HH(c2, d2, a2, b2, M_offset_7, 16, T2[38]);
          b2 = HH(b2, c2, d2, a2, M_offset_10, 23, T2[39]);
          a2 = HH(a2, b2, c2, d2, M_offset_13, 4, T2[40]);
          d2 = HH(d2, a2, b2, c2, M_offset_0, 11, T2[41]);
          c2 = HH(c2, d2, a2, b2, M_offset_3, 16, T2[42]);
          b2 = HH(b2, c2, d2, a2, M_offset_6, 23, T2[43]);
          a2 = HH(a2, b2, c2, d2, M_offset_9, 4, T2[44]);
          d2 = HH(d2, a2, b2, c2, M_offset_12, 11, T2[45]);
          c2 = HH(c2, d2, a2, b2, M_offset_15, 16, T2[46]);
          b2 = HH(b2, c2, d2, a2, M_offset_2, 23, T2[47]);
          a2 = II2(a2, b2, c2, d2, M_offset_0, 6, T2[48]);
          d2 = II2(d2, a2, b2, c2, M_offset_7, 10, T2[49]);
          c2 = II2(c2, d2, a2, b2, M_offset_14, 15, T2[50]);
          b2 = II2(b2, c2, d2, a2, M_offset_5, 21, T2[51]);
          a2 = II2(a2, b2, c2, d2, M_offset_12, 6, T2[52]);
          d2 = II2(d2, a2, b2, c2, M_offset_3, 10, T2[53]);
          c2 = II2(c2, d2, a2, b2, M_offset_10, 15, T2[54]);
          b2 = II2(b2, c2, d2, a2, M_offset_1, 21, T2[55]);
          a2 = II2(a2, b2, c2, d2, M_offset_8, 6, T2[56]);
          d2 = II2(d2, a2, b2, c2, M_offset_15, 10, T2[57]);
          c2 = II2(c2, d2, a2, b2, M_offset_6, 15, T2[58]);
          b2 = II2(b2, c2, d2, a2, M_offset_13, 21, T2[59]);
          a2 = II2(a2, b2, c2, d2, M_offset_4, 6, T2[60]);
          d2 = II2(d2, a2, b2, c2, M_offset_11, 10, T2[61]);
          c2 = II2(c2, d2, a2, b2, M_offset_2, 15, T2[62]);
          b2 = II2(b2, c2, d2, a2, M_offset_9, 21, T2[63]);
          H2[0] = H2[0] + a2 | 0;
          H2[1] = H2[1] + b2 | 0;
          H2[2] = H2[2] + c2 | 0;
          H2[3] = H2[3] + d2 | 0;
        },
        _doFinalize: function() {
          var data = this._data;
          var dataWords = data.words;
          var nBitsTotal = this._nDataBytes * 8;
          var nBitsLeft = data.sigBytes * 8;
          dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
          var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
          var nBitsTotalL = nBitsTotal;
          dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
          dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
          data.sigBytes = (dataWords.length + 1) * 4;
          this._process();
          var hash = this._hash;
          var H2 = hash.words;
          for (var i2 = 0; i2 < 4; i2++) {
            var H_i = H2[i2];
            H2[i2] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
          }
          return hash;
        },
        clone: function() {
          var clone2 = Hasher.clone.call(this);
          clone2._hash = this._hash.clone();
          return clone2;
        }
      });
      function FF2(a2, b2, c2, d2, x2, s2, t2) {
        var n2 = a2 + (b2 & c2 | ~b2 & d2) + x2 + t2;
        return (n2 << s2 | n2 >>> 32 - s2) + b2;
      }
      function GG(a2, b2, c2, d2, x2, s2, t2) {
        var n2 = a2 + (b2 & d2 | c2 & ~d2) + x2 + t2;
        return (n2 << s2 | n2 >>> 32 - s2) + b2;
      }
      function HH(a2, b2, c2, d2, x2, s2, t2) {
        var n2 = a2 + (b2 ^ c2 ^ d2) + x2 + t2;
        return (n2 << s2 | n2 >>> 32 - s2) + b2;
      }
      function II2(a2, b2, c2, d2, x2, s2, t2) {
        var n2 = a2 + (c2 ^ (b2 | ~d2)) + x2 + t2;
        return (n2 << s2 | n2 >>> 32 - s2) + b2;
      }
      C2.MD5 = Hasher._createHelper(MD5);
      C2.HmacMD5 = Hasher._createHmacHelper(MD5);
    })(Math);
    return CryptoJS.MD5;
  });
})(md5$1);
var md5 = md5$1.exports;
var ansiStyles$1 = { exports: {} };
var colorName = {
  "aliceblue": [240, 248, 255],
  "antiquewhite": [250, 235, 215],
  "aqua": [0, 255, 255],
  "aquamarine": [127, 255, 212],
  "azure": [240, 255, 255],
  "beige": [245, 245, 220],
  "bisque": [255, 228, 196],
  "black": [0, 0, 0],
  "blanchedalmond": [255, 235, 205],
  "blue": [0, 0, 255],
  "blueviolet": [138, 43, 226],
  "brown": [165, 42, 42],
  "burlywood": [222, 184, 135],
  "cadetblue": [95, 158, 160],
  "chartreuse": [127, 255, 0],
  "chocolate": [210, 105, 30],
  "coral": [255, 127, 80],
  "cornflowerblue": [100, 149, 237],
  "cornsilk": [255, 248, 220],
  "crimson": [220, 20, 60],
  "cyan": [0, 255, 255],
  "darkblue": [0, 0, 139],
  "darkcyan": [0, 139, 139],
  "darkgoldenrod": [184, 134, 11],
  "darkgray": [169, 169, 169],
  "darkgreen": [0, 100, 0],
  "darkgrey": [169, 169, 169],
  "darkkhaki": [189, 183, 107],
  "darkmagenta": [139, 0, 139],
  "darkolivegreen": [85, 107, 47],
  "darkorange": [255, 140, 0],
  "darkorchid": [153, 50, 204],
  "darkred": [139, 0, 0],
  "darksalmon": [233, 150, 122],
  "darkseagreen": [143, 188, 143],
  "darkslateblue": [72, 61, 139],
  "darkslategray": [47, 79, 79],
  "darkslategrey": [47, 79, 79],
  "darkturquoise": [0, 206, 209],
  "darkviolet": [148, 0, 211],
  "deeppink": [255, 20, 147],
  "deepskyblue": [0, 191, 255],
  "dimgray": [105, 105, 105],
  "dimgrey": [105, 105, 105],
  "dodgerblue": [30, 144, 255],
  "firebrick": [178, 34, 34],
  "floralwhite": [255, 250, 240],
  "forestgreen": [34, 139, 34],
  "fuchsia": [255, 0, 255],
  "gainsboro": [220, 220, 220],
  "ghostwhite": [248, 248, 255],
  "gold": [255, 215, 0],
  "goldenrod": [218, 165, 32],
  "gray": [128, 128, 128],
  "green": [0, 128, 0],
  "greenyellow": [173, 255, 47],
  "grey": [128, 128, 128],
  "honeydew": [240, 255, 240],
  "hotpink": [255, 105, 180],
  "indianred": [205, 92, 92],
  "indigo": [75, 0, 130],
  "ivory": [255, 255, 240],
  "khaki": [240, 230, 140],
  "lavender": [230, 230, 250],
  "lavenderblush": [255, 240, 245],
  "lawngreen": [124, 252, 0],
  "lemonchiffon": [255, 250, 205],
  "lightblue": [173, 216, 230],
  "lightcoral": [240, 128, 128],
  "lightcyan": [224, 255, 255],
  "lightgoldenrodyellow": [250, 250, 210],
  "lightgray": [211, 211, 211],
  "lightgreen": [144, 238, 144],
  "lightgrey": [211, 211, 211],
  "lightpink": [255, 182, 193],
  "lightsalmon": [255, 160, 122],
  "lightseagreen": [32, 178, 170],
  "lightskyblue": [135, 206, 250],
  "lightslategray": [119, 136, 153],
  "lightslategrey": [119, 136, 153],
  "lightsteelblue": [176, 196, 222],
  "lightyellow": [255, 255, 224],
  "lime": [0, 255, 0],
  "limegreen": [50, 205, 50],
  "linen": [250, 240, 230],
  "magenta": [255, 0, 255],
  "maroon": [128, 0, 0],
  "mediumaquamarine": [102, 205, 170],
  "mediumblue": [0, 0, 205],
  "mediumorchid": [186, 85, 211],
  "mediumpurple": [147, 112, 219],
  "mediumseagreen": [60, 179, 113],
  "mediumslateblue": [123, 104, 238],
  "mediumspringgreen": [0, 250, 154],
  "mediumturquoise": [72, 209, 204],
  "mediumvioletred": [199, 21, 133],
  "midnightblue": [25, 25, 112],
  "mintcream": [245, 255, 250],
  "mistyrose": [255, 228, 225],
  "moccasin": [255, 228, 181],
  "navajowhite": [255, 222, 173],
  "navy": [0, 0, 128],
  "oldlace": [253, 245, 230],
  "olive": [128, 128, 0],
  "olivedrab": [107, 142, 35],
  "orange": [255, 165, 0],
  "orangered": [255, 69, 0],
  "orchid": [218, 112, 214],
  "palegoldenrod": [238, 232, 170],
  "palegreen": [152, 251, 152],
  "paleturquoise": [175, 238, 238],
  "palevioletred": [219, 112, 147],
  "papayawhip": [255, 239, 213],
  "peachpuff": [255, 218, 185],
  "peru": [205, 133, 63],
  "pink": [255, 192, 203],
  "plum": [221, 160, 221],
  "powderblue": [176, 224, 230],
  "purple": [128, 0, 128],
  "rebeccapurple": [102, 51, 153],
  "red": [255, 0, 0],
  "rosybrown": [188, 143, 143],
  "royalblue": [65, 105, 225],
  "saddlebrown": [139, 69, 19],
  "salmon": [250, 128, 114],
  "sandybrown": [244, 164, 96],
  "seagreen": [46, 139, 87],
  "seashell": [255, 245, 238],
  "sienna": [160, 82, 45],
  "silver": [192, 192, 192],
  "skyblue": [135, 206, 235],
  "slateblue": [106, 90, 205],
  "slategray": [112, 128, 144],
  "slategrey": [112, 128, 144],
  "snow": [255, 250, 250],
  "springgreen": [0, 255, 127],
  "steelblue": [70, 130, 180],
  "tan": [210, 180, 140],
  "teal": [0, 128, 128],
  "thistle": [216, 191, 216],
  "tomato": [255, 99, 71],
  "turquoise": [64, 224, 208],
  "violet": [238, 130, 238],
  "wheat": [245, 222, 179],
  "white": [255, 255, 255],
  "whitesmoke": [245, 245, 245],
  "yellow": [255, 255, 0],
  "yellowgreen": [154, 205, 50]
};
const cssKeywords = colorName;
const reverseKeywords = {};
for (const key of Object.keys(cssKeywords)) {
  reverseKeywords[cssKeywords[key]] = key;
}
const convert$2 = {
  rgb: { channels: 3, labels: "rgb" },
  hsl: { channels: 3, labels: "hsl" },
  hsv: { channels: 3, labels: "hsv" },
  hwb: { channels: 3, labels: "hwb" },
  cmyk: { channels: 4, labels: "cmyk" },
  xyz: { channels: 3, labels: "xyz" },
  lab: { channels: 3, labels: "lab" },
  lch: { channels: 3, labels: "lch" },
  hex: { channels: 1, labels: ["hex"] },
  keyword: { channels: 1, labels: ["keyword"] },
  ansi16: { channels: 1, labels: ["ansi16"] },
  ansi256: { channels: 1, labels: ["ansi256"] },
  hcg: { channels: 3, labels: ["h", "c", "g"] },
  apple: { channels: 3, labels: ["r16", "g16", "b16"] },
  gray: { channels: 1, labels: ["gray"] }
};
var conversions$2 = convert$2;
for (const model of Object.keys(convert$2)) {
  if (!("channels" in convert$2[model])) {
    throw new Error("missing channels property: " + model);
  }
  if (!("labels" in convert$2[model])) {
    throw new Error("missing channel labels property: " + model);
  }
  if (convert$2[model].labels.length !== convert$2[model].channels) {
    throw new Error("channel and label counts mismatch: " + model);
  }
  const { channels, labels } = convert$2[model];
  delete convert$2[model].channels;
  delete convert$2[model].labels;
  Object.defineProperty(convert$2[model], "channels", { value: channels });
  Object.defineProperty(convert$2[model], "labels", { value: labels });
}
convert$2.rgb.hsl = function(rgb) {
  const r2 = rgb[0] / 255;
  const g2 = rgb[1] / 255;
  const b2 = rgb[2] / 255;
  const min2 = Math.min(r2, g2, b2);
  const max2 = Math.max(r2, g2, b2);
  const delta = max2 - min2;
  let h2;
  let s2;
  if (max2 === min2) {
    h2 = 0;
  } else if (r2 === max2) {
    h2 = (g2 - b2) / delta;
  } else if (g2 === max2) {
    h2 = 2 + (b2 - r2) / delta;
  } else if (b2 === max2) {
    h2 = 4 + (r2 - g2) / delta;
  }
  h2 = Math.min(h2 * 60, 360);
  if (h2 < 0) {
    h2 += 360;
  }
  const l2 = (min2 + max2) / 2;
  if (max2 === min2) {
    s2 = 0;
  } else if (l2 <= 0.5) {
    s2 = delta / (max2 + min2);
  } else {
    s2 = delta / (2 - max2 - min2);
  }
  return [h2, s2 * 100, l2 * 100];
};
convert$2.rgb.hsv = function(rgb) {
  let rdif;
  let gdif;
  let bdif;
  let h2;
  let s2;
  const r2 = rgb[0] / 255;
  const g2 = rgb[1] / 255;
  const b2 = rgb[2] / 255;
  const v2 = Math.max(r2, g2, b2);
  const diff2 = v2 - Math.min(r2, g2, b2);
  const diffc = function(c2) {
    return (v2 - c2) / 6 / diff2 + 1 / 2;
  };
  if (diff2 === 0) {
    h2 = 0;
    s2 = 0;
  } else {
    s2 = diff2 / v2;
    rdif = diffc(r2);
    gdif = diffc(g2);
    bdif = diffc(b2);
    if (r2 === v2) {
      h2 = bdif - gdif;
    } else if (g2 === v2) {
      h2 = 1 / 3 + rdif - bdif;
    } else if (b2 === v2) {
      h2 = 2 / 3 + gdif - rdif;
    }
    if (h2 < 0) {
      h2 += 1;
    } else if (h2 > 1) {
      h2 -= 1;
    }
  }
  return [
    h2 * 360,
    s2 * 100,
    v2 * 100
  ];
};
convert$2.rgb.hwb = function(rgb) {
  const r2 = rgb[0];
  const g2 = rgb[1];
  let b2 = rgb[2];
  const h2 = convert$2.rgb.hsl(rgb)[0];
  const w2 = 1 / 255 * Math.min(r2, Math.min(g2, b2));
  b2 = 1 - 1 / 255 * Math.max(r2, Math.max(g2, b2));
  return [h2, w2 * 100, b2 * 100];
};
convert$2.rgb.cmyk = function(rgb) {
  const r2 = rgb[0] / 255;
  const g2 = rgb[1] / 255;
  const b2 = rgb[2] / 255;
  const k2 = Math.min(1 - r2, 1 - g2, 1 - b2);
  const c2 = (1 - r2 - k2) / (1 - k2) || 0;
  const m2 = (1 - g2 - k2) / (1 - k2) || 0;
  const y2 = (1 - b2 - k2) / (1 - k2) || 0;
  return [c2 * 100, m2 * 100, y2 * 100, k2 * 100];
};
function comparativeDistance(x2, y2) {
  return (x2[0] - y2[0]) ** 2 + (x2[1] - y2[1]) ** 2 + (x2[2] - y2[2]) ** 2;
}
convert$2.rgb.keyword = function(rgb) {
  const reversed = reverseKeywords[rgb];
  if (reversed) {
    return reversed;
  }
  let currentClosestDistance = Infinity;
  let currentClosestKeyword;
  for (const keyword of Object.keys(cssKeywords)) {
    const value = cssKeywords[keyword];
    const distance = comparativeDistance(rgb, value);
    if (distance < currentClosestDistance) {
      currentClosestDistance = distance;
      currentClosestKeyword = keyword;
    }
  }
  return currentClosestKeyword;
};
convert$2.keyword.rgb = function(keyword) {
  return cssKeywords[keyword];
};
convert$2.rgb.xyz = function(rgb) {
  let r2 = rgb[0] / 255;
  let g2 = rgb[1] / 255;
  let b2 = rgb[2] / 255;
  r2 = r2 > 0.04045 ? ((r2 + 0.055) / 1.055) ** 2.4 : r2 / 12.92;
  g2 = g2 > 0.04045 ? ((g2 + 0.055) / 1.055) ** 2.4 : g2 / 12.92;
  b2 = b2 > 0.04045 ? ((b2 + 0.055) / 1.055) ** 2.4 : b2 / 12.92;
  const x2 = r2 * 0.4124 + g2 * 0.3576 + b2 * 0.1805;
  const y2 = r2 * 0.2126 + g2 * 0.7152 + b2 * 0.0722;
  const z2 = r2 * 0.0193 + g2 * 0.1192 + b2 * 0.9505;
  return [x2 * 100, y2 * 100, z2 * 100];
};
convert$2.rgb.lab = function(rgb) {
  const xyz = convert$2.rgb.xyz(rgb);
  let x2 = xyz[0];
  let y2 = xyz[1];
  let z2 = xyz[2];
  x2 /= 95.047;
  y2 /= 100;
  z2 /= 108.883;
  x2 = x2 > 8856e-6 ? x2 ** (1 / 3) : 7.787 * x2 + 16 / 116;
  y2 = y2 > 8856e-6 ? y2 ** (1 / 3) : 7.787 * y2 + 16 / 116;
  z2 = z2 > 8856e-6 ? z2 ** (1 / 3) : 7.787 * z2 + 16 / 116;
  const l2 = 116 * y2 - 16;
  const a2 = 500 * (x2 - y2);
  const b2 = 200 * (y2 - z2);
  return [l2, a2, b2];
};
convert$2.hsl.rgb = function(hsl) {
  const h2 = hsl[0] / 360;
  const s2 = hsl[1] / 100;
  const l2 = hsl[2] / 100;
  let t2;
  let t3;
  let val;
  if (s2 === 0) {
    val = l2 * 255;
    return [val, val, val];
  }
  if (l2 < 0.5) {
    t2 = l2 * (1 + s2);
  } else {
    t2 = l2 + s2 - l2 * s2;
  }
  const t1 = 2 * l2 - t2;
  const rgb = [0, 0, 0];
  for (let i2 = 0; i2 < 3; i2++) {
    t3 = h2 + 1 / 3 * -(i2 - 1);
    if (t3 < 0) {
      t3++;
    }
    if (t3 > 1) {
      t3--;
    }
    if (6 * t3 < 1) {
      val = t1 + (t2 - t1) * 6 * t3;
    } else if (2 * t3 < 1) {
      val = t2;
    } else if (3 * t3 < 2) {
      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    } else {
      val = t1;
    }
    rgb[i2] = val * 255;
  }
  return rgb;
};
convert$2.hsl.hsv = function(hsl) {
  const h2 = hsl[0];
  let s2 = hsl[1] / 100;
  let l2 = hsl[2] / 100;
  let smin = s2;
  const lmin = Math.max(l2, 0.01);
  l2 *= 2;
  s2 *= l2 <= 1 ? l2 : 2 - l2;
  smin *= lmin <= 1 ? lmin : 2 - lmin;
  const v2 = (l2 + s2) / 2;
  const sv2 = l2 === 0 ? 2 * smin / (lmin + smin) : 2 * s2 / (l2 + s2);
  return [h2, sv2 * 100, v2 * 100];
};
convert$2.hsv.rgb = function(hsv) {
  const h2 = hsv[0] / 60;
  const s2 = hsv[1] / 100;
  let v2 = hsv[2] / 100;
  const hi2 = Math.floor(h2) % 6;
  const f2 = h2 - Math.floor(h2);
  const p2 = 255 * v2 * (1 - s2);
  const q2 = 255 * v2 * (1 - s2 * f2);
  const t2 = 255 * v2 * (1 - s2 * (1 - f2));
  v2 *= 255;
  switch (hi2) {
    case 0:
      return [v2, t2, p2];
    case 1:
      return [q2, v2, p2];
    case 2:
      return [p2, v2, t2];
    case 3:
      return [p2, q2, v2];
    case 4:
      return [t2, p2, v2];
    case 5:
      return [v2, p2, q2];
  }
};
convert$2.hsv.hsl = function(hsv) {
  const h2 = hsv[0];
  const s2 = hsv[1] / 100;
  const v2 = hsv[2] / 100;
  const vmin = Math.max(v2, 0.01);
  let sl2;
  let l2;
  l2 = (2 - s2) * v2;
  const lmin = (2 - s2) * vmin;
  sl2 = s2 * vmin;
  sl2 /= lmin <= 1 ? lmin : 2 - lmin;
  sl2 = sl2 || 0;
  l2 /= 2;
  return [h2, sl2 * 100, l2 * 100];
};
convert$2.hwb.rgb = function(hwb) {
  const h2 = hwb[0] / 360;
  let wh2 = hwb[1] / 100;
  let bl2 = hwb[2] / 100;
  const ratio = wh2 + bl2;
  let f2;
  if (ratio > 1) {
    wh2 /= ratio;
    bl2 /= ratio;
  }
  const i2 = Math.floor(6 * h2);
  const v2 = 1 - bl2;
  f2 = 6 * h2 - i2;
  if ((i2 & 1) !== 0) {
    f2 = 1 - f2;
  }
  const n2 = wh2 + f2 * (v2 - wh2);
  let r2;
  let g2;
  let b2;
  switch (i2) {
    default:
    case 6:
    case 0:
      r2 = v2;
      g2 = n2;
      b2 = wh2;
      break;
    case 1:
      r2 = n2;
      g2 = v2;
      b2 = wh2;
      break;
    case 2:
      r2 = wh2;
      g2 = v2;
      b2 = n2;
      break;
    case 3:
      r2 = wh2;
      g2 = n2;
      b2 = v2;
      break;
    case 4:
      r2 = n2;
      g2 = wh2;
      b2 = v2;
      break;
    case 5:
      r2 = v2;
      g2 = wh2;
      b2 = n2;
      break;
  }
  return [r2 * 255, g2 * 255, b2 * 255];
};
convert$2.cmyk.rgb = function(cmyk) {
  const c2 = cmyk[0] / 100;
  const m2 = cmyk[1] / 100;
  const y2 = cmyk[2] / 100;
  const k2 = cmyk[3] / 100;
  const r2 = 1 - Math.min(1, c2 * (1 - k2) + k2);
  const g2 = 1 - Math.min(1, m2 * (1 - k2) + k2);
  const b2 = 1 - Math.min(1, y2 * (1 - k2) + k2);
  return [r2 * 255, g2 * 255, b2 * 255];
};
convert$2.xyz.rgb = function(xyz) {
  const x2 = xyz[0] / 100;
  const y2 = xyz[1] / 100;
  const z2 = xyz[2] / 100;
  let r2;
  let g2;
  let b2;
  r2 = x2 * 3.2406 + y2 * -1.5372 + z2 * -0.4986;
  g2 = x2 * -0.9689 + y2 * 1.8758 + z2 * 0.0415;
  b2 = x2 * 0.0557 + y2 * -0.204 + z2 * 1.057;
  r2 = r2 > 31308e-7 ? 1.055 * r2 ** (1 / 2.4) - 0.055 : r2 * 12.92;
  g2 = g2 > 31308e-7 ? 1.055 * g2 ** (1 / 2.4) - 0.055 : g2 * 12.92;
  b2 = b2 > 31308e-7 ? 1.055 * b2 ** (1 / 2.4) - 0.055 : b2 * 12.92;
  r2 = Math.min(Math.max(0, r2), 1);
  g2 = Math.min(Math.max(0, g2), 1);
  b2 = Math.min(Math.max(0, b2), 1);
  return [r2 * 255, g2 * 255, b2 * 255];
};
convert$2.xyz.lab = function(xyz) {
  let x2 = xyz[0];
  let y2 = xyz[1];
  let z2 = xyz[2];
  x2 /= 95.047;
  y2 /= 100;
  z2 /= 108.883;
  x2 = x2 > 8856e-6 ? x2 ** (1 / 3) : 7.787 * x2 + 16 / 116;
  y2 = y2 > 8856e-6 ? y2 ** (1 / 3) : 7.787 * y2 + 16 / 116;
  z2 = z2 > 8856e-6 ? z2 ** (1 / 3) : 7.787 * z2 + 16 / 116;
  const l2 = 116 * y2 - 16;
  const a2 = 500 * (x2 - y2);
  const b2 = 200 * (y2 - z2);
  return [l2, a2, b2];
};
convert$2.lab.xyz = function(lab) {
  const l2 = lab[0];
  const a2 = lab[1];
  const b2 = lab[2];
  let x2;
  let y2;
  let z2;
  y2 = (l2 + 16) / 116;
  x2 = a2 / 500 + y2;
  z2 = y2 - b2 / 200;
  const y22 = y2 ** 3;
  const x22 = x2 ** 3;
  const z22 = z2 ** 3;
  y2 = y22 > 8856e-6 ? y22 : (y2 - 16 / 116) / 7.787;
  x2 = x22 > 8856e-6 ? x22 : (x2 - 16 / 116) / 7.787;
  z2 = z22 > 8856e-6 ? z22 : (z2 - 16 / 116) / 7.787;
  x2 *= 95.047;
  y2 *= 100;
  z2 *= 108.883;
  return [x2, y2, z2];
};
convert$2.lab.lch = function(lab) {
  const l2 = lab[0];
  const a2 = lab[1];
  const b2 = lab[2];
  let h2;
  const hr2 = Math.atan2(b2, a2);
  h2 = hr2 * 360 / 2 / Math.PI;
  if (h2 < 0) {
    h2 += 360;
  }
  const c2 = Math.sqrt(a2 * a2 + b2 * b2);
  return [l2, c2, h2];
};
convert$2.lch.lab = function(lch) {
  const l2 = lch[0];
  const c2 = lch[1];
  const h2 = lch[2];
  const hr2 = h2 / 360 * 2 * Math.PI;
  const a2 = c2 * Math.cos(hr2);
  const b2 = c2 * Math.sin(hr2);
  return [l2, a2, b2];
};
convert$2.rgb.ansi16 = function(args, saturation = null) {
  const [r2, g2, b2] = args;
  let value = saturation === null ? convert$2.rgb.hsv(args)[2] : saturation;
  value = Math.round(value / 50);
  if (value === 0) {
    return 30;
  }
  let ansi = 30 + (Math.round(b2 / 255) << 2 | Math.round(g2 / 255) << 1 | Math.round(r2 / 255));
  if (value === 2) {
    ansi += 60;
  }
  return ansi;
};
convert$2.hsv.ansi16 = function(args) {
  return convert$2.rgb.ansi16(convert$2.hsv.rgb(args), args[2]);
};
convert$2.rgb.ansi256 = function(args) {
  const r2 = args[0];
  const g2 = args[1];
  const b2 = args[2];
  if (r2 === g2 && g2 === b2) {
    if (r2 < 8) {
      return 16;
    }
    if (r2 > 248) {
      return 231;
    }
    return Math.round((r2 - 8) / 247 * 24) + 232;
  }
  const ansi = 16 + 36 * Math.round(r2 / 255 * 5) + 6 * Math.round(g2 / 255 * 5) + Math.round(b2 / 255 * 5);
  return ansi;
};
convert$2.ansi16.rgb = function(args) {
  let color2 = args % 10;
  if (color2 === 0 || color2 === 7) {
    if (args > 50) {
      color2 += 3.5;
    }
    color2 = color2 / 10.5 * 255;
    return [color2, color2, color2];
  }
  const mult = (~~(args > 50) + 1) * 0.5;
  const r2 = (color2 & 1) * mult * 255;
  const g2 = (color2 >> 1 & 1) * mult * 255;
  const b2 = (color2 >> 2 & 1) * mult * 255;
  return [r2, g2, b2];
};
convert$2.ansi256.rgb = function(args) {
  if (args >= 232) {
    const c2 = (args - 232) * 10 + 8;
    return [c2, c2, c2];
  }
  args -= 16;
  let rem;
  const r2 = Math.floor(args / 36) / 5 * 255;
  const g2 = Math.floor((rem = args % 36) / 6) / 5 * 255;
  const b2 = rem % 6 / 5 * 255;
  return [r2, g2, b2];
};
convert$2.rgb.hex = function(args) {
  const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
  const string2 = integer.toString(16).toUpperCase();
  return "000000".substring(string2.length) + string2;
};
convert$2.hex.rgb = function(args) {
  const match5 = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
  if (!match5) {
    return [0, 0, 0];
  }
  let colorString = match5[0];
  if (match5[0].length === 3) {
    colorString = colorString.split("").map((char) => {
      return char + char;
    }).join("");
  }
  const integer = parseInt(colorString, 16);
  const r2 = integer >> 16 & 255;
  const g2 = integer >> 8 & 255;
  const b2 = integer & 255;
  return [r2, g2, b2];
};
convert$2.rgb.hcg = function(rgb) {
  const r2 = rgb[0] / 255;
  const g2 = rgb[1] / 255;
  const b2 = rgb[2] / 255;
  const max2 = Math.max(Math.max(r2, g2), b2);
  const min2 = Math.min(Math.min(r2, g2), b2);
  const chroma = max2 - min2;
  let grayscale;
  let hue;
  if (chroma < 1) {
    grayscale = min2 / (1 - chroma);
  } else {
    grayscale = 0;
  }
  if (chroma <= 0) {
    hue = 0;
  } else if (max2 === r2) {
    hue = (g2 - b2) / chroma % 6;
  } else if (max2 === g2) {
    hue = 2 + (b2 - r2) / chroma;
  } else {
    hue = 4 + (r2 - g2) / chroma;
  }
  hue /= 6;
  hue %= 1;
  return [hue * 360, chroma * 100, grayscale * 100];
};
convert$2.hsl.hcg = function(hsl) {
  const s2 = hsl[1] / 100;
  const l2 = hsl[2] / 100;
  const c2 = l2 < 0.5 ? 2 * s2 * l2 : 2 * s2 * (1 - l2);
  let f2 = 0;
  if (c2 < 1) {
    f2 = (l2 - 0.5 * c2) / (1 - c2);
  }
  return [hsl[0], c2 * 100, f2 * 100];
};
convert$2.hsv.hcg = function(hsv) {
  const s2 = hsv[1] / 100;
  const v2 = hsv[2] / 100;
  const c2 = s2 * v2;
  let f2 = 0;
  if (c2 < 1) {
    f2 = (v2 - c2) / (1 - c2);
  }
  return [hsv[0], c2 * 100, f2 * 100];
};
convert$2.hcg.rgb = function(hcg) {
  const h2 = hcg[0] / 360;
  const c2 = hcg[1] / 100;
  const g2 = hcg[2] / 100;
  if (c2 === 0) {
    return [g2 * 255, g2 * 255, g2 * 255];
  }
  const pure = [0, 0, 0];
  const hi2 = h2 % 1 * 6;
  const v2 = hi2 % 1;
  const w2 = 1 - v2;
  let mg2 = 0;
  switch (Math.floor(hi2)) {
    case 0:
      pure[0] = 1;
      pure[1] = v2;
      pure[2] = 0;
      break;
    case 1:
      pure[0] = w2;
      pure[1] = 1;
      pure[2] = 0;
      break;
    case 2:
      pure[0] = 0;
      pure[1] = 1;
      pure[2] = v2;
      break;
    case 3:
      pure[0] = 0;
      pure[1] = w2;
      pure[2] = 1;
      break;
    case 4:
      pure[0] = v2;
      pure[1] = 0;
      pure[2] = 1;
      break;
    default:
      pure[0] = 1;
      pure[1] = 0;
      pure[2] = w2;
  }
  mg2 = (1 - c2) * g2;
  return [
    (c2 * pure[0] + mg2) * 255,
    (c2 * pure[1] + mg2) * 255,
    (c2 * pure[2] + mg2) * 255
  ];
};
convert$2.hcg.hsv = function(hcg) {
  const c2 = hcg[1] / 100;
  const g2 = hcg[2] / 100;
  const v2 = c2 + g2 * (1 - c2);
  let f2 = 0;
  if (v2 > 0) {
    f2 = c2 / v2;
  }
  return [hcg[0], f2 * 100, v2 * 100];
};
convert$2.hcg.hsl = function(hcg) {
  const c2 = hcg[1] / 100;
  const g2 = hcg[2] / 100;
  const l2 = g2 * (1 - c2) + 0.5 * c2;
  let s2 = 0;
  if (l2 > 0 && l2 < 0.5) {
    s2 = c2 / (2 * l2);
  } else if (l2 >= 0.5 && l2 < 1) {
    s2 = c2 / (2 * (1 - l2));
  }
  return [hcg[0], s2 * 100, l2 * 100];
};
convert$2.hcg.hwb = function(hcg) {
  const c2 = hcg[1] / 100;
  const g2 = hcg[2] / 100;
  const v2 = c2 + g2 * (1 - c2);
  return [hcg[0], (v2 - c2) * 100, (1 - v2) * 100];
};
convert$2.hwb.hcg = function(hwb) {
  const w2 = hwb[1] / 100;
  const b2 = hwb[2] / 100;
  const v2 = 1 - b2;
  const c2 = v2 - w2;
  let g2 = 0;
  if (c2 < 1) {
    g2 = (v2 - c2) / (1 - c2);
  }
  return [hwb[0], c2 * 100, g2 * 100];
};
convert$2.apple.rgb = function(apple) {
  return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
};
convert$2.rgb.apple = function(rgb) {
  return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
};
convert$2.gray.rgb = function(args) {
  return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};
convert$2.gray.hsl = function(args) {
  return [0, 0, args[0]];
};
convert$2.gray.hsv = convert$2.gray.hsl;
convert$2.gray.hwb = function(gray) {
  return [0, 100, gray[0]];
};
convert$2.gray.cmyk = function(gray) {
  return [0, 0, 0, gray[0]];
};
convert$2.gray.lab = function(gray) {
  return [gray[0], 0, 0];
};
convert$2.gray.hex = function(gray) {
  const val = Math.round(gray[0] / 100 * 255) & 255;
  const integer = (val << 16) + (val << 8) + val;
  const string2 = integer.toString(16).toUpperCase();
  return "000000".substring(string2.length) + string2;
};
convert$2.rgb.gray = function(rgb) {
  const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
  return [val / 255 * 100];
};
const conversions$1 = conversions$2;
function buildGraph() {
  const graph = {};
  const models2 = Object.keys(conversions$1);
  for (let len = models2.length, i2 = 0; i2 < len; i2++) {
    graph[models2[i2]] = {
      distance: -1,
      parent: null
    };
  }
  return graph;
}
function deriveBFS(fromModel) {
  const graph = buildGraph();
  const queue = [fromModel];
  graph[fromModel].distance = 0;
  while (queue.length) {
    const current = queue.pop();
    const adjacents = Object.keys(conversions$1[current]);
    for (let len = adjacents.length, i2 = 0; i2 < len; i2++) {
      const adjacent = adjacents[i2];
      const node = graph[adjacent];
      if (node.distance === -1) {
        node.distance = graph[current].distance + 1;
        node.parent = current;
        queue.unshift(adjacent);
      }
    }
  }
  return graph;
}
function link(from2, to2) {
  return function(args) {
    return to2(from2(args));
  };
}
function wrapConversion(toModel, graph) {
  const path2 = [graph[toModel].parent, toModel];
  let fn2 = conversions$1[graph[toModel].parent][toModel];
  let cur = graph[toModel].parent;
  while (graph[cur].parent) {
    path2.unshift(graph[cur].parent);
    fn2 = link(conversions$1[graph[cur].parent][cur], fn2);
    cur = graph[cur].parent;
  }
  fn2.conversion = path2;
  return fn2;
}
var route$1 = function(fromModel) {
  const graph = deriveBFS(fromModel);
  const conversion = {};
  const models2 = Object.keys(graph);
  for (let len = models2.length, i2 = 0; i2 < len; i2++) {
    const toModel = models2[i2];
    const node = graph[toModel];
    if (node.parent === null) {
      continue;
    }
    conversion[toModel] = wrapConversion(toModel, graph);
  }
  return conversion;
};
const conversions = conversions$2;
const route = route$1;
const convert$1 = {};
const models = Object.keys(conversions);
function wrapRaw(fn2) {
  const wrappedFn = function(...args) {
    const arg0 = args[0];
    if (arg0 === void 0 || arg0 === null) {
      return arg0;
    }
    if (arg0.length > 1) {
      args = arg0;
    }
    return fn2(args);
  };
  if ("conversion" in fn2) {
    wrappedFn.conversion = fn2.conversion;
  }
  return wrappedFn;
}
function wrapRounded(fn2) {
  const wrappedFn = function(...args) {
    const arg0 = args[0];
    if (arg0 === void 0 || arg0 === null) {
      return arg0;
    }
    if (arg0.length > 1) {
      args = arg0;
    }
    const result = fn2(args);
    if (typeof result === "object") {
      for (let len = result.length, i2 = 0; i2 < len; i2++) {
        result[i2] = Math.round(result[i2]);
      }
    }
    return result;
  };
  if ("conversion" in fn2) {
    wrappedFn.conversion = fn2.conversion;
  }
  return wrappedFn;
}
models.forEach((fromModel) => {
  convert$1[fromModel] = {};
  Object.defineProperty(convert$1[fromModel], "channels", { value: conversions[fromModel].channels });
  Object.defineProperty(convert$1[fromModel], "labels", { value: conversions[fromModel].labels });
  const routes = route(fromModel);
  const routeModels = Object.keys(routes);
  routeModels.forEach((toModel) => {
    const fn2 = routes[toModel];
    convert$1[fromModel][toModel] = wrapRounded(fn2);
    convert$1[fromModel][toModel].raw = wrapRaw(fn2);
  });
});
var colorConvert = convert$1;
(function(module2) {
  const wrapAnsi16 = (fn2, offset2) => (...args) => {
    const code4 = fn2(...args);
    return `[${code4 + offset2}m`;
  };
  const wrapAnsi256 = (fn2, offset2) => (...args) => {
    const code4 = fn2(...args);
    return `[${38 + offset2};5;${code4}m`;
  };
  const wrapAnsi16m = (fn2, offset2) => (...args) => {
    const rgb = fn2(...args);
    return `[${38 + offset2};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
  };
  const ansi2ansi = (n2) => n2;
  const rgb2rgb = (r2, g2, b2) => [r2, g2, b2];
  const setLazyProperty = (object, property2, get2) => {
    Object.defineProperty(object, property2, {
      get: () => {
        const value = get2();
        Object.defineProperty(object, property2, {
          value,
          enumerable: true,
          configurable: true
        });
        return value;
      },
      enumerable: true,
      configurable: true
    });
  };
  let colorConvert$1;
  const makeDynamicStyles = (wrap2, targetSpace, identity2, isBackground) => {
    if (colorConvert$1 === void 0) {
      colorConvert$1 = colorConvert;
    }
    const offset2 = isBackground ? 10 : 0;
    const styles2 = {};
    for (const [sourceSpace, suite] of Object.entries(colorConvert$1)) {
      const name2 = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
      if (sourceSpace === targetSpace) {
        styles2[name2] = wrap2(identity2, offset2);
      } else if (typeof suite === "object") {
        styles2[name2] = wrap2(suite[targetSpace], offset2);
      }
    }
    return styles2;
  };
  function assembleStyles() {
    const codes = new Map();
    const styles2 = {
      modifier: {
        reset: [0, 0],
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        blackBright: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    styles2.color.gray = styles2.color.blackBright;
    styles2.bgColor.bgGray = styles2.bgColor.bgBlackBright;
    styles2.color.grey = styles2.color.blackBright;
    styles2.bgColor.bgGrey = styles2.bgColor.bgBlackBright;
    for (const [groupName, group] of Object.entries(styles2)) {
      for (const [styleName, style] of Object.entries(group)) {
        styles2[styleName] = {
          open: `[${style[0]}m`,
          close: `[${style[1]}m`
        };
        group[styleName] = styles2[styleName];
        codes.set(style[0], style[1]);
      }
      Object.defineProperty(styles2, groupName, {
        value: group,
        enumerable: false
      });
    }
    Object.defineProperty(styles2, "codes", {
      value: codes,
      enumerable: false
    });
    styles2.color.close = "[39m";
    styles2.bgColor.close = "[49m";
    setLazyProperty(styles2.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
    setLazyProperty(styles2.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
    setLazyProperty(styles2.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
    setLazyProperty(styles2.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
    setLazyProperty(styles2.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
    setLazyProperty(styles2.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
    return styles2;
  }
  Object.defineProperty(module2, "exports", {
    enumerable: true,
    get: assembleStyles
  });
})(ansiStyles$1);
var browser$1 = {
  stdout: false,
  stderr: false
};
const stringReplaceAll$1 = (string2, substring, replacer) => {
  let index = string2.indexOf(substring);
  if (index === -1) {
    return string2;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = "";
  do {
    returnValue += string2.substr(endIndex, index - endIndex) + substring + replacer;
    endIndex = index + substringLength;
    index = string2.indexOf(substring, endIndex);
  } while (index !== -1);
  returnValue += string2.substr(endIndex);
  return returnValue;
};
const stringEncaseCRLFWithFirstIndex$1 = (string2, prefix, postfix, index) => {
  let endIndex = 0;
  let returnValue = "";
  do {
    const gotCR = string2[index - 1] === "\r";
    returnValue += string2.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
    endIndex = index + 1;
    index = string2.indexOf("\n", endIndex);
  } while (index !== -1);
  returnValue += string2.substr(endIndex);
  return returnValue;
};
var util = {
  stringReplaceAll: stringReplaceAll$1,
  stringEncaseCRLFWithFirstIndex: stringEncaseCRLFWithFirstIndex$1
};
const TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
const ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
const ESCAPES = new Map([
  ["n", "\n"],
  ["r", "\r"],
  ["t", "	"],
  ["b", "\b"],
  ["f", "\f"],
  ["v", "\v"],
  ["0", "\0"],
  ["\\", "\\"],
  ["e", ""],
  ["a", "\x07"]
]);
function unescape$1(c2) {
  const u2 = c2[0] === "u";
  const bracket = c2[1] === "{";
  if (u2 && !bracket && c2.length === 5 || c2[0] === "x" && c2.length === 3) {
    return String.fromCharCode(parseInt(c2.slice(1), 16));
  }
  if (u2 && bracket) {
    return String.fromCodePoint(parseInt(c2.slice(2, -1), 16));
  }
  return ESCAPES.get(c2) || c2;
}
function parseArguments(name2, arguments_) {
  const results = [];
  const chunks = arguments_.trim().split(/\s*,\s*/g);
  let matches2;
  for (const chunk of chunks) {
    const number = Number(chunk);
    if (!Number.isNaN(number)) {
      results.push(number);
    } else if (matches2 = chunk.match(STRING_REGEX)) {
      results.push(matches2[2].replace(ESCAPE_REGEX, (m2, escape2, character) => escape2 ? unescape$1(escape2) : character));
    } else {
      throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name2}')`);
    }
  }
  return results;
}
function parseStyle(style) {
  STYLE_REGEX.lastIndex = 0;
  const results = [];
  let matches2;
  while ((matches2 = STYLE_REGEX.exec(style)) !== null) {
    const name2 = matches2[1];
    if (matches2[2]) {
      const args = parseArguments(name2, matches2[2]);
      results.push([name2].concat(args));
    } else {
      results.push([name2]);
    }
  }
  return results;
}
function buildStyle(chalk2, styles2) {
  const enabled = {};
  for (const layer of styles2) {
    for (const style of layer.styles) {
      enabled[style[0]] = layer.inverse ? null : style.slice(1);
    }
  }
  let current = chalk2;
  for (const [styleName, styles3] of Object.entries(enabled)) {
    if (!Array.isArray(styles3)) {
      continue;
    }
    if (!(styleName in current)) {
      throw new Error(`Unknown Chalk style: ${styleName}`);
    }
    current = styles3.length > 0 ? current[styleName](...styles3) : current[styleName];
  }
  return current;
}
var templates = (chalk2, temporary) => {
  const styles2 = [];
  const chunks = [];
  let chunk = [];
  temporary.replace(TEMPLATE_REGEX, (m2, escapeCharacter, inverse, style, close, character) => {
    if (escapeCharacter) {
      chunk.push(unescape$1(escapeCharacter));
    } else if (style) {
      const string2 = chunk.join("");
      chunk = [];
      chunks.push(styles2.length === 0 ? string2 : buildStyle(chalk2, styles2)(string2));
      styles2.push({ inverse, styles: parseStyle(style) });
    } else if (close) {
      if (styles2.length === 0) {
        throw new Error("Found extraneous } in Chalk template literal");
      }
      chunks.push(buildStyle(chalk2, styles2)(chunk.join("")));
      chunk = [];
      styles2.pop();
    } else {
      chunk.push(character);
    }
  });
  chunks.push(chunk.join(""));
  if (styles2.length > 0) {
    const errMessage = `Chalk template literal is missing ${styles2.length} closing bracket${styles2.length === 1 ? "" : "s"} (\`}\`)`;
    throw new Error(errMessage);
  }
  return chunks.join("");
};
const ansiStyles = ansiStyles$1.exports;
const { stdout: stdoutColor, stderr: stderrColor } = browser$1;
const {
  stringReplaceAll,
  stringEncaseCRLFWithFirstIndex
} = util;
const { isArray: isArray$8 } = Array;
const levelMapping = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
];
const styles = Object.create(null);
const applyOptions = (object, options = {}) => {
  if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
    throw new Error("The `level` option should be an integer from 0 to 3");
  }
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options.level === void 0 ? colorLevel : options.level;
};
class ChalkClass {
  constructor(options) {
    return chalkFactory(options);
  }
}
const chalkFactory = (options) => {
  const chalk2 = {};
  applyOptions(chalk2, options);
  chalk2.template = (...arguments_) => chalkTag(chalk2.template, ...arguments_);
  Object.setPrototypeOf(chalk2, Chalk.prototype);
  Object.setPrototypeOf(chalk2.template, chalk2);
  chalk2.template.constructor = () => {
    throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
  };
  chalk2.template.Instance = ChalkClass;
  return chalk2.template;
};
function Chalk(options) {
  return chalkFactory(options);
}
for (const [styleName, style] of Object.entries(ansiStyles)) {
  styles[styleName] = {
    get() {
      const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
      Object.defineProperty(this, styleName, { value: builder });
      return builder;
    }
  };
}
styles.visible = {
  get() {
    const builder = createBuilder(this, this._styler, true);
    Object.defineProperty(this, "visible", { value: builder });
    return builder;
  }
};
const usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
for (const model of usedModels) {
  styles[model] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
        return createBuilder(this, styler, this._isEmpty);
      };
    }
  };
}
for (const model of usedModels) {
  const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
  styles[bgModel] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
        return createBuilder(this, styler, this._isEmpty);
      };
    }
  };
}
const proto$3 = Object.defineProperties(() => {
}, __spreadProps(__spreadValues({}, styles), {
  level: {
    enumerable: true,
    get() {
      return this._generator.level;
    },
    set(level) {
      this._generator.level = level;
    }
  }
}));
const createStyler = (open, close, parent) => {
  let openAll;
  let closeAll;
  if (parent === void 0) {
    openAll = open;
    closeAll = close;
  } else {
    openAll = parent.openAll + open;
    closeAll = close + parent.closeAll;
  }
  return {
    open,
    close,
    openAll,
    closeAll,
    parent
  };
};
const createBuilder = (self2, _styler, _isEmpty) => {
  const builder = (...arguments_) => {
    if (isArray$8(arguments_[0]) && isArray$8(arguments_[0].raw)) {
      return applyStyle(builder, chalkTag(builder, ...arguments_));
    }
    return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
  };
  Object.setPrototypeOf(builder, proto$3);
  builder._generator = self2;
  builder._styler = _styler;
  builder._isEmpty = _isEmpty;
  return builder;
};
const applyStyle = (self2, string2) => {
  if (self2.level <= 0 || !string2) {
    return self2._isEmpty ? "" : string2;
  }
  let styler = self2._styler;
  if (styler === void 0) {
    return string2;
  }
  const { openAll, closeAll } = styler;
  if (string2.indexOf("") !== -1) {
    while (styler !== void 0) {
      string2 = stringReplaceAll(string2, styler.close, styler.open);
      styler = styler.parent;
    }
  }
  const lfIndex = string2.indexOf("\n");
  if (lfIndex !== -1) {
    string2 = stringEncaseCRLFWithFirstIndex(string2, closeAll, openAll, lfIndex);
  }
  return openAll + string2 + closeAll;
};
let template;
const chalkTag = (chalk2, ...strings) => {
  const [firstString] = strings;
  if (!isArray$8(firstString) || !isArray$8(firstString.raw)) {
    return strings.join(" ");
  }
  const arguments_ = strings.slice(1);
  const parts = [firstString.raw[0]];
  for (let i2 = 1; i2 < firstString.length; i2++) {
    parts.push(String(arguments_[i2 - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i2]));
  }
  if (template === void 0) {
    template = templates;
  }
  return template(chalk2, parts.join(""));
};
Object.defineProperties(Chalk.prototype, styles);
const chalk = Chalk();
chalk.supportsColor = stdoutColor;
chalk.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
chalk.stderr.supportsColor = stderrColor;
var source$1 = chalk;
function classInstance(object) {
  if (!object)
    return false;
  if (typeof object !== "object")
    return false;
  if (object.constructor && object.constructor.name === "Object")
    return false;
  if (Object.prototype.toString.call(object) === "[object Object]")
    return false;
  if (object.constructor === Object)
    return false;
  return true;
}
function deepMap(objectOrArray, processor, settings = {}, _path = []) {
  settings = __deepMerge$7({
    classInstances: false,
    array: true,
    privateProps: false,
    cloneFirst: true
  }, settings);
  const isArray2 = Array.isArray(objectOrArray);
  let newObject = isArray2 ? [] : settings.cloneFirst ? Object.assign({}, objectOrArray) : objectOrArray;
  Object.keys(objectOrArray).forEach((prop) => {
    if (!settings.privateProps && prop.match(/^_/))
      return;
    if (plainObject$7(objectOrArray[prop]) || classInstance(objectOrArray[prop]) && settings.classInstances || Array.isArray(objectOrArray[prop]) && settings.array) {
      const res2 = deepMap(objectOrArray[prop], processor, settings, [
        ..._path,
        prop
      ]);
      if (isArray2) {
        newObject.push(res2);
      } else {
        if (prop === "..." && plainObject$7(res2)) {
          newObject = Object.assign(Object.assign({}, newObject), res2);
        } else {
          newObject[prop] = res2;
        }
      }
      return;
    }
    const res = processor({
      object: objectOrArray,
      prop,
      value: objectOrArray[prop],
      path: [..._path, prop].join(".")
    });
    if (res === -1) {
      delete objectOrArray[prop];
      return;
    }
    if (isArray2)
      newObject.push(res);
    else {
      if (prop === "..." && plainObject$7(res)) {
        newObject = Object.assign(Object.assign({}, newObject), res);
      } else {
        newObject[prop] = res;
      }
    }
  });
  return newObject;
}
function isMap(value) {
  return value instanceof Map;
}
function isArray$7(value) {
  return value && typeof value === "object" && value.constructor === Array;
}
function isBoolean(value) {
  return typeof value === "boolean";
}
function isFunction$2(value) {
  return value && {}.toString.call(value) === "[object Function]";
}
function isJson(value) {
  try {
    const res = JSON.parse(value);
    if (Object.keys(res).length)
      return true;
    return false;
  } catch (e20) {
    return false;
  }
  return true;
}
function isObject$3(value) {
  return value && typeof value === "object" && value.constructor === Object;
}
function mapToObject(map2) {
  const obj2 = {};
  for (const [k2, v2] of map2)
    obj2[k2] = v2;
  return obj2;
}
var decycle_1;
const isArray$6 = (e20) => Array.isArray(e20), isObject$2 = (e20) => Object.prototype.toString.call(e20).slice(8, -1) === "Object", validate$1 = (e20) => {
  if (e20 === void 0)
    throw new Error("This method requires one parameter");
  if (!isArray$6(e20) && !isObject$2(e20))
    throw new TypeError("This method only accepts arrays and objects");
}, findRef = (e20, r2) => Object.keys(r2).find((a2) => r2[a2] === e20), decycle = (e20) => {
  validate$1(e20);
  let r2 = {};
  const a2 = (e21, c2 = "$") => {
    const s2 = findRef(e21, r2);
    return s2 ? { $ref: s2 } : isArray$6(e21) || isObject$2(e21) ? (r2[c2] = e21, isArray$6(e21) ? e21.map((e22, r3) => a2(e22, `${c2}[${r3}]`)) : Object.keys(e21).reduce((r3, s3) => (r3[s3] = a2(e21[s3], `${c2}.${s3}`), r3), {})) : e21;
  };
  return a2(e20);
};
decycle_1 = decycle;
function fn$6(value, settings = {}) {
  settings = __deepMerge$7({
    beautify: true,
    highlight: true,
    verbose: true,
    theme: {
      number: source$1.yellow,
      default: source$1.white,
      keyword: source$1.blue,
      regexp: source$1.red,
      string: source$1.whiteBright,
      class: source$1.yellow,
      function: source$1.yellow,
      comment: source$1.gray,
      variable: source$1.red,
      attr: source$1.green
    }
  }, settings);
  if (typeof value === "string")
    return value;
  if (value === null)
    return null;
  if (value === void 0)
    return void 0;
  if (value instanceof Error) {
    const errorStr = value.toString();
    const stackStr = value.stack;
    const messageStr = value.message;
    if (settings.verbose) {
      return [
        `<red>${value.constructor.name || "Error"}</red>`,
        "",
        messageStr,
        "",
        stackStr
      ].join("\n");
    }
    return errorStr;
  }
  if (isMap(value)) {
    value = mapToObject(value);
  }
  if (isObject$3(value) || isArray$7(value) || isJson(value)) {
    try {
      value = decycle_1(value);
    } catch (e20) {
    }
    value = deepMap(value, ({ value: value2 }) => {
      if (value2 instanceof Map)
        return mapToObject(value2);
      return value2;
    });
    let prettyString = JSON.stringify(value, null, settings.beautify ? 4 : 0);
    prettyString = prettyString.replace(/"([^"]+)":/g, "$1:").replace(/\uFFFF/g, '\\"');
    if (settings.highlight)
      ;
    return prettyString;
  }
  if (isBoolean(value)) {
    if (value)
      return "true";
    else
      return "false";
  }
  if (isFunction$2(value)) {
    return "" + value;
  }
  let returnString = "";
  try {
    value = decycle_1(value);
    returnString = JSON.stringify(value, null, settings.beautify ? 4 : 0);
  } catch (e20) {
    try {
      returnString = value.toString();
    } catch (e21) {
      returnString = value;
    }
  }
  return returnString;
}
var __parse = (value) => {
  if (typeof value !== "string")
    return value;
  value = value.split("\u2800").join("").trim();
  try {
    return Function(`
      "use strict";
      return (${value});
    `)();
  } catch (e20) {
    return value;
  }
};
const __encryptedMessages = {};
var __md5 = {
  encrypt: function(message) {
    if (typeof message !== "string")
      message = fn$6(message);
    const string2 = md5(message).toString();
    __encryptedMessages[string2] = message;
    return string2;
  },
  decrypt: function(message) {
    if (!__encryptedMessages[message]) {
      console.warn(`The message "${message}" cannot be decrypted...`);
      return;
    }
    const string2 = __encryptedMessages[message];
    delete __encryptedMessages[message];
    return __parse(string2);
  }
};
function availableColors(settings) {
  settings = Object.assign({ excludeBasics: false }, settings !== null && settings !== void 0 ? settings : {});
  const _colors = [
    "yellow",
    "cyan",
    "green",
    "magenta",
    "blue",
    "red",
    "grey",
    "gray"
  ];
  let colors = _colors;
  if (settings.excludeBasics) {
    colors = _colors.filter((c2) => {
      return c2 !== "white" && c2 !== "black" && c2 !== "grey" && c2 !== "gray";
    });
  }
  return colors;
}
function pickRandom(array) {
  return array[Math.round(Math.random() * (array.length - 1))];
}
const _colorUsedByScope = {};
const _colorsStack = {};
function getColorFor(ref, settings) {
  settings = __deepMerge$7({
    scope: "default",
    excludeBasics: true
  }, settings !== null && settings !== void 0 ? settings : {});
  const availableColors$1 = availableColors(settings);
  const scopeId = __md5.encrypt(settings.scope);
  const refId = __md5.encrypt(ref);
  if (_colorsStack[`${scopeId}.${refId}`])
    return _colorsStack[`${scopeId}.${refId}`];
  if (!_colorUsedByScope[scopeId])
    _colorUsedByScope[scopeId] = [];
  if (_colorUsedByScope[scopeId].length >= availableColors$1.length) {
    const color2 = pickRandom(availableColors$1);
    _colorsStack[`${scopeId}.${refId}`] = color2;
    return color2;
  } else {
    for (let i2 = 0; i2 < availableColors$1.length; i2++) {
      if (_colorUsedByScope[scopeId].indexOf(availableColors$1[i2]) === -1) {
        _colorUsedByScope[scopeId].push(availableColors$1[i2]);
        _colorsStack[`${scopeId}.${refId}`] = availableColors$1[i2];
        return availableColors$1[i2];
      }
    }
  }
}
var __set = (obj2, path2, value, settings = {}) => {
  settings = Object.assign({}, settings);
  if (!path2 || path2 === "" || path2 === ".") {
    obj2 = value;
    return;
  }
  path2 = path2.replace(/\[(\w+)\]/g, ".[$1]");
  const a2 = unquote(path2).split(/(?!\B"[^"]*)\.(?![^"]*"\B)/gm).map((p2) => unquote(p2));
  let o2 = obj2;
  while (a2.length - 1) {
    const n2 = a2.shift();
    if (!(n2 in o2)) {
      if (a2[0].match(/^\[[0-9]+\]$/))
        o2[n2] = [];
      else
        o2[n2] = {};
    }
    o2 = o2[n2];
  }
  if (a2[0].match(/^\[[0-9]+\]$/)) {
    if (!Array.isArray(o2))
      o2 = [];
    o2.push(value);
  } else {
    o2[a2[0]] = value;
  }
  return get$3(obj2, path2);
};
function toJson(object) {
  const newObj = {};
  deepMap(object, ({ value, path: path2 }) => {
    __set(newObj, path2, value);
    return value;
  }, {
    privateProps: false,
    classInstances: true
  });
  return newObj;
}
class SClass {
  constructor(settings = {}) {
    this._settings = {};
    this._interfacesStack = {};
    generateInterfacesStack(this);
    setSettings(this, settings);
    applyInterfaces(this);
    this.metas = getMetas(this);
    Object.defineProperty(this, "metas", {
      enumerable: true,
      value: getMetas(this)
    });
  }
  get formattedName() {
    var _a2, _b2, _c2;
    let name2 = `<yellow>${((_a2 = this.metas) === null || _a2 === void 0 ? void 0 : _a2.name) || ""}</yellow>`;
    if ((_b2 = this.metas) === null || _b2 === void 0 ? void 0 : _b2.id) {
      name2 += ` <cyan>${(_c2 = this.metas) === null || _c2 === void 0 ? void 0 : _c2.id}</cyan>`;
    }
    return name2;
  }
  static extends(Cls) {
    class SClass2 extends Cls {
      constructor(settings, ...args) {
        super(...args);
        this._settings = {};
        this._interfacesStack = {};
        generateInterfacesStack(this);
        setSettings(this, settings);
        applyInterfaces(this);
        this.metas = getMetas(this);
        Object.defineProperty(this, "metas", {
          enumerable: true,
          value: getMetas(this)
        });
      }
      get formattedName() {
        let name2 = `<yellow>${this.name || ""}</yellow>`;
        if (this.id) {
          name2 += ` <cyan>${this.id}</cyan>`;
        }
        return name2;
      }
      expose(instance, settings) {
        return expose(this, instance, settings);
      }
      applyInterface(name2, on2) {
        return applyInterface(this, name2, on2);
      }
      getInterface(name2) {
        return getInterface(this, name2);
      }
      toPlainObject() {
        return toPlainObject(this);
      }
    }
    return SClass2;
  }
  expose(instance, settings) {
    return expose(this, instance, settings);
  }
  applyInterface(name2, on2) {
    return applyInterface(this, name2, on2);
  }
  getInterface(name2) {
    return getInterface(this, name2);
  }
  toPlainObject() {
    return toPlainObject(this);
  }
}
function getMetas(ctx) {
  var _a2, _b2, _c2, _d2, _e2, _f3, _g2, _h2;
  let name2 = `<yellow>${((_a2 = ctx._settings.metas) === null || _a2 === void 0 ? void 0 : _a2.name) || ""}</yellow>`;
  if ((_b2 = ctx._settings.metas) === null || _b2 === void 0 ? void 0 : _b2.id) {
    name2 += ` <cyan>${ctx._settings.metas.id}</cyan>`;
  }
  const metasObj = {
    id: (_d2 = (_c2 = ctx._settings.metas) === null || _c2 === void 0 ? void 0 : _c2.id) !== null && _d2 !== void 0 ? _d2 : ctx.constructor.name,
    name: (_f3 = (_e2 = ctx._settings.metas) === null || _e2 === void 0 ? void 0 : _e2.name) !== null && _f3 !== void 0 ? _f3 : ctx.constructor.name,
    formattedName: name2,
    color: (_h2 = (_g2 = ctx._settings.metas) === null || _g2 === void 0 ? void 0 : _g2.color) !== null && _h2 !== void 0 ? _h2 : "yellow"
  };
  return metasObj;
}
function generateInterfacesStack(ctx) {
  const extendsStack = fn$7(ctx, {
    includeBaseClass: true
  });
  Object.keys(extendsStack).forEach((className) => {
    const cls2 = extendsStack[className];
    if (cls2.interfaces) {
      ctx._interfacesStack[className] = cls2.interfaces;
    }
  });
}
function expose(ctx, instance, settings) {
  settings = __deepMerge$7({
    as: void 0,
    props: []
  }, settings);
  if (settings.as && typeof settings.as === "string") {
    ctx[settings.as] = instance;
  }
  if (settings.props) {
    settings.props.forEach((prop) => {
      if (instance[prop].bind && typeof instance[prop].bind === "function") {
        ctx[prop] = instance[prop].bind(instance);
      } else {
        ctx[prop] = instance[prop];
      }
    });
  }
}
function getInterfaceObj(ctx, name2) {
  let interfaceObj = get$3(ctx._interfacesStack, name2);
  if (!interfaceObj) {
    const keys2 = Object.keys(ctx._interfacesStack);
    for (let i2 = 0; i2 < keys2.length; i2++) {
      const interfacesObj = ctx._interfacesStack[keys2[i2]];
      if (interfacesObj[name2] !== void 0) {
        if (plainObject$7(interfacesObj[name2])) {
          interfaceObj = interfacesObj[name2];
        } else {
          interfaceObj = {
            apply: true,
            on: name2 === "settings" ? "_settings" : name2 === "this" ? ctx : void 0,
            class: interfacesObj[name2]
          };
        }
        break;
      }
    }
  }
  if (name2 === "settings" && interfaceObj.on === void 0) {
    if (ctx.settings !== void 0)
      interfaceObj.on = "settings";
    else if (ctx._settings !== void 0)
      interfaceObj.on = "_settings";
  }
  return interfaceObj;
}
function toPlainObject(ctx) {
  return toJson(ctx);
}
function getInterface(ctx, name2) {
  const interfaceObj = getInterfaceObj(ctx, name2);
  if (plainObject$7(interfaceObj))
    return interfaceObj.class;
  return interfaceObj;
}
function applyInterfaces(ctx) {
  const keys2 = Object.keys(ctx._interfacesStack);
  for (let i2 = keys2.length - 1; i2 >= 0; i2--) {
    const interfacesObj = ctx._interfacesStack[keys2[i2]];
    const className = keys2[i2];
    Object.keys(interfacesObj).forEach((name2) => {
      const interfaceObj = interfacesObj[name2];
      let settings;
      if (plainObject$7(interfaceObj)) {
        settings = Object.assign({}, Object.assign({ apply: true, on: name2 === "settings" ? "_settings" : name2 === "this" ? ctx : void 0 }, interfaceObj));
      } else {
        settings = Object.assign({}, {
          apply: true,
          on: name2 === "settings" ? "_settings" : name2 === "this" ? ctx : void 0,
          class: interfaceObj
        });
      }
      if (settings.apply !== true)
        return;
      if (settings.on) {
        if (typeof settings.on === "string" && get$3(ctx, settings.on) !== void 0) {
          applyInterface(ctx, `${className}.${name2}`, settings.on);
        } else if (typeof settings.on === "object") {
          applyInterface(ctx, `${className}.${name2}`, settings.on);
        } else if (ctx[name2] !== void 0) {
          applyInterface(ctx, `${className}.${name2}`);
        }
      }
    });
  }
}
function applyInterface(ctx, name2, on2 = null) {
  const interfaceObj = getInterfaceObj(ctx, `${name2}`);
  if (!interfaceObj) {
    throw new Error(`You try to apply the interface named "<yellow>${name2}</yellow>" on the context "<cyan>${ctx.name}</cyan>" but it does not exists...`);
  }
  if (on2 !== void 0)
    interfaceObj.on = on2;
  if (!interfaceObj) {
    throw `Sorry the the asked interface "<yellow>${name2}</yellow>" does not exists on the class "<cyan>${ctx.constructor.name}</cyan>"`;
  }
  if (name2.includes(".")) {
    name2 = name2.split(".").slice(1).join(".");
  }
  if (plainObject$7(interfaceObj)) {
    let onValue;
    if (interfaceObj.on && typeof interfaceObj.on === "string") {
      onValue = get$3(ctx, interfaceObj.on);
    } else if (interfaceObj.on && typeof interfaceObj.on === "object") {
      onValue = interfaceObj.on;
    } else {
      onValue = get$3(ctx, name2);
    }
    let applyId = ctx.constructor.name;
    if (ctx.id)
      applyId += `(${ctx.id})`;
    if (name2)
      applyId += `.${name2}`;
    if (interfaceObj.on && interfaceObj.on.constructor)
      applyId += `.${interfaceObj.on.constructor.name}`;
    if (interfaceObj.on && interfaceObj.on.id)
      applyId += `(${interfaceObj.on.id})`;
    let res;
    if (name2 === "this") {
      res = interfaceObj.class.apply(onValue || {}, {
        id: applyId,
        throw: true
      });
      deepAssign(ctx, res.value);
      return ctx;
    } else {
      res = interfaceObj.class.apply(onValue, {
        id: applyId,
        throw: true
      });
      if (interfaceObj.on && typeof interfaceObj.on === "object") {
        const returnValue = deepAssign(interfaceObj.on, res);
        return returnValue;
      } else if (interfaceObj.on && typeof interfaceObj.on === "string") {
        return deepAssign(get$3(ctx, interfaceObj.on), res);
      } else if (ctx[name2] !== void 0) {
        return ctx[name2];
      } else {
        return res;
      }
    }
  }
}
function setSettings(ctx, settings = {}) {
  var _a2;
  ctx._settings = settings;
  if (!ctx._settings.metas)
    ctx._settings.metas = {};
  if (!((_a2 = ctx._settings.metas) === null || _a2 === void 0 ? void 0 : _a2.id))
    ctx._settings.metas.id = ctx.constructor.name;
  if (!ctx.constructor.name.match(/^SConfig/)) {
    if (!ctx._settings.metas.color)
      ctx._settings.metas.color = getColorFor(ctx.constructor.name, {
        scope: "class"
      });
  } else if (!ctx._settings.metas.color)
    ctx._settings.metas.color = "yellow";
}
function isInteger(data) {
  return typeof data === "number" && !isNaN(data) && function(x2) {
    return (x2 | 0) === x2;
  }(parseFloat(data));
}
function upperFirst(string2) {
  return string2.charAt(0).toUpperCase() + string2.slice(1);
}
function typeOf(value, settings = {}) {
  settings = __deepMerge$7({
    of: false,
    customClass: true
  }, settings);
  let type;
  if (Array.isArray(value))
    type = "Array";
  else if (value instanceof Map)
    type = "Map";
  else if (value === null)
    type = "Null";
  else if (value === void 0)
    type = "Undefined";
  else if (typeof value === "string")
    type = "String";
  else if (isInteger(value))
    type = "Integer";
  else if (typeof value === "number")
    type = "Number";
  else if (typeof value === "boolean")
    type = "Boolean";
  else if (value instanceof RegExp)
    type = "RegExp";
  else if (settings.customClass === true && cls(value) && value.name !== void 0) {
    type = upperFirst(value.name);
  } else if (settings.customClass === true && value.constructor !== void 0 && value.constructor.name !== void 0) {
    type = upperFirst(value.constructor.name);
  } else if (settings.customClass === false && cls(value)) {
    type = "Class";
  } else if (typeof value === "function")
    type = "Function";
  else if (typeof value === "object")
    type = "Object";
  else
    type = "Unknown";
  const avoidTypes = [
    "Null",
    "Undefined",
    "String",
    "Integer",
    "Number",
    "Boolean",
    "Unknown"
  ];
  if (settings.of === true && !avoidTypes.includes(type)) {
    const loopOn = Array.isArray(value) ? [...value.keys()] : Object.keys(value);
    const receivedTypes = [];
    loopOn.forEach((valueIndex) => {
      const valueToCheck = value[valueIndex];
      const childType = typeOf(valueToCheck, {
        of: false,
        customClass: settings.customClass
      });
      if (!receivedTypes.includes(childType)) {
        receivedTypes.push(childType);
      }
    });
    type += `<${receivedTypes.join("|")}>`;
  }
  return type;
}
const fn$5 = function(stack, callback, settings = {}) {
  settings = Object.assign({ newStack: false }, settings);
  const stackType = typeOf(stack).toLowerCase();
  let loopOnKeys;
  if (stackType === "object")
    loopOnKeys = Object.keys(stack);
  else if (stackType === "array")
    loopOnKeys = Array.from(Array(stack.length).keys());
  else if (stackType === "number" || stackType === "integer")
    loopOnKeys = Array.from(Array(Math.round(stack)).keys());
  else if (stackType === "string")
    loopOnKeys = Array.from(stack);
  else if (stackType === "set")
    loopOnKeys = Array.from(stack);
  else
    loopOnKeys = Array.from(stack.keys());
  if (stackType === "string" || stackType === "number" || stackType === "integer" || stackType === "set")
    settings.newStack = true;
  let newStack = [];
  if (stackType === "object")
    newStack = {};
  else if (stackType === "map")
    newStack = new Map();
  else if (stackType === "set")
    newStack = new Set();
  let value;
  let newValue;
  const _get = (s2, k2) => {
    switch (typeOf(s2).toLowerCase()) {
      case "array":
      case "object":
        return s2[k2];
      case "string":
        return k2;
      case "number":
      case "integer":
        return k2;
      case "map":
        return s2.get(k2);
      case "set":
        return k2;
    }
  };
  const _set = (s2, k2, v2) => {
    switch (typeOf(s2).toLowerCase()) {
      case "array":
        if (settings.newStack === true)
          s2.push(v2);
        else
          s2[k2] = v2;
        break;
      case "object":
        s2[k2] = v2;
        break;
      case "number":
      case "integer":
      case "string":
        s2.push(v2);
        break;
      case "map":
        s2.set(k2, v2);
        break;
      case "set":
        s2.add(v2);
        break;
    }
  };
  for (let i2 = 0; i2 < loopOnKeys.length; i2++) {
    const key = loopOnKeys[i2];
    value = _get(stack, key);
    newValue = callback({ key, prop: key, value, i: i2, idx: i2 });
    if (newValue === -1)
      break;
    _set(settings.newStack ? newStack : stack, key, newValue);
  }
  if (stackType === "string") {
    return newStack.join("");
  }
  return settings.newStack ? newStack : stack;
};
source$1.level = 3;
const tagsMap = {
  black: (tag2, content) => source$1.black(content),
  red: (tag2, content) => source$1.red(content),
  green: (tag2, content) => source$1.green(content),
  yellow: (tag2, content) => source$1.yellow(content),
  blue: (tag2, content) => source$1.blue(content),
  magenta: (tag2, content) => source$1.magenta(content),
  cyan: (tag2, content) => source$1.cyan(content),
  white: (tag2, content) => source$1.white(content),
  grey: (tag2, content) => source$1.grey(content),
  bgBlack: (tag2, content) => source$1.bgBlack(content),
  bgRed: (tag2, content) => source$1.bgRed(content),
  bgGreen: (tag2, content) => source$1.bgGreen(content),
  bgYellow: (tag2, content) => source$1.bgYellow(content),
  bgBlue: (tag2, content) => source$1.bgBlue(content),
  bgMagenta: (tag2, content) => source$1.bgMagenta(content),
  bgCyan: (tag2, content) => source$1.bgCyan(content),
  bgWhite: (tag2, content) => source$1.bgWhite(content),
  bold: (tag2, content) => source$1.bold(content),
  dim: (tag2, content) => source$1.dim(content),
  italic: (tag2, content) => source$1.italic(content),
  underline: (tag2, content) => source$1.underline(content),
  strike: (tag2, content) => source$1.strike(content),
  h1: (tag2, content) => {
    return source$1.underline(source$1.bold(content)) + "\n\n";
  },
  h2: (tag2, content) => {
    return source$1.bold(content) + "\n";
  },
  date: (tag2, content) => new Date().getDate().toString().padStart("0", 2) + "-" + (new Date().getMonth() + 1).toString().padStart("0", 2) + "-" + new Date().getFullYear().toString().padStart("0", 2),
  time: (tag2, content) => new Date().getHours().toString().padStart("0", 2) + ":" + new Date().getMinutes().toString().padStart("0", 2) + ":" + new Date().getMinutes().toString().padStart("0", 2),
  day: (tag2, content) => new Date().getDate().toString().padStart("0", 2),
  days: (tag2, content) => new Date().getDate().toString().padStart("0", 2),
  month: (tag2, content) => new Date().getMonth().toString().padStart("0", 2),
  months: (tag2, content) => new Date().getMonth().toString().padStart("0", 2),
  year: (tag2, content) => new Date().getFullYear().toString().padStart("0", 2),
  years: (tag2, content) => new Date().getFullYear().toString().padStart("0", 2),
  hour: (tag2, content) => new Date().getHours().toString().padStart("0", 2),
  hours: (tag2, content) => new Date().getHours().toString().padStart("0", 2),
  minute: (tag2, content) => new Date().getMinutes().toString().padStart("0", 2),
  minutes: (tag2, content) => new Date().getMinutes().toString().padStart("0", 2),
  second: (tag2, content) => new Date().getSeconds().toString().padStart("0", 2),
  seconds: (tag2, content) => new Date().getSeconds().toString().padStart("0", 2),
  br: (tag2, content) => "\n"
};
function replaceTags(text, tags) {
  if (!text)
    text = "";
  text = fn$6(text);
  let oneLineText = text.replace(/\r\n/g, "|rn|");
  oneLineText = oneLineText.replace(/\n/g, "|n|");
  oneLineText = oneLineText.replace(/\r/g, "|r|");
  Object.keys(tags).forEach((tagName) => {
    const reg = new RegExp(`<s*${tagName}[^>]*>((.*?))<\\s*/\\s*${tagName}>`, "g");
    const tagsArray = oneLineText.match(reg);
    const singleReg = new RegExp(`\\s?<${tagName}\\s?/>\\s?`, "g");
    const singleTagsArray = oneLineText.match(singleReg);
    if (tagsArray) {
      for (let i2 = 0; i2 < tagsArray.length; i2++) {
        const t2 = tagsArray[i2];
        const tagArgs = t2.match(`<\\s*${tagName}[^>]*>((.*?))<\\s*/\\s*${tagName}>`);
        if (!tagArgs)
          continue;
        const tagToReplace = tagArgs[0];
        const tagContent = tagArgs[1];
        oneLineText = oneLineText.replace(tagToReplace, tags[tagName](tagName, tagContent));
      }
    }
    if (singleTagsArray) {
      for (let i2 = 0; i2 < singleTagsArray.length; i2++) {
        const t2 = singleTagsArray[i2];
        const tagArgs = t2.match(`\\s?<${tagName}\\s?/>\\s?`);
        if (!tagArgs)
          continue;
        const tagToReplace = tagArgs[0];
        const tagContent = "";
        oneLineText = oneLineText.replace(tagToReplace, tags[tagName](tagName, tagContent));
      }
    }
  });
  oneLineText = oneLineText.replace(/\|rn\|/g, "\r\n");
  oneLineText = oneLineText.replace(/\|n\|/g, "\n");
  oneLineText = oneLineText.replace(/\|r\|/g, "\r");
  return oneLineText;
}
function parseHtml(message) {
  let isArray2 = false;
  if (Array.isArray(message)) {
    isArray2 = true;
  } else {
    message = [message];
  }
  message = message.map((m2) => {
    return replaceTags(m2, tagsMap);
  });
  if (isArray2)
    return message;
  return message[0];
}
function parseSingleTypeString(typeString) {
  let ofStr = "", typeStr = typeString;
  const ofPartsString = typeString.match(/<(.+)>$/gm);
  if (ofPartsString && ofPartsString.length) {
    ofStr = ofPartsString[0].replace("<", "").replace(">", "");
  }
  if (ofStr !== "") {
    typeStr = typeStr.replace(`<${ofStr}>`, "");
  }
  let ofTypes = ofStr !== "" ? [ofStr.toLowerCase()] : void 0;
  if (ofStr !== void 0 && ofStr.includes("|")) {
    ofTypes = ofStr.split("|").map((t2) => t2.trim().toLowerCase());
  }
  return {
    type: typeStr,
    of: ofTypes
  };
}
const fn$4 = function parseTypeString(typeString) {
  typeString = typeString.toLowerCase().trim();
  typeString = typeString.split("|").map((part) => {
    part = part.trim().replace(/^([a-zA-Z0-9-_]+)\[\]$/, "array<$1>");
    return part;
  }).join("|");
  typeString = typeString.split("|").map((part) => {
    part = part.trim().replace(/^([a-zA-Z0-9-_]+)\{\}$/, "object<$1>");
    return part;
  }).join("|");
  let types = [], inGroup = false, currentStr = "";
  for (let i2 = 0; i2 < typeString.length; i2++) {
    const char = typeString[i2];
    if (char === "<") {
      inGroup = true;
      currentStr += char;
    } else if (char === ">") {
      inGroup = false;
      currentStr += char;
    } else if (char === "|") {
      if (inGroup === false) {
        types.push(currentStr);
        currentStr = "";
      } else {
        currentStr += char;
      }
    } else {
      currentStr += char;
    }
  }
  types.push(currentStr);
  const finalTypes = [];
  types.forEach((type) => {
    finalTypes.push(parseSingleTypeString(type));
  });
  const res = {
    raw: typeString,
    types: finalTypes
  };
  return res;
};
var __isNode$1 = () => {
  return typeof process !== "undefined" && process.release && process.release.name === "node";
};
class STypeResult {
  constructor(data) {
    this._data = data;
  }
  get typeString() {
    return this._data.typeString;
  }
  get value() {
    return this._data.value;
  }
  get received() {
    return this._data.received;
  }
  get expected() {
    return this._data.expected;
  }
  get issues() {
    return this._data.issues;
  }
  get settings() {
    return this._data.settings;
  }
  hasIssues() {
    if (this._data)
      return true;
    return false;
  }
  toString() {
    if (__isNode$1()) {
      return this.toConsole();
    } else {
      return `The method "toHtml" has not being integrated for now...`;
    }
  }
  toConsole() {
    const headerArray = [
      `<underline><magenta>${this._data.settings.name}</magenta></underline>`,
      "",
      "<underline>Received value</underline>",
      "",
      `${fn$6(this._data.value, {
        beautify: true
      })}`,
      ""
    ];
    const issuesArray = [];
    Object.keys(this._data.issues).forEach((ruleId) => {
      const issueObj = this._data.issues[ruleId];
      const message = [];
      if (issueObj.expected.type) {
        message.push(`- Expected "<yellow>${issueObj.expected.type}</yellow>"`);
      }
      if (issueObj.received.type) {
        message.push(`- Received "<red>${issueObj.received.type}</red>"`);
      }
      if (issueObj.message) {
        message.push(["<underline>Details:</underline>", issueObj.message].join("\n"));
      }
      issuesArray.push(message.join("\n"));
    });
    const settingsArray = [
      "",
      `<underline>Settings</underline>`,
      "",
      `${fn$6(this._data.settings, {
        beautify: true
      })}`
    ];
    return parseHtml(`
${headerArray.join("\n")}
${issuesArray.join("\n")}
${this.settings.verbose ? settingsArray.join("\n") : ""}
    `).trim();
  }
}
class SType {
  constructor(typeString, settings = {}) {
    this.typeString = typeString;
    typeString = typeString.toLowerCase().trim();
    if (this.constructor._instanciatedTypes[typeString] !== void 0)
      return this.constructor._instanciatedTypes[typeString];
    this.types = fn$4(typeString).types;
    this._settings = __deepMerge$7({
      id: this.constructor.name,
      name: this.constructor.name,
      customTypes: true,
      interfaces: true
    }, settings);
    this.constructor._instanciatedTypes[typeString] = this;
  }
  static registerType(type) {
    if (type.id === void 0 || typeof type.id !== "string") {
      throw new Error(`Sorry but you try to register a type that does not fit the ISTypeDescriptor interface...`);
    }
    this._registeredTypes[type.id] = type;
  }
  is(value, settings = {}) {
    const res = this.check(value, settings);
    if (res === true)
      return true;
    else if (res instanceof STypeResult)
      return !res.hasIssues();
    return true;
  }
  check(value, settings = {}) {
    settings = __deepMerge$7(this._settings, settings);
    const issues = {};
    for (let i2 = 0; i2 < this.types.length; i2++) {
      const typeObj = this.types[i2], typeId = typeObj.type;
      const res2 = this._isType(value, typeId, settings);
      if (res2 === true) {
        if (typeObj.of === void 0)
          return true;
        const typeOf$1 = typeOf(value);
        if (typeOf$1 !== "Array" && typeOf$1 !== "Object" && typeOf$1 !== "Map") {
          throw new Error(`Sorry but you have specified a type string "<yellow>${this.typeString}</yellow>" with some "<...>" definition on a type "<cyan>${typeOf$1}</cyan>" that does not support "child" value(s)...`);
        }
        const loopOn = typeOf$1 === "Object" ? Object.keys(value) : Array.from(value.keys());
        if (!loopOn.length)
          return true;
        for (let k2 = 0; k2 < loopOn.length; k2++) {
          for (let j2 = 0; j2 < typeObj.of.length; j2++) {
            const type = typeObj.of[j2];
            const idx = loopOn[k2];
            const v2 = typeOf$1 === "Map" ? value.get(idx) : value[idx];
            const ofRes = this._isType(v2, type, settings);
            if (ofRes !== true) {
              issues[typeObj.type] = {
                expected: {
                  type: typeObj.type
                },
                received: {
                  type: typeOf(v2),
                  value: v2
                }
              };
            } else {
              return true;
            }
          }
        }
      } else {
        const issueObj = {
          expected: {
            type: typeObj.type
          },
          received: {
            type: typeOf(value),
            value
          }
        };
        if (res2 !== void 0 && res2 !== null && res2 !== false && res2.toString && typeof res2.toString === "function") {
          issueObj.message = res2.toString();
        }
        issues[typeObj.type] = issueObj;
      }
    }
    const res = new STypeResult({
      typeString: this.typeString,
      value,
      expected: {
        type: this.typeString
      },
      received: {
        type: typeOf(value)
      },
      issues,
      settings
    });
    return res;
  }
  _isType(value, type, settings = {}) {
    settings = __deepMerge$7(this._settings, settings);
    if (this.constructor._registeredTypes[type.toLowerCase()] === void 0) {
      if (settings.interfaces === true) {
        const availableInterfaceTypes = SInterface.getAvailableTypes();
        if (availableInterfaceTypes[type] !== void 0) {
          const res = availableInterfaceTypes[type].apply(value, {});
          return res;
        }
      }
      if (settings.customTypes === true) {
        const typeOf$1 = typeOf(value).toLowerCase();
        const extendsStack = Object.keys(fn$7(value)).map((s2) => s2.toLowerCase());
        if (type === typeOf$1 || extendsStack.indexOf(type) !== -1)
          return true;
      }
      throw new Error(`Sorry but you try to validate a value with the type "<yellow>${type}</yellow>" but this type is not registered...`);
    }
    return this.constructor._registeredTypes[type.toLowerCase()].is(value);
  }
  cast(value, params, settings) {
    settings = __deepMerge$7(this._settings, settings);
    const verboseObj = {
      value,
      issues: {},
      settings,
      toString() {
        const strAr = Object.entries(this.issues);
        return strAr.map((l2) => l2[1]).join("\n");
      }
    };
    if (this.is(value)) {
      return value;
    }
    for (let i2 = 0; i2 < this.types.length; i2++) {
      const typeObj = this.types[i2], typeId = typeObj.type;
      const descriptorObj = this.constructor._registeredTypes[typeId.toLowerCase()];
      if (descriptorObj === void 0) {
        continue;
      }
      if (descriptorObj.cast === void 0)
        continue;
      let castedValue;
      castedValue = descriptorObj.cast(value, params);
      if (castedValue instanceof Error) {
        verboseObj.issues[typeId] = castedValue.toString();
        continue;
      }
      if (typeObj.of !== void 0 && this.canHaveChilds(castedValue) === false) {
        const issueStr = `Sorry but the passed type "<yellow>${typeId}</yellow>" has some child(s) dependencies "<green>${typeObj.of.join("|")}</green>" but this type can not have child(s)`;
        throw new Error(parseHtml(issueStr));
      } else if (typeObj.of !== void 0) {
        const sTypeInstance = new SType(typeObj.of.join("|"));
        castedValue = fn$5(castedValue, ({ value: value2 }) => {
          return sTypeInstance.cast(value2, params, settings);
        });
      }
      if (castedValue === null && descriptorObj.id === "null")
        return null;
      if (castedValue === void 0 && descriptorObj.id === "undefined")
        return void 0;
      if (castedValue !== null && castedValue !== void 0)
        return castedValue;
      verboseObj.issues[typeId] = `Something goes wrong but no details are available... Sorry`;
    }
    const stack = [
      `Sorry but the value of type "<cyan>${typeOf(value)}</cyan>" passed to be casted in type "<yellow>${this.typeString}</yellow>" can not be casted correctly. Here's why:
`
    ];
    Object.keys(verboseObj.issues).forEach((descriptorId) => {
      stack.push(`- <red>${descriptorId}</red>: ${verboseObj.issues[descriptorId]}`);
    });
    throw new Error(parseHtml(stack.join("\n")));
  }
  canHaveChilds(value) {
    const type = typeOf(value);
    return type === "Array" || type === "Object" || type === "Map";
  }
  get name() {
    return this._settings.name;
  }
  get id() {
    return this._settings.id;
  }
}
SType._instanciatedTypes = {};
SType._registeredTypes = {};
function isString$2(value) {
  return typeof value === "string" || value instanceof String;
}
const descriptor$g = {
  name: "String",
  id: "string",
  is: (value) => isString$2(value),
  cast: (value) => fn$6(value, {
    beautify: true
  })
};
const descriptor$f = {
  name: "Map",
  id: "map",
  is: (value) => isMap(value),
  cast: (value) => {
    if (isMap(value))
      return value;
    const map2 = new Map();
    map2.set("value", value);
    return map2;
  }
};
const descriptor$e = {
  name: "Object",
  id: "object",
  is: (value) => isObject$3(value),
  cast: (value) => {
    if (isObject$3(value))
      return value;
    return {
      value
    };
  }
};
const descriptor$d = {
  name: "Array",
  id: "array",
  is: (value) => {
    return Array.isArray(value);
  },
  cast: (value, params = {}) => {
    if (!value)
      return [];
    if (params.splitChars && Array.isArray(params.splitChars)) {
      value = value.split(new RegExp(`(${params.splitChars.join("|")})`, "gm")).filter((l2) => l2.trim() !== "" && params.splitChars.indexOf(l2) === -1);
    }
    if (Array.isArray(value))
      return value;
    return [value];
  }
};
const descriptor$c = {
  name: "Integer",
  id: "integer",
  is: (value) => Number.isInteger(value),
  cast: (value) => {
    if (typeof value !== "string" && typeof value !== "number") {
      return new Error(`Sorry but only strings and numbers can be casted to integers... Passed value: ${value}`);
    }
    const res = parseInt(value);
    if (isNaN(res))
      return new Error(`Sorry but the conversion of "<yellow>${value}</yellow>" to a <green>Integer</green> does not work...`);
    return res;
  }
};
const descriptor$b = {
  name: "Number",
  id: "number",
  is: (value) => typeof value === "number",
  cast: (value) => {
    if (typeof value !== "string") {
      return new Error(`Sorry but only strings can be casted to numbers...`);
    }
    const res = parseFloat(value);
    if (isNaN(res))
      return new Error(`Sorry but the conversion of "<yellow>${value}</yellow>" to a <green>Number</green> does not work...`);
    return res;
  }
};
const descriptor$a = {
  name: "Boolean",
  id: "boolean",
  is: (value) => typeof value === "boolean",
  cast: (value, params = {}) => {
    if (value !== false && params && params.nullishAsTrue && !value) {
      return true;
    }
    if (typeof value === "boolean")
      return value;
    if (value === null || value === void 0)
      return false;
    if (typeof value === "number") {
      if (value > 0)
        return true;
      return false;
    }
    if (typeof value === "string") {
      return value.length > 0 ? true : false;
    }
    if (Array.isArray(value)) {
      if (value.length > 0)
        return true;
      return false;
    }
    if (typeof value === "object") {
      return Object.keys(value).length > 0 ? true : false;
    }
    return new Error([
      `Sorry but for now only these types can be casted to boolean:`,
      "- <yellow>null</yellow>: Will be casted as <red>false</red>",
      "- <yellow>undefined</yellow>: Will be casted as <red>false</red>",
      "- <yellow>Number</yellow>: Will be casted as <green>true</green> when greater than 0, <red>false</red> otherwise",
      "- <yellow>String</yellow>: Will be casted as <green>true</green> when longer than 0 characters, <red>false</red> otherwise",
      "- <yellow>Array</yellow>: Will be casted as <green>true</green> when having more than 0 items, <red>false</red> otherwise",
      "- <yellow>Object</yellow>: Will be casted as <green>true</green> when have more than 0 properties, <red>false</red> otherwise"
    ].join("\n"));
  }
};
const descriptor$9 = {
  name: "Undefined",
  id: "undefined",
  is: (value) => value === void 0,
  cast: (value) => {
    return void 0;
  }
};
const descriptor$8 = {
  name: "Null",
  id: "null",
  is: (value) => value === null,
  cast: (value) => {
    return null;
  }
};
const descriptor$7 = {
  name: "Symbol",
  id: "symbol",
  is: (value) => typeof value === "symbol",
  cast: (value) => {
    if (typeof value === "symbol")
      return value;
    return Symbol(value);
  }
};
const descriptor$6 = {
  name: "Bigint",
  id: "bigint",
  is: (value) => typeof value === "bigint",
  cast: (value) => {
    if (typeof value === "bigint")
      return value;
    if (typeof value !== "string" && typeof value !== "number") {
      return new Error(`Sorry but only <yellow>String</yellow> and <yellow>Number</yellow> can be casted to <green>Bigint</green>`);
    }
    let res;
    try {
      res = BigInt(value);
    } catch (e20) {
      res = new Error(`It seem's that the passed value "<yellow>${value}</yellow>" can not be casted to a <green>BigInt</green>`);
    }
    return res;
  }
};
const descriptor$5 = {
  name: "Date",
  id: "date",
  is: (value) => value instanceof Date,
  cast: (value) => {
    if (typeof value === "string") {
      return new Date(value);
    }
    if (typeof value === "number") {
      return new Date(Math.round(value));
    }
    if (plainObject$7(value)) {
      const now2 = new Date();
      let year = now2.getFullYear(), month = 0, day = 1, hours2 = 0, minutes2 = 0, seconds2 = 0, milliseconds2 = 0;
      if (value.year && typeof value.year === "number") {
        year = value.year;
      }
      if (value.month && typeof value.month === "number") {
        month = value.month;
      }
      if (value.day && typeof value.day === "number") {
        day = value.day;
      }
      if (value.hours && typeof value.hours === "number") {
        hours2 = value.hours;
      }
      if (value.minutes && typeof value.minutes === "number") {
        minutes2 = value.minutes;
      }
      if (value.seconds && typeof value.seconds === "number") {
        seconds2 = value.seconds;
      }
      if (value.milliseconds && typeof value.milliseconds === "number") {
        milliseconds2 = value.milliseconds;
      }
      return new Date(year, month, day, hours2, minutes2, seconds2, milliseconds2);
    }
    return new Error(`Sorry but for now only <yellow>String</yellow>, <yellow>Number</yellow> and <yellow>Object</yellow> (with properties: year, month, day?, hours?, minutes?, seconds? and milliseconds?) are castable to Date`);
  }
};
const descriptor$4 = {
  name: "Function",
  id: "function",
  is: (value) => typeof value === "function",
  cast: (value) => {
    return new Error(`Sorry but nothing is castable to a Function`);
  }
};
const descriptor$3 = {
  name: "WeakMap",
  id: "weakmap",
  is: (value) => value instanceof WeakMap,
  cast: (value) => {
    return new Error(`Sorry but nothing can be casted to a WeakMap for now`);
  }
};
const descriptor$2 = {
  name: "WeakSet",
  id: "weakset",
  is: (value) => value instanceof WeakSet,
  cast: (value) => {
    return new Error(`Sorry but nothing can be casted to a WeakSet for now`);
  }
};
const descriptor$1 = {
  name: "Set",
  id: "set",
  is: (value) => value instanceof Set,
  cast: (value) => {
    if (value instanceof Set)
      return value;
    const set2 = new Set();
    set2.add(value);
    return set2;
  }
};
const descriptor = {
  name: "Class",
  id: "class",
  is: (value) => cls(value),
  cast: (value) => {
    return new Error(`Sorry but nothing is castable to a Class`);
  }
};
SType.registerType(descriptor$g);
SType.registerType(descriptor$f);
SType.registerType(descriptor$e);
SType.registerType(descriptor$d);
SType.registerType(descriptor$c);
SType.registerType(descriptor$b);
SType.registerType(descriptor$a);
SType.registerType(descriptor$9);
SType.registerType(descriptor$8);
SType.registerType(descriptor$7);
SType.registerType(descriptor$6);
SType.registerType(descriptor$5);
SType.registerType(descriptor$4);
SType.registerType(descriptor$3);
SType.registerType(descriptor$2);
SType.registerType(descriptor$1);
SType.registerType(descriptor);
function ofType(value, typeString, settings = {}) {
  settings = Object.assign({ verbose: false }, settings);
  const typeInstance = new SType(typeString, settings);
  const res = typeInstance.is(value);
  return res;
}
class SDescriptorResult extends SClass {
  constructor(descriptor2, value, descriptorSettings) {
    super({});
    this._issues = {};
    this._descriptor = descriptor2;
    this._descriptorSettings = descriptorSettings;
    try {
      this._originalValue = clone$2(value, { deep: true });
    } catch (e20) {
      this._originalValue = value;
    }
    this.value = value;
  }
  hasIssues() {
    return Object.keys(this._issues).length >= 1;
  }
  add(ruleResult) {
    if (!ruleResult.__ruleObj.id)
      return;
    this._issues[ruleResult.__ruleObj.id] = ruleResult;
  }
  toString() {
    if (__isNode$1()) {
      return this.toConsole();
    } else {
      return this.toConsole();
    }
  }
  toConsole() {
    const headerArray = [
      `<underline><magenta>${this._descriptor.metas.name}</magenta></underline>`,
      "",
      `${fn$6(this.value, {
        beautify: true
      })}`,
      ""
    ];
    const issuesArray = [];
    Object.keys(this._issues).forEach((ruleId) => {
      const ruleResult = this._issues[ruleId];
      let message = "";
      if (ruleResult.__error && ruleResult.__error instanceof Error) {
        message = ruleResult.__error.message;
      } else if (ruleResult.__ruleObj.message !== void 0 && typeof ruleResult.__ruleObj.message === "function") {
        message = ruleResult.__ruleObj.message(ruleResult);
      } else if (ruleResult.__ruleObj.message !== void 0 && typeof ruleResult.__ruleObj.message === "string") {
        message = ruleResult.__ruleObj.message;
      }
      issuesArray.push(`-${typeof ruleResult.__propName === "string" ? ` [<magenta>${ruleResult.__propName}</magenta>]` : ""} <red>${ruleId}</red>: ${message}`);
    });
    const settingsArray = [
      "",
      `<underline>Settings</underline>`,
      "",
      `${fn$6(this._descriptorSettings, {
        beautify: true
      })}`
    ];
    return parseHtml(`
${headerArray.join("\n")}
${issuesArray.join("\n")}
${settingsArray.join("\n")}
    `).trim();
  }
}
/*!
* is-extglob <https://github.com/jonschlinkert/is-extglob>
*
* Copyright (c) 2014-2016, Jon Schlinkert.
* Licensed under the MIT License.
*/
var isExtglob$1 = function isExtglob2(str) {
  if (typeof str !== "string" || str === "") {
    return false;
  }
  var match5;
  while (match5 = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
    if (match5[2])
      return true;
    str = str.slice(match5.index + match5[0].length);
  }
  return false;
};
/*!
* is-glob <https://github.com/jonschlinkert/is-glob>
*
* Copyright (c) 2014-2017, Jon Schlinkert.
* Released under the MIT License.
*/
var isExtglob = isExtglob$1;
var chars = { "{": "}", "(": ")", "[": "]" };
var strictCheck = function(str) {
  if (str[0] === "!") {
    return true;
  }
  var index = 0;
  var pipeIndex = -2;
  var closeSquareIndex = -2;
  var closeCurlyIndex = -2;
  var closeParenIndex = -2;
  var backSlashIndex = -2;
  while (index < str.length) {
    if (str[index] === "*") {
      return true;
    }
    if (str[index + 1] === "?" && /[\].+)]/.test(str[index])) {
      return true;
    }
    if (closeSquareIndex !== -1 && str[index] === "[" && str[index + 1] !== "]") {
      if (closeSquareIndex < index) {
        closeSquareIndex = str.indexOf("]", index);
      }
      if (closeSquareIndex > index) {
        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
          return true;
        }
        backSlashIndex = str.indexOf("\\", index);
        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
          return true;
        }
      }
    }
    if (closeCurlyIndex !== -1 && str[index] === "{" && str[index + 1] !== "}") {
      closeCurlyIndex = str.indexOf("}", index);
      if (closeCurlyIndex > index) {
        backSlashIndex = str.indexOf("\\", index);
        if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
          return true;
        }
      }
    }
    if (closeParenIndex !== -1 && str[index] === "(" && str[index + 1] === "?" && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ")") {
      closeParenIndex = str.indexOf(")", index);
      if (closeParenIndex > index) {
        backSlashIndex = str.indexOf("\\", index);
        if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
          return true;
        }
      }
    }
    if (pipeIndex !== -1 && str[index] === "(" && str[index + 1] !== "|") {
      if (pipeIndex < index) {
        pipeIndex = str.indexOf("|", index);
      }
      if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
        closeParenIndex = str.indexOf(")", pipeIndex);
        if (closeParenIndex > pipeIndex) {
          backSlashIndex = str.indexOf("\\", pipeIndex);
          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
            return true;
          }
        }
      }
    }
    if (str[index] === "\\") {
      var open = str[index + 1];
      index += 2;
      var close = chars[open];
      if (close) {
        var n2 = str.indexOf(close, index);
        if (n2 !== -1) {
          index = n2 + 1;
        }
      }
      if (str[index] === "!") {
        return true;
      }
    } else {
      index++;
    }
  }
  return false;
};
var relaxedCheck = function(str) {
  if (str[0] === "!") {
    return true;
  }
  var index = 0;
  while (index < str.length) {
    if (/[*?{}()[\]]/.test(str[index])) {
      return true;
    }
    if (str[index] === "\\") {
      var open = str[index + 1];
      index += 2;
      var close = chars[open];
      if (close) {
        var n2 = str.indexOf(close, index);
        if (n2 !== -1) {
          index = n2 + 1;
        }
      }
      if (str[index] === "!") {
        return true;
      }
    } else {
      index++;
    }
  }
  return false;
};
var isGlob = function isGlob2(str, options) {
  if (typeof str !== "string" || str === "") {
    return false;
  }
  if (isExtglob(str)) {
    return true;
  }
  var check = strictCheck;
  if (options && options.strict === false) {
    check = relaxedCheck;
  }
  return check(str);
};
var __isGlob = (string2) => {
  return isGlob(string2);
};
class SDescriptor extends SClass {
  constructor(settings) {
    super(__deepMerge$7({
      descriptor: {
        rules: {},
        type: "Object",
        arrayAsValue: false,
        throwOnMissingRule: false,
        defaults: true
      }
    }, settings !== null && settings !== void 0 ? settings : {}));
  }
  static registerRule(rule) {
    if (rule.id === void 0 || typeof rule.id !== "string") {
      throw new Error(`Sorry but you try to register a rule that does not fit the ISDescriptionRule interface...`);
    }
    this._registeredRules[rule.id] = rule;
  }
  get descriptorSettings() {
    return this._settings.descriptor;
  }
  apply(value, settings) {
    const set2 = __deepMerge$7(this.descriptorSettings, settings || {});
    if (value === void 0 || value === null)
      value = {};
    const valuesObjToProcess = {}, finalValuesObj = {};
    this._descriptorResult = new SDescriptorResult(this, finalValuesObj, Object.assign({}, set2));
    const rules2 = set2.rules;
    if (!ofType(value, set2.type)) {
      throw new Error(`Sorry but this descriptor "<yellow>${this.metas.name}</yellow>" does not accept values of type "<cyan>${typeOf(value)}</cyan>" but only "<green>${set2.type}</green>"...`);
    }
    if (Array.isArray(value) && !set2.arrayAsValue) {
      throw new Error(`Sorry but the support for arrays like values has not been integrated for not...`);
    } else if (typeof value === "object" && value !== null && value !== void 0) {
      Object.keys(rules2).forEach((propName) => {
        if (__isGlob(propName) && value)
          ;
        else {
          valuesObjToProcess[propName] = get$3(value, propName);
        }
      });
      Object.keys(valuesObjToProcess).forEach((propName) => {
        const ruleObj2 = rules2[propName];
        if (valuesObjToProcess[propName] === void 0 && set2.defaults && ruleObj2.default !== void 0) {
          valuesObjToProcess[propName] = ruleObj2.default;
        }
        if (ruleObj2.interface !== void 0) {
          const interfaceValue = valuesObjToProcess[propName];
          valuesObjToProcess[propName] = ruleObj2.interface.apply(interfaceValue || {}, {});
        }
        const validationResult = this._validate(valuesObjToProcess[propName], propName, ruleObj2, set2);
        if (validationResult !== void 0 && validationResult !== null) {
          __set(finalValuesObj, propName, validationResult);
        }
      });
    } else {
      console.warn(value);
      throw new Error(`You can apply an <yellow>SDescriptor</yellow> only on an Object like value...`);
    }
    if (this._descriptorResult.hasIssues()) {
      throw new Error(this._descriptorResult.toString());
    }
    return this._descriptorResult;
  }
  _validate(value, propName, rulesObj, settings) {
    if (rulesObj === void 0)
      return value;
    if (rulesObj.required === void 0 || rulesObj.required === false) {
      if (value === void 0 || value === null)
        return value;
    }
    let rulesNamesInOrder = Object.keys(rulesObj).filter((l2) => l2 !== "default");
    rulesNamesInOrder = rulesNamesInOrder.sort((a2, b2) => {
      const objA = this.constructor._registeredRules[a2];
      const objB = this.constructor._registeredRules[b2];
      if (!objA)
        return -1;
      if (!objB)
        return 1;
      if (objA.priority === void 0)
        objA.priority = 9999999999;
      if (objB.priority === void 0)
        objB.priority = 9999999999;
      return objA.priotity - objB.priority;
    }).reverse();
    let resultValue = value;
    rulesNamesInOrder.forEach((ruleName) => {
      const ruleValue = rulesObj[ruleName];
      if (this.constructor._registeredRules[ruleName] === void 0) {
        if (settings.throwOnMissingRule) {
          throw new Error(`Sorry but you try to validate a value using the "<yellow>${ruleName}</yellow>" rule but this rule is not registered. Here's the available rules:
              - ${Object.keys(this.constructor._registeredRules).join("\n- ")}`);
        }
      } else {
        const ruleObj2 = this.constructor._registeredRules[ruleName];
        const params = ruleObj2.processParams !== void 0 ? ruleObj2.processParams(ruleValue) : ruleValue;
        const ruleSettings = ruleObj2.settings !== void 0 ? ruleObj2.settings : {};
        if (ruleSettings.mapOnArray && Array.isArray(resultValue)) {
          let newResultValue = [];
          resultValue.forEach((v2) => {
            const processedValue = this._processRule(v2, ruleObj2, propName, params, ruleSettings, settings);
            if (Array.isArray(processedValue)) {
              newResultValue = [
                ...newResultValue,
                ...processedValue
              ];
            } else {
              newResultValue.push(processedValue);
            }
          });
          resultValue = newResultValue;
        } else {
          const processedValue = this._processRule(resultValue, ruleObj2, propName, params, ruleSettings, settings);
          resultValue = processedValue;
        }
      }
    });
    return resultValue;
  }
  _processRule(value, ruleObj2, propName, params, ruleSettings, settings) {
    const ruleResult = ruleObj2.apply(value, params, ruleSettings, Object.assign(Object.assign({}, settings), { propName, name: `${settings.name}.${propName}` }));
    if (params && params.type && params.type.toLowerCase() === "boolean" && ruleResult === true) {
      return true;
    }
    if (ruleResult instanceof Error) {
      const obj2 = {
        __error: ruleResult,
        __ruleObj: ruleObj2,
        __propName: propName
      };
      if (this._descriptorResult) {
        this._descriptorResult.add(obj2);
        throw new Error(this._descriptorResult.toString());
      }
    } else {
      return ruleResult;
    }
  }
}
SDescriptor._registeredRules = {};
SDescriptor.rules = {};
SDescriptor.type = "Object";
const ruleObj$3 = {
  priority: 1,
  name: "Required",
  id: "required",
  settings: {
    when: [void 0, null]
  },
  message: "This value is required",
  processParams: (params) => {
    return { value: params };
  },
  apply: (value, params, ruleSettings, settings) => {
    if (params.value === true) {
      if (ruleSettings.when.indexOf(value) !== -1) {
        return new Error("This property is <yellow>required</yellow>");
      }
    }
    return value;
  }
};
const ruleObj$2 = {
  prority: 10,
  name: "Type",
  id: "type",
  settings: {},
  processParams: (params) => {
    var _a2, _b2;
    if (!(params === null || params === void 0 ? void 0 : params.type) && typeof params !== "string") {
      throw new Error(`<yellow>[sugar.shared.type.descriptors.typeRule]</yellow> Sorry but to use the <magenta>type</magenta> descriptor rule you need to specify a type string either directly under the "type" property, or in an object under the "type.type" property...`);
    }
    return Object.assign(Object.assign({}, typeof params !== "string" ? params : {}), { type: (_a2 = params.type) !== null && _a2 !== void 0 ? _a2 : params, cast: (_b2 = params.cast) !== null && _b2 !== void 0 ? _b2 : true });
  },
  apply: (value, params, ruleSettings, settings) => {
    const type = new SType(params.type, {
      metas: {
        id: settings.id
      }
    });
    if (params.cast && !type.is(value)) {
      value = type.cast(value, params);
    }
    if (!type.is(value)) {
      return new Error(`The value must be of type "<yellow>${params.type}</yellow>" but you've passed a value of type "<cyan>${typeof value}</cyan>"`);
    }
    return value;
  }
};
const ruleObj$1 = {
  name: "Min",
  id: "min",
  settings: {},
  accept: "Number",
  message: (resultObj) => {
    return `This value has to be minimum "<yellow>${resultObj.min}</yellow>". Received "<red>${resultObj.received}</red>"`;
  },
  processParams: (params) => {
    return { value: params };
  },
  apply: (value, params, ruleSettings, settings) => {
    if (value < params.value) {
      return new Error(`<red>[minRule]</red> Sorry but the passed value "<yellow>${value}</yellow>" must be greater or equal at <cyan>${params.value}</cyan>`);
    }
    return value;
  }
};
const ruleObj = {
  name: "Max",
  id: "max",
  settings: {},
  accept: "Number",
  message: (resultObj) => {
    return `This value has to be maximum "<yellow>${resultObj.max}</yellow>". Received "<red>${resultObj.received}</red>"`;
  },
  processParams: (params) => {
    return { value: params };
  },
  apply: (value, params, ruleSettings, settings) => {
    if (value > params.value) {
      return new Error(`<red>[minRule]</red> Sorry but the passed value "<yellow>${value}</yellow>" must be lower or equal at <cyan>${params.value}</cyan>`);
    }
    return value;
  }
};
SDescriptor.registerRule(ruleObj$3);
SDescriptor.registerRule(ruleObj$2);
SDescriptor.registerRule(ruleObj$1);
SDescriptor.registerRule(ruleObj);
function parseArgs(string2, settings = {}) {
  settings = __deepMerge$7({
    throw: true,
    defaultObj: {},
    cast: true,
    valueQuote: void 0
  }, settings);
  string2 = string2.trim();
  string2 = string2.replace(/(["'`])--/gm, "$1--\xA7 --");
  let valueQuote = settings.valueQuote;
  if (!valueQuote) {
    for (let i2 = 0; i2 < string2.length; i2++) {
      const char = string2[i2];
      if (char === '"' || char === "`" || char === "'") {
        valueQuote = char;
        break;
      }
    }
    if (!valueQuote)
      valueQuote = '"';
  }
  let stringArray = [];
  let isFunctionStyle = false;
  if (string2.match(/^\(/) && string2.match(/\)$/)) {
    isFunctionStyle = true;
    string2 = string2.slice(1, -1);
    let currentStr = "";
    let parenthesisCount = 0;
    let quotesCount = 0;
    for (let i2 = 0; i2 < string2.length; i2++) {
      const char = string2[i2];
      const previousChar = string2[i2 - 1] || string2[0];
      if (char === valueQuote && previousChar !== "\\" && !quotesCount) {
        quotesCount++;
      } else if (char === valueQuote && previousChar !== "\\" && quotesCount) {
        quotesCount--;
      }
      if (!quotesCount && char === "(") {
        parenthesisCount++;
      } else if (!quotesCount && char === ")") {
        parenthesisCount--;
      }
      if (char === ",") {
        if (quotesCount || parenthesisCount) {
          currentStr += char;
        } else {
          stringArray.push(currentStr.trim());
          currentStr = "";
        }
      } else {
        currentStr += char;
      }
    }
    if (parenthesisCount)
      currentStr += ")".repeat(parenthesisCount);
    stringArray.push(currentStr.trim());
  } else {
    let currentStr = "";
    let quotesCount = false;
    for (let i2 = 0; i2 < string2.length; i2++) {
      const char = string2[i2];
      const previousChar = string2[i2 - 1] || string2[0];
      if (char === valueQuote && previousChar !== "\\" && !quotesCount) {
        quotesCount = true;
      } else if (char === valueQuote && previousChar !== "\\" && quotesCount) {
        quotesCount = false;
      }
      if (char === " ") {
        if (quotesCount) {
          currentStr += char;
        } else {
          stringArray.push(currentStr.trim());
          currentStr = "";
        }
      } else {
        currentStr += char;
      }
    }
    stringArray.push(currentStr.trim());
  }
  stringArray = stringArray.map((item) => unquote(item));
  const argsObj = {};
  let currentArgName = void 0;
  let currentValue;
  stringArray = stringArray.forEach((part, i2) => {
    if (!isFunctionStyle && !part.includes(" ") && (part.slice(0, 2) === "--" || part.slice(0, 1) === "-")) {
      if (currentValue === void 0 && currentArgName !== -1 && currentArgName && argsObj[currentArgName] === void 0) {
        argsObj[currentArgName] = true;
      }
      currentArgName = part.replace(/^[-]{1,2}/, "");
      if (argsObj[currentArgName] === void 0) {
        argsObj[currentArgName] = true;
      }
    } else {
      let value;
      if (part && typeof part === "string") {
        value = part.replace(/^\\\\\\`/, "").replace(/\\\\\\`$/, "").replace(/^'/, "").replace(/'$/, "").replace(/^"/, "").replace(/"$/, "");
        if (value.match(/^\$[a-zA-Z0-9-_]+\s?:.*/)) {
          const parts = part.split(":");
          currentArgName = parts[0].trim().replace(/^\$/, "");
          value = parts.slice(1).join(":").trim();
        }
      }
      currentValue = __parse(value);
      if (typeof currentValue === "string") {
        currentValue = currentValue.replace("--\xA7 ", "");
      }
      if (currentArgName !== void 0) {
        if (argsObj[currentArgName] !== void 0 && argsObj[currentArgName] !== true) {
          if (!Array.isArray(argsObj[currentArgName])) {
            argsObj[currentArgName] = [argsObj[currentArgName]];
          }
          argsObj[currentArgName].push(currentValue);
        } else {
          argsObj[currentArgName] = currentValue;
        }
        currentValue = void 0;
        currentArgName = void 0;
      } else {
        argsObj[i2] = currentValue;
      }
    }
  });
  Object.keys(argsObj).forEach((key) => {
    const value = argsObj[key];
    if (value === void 0)
      delete argsObj[key];
  });
  return argsObj;
}
function getAvailableInterfaceTypes() {
  if (global !== void 0)
    return global._registeredInterfacesTypes || {};
  else if (window !== void 0)
    return window._registeredInterfacesTypes || {};
  else
    return {};
}
if (__isNode$1())
  global._registeredInterfacesTypes = {};
else
  window._registeredInterfacesTypes = {};
class SInterface extends SClass {
  constructor(settings) {
    super(__deepMerge$7({
      interface: {
        stripUnkown: false
      }
    }, settings !== null && settings !== void 0 ? settings : {}));
    this._definition = {};
    this._definition = this.constructor.definition;
  }
  static get definition() {
    if (this._cachedDefinition)
      return this._cachedDefinition;
    this._cachedDefinition = this._definition;
    return this._cachedDefinition;
  }
  static set definition(value) {
    this._cachedDefinition = value;
  }
  get interfaceSettings() {
    return this._settings.interface;
  }
  static registerRenderer(rendererClass) {
    if (!rendererClass.id) {
      throw new Error(`Sorry but the interface renderer "<yellow>${rendererClass.name}</yellow>" that you want to register is missing the required <yellow>static</yellow> <green>id</green> property...`);
    }
    this._registeredRenderers[rendererClass.id] = rendererClass;
  }
  static override(definition) {
    const _this = this;
    class SInterfaceOverrided extends this {
    }
    SInterfaceOverrided.overridedName = `${_this.name} (overrided)`;
    SInterfaceOverrided.definition = __deepMerge$7(_this.definition, definition);
    return SInterfaceOverrided;
  }
  static getAvailableTypes() {
    return getAvailableInterfaceTypes();
  }
  static makeAvailableAsType(name2 = null) {
    const n2 = (name2 || this.name).toLowerCase();
    if (global !== void 0) {
      global._registeredInterfacesTypes[n2] = this;
      global._registeredInterfacesTypes[n2.replace("interface", "")] = this;
    } else if (window !== void 0) {
      window._registeredInterfacesTypes[n2] = this;
      window._registeredInterfacesTypes[n2.replace("interface", "")] = this;
    }
  }
  static toObject() {
    var _a2;
    return {
      name: this.name,
      description: (_a2 = this.description) !== null && _a2 !== void 0 ? _a2 : "",
      definition: Object.assign({}, this.definition)
    };
  }
  static defaults() {
    const defaults2 = {};
    Object.keys(this.definition).forEach((key) => {
      const propObj = this.definition[key];
      if (propObj.default !== void 0) {
        defaults2[key] = propObj.default;
      }
    });
    return defaults2;
  }
  static apply(objectOrString, settings) {
    const int = new this({
      interface: settings !== null && settings !== void 0 ? settings : {}
    });
    return int.apply(objectOrString);
  }
  static render(renderer = "terminal", settings) {
    const set2 = __deepMerge$7({
      renderer: "terminal",
      exclude: ["help"]
    }, settings);
    if (!this._registeredRenderers[renderer]) {
      throw new Error(`Sorry but the requested renderer "<yellow>${renderer}</yellow>" does not exists... Here's the available renderers: <green>${Object.keys(this._registeredRenderers).join(", ")}</green>`);
    }
    const rendererInstance = new this._registeredRenderers[renderer](this, set2);
    return rendererInstance.render();
  }
  apply(objectOrString, settings) {
    var _a2;
    const set2 = __deepMerge$7(this.interfaceSettings, settings !== null && settings !== void 0 ? settings : {});
    let objectOnWhichToApplyInterface = objectOrString;
    if (typeof objectOrString === "string") {
      objectOnWhichToApplyInterface = parseArgs(objectOrString);
      Object.keys(objectOnWhichToApplyInterface).forEach((argName) => {
        for (let i2 = 0; i2 < Object.keys(this._definition).length; i2++) {
          const defArgName = Object.keys(this._definition)[i2];
          const obj2 = this._definition[defArgName];
          if (obj2.explicit) {
            if (obj2.alias && ` ${objectOrString} `.match(new RegExp(`\\s-${obj2.alias}\\s`)))
              return;
            else if (` ${objectOrString} `.match(new RegExp(`\\s--${argName}\\s`)))
              return;
            delete objectOnWhichToApplyInterface[argName];
          }
        }
      });
      Object.keys(objectOnWhichToApplyInterface).forEach((argName) => {
        for (let i2 = 0; i2 < Object.keys(this._definition).length; i2++) {
          const defArgName = Object.keys(this._definition)[i2];
          const obj2 = this._definition[defArgName];
          if (!obj2.alias)
            continue;
          if (obj2.alias === argName && objectOnWhichToApplyInterface[defArgName] === void 0) {
            objectOnWhichToApplyInterface[defArgName] = objectOnWhichToApplyInterface[argName];
            delete objectOnWhichToApplyInterface[argName];
          }
        }
      });
      Object.keys(objectOnWhichToApplyInterface).forEach((argName, i2) => {
        if (argName === `${i2}`) {
          const definitionKeys = Object.keys(this._definition);
          if (definitionKeys[i2]) {
            objectOnWhichToApplyInterface[definitionKeys[i2]] = objectOnWhichToApplyInterface[argName];
          }
          delete objectOnWhichToApplyInterface[argName];
        }
      });
    }
    const descriptor2 = new SDescriptor({
      descriptor: Object.assign({ type: "Object", rules: this._definition }, (_a2 = set2.descriptor) !== null && _a2 !== void 0 ? _a2 : {})
    });
    if (set2.baseObj) {
      objectOnWhichToApplyInterface = __deepMerge$7(set2.baseObj, objectOnWhichToApplyInterface);
    }
    const descriptorResult = descriptor2.apply(objectOnWhichToApplyInterface);
    if (descriptorResult.hasIssues()) {
      throw new Error(descriptorResult.toString());
    }
    let resultObj = descriptorResult.value;
    if (!set2.stripUnkown) {
      resultObj = __deepMerge$7(objectOnWhichToApplyInterface, resultObj);
    }
    return resultObj;
  }
}
SInterface.description = "";
SInterface._registeredRenderers = {};
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate(uuid) {
  return typeof uuid === "string" && REGEX.test(uuid);
}
var byteToHex = [];
for (var i$4 = 0; i$4 < 256; ++i$4) {
  byteToHex.push((i$4 + 256).toString(16).substr(1));
}
function stringify(arr) {
  var offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + "-" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + "-" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + "-" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + "-" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]]).toLowerCase();
  if (!validate(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
function v4(options, buf, offset2) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset2 = offset2 || 0;
    for (var i2 = 0; i2 < 16; ++i2) {
      buf[offset2 + i2] = rnds[i2];
    }
    return buf;
  }
  return stringify(rnds);
}
function uniqid() {
  return v4();
}
var __awaiter$h = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e20) {
        reject(e20);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e20) {
        reject(e20);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const _links = {}, _stylesheets = {};
function adoptStyleInShadowRoot($shadowRoot, $context = document) {
  return __awaiter$h(this, void 0, void 0, function* () {
    const _styleNodes = [];
    const $links = $context.querySelectorAll('link[rel="stylesheet"]');
    if ($links && $shadowRoot) {
      Array.from($links).forEach(($link) => __awaiter$h(this, void 0, void 0, function* () {
        if (!$link.id)
          $link.id = `link-${uniqid()}`;
        const stylesheetId = $link.id;
        if (_links[stylesheetId]) {
          $shadowRoot.adoptedStyleSheets = [
            ...$shadowRoot.adoptedStyleSheets,
            _links[stylesheetId].stylesheet
          ];
          return;
        }
        $shadowRoot === null || $shadowRoot === void 0 ? void 0 : $shadowRoot.appendChild($link.cloneNode());
        if (_styleNodes.indexOf($link) !== -1)
          return;
        _styleNodes.push($link);
        const res = yield fetch($link.href, {
          headers: {
            Accept: "text/css,*/*;q=0.1"
          }
        });
        let cssStr = yield res.text();
        const stylesheet = new CSSStyleSheet();
        stylesheet.replace(cssStr);
        _links[stylesheetId] = {
          stylesheet
        };
      }));
    }
    const $styles = $context.querySelectorAll("style");
    if ($styles && $shadowRoot) {
      Array.from($styles).forEach(($style) => {
        if (!$style.id)
          $style.id = `stylesheet-${uniqid()}`;
        const stylesheetId = $style.id;
        if (_stylesheets[stylesheetId]) {
          $shadowRoot.adoptedStyleSheets = [
            ...$shadowRoot.adoptedStyleSheets,
            _stylesheets[stylesheetId].stylesheet
          ];
          return;
        }
        if (_styleNodes.indexOf($style) !== -1)
          return;
        _styleNodes.push($style);
        const stylesheet = new CSSStyleSheet();
        stylesheet.replace($style.innerHTML);
        _stylesheets[stylesheetId] = {
          stylesheet
        };
        $shadowRoot.adoptedStyleSheets = [
          ...$shadowRoot.adoptedStyleSheets,
          _stylesheets[stylesheetId].stylesheet
        ];
      });
    }
    return true;
  });
}
function injectStyle(style, id2 = `injected-style-${uniqid()}`, node = document.head) {
  const $tag = document.createElement("style");
  $tag.type = "text/css";
  $tag.setAttribute("id", `injected-style-${id2.toLowerCase()}`);
  $tag.innerHTML = style;
  node.appendChild($tag);
  return $tag;
}
function camelize$1(text) {
  let res = "";
  const reg = /(?:^|[_-\s])(\w)/g;
  res = text.replace(reg, function(_2, c2) {
    return c2 ? c2.toUpperCase() : "";
  });
  res = res.substr(0, 1).toLowerCase() + res.slice(1);
  return res.trim();
}
function camelCase(text) {
  return camelize$1(text);
}
function getMethods(toCheck) {
  let props = [];
  let obj2 = toCheck;
  do {
    const _props = Object.getOwnPropertyNames(obj2);
    if (_props.indexOf("__defineGetter__") !== -1)
      continue;
    props = props.concat(_props);
  } while (obj2 = Object.getPrototypeOf(obj2));
  return props.sort().filter(function(e20, i2, arr) {
    if (e20 != arr[i2 + 1] && typeof toCheck[e20] == "function")
      return true;
  });
}
var concatMap$1 = function(xs2, fn2) {
  var res = [];
  for (var i2 = 0; i2 < xs2.length; i2++) {
    var x2 = fn2(xs2[i2], i2);
    if (isArray$5(x2))
      res.push.apply(res, x2);
    else
      res.push(x2);
  }
  return res;
};
var isArray$5 = Array.isArray || function(xs2) {
  return Object.prototype.toString.call(xs2) === "[object Array]";
};
var balancedMatch = balanced$1;
function balanced$1(a2, b2, str) {
  if (a2 instanceof RegExp)
    a2 = maybeMatch(a2, str);
  if (b2 instanceof RegExp)
    b2 = maybeMatch(b2, str);
  var r2 = range(a2, b2, str);
  return r2 && {
    start: r2[0],
    end: r2[1],
    pre: str.slice(0, r2[0]),
    body: str.slice(r2[0] + a2.length, r2[1]),
    post: str.slice(r2[1] + b2.length)
  };
}
function maybeMatch(reg, str) {
  var m2 = str.match(reg);
  return m2 ? m2[0] : null;
}
balanced$1.range = range;
function range(a2, b2, str) {
  var begs, beg, left2, right, result;
  var ai2 = str.indexOf(a2);
  var bi2 = str.indexOf(b2, ai2 + 1);
  var i2 = ai2;
  if (ai2 >= 0 && bi2 > 0) {
    if (a2 === b2) {
      return [ai2, bi2];
    }
    begs = [];
    left2 = str.length;
    while (i2 >= 0 && !result) {
      if (i2 == ai2) {
        begs.push(i2);
        ai2 = str.indexOf(a2, i2 + 1);
      } else if (begs.length == 1) {
        result = [begs.pop(), bi2];
      } else {
        beg = begs.pop();
        if (beg < left2) {
          left2 = beg;
          right = bi2;
        }
        bi2 = str.indexOf(b2, i2 + 1);
      }
      i2 = ai2 < bi2 && ai2 >= 0 ? ai2 : bi2;
    }
    if (begs.length) {
      result = [left2, right];
    }
  }
  return result;
}
var concatMap = concatMap$1;
var balanced = balancedMatch;
var braceExpansion = expandTop;
var escSlash = "\0SLASH" + Math.random() + "\0";
var escOpen = "\0OPEN" + Math.random() + "\0";
var escClose = "\0CLOSE" + Math.random() + "\0";
var escComma = "\0COMMA" + Math.random() + "\0";
var escPeriod = "\0PERIOD" + Math.random() + "\0";
function numeric(str) {
  return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
}
function escapeBraces(str) {
  return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
}
function unescapeBraces(str) {
  return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
}
function parseCommaParts(str) {
  if (!str)
    return [""];
  var parts = [];
  var m2 = balanced("{", "}", str);
  if (!m2)
    return str.split(",");
  var pre = m2.pre;
  var body = m2.body;
  var post = m2.post;
  var p2 = pre.split(",");
  p2[p2.length - 1] += "{" + body + "}";
  var postParts = parseCommaParts(post);
  if (post.length) {
    p2[p2.length - 1] += postParts.shift();
    p2.push.apply(p2, postParts);
  }
  parts.push.apply(parts, p2);
  return parts;
}
function expandTop(str) {
  if (!str)
    return [];
  if (str.substr(0, 2) === "{}") {
    str = "\\{\\}" + str.substr(2);
  }
  return expand$1(escapeBraces(str), true).map(unescapeBraces);
}
function embrace(str) {
  return "{" + str + "}";
}
function isPadded(el2) {
  return /^-?0\d/.test(el2);
}
function lte(i2, y2) {
  return i2 <= y2;
}
function gte(i2, y2) {
  return i2 >= y2;
}
function expand$1(str, isTop) {
  var expansions = [];
  var m2 = balanced("{", "}", str);
  if (!m2 || /\$$/.test(m2.pre))
    return [str];
  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m2.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m2.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = m2.body.indexOf(",") >= 0;
  if (!isSequence && !isOptions) {
    if (m2.post.match(/,.*\}/)) {
      str = m2.pre + "{" + m2.body + escClose + m2.post;
      return expand$1(str);
    }
    return [str];
  }
  var n2;
  if (isSequence) {
    n2 = m2.body.split(/\.\./);
  } else {
    n2 = parseCommaParts(m2.body);
    if (n2.length === 1) {
      n2 = expand$1(n2[0], false).map(embrace);
      if (n2.length === 1) {
        var post = m2.post.length ? expand$1(m2.post, false) : [""];
        return post.map(function(p2) {
          return m2.pre + n2[0] + p2;
        });
      }
    }
  }
  var pre = m2.pre;
  var post = m2.post.length ? expand$1(m2.post, false) : [""];
  var N2;
  if (isSequence) {
    var x2 = numeric(n2[0]);
    var y2 = numeric(n2[1]);
    var width = Math.max(n2[0].length, n2[1].length);
    var incr = n2.length == 3 ? Math.abs(numeric(n2[2])) : 1;
    var test = lte;
    var reverse = y2 < x2;
    if (reverse) {
      incr *= -1;
      test = gte;
    }
    var pad = n2.some(isPadded);
    N2 = [];
    for (var i2 = x2; test(i2, y2); i2 += incr) {
      var c2;
      if (isAlphaSequence) {
        c2 = String.fromCharCode(i2);
        if (c2 === "\\")
          c2 = "";
      } else {
        c2 = String(i2);
        if (pad) {
          var need = width - c2.length;
          if (need > 0) {
            var z2 = new Array(need + 1).join("0");
            if (i2 < 0)
              c2 = "-" + z2 + c2.slice(1);
            else
              c2 = z2 + c2;
          }
        }
      }
      N2.push(c2);
    }
  } else {
    N2 = concatMap(n2, function(el2) {
      return expand$1(el2, false);
    });
  }
  for (var j2 = 0; j2 < N2.length; j2++) {
    for (var k2 = 0; k2 < post.length; k2++) {
      var expansion = pre + N2[j2] + post[k2];
      if (!isTop || isSequence || expansion)
        expansions.push(expansion);
    }
  }
  return expansions;
}
var minimatch_1 = minimatch;
minimatch.Minimatch = Minimatch;
var path = { sep: "/" };
try {
  path = require("path");
} catch (er2) {
}
var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
var expand = braceExpansion;
var plTypes = {
  "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
  "?": { open: "(?:", close: ")?" },
  "+": { open: "(?:", close: ")+" },
  "*": { open: "(?:", close: ")*" },
  "@": { open: "(?:", close: ")" }
};
var qmark = "[^/]";
var star = qmark + "*?";
var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
var reSpecials = charSet("().*{}+?[]^$\\!");
function charSet(s2) {
  return s2.split("").reduce(function(set2, c2) {
    set2[c2] = true;
    return set2;
  }, {});
}
var slashSplit = /\/+/;
minimatch.filter = filter$3;
function filter$3(pattern, options) {
  options = options || {};
  return function(p2, i2, list) {
    return minimatch(p2, pattern, options);
  };
}
function ext(a2, b2) {
  a2 = a2 || {};
  b2 = b2 || {};
  var t2 = {};
  Object.keys(b2).forEach(function(k2) {
    t2[k2] = b2[k2];
  });
  Object.keys(a2).forEach(function(k2) {
    t2[k2] = a2[k2];
  });
  return t2;
}
minimatch.defaults = function(def) {
  if (!def || !Object.keys(def).length)
    return minimatch;
  var orig = minimatch;
  var m2 = function minimatch2(p2, pattern, options) {
    return orig.minimatch(p2, pattern, ext(def, options));
  };
  m2.Minimatch = function Minimatch2(pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options));
  };
  return m2;
};
Minimatch.defaults = function(def) {
  if (!def || !Object.keys(def).length)
    return Minimatch;
  return minimatch.defaults(def).Minimatch;
};
function minimatch(p2, pattern, options) {
  if (typeof pattern !== "string") {
    throw new TypeError("glob pattern string required");
  }
  if (!options)
    options = {};
  if (!options.nocomment && pattern.charAt(0) === "#") {
    return false;
  }
  if (pattern.trim() === "")
    return p2 === "";
  return new Minimatch(pattern, options).match(p2);
}
function Minimatch(pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options);
  }
  if (typeof pattern !== "string") {
    throw new TypeError("glob pattern string required");
  }
  if (!options)
    options = {};
  pattern = pattern.trim();
  if (path.sep !== "/") {
    pattern = pattern.split(path.sep).join("/");
  }
  this.options = options;
  this.set = [];
  this.pattern = pattern;
  this.regexp = null;
  this.negate = false;
  this.comment = false;
  this.empty = false;
  this.make();
}
Minimatch.prototype.debug = function() {
};
Minimatch.prototype.make = make;
function make() {
  if (this._made)
    return;
  var pattern = this.pattern;
  var options = this.options;
  if (!options.nocomment && pattern.charAt(0) === "#") {
    this.comment = true;
    return;
  }
  if (!pattern) {
    this.empty = true;
    return;
  }
  this.parseNegate();
  var set2 = this.globSet = this.braceExpand();
  if (options.debug)
    this.debug = console.error;
  this.debug(this.pattern, set2);
  set2 = this.globParts = set2.map(function(s2) {
    return s2.split(slashSplit);
  });
  this.debug(this.pattern, set2);
  set2 = set2.map(function(s2, si2, set3) {
    return s2.map(this.parse, this);
  }, this);
  this.debug(this.pattern, set2);
  set2 = set2.filter(function(s2) {
    return s2.indexOf(false) === -1;
  });
  this.debug(this.pattern, set2);
  this.set = set2;
}
Minimatch.prototype.parseNegate = parseNegate;
function parseNegate() {
  var pattern = this.pattern;
  var negate = false;
  var options = this.options;
  var negateOffset = 0;
  if (options.nonegate)
    return;
  for (var i2 = 0, l2 = pattern.length; i2 < l2 && pattern.charAt(i2) === "!"; i2++) {
    negate = !negate;
    negateOffset++;
  }
  if (negateOffset)
    this.pattern = pattern.substr(negateOffset);
  this.negate = negate;
}
minimatch.braceExpand = function(pattern, options) {
  return braceExpand(pattern, options);
};
Minimatch.prototype.braceExpand = braceExpand;
function braceExpand(pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options;
    } else {
      options = {};
    }
  }
  pattern = typeof pattern === "undefined" ? this.pattern : pattern;
  if (typeof pattern === "undefined") {
    throw new TypeError("undefined pattern");
  }
  if (options.nobrace || !pattern.match(/\{.*\}/)) {
    return [pattern];
  }
  return expand(pattern);
}
Minimatch.prototype.parse = parse;
var SUBPARSE = {};
function parse(pattern, isSub) {
  if (pattern.length > 1024 * 64) {
    throw new TypeError("pattern is too long");
  }
  var options = this.options;
  if (!options.noglobstar && pattern === "**")
    return GLOBSTAR;
  if (pattern === "")
    return "";
  var re2 = "";
  var hasMagic = !!options.nocase;
  var escaping = false;
  var patternListStack = [];
  var negativeLists = [];
  var stateChar;
  var inClass = false;
  var reClassStart = -1;
  var classStart = -1;
  var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
  var self2 = this;
  function clearStateChar() {
    if (stateChar) {
      switch (stateChar) {
        case "*":
          re2 += star;
          hasMagic = true;
          break;
        case "?":
          re2 += qmark;
          hasMagic = true;
          break;
        default:
          re2 += "\\" + stateChar;
          break;
      }
      self2.debug("clearStateChar %j %j", stateChar, re2);
      stateChar = false;
    }
  }
  for (var i2 = 0, len = pattern.length, c2; i2 < len && (c2 = pattern.charAt(i2)); i2++) {
    this.debug("%s	%s %s %j", pattern, i2, re2, c2);
    if (escaping && reSpecials[c2]) {
      re2 += "\\" + c2;
      escaping = false;
      continue;
    }
    switch (c2) {
      case "/":
        return false;
      case "\\":
        clearStateChar();
        escaping = true;
        continue;
      case "?":
      case "*":
      case "+":
      case "@":
      case "!":
        this.debug("%s	%s %s %j <-- stateChar", pattern, i2, re2, c2);
        if (inClass) {
          this.debug("  in class");
          if (c2 === "!" && i2 === classStart + 1)
            c2 = "^";
          re2 += c2;
          continue;
        }
        self2.debug("call clearStateChar %j", stateChar);
        clearStateChar();
        stateChar = c2;
        if (options.noext)
          clearStateChar();
        continue;
      case "(":
        if (inClass) {
          re2 += "(";
          continue;
        }
        if (!stateChar) {
          re2 += "\\(";
          continue;
        }
        patternListStack.push({
          type: stateChar,
          start: i2 - 1,
          reStart: re2.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        });
        re2 += stateChar === "!" ? "(?:(?!(?:" : "(?:";
        this.debug("plType %j %j", stateChar, re2);
        stateChar = false;
        continue;
      case ")":
        if (inClass || !patternListStack.length) {
          re2 += "\\)";
          continue;
        }
        clearStateChar();
        hasMagic = true;
        var pl2 = patternListStack.pop();
        re2 += pl2.close;
        if (pl2.type === "!") {
          negativeLists.push(pl2);
        }
        pl2.reEnd = re2.length;
        continue;
      case "|":
        if (inClass || !patternListStack.length || escaping) {
          re2 += "\\|";
          escaping = false;
          continue;
        }
        clearStateChar();
        re2 += "|";
        continue;
      case "[":
        clearStateChar();
        if (inClass) {
          re2 += "\\" + c2;
          continue;
        }
        inClass = true;
        classStart = i2;
        reClassStart = re2.length;
        re2 += c2;
        continue;
      case "]":
        if (i2 === classStart + 1 || !inClass) {
          re2 += "\\" + c2;
          escaping = false;
          continue;
        }
        if (inClass) {
          var cs2 = pattern.substring(classStart + 1, i2);
          try {
            RegExp("[" + cs2 + "]");
          } catch (er2) {
            var sp2 = this.parse(cs2, SUBPARSE);
            re2 = re2.substr(0, reClassStart) + "\\[" + sp2[0] + "\\]";
            hasMagic = hasMagic || sp2[1];
            inClass = false;
            continue;
          }
        }
        hasMagic = true;
        inClass = false;
        re2 += c2;
        continue;
      default:
        clearStateChar();
        if (escaping) {
          escaping = false;
        } else if (reSpecials[c2] && !(c2 === "^" && inClass)) {
          re2 += "\\";
        }
        re2 += c2;
    }
  }
  if (inClass) {
    cs2 = pattern.substr(classStart + 1);
    sp2 = this.parse(cs2, SUBPARSE);
    re2 = re2.substr(0, reClassStart) + "\\[" + sp2[0];
    hasMagic = hasMagic || sp2[1];
  }
  for (pl2 = patternListStack.pop(); pl2; pl2 = patternListStack.pop()) {
    var tail = re2.slice(pl2.reStart + pl2.open.length);
    this.debug("setting tail", re2, pl2);
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_2, $1, $2) {
      if (!$2) {
        $2 = "\\";
      }
      return $1 + $1 + $2 + "|";
    });
    this.debug("tail=%j\n   %s", tail, tail, pl2, re2);
    var t2 = pl2.type === "*" ? star : pl2.type === "?" ? qmark : "\\" + pl2.type;
    hasMagic = true;
    re2 = re2.slice(0, pl2.reStart) + t2 + "\\(" + tail;
  }
  clearStateChar();
  if (escaping) {
    re2 += "\\\\";
  }
  var addPatternStart = false;
  switch (re2.charAt(0)) {
    case ".":
    case "[":
    case "(":
      addPatternStart = true;
  }
  for (var n2 = negativeLists.length - 1; n2 > -1; n2--) {
    var nl2 = negativeLists[n2];
    var nlBefore = re2.slice(0, nl2.reStart);
    var nlFirst = re2.slice(nl2.reStart, nl2.reEnd - 8);
    var nlLast = re2.slice(nl2.reEnd - 8, nl2.reEnd);
    var nlAfter = re2.slice(nl2.reEnd);
    nlLast += nlAfter;
    var openParensBefore = nlBefore.split("(").length - 1;
    var cleanAfter = nlAfter;
    for (i2 = 0; i2 < openParensBefore; i2++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
    }
    nlAfter = cleanAfter;
    var dollar = "";
    if (nlAfter === "" && isSub !== SUBPARSE) {
      dollar = "$";
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
    re2 = newRe;
  }
  if (re2 !== "" && hasMagic) {
    re2 = "(?=.)" + re2;
  }
  if (addPatternStart) {
    re2 = patternStart + re2;
  }
  if (isSub === SUBPARSE) {
    return [re2, hasMagic];
  }
  if (!hasMagic) {
    return globUnescape(pattern);
  }
  var flags = options.nocase ? "i" : "";
  try {
    var regExp = new RegExp("^" + re2 + "$", flags);
  } catch (er2) {
    return new RegExp("$.");
  }
  regExp._glob = pattern;
  regExp._src = re2;
  return regExp;
}
minimatch.makeRe = function(pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe();
};
Minimatch.prototype.makeRe = makeRe;
function makeRe() {
  if (this.regexp || this.regexp === false)
    return this.regexp;
  var set2 = this.set;
  if (!set2.length) {
    this.regexp = false;
    return this.regexp;
  }
  var options = this.options;
  var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
  var flags = options.nocase ? "i" : "";
  var re2 = set2.map(function(pattern) {
    return pattern.map(function(p2) {
      return p2 === GLOBSTAR ? twoStar : typeof p2 === "string" ? regExpEscape(p2) : p2._src;
    }).join("\\/");
  }).join("|");
  re2 = "^(?:" + re2 + ")$";
  if (this.negate)
    re2 = "^(?!" + re2 + ").*$";
  try {
    this.regexp = new RegExp(re2, flags);
  } catch (ex2) {
    this.regexp = false;
  }
  return this.regexp;
}
minimatch.match = function(list, pattern, options) {
  options = options || {};
  var mm2 = new Minimatch(pattern, options);
  list = list.filter(function(f2) {
    return mm2.match(f2);
  });
  if (mm2.options.nonull && !list.length) {
    list.push(pattern);
  }
  return list;
};
Minimatch.prototype.match = match;
function match(f2, partial) {
  this.debug("match", f2, this.pattern);
  if (this.comment)
    return false;
  if (this.empty)
    return f2 === "";
  if (f2 === "/" && partial)
    return true;
  var options = this.options;
  if (path.sep !== "/") {
    f2 = f2.split(path.sep).join("/");
  }
  f2 = f2.split(slashSplit);
  this.debug(this.pattern, "split", f2);
  var set2 = this.set;
  this.debug(this.pattern, "set", set2);
  var filename;
  var i2;
  for (i2 = f2.length - 1; i2 >= 0; i2--) {
    filename = f2[i2];
    if (filename)
      break;
  }
  for (i2 = 0; i2 < set2.length; i2++) {
    var pattern = set2[i2];
    var file = f2;
    if (options.matchBase && pattern.length === 1) {
      file = [filename];
    }
    var hit = this.matchOne(file, pattern, partial);
    if (hit) {
      if (options.flipNegate)
        return true;
      return !this.negate;
    }
  }
  if (options.flipNegate)
    return false;
  return this.negate;
}
Minimatch.prototype.matchOne = function(file, pattern, partial) {
  var options = this.options;
  this.debug("matchOne", { "this": this, file, pattern });
  this.debug("matchOne", file.length, pattern.length);
  for (var fi2 = 0, pi2 = 0, fl2 = file.length, pl2 = pattern.length; fi2 < fl2 && pi2 < pl2; fi2++, pi2++) {
    this.debug("matchOne loop");
    var p2 = pattern[pi2];
    var f2 = file[fi2];
    this.debug(pattern, p2, f2);
    if (p2 === false)
      return false;
    if (p2 === GLOBSTAR) {
      this.debug("GLOBSTAR", [pattern, p2, f2]);
      var fr2 = fi2;
      var pr2 = pi2 + 1;
      if (pr2 === pl2) {
        this.debug("** at the end");
        for (; fi2 < fl2; fi2++) {
          if (file[fi2] === "." || file[fi2] === ".." || !options.dot && file[fi2].charAt(0) === ".")
            return false;
        }
        return true;
      }
      while (fr2 < fl2) {
        var swallowee = file[fr2];
        this.debug("\nglobstar while", file, fr2, pattern, pr2, swallowee);
        if (this.matchOne(file.slice(fr2), pattern.slice(pr2), partial)) {
          this.debug("globstar found match!", fr2, fl2, swallowee);
          return true;
        } else {
          if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
            this.debug("dot detected!", file, fr2, pattern, pr2);
            break;
          }
          this.debug("globstar swallow a segment, and continue");
          fr2++;
        }
      }
      if (partial) {
        this.debug("\n>>> no match, partial?", file, fr2, pattern, pr2);
        if (fr2 === fl2)
          return true;
      }
      return false;
    }
    var hit;
    if (typeof p2 === "string") {
      if (options.nocase) {
        hit = f2.toLowerCase() === p2.toLowerCase();
      } else {
        hit = f2 === p2;
      }
      this.debug("string match", p2, f2, hit);
    } else {
      hit = f2.match(p2);
      this.debug("pattern match", p2, f2, hit);
    }
    if (!hit)
      return false;
  }
  if (fi2 === fl2 && pi2 === pl2) {
    return true;
  } else if (fi2 === fl2) {
    return partial;
  } else if (pi2 === pl2) {
    var emptyFileEnd = fi2 === fl2 - 1 && file[fi2] === "";
    return emptyFileEnd;
  }
  throw new Error("wtf?");
};
function globUnescape(s2) {
  return s2.replace(/\\(.)/g, "$1");
}
function regExpEscape(s2) {
  return s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
}
var ansiRegex$1 = ({ onlyFirst = false } = {}) => {
  const pattern = [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
  ].join("|");
  return new RegExp(pattern, onlyFirst ? void 0 : "g");
};
const ansiRegex = ansiRegex$1;
var stripAnsi$1 = (string2) => typeof string2 === "string" ? string2.replace(ansiRegex(), "") : string2;
function stripAnsi(string2) {
  return stripAnsi$1(string2);
}
function isTestEnv() {
  var _a2;
  return ((_a2 = process === null || process === void 0 ? void 0 : process.env) === null || _a2 === void 0 ? void 0 : _a2.NODE_ENV) === "test";
}
function isChildProcess() {
  if (isTestEnv())
    return false;
  return process.send !== void 0 || {}.IS_CHILD_PROCESS !== void 0;
}
class SLog {
  constructor(logObj) {
    var _a2;
    if (!(logObj === null || logObj === void 0 ? void 0 : logObj.value) && !logObj._logObj) {
      throw new Error(`<red>[${this.constructor.name}]</red> Sorry but you cannot instanciate a new SLog without a "<yellow>value</yellow>" property...`);
    }
    this._logObj = __deepMerge$7({
      type: SLog.LOG,
      timestamp: Date.now(),
      decorators: true,
      time: false
    }, this.constructor._defaultLogObj, (_a2 = logObj._logObj) !== null && _a2 !== void 0 ? _a2 : logObj);
  }
  static filter(filterObj, name2 = "default") {
    this._appliedFilters[name2] = filterObj;
  }
  static clearFilters() {
    this._appliedFilters = {};
  }
  static removeFilter(name2) {
    delete this._appliedFilters[name2];
  }
  static setDefaultLogObj(logObj) {
    this._defaultLogObj = logObj;
  }
  get value() {
    return this._logObj.value;
  }
  set value(value) {
    this._logObj.value = value;
  }
  get type() {
    return this._logObj.type;
  }
  get active() {
    const keys2 = Object.keys(this.constructor._appliedFilters);
    for (let i2 = 0; i2 < keys2.length; i2++) {
      const filterObj = this.constructor._appliedFilters[keys2[i2]];
      for (let j2 = 0; j2 < Object.keys(filterObj).length; j2++) {
        const filterId = Object.keys(filterObj)[j2];
        const filterItem = filterObj[filterId];
        if (this[filterId] === void 0) {
          continue;
        }
        if (Array.isArray(filterItem)) {
          if (filterItem.indexOf(this[filterId]) === -1)
            return false;
        } else if (filterItem !== this[filterId]) {
          return false;
        }
      }
    }
    return true;
  }
  get decorators() {
    return this._logObj.decorators;
  }
  set decorators(value) {
    this._logObj.decorators = value;
  }
  get time() {
    return this._logObj.time;
  }
  get timestamp() {
    return this._logObj.timestamp;
  }
  get clear() {
    return this._logObj.clear;
  }
  get temp() {
    return this._logObj.temp;
  }
  get as() {
    return this._logObj.as;
  }
}
SLog.TYPE_LOG = "log";
SLog.TYPE_INFO = "info";
SLog.TYPE_WARN = "warn";
SLog.TYPE_ERROR = "error";
SLog.TYPE_VERBOSE = "verbose";
SLog.TYPE_SUMMARY = "summary";
SLog.TYPE_CHILD_PROCESS = "child_process";
SLog._appliedFilters = {};
SLog._defaultLogObj = {};
var __awaiter$g = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e20) {
        reject(e20);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e20) {
        reject(e20);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SEventEmitter extends SClass {
  constructor(settings = {}) {
    super(__deepMerge$7({
      eventEmitter: {
        emitter: void 0,
        asyncStart: false,
        defaultCallTime: {},
        bufferTimeout: 1e3,
        bufferedEvents: [],
        forceObject: ["log"],
        defaults: {},
        castByEvent: {
          log: SLog
        },
        bind: void 0
      }
    }, settings || {}));
    this._asyncStarted = false;
    this._buffer = [];
    this._eventsStacks = {};
    this._onStackById = {};
  }
  static get global() {
    if (!this._globalInstance) {
      this._globalInstance = new SEventEmitter({
        metas: {
          id: "sugarEventSPromise"
        }
      });
    }
    return this._globalInstance;
  }
  static pipe(sourceSEventEmitter, destSEventEmitter, settings) {
    const set2 = Object.assign({ events: "*", prefixEvent: false, prefixValue: void 0, stripAnsi: false, trim: true, keepLineBreak: true, overrideEmitter: "bind", processor: void 0, exclude: ["finally", "resolve", "reject", "cancel", "catch"], filter: void 0 }, settings !== null && settings !== void 0 ? settings : {});
    if (!sourceSEventEmitter || !sourceSEventEmitter.on || typeof sourceSEventEmitter.on !== "function")
      return sourceSEventEmitter;
    sourceSEventEmitter.on(set2.events || "*", (value, metas) => __awaiter$g(this, void 0, void 0, function* () {
      var _a2, _b2, _c2, _d2, _e2, _f3, _g2;
      if (!metas) {
        return;
      }
      metas.id = (_c2 = (_a2 = metas.id) !== null && _a2 !== void 0 ? _a2 : (_b2 = metas.emitter.metas) === null || _b2 === void 0 ? void 0 : _b2.id) !== null && _c2 !== void 0 ? _c2 : uniqid();
      metas.color = (_f3 = (_d2 = metas.color) !== null && _d2 !== void 0 ? _d2 : (_e2 = metas.emitter.metas) === null || _e2 === void 0 ? void 0 : _e2.color) !== null && _f3 !== void 0 ? _f3 : getColorFor(metas.id);
      if (set2.exclude && set2.exclude.indexOf(metas.event) !== -1)
        return;
      if (set2.filter && !set2.filter(value, metas))
        return;
      if (set2.stripAnsi) {
        if (value && value.value && typeof value.value === "string")
          value.value = stripAnsi(value.value);
        else if (typeof value === "string")
          value = stripAnsi(value);
      }
      if (set2.trim) {
        if (value && value.value && typeof value.value === "string")
          value.value = value.value.trim();
        else if (typeof value === "string")
          value = value.trim();
      }
      if (set2.keepLineBreak === false) {
        if (value && value.value && typeof value.value === "string")
          value.value = value.value.replace(/\r?\n|\r/g, "");
        else if (typeof value === "string")
          value = value.replace(/\r?\n|\r/g, "");
      }
      if (set2.processor) {
        const res = set2.processor(value, metas);
        if (Array.isArray(res) && res.length === 2) {
          value = res[0];
          metas = res[1];
        } else if (typeof res === "object" && res.value !== void 0 && res.metas !== void 0) {
          value = res.value;
          metas = res.metas;
        } else {
          value = res;
        }
      }
      if (set2.prefixValue) {
        if (value && value.value && typeof value.value === "string") {
          value.value = `${set2.prefixValue}${value.value}`;
        } else if (typeof value === "string") {
          value = `${set2.prefixValue}${value}`;
        }
      }
      if (metas && metas.event) {
        let emitStack = metas.event;
        if (!metas.emitter) {
          metas.emitter = this;
        }
        if (set2.prefixEvent) {
          if (typeof set2.prefixEvent === "string") {
            emitStack = `${set2.prefixEvent}.${metas.event}`;
          } else {
            emitStack = `${metas.name}`;
          }
          metas.event = emitStack;
        }
        const emitMetas = Object.assign(Object.assign({}, metas), { level: ((_g2 = metas === null || metas === void 0 ? void 0 : metas.level) !== null && _g2 !== void 0 ? _g2 : 0) + 1 });
        if (destSEventEmitter instanceof SEventEmitter) {
          if (set2.overrideEmitter === "bind" && destSEventEmitter.eventEmitterSettings.bind) {
            emitMetas.emitter = destSEventEmitter.eventEmitterSettings.bind;
          } else if (set2.overrideEmitter === true) {
            emitMetas.emitter = destSEventEmitter;
          }
        }
        if (destSEventEmitter === process && isChildProcess() && process.send) {
          if (value.value && value.value instanceof Error) {
            value.value = fn$6(value.value);
          }
          process.send({
            value,
            metas: emitMetas
          });
        } else {
          destSEventEmitter.emit(metas.event, value, emitMetas);
        }
      }
    }));
  }
  get eventEmitterSettings() {
    return this._settings.eventEmitter;
  }
  pipe(input, settings) {
    SEventEmitter.pipe(input, this, settings);
    return input;
  }
  pipeErrors(input, settings) {
    SEventEmitter.pipe(input, this, Object.assign(Object.assign({}, settings), { events: "error" }));
    return input;
  }
  pipeFrom(input, settings) {
    return this.pipe(input, settings);
  }
  pipeTo(dest, settings) {
    SEventEmitter.pipe(this, dest, settings);
    return this;
  }
  start() {
    if (!this.eventEmitterSettings.asyncStart)
      return;
    this._asyncStarted = true;
    this._processBuffer();
  }
  _createMetas(event, metas = {}) {
    var _a2, _b2, _c2;
    return __deepMerge$7({
      event,
      name: event,
      emitter: (_b2 = (_a2 = this.eventEmitterSettings.bind) !== null && _a2 !== void 0 ? _a2 : metas === null || metas === void 0 ? void 0 : metas.emitter) !== null && _b2 !== void 0 ? _b2 : this,
      originalEmitter: (_c2 = metas === null || metas === void 0 ? void 0 : metas.originalEmitter) !== null && _c2 !== void 0 ? _c2 : this,
      time: Date.now(),
      level: 0
    }, metas !== null && metas !== void 0 ? metas : {});
  }
  emit(event, value, metas) {
    return new Promise((resolve2, reject) => __awaiter$g(this, void 0, void 0, function* () {
      let metasObj = this._createMetas(event, metas);
      const isFirstLevel = !metasObj.level;
      if (plainObject$7(value)) {
        Object.keys(this.eventEmitterSettings.defaults).forEach((key) => {
          var _a2;
          const parts = key.split(",").map((l2) => l2.trim());
          if (parts.indexOf(event) === -1 && parts.indexOf("*") === -1)
            return;
          value = __deepMerge$7(value, (_a2 = this.eventEmitterSettings.defaults) === null || _a2 === void 0 ? void 0 : _a2[key]);
        });
      }
      const CastClass = this.eventEmitterSettings.castByEvent[event];
      if (CastClass && cls(CastClass) && !(value instanceof CastClass) && !value._sEventEmitterPreprocessed) {
        value = new CastClass(value);
      }
      if (event === "ask") {
        if (isFirstLevel) {
          metasObj.askId = uniqid();
        }
      }
      if (!this._asyncStarted && this.eventEmitterSettings.asyncStart) {
        this._buffer.push({
          event,
          value,
          metas: metasObj,
          resolve: resolve2,
          reject
        });
        return;
      }
      this._emit({
        event,
        value,
        metas: metasObj,
        resolve: resolve2,
        reject
      });
    }));
  }
  _emit(logObj) {
    return __awaiter$g(this, void 0, void 0, function* () {
      if (logObj.event === "ask") {
        this.constructor.global.on(`answer.${logObj.metas.askId}:1`, (answer, metas) => {
          logObj.resolve(answer);
        });
        this._emitEvents(logObj.event, logObj.value, logObj.metas);
      } else {
        const res = yield this._emitEvents(logObj.event, logObj.value, Object.assign({}, logObj.metas));
        logObj.resolve(res);
      }
    });
  }
  _registerNewEventsStacks(events) {
    if (typeof events === "string")
      events = events.split(",").map((s2) => s2.trim());
    events.forEach((event) => {
      if (!this._eventsStacks[event]) {
        this._eventsStacks[event] = {
          buffer: [],
          callStack: []
        };
      }
    });
  }
  _registerCallbackInEventStack(event, callback, settings = {}) {
    settings = Object.assign({ callNumber: void 0, filter: void 0, processor: void 0, id: void 0 }, settings);
    if (settings.id) {
      if (!this._onStackById[settings.id])
        this._onStackById[settings.id] = [];
      this._onStackById[settings.id].push({
        event,
        callback,
        settings
      });
    }
    if (!this._eventsStacks[event]) {
      this._registerNewEventsStacks(event);
    }
    const eventStackObj = this._eventsStacks[event];
    let callNumber = settings.callNumber;
    if (callNumber === void 0 && this.eventEmitterSettings.defaultCallTime[event] !== void 0) {
      callNumber = this.eventEmitterSettings.defaultCallTime[event];
    } else if (callNumber === void 0) {
      callNumber = -1;
    }
    if (typeof callback === "function")
      eventStackObj.callStack.push({
        callback,
        callNumber,
        filter: settings.filter,
        processor: settings.processor,
        called: 0
      });
    this._processBuffer();
    return this;
  }
  _processBuffer() {
    if (this._buffer.length > 0) {
      setTimeout(() => {
        this._buffer = this._buffer.filter((item) => {
          this._emit(item);
          return false;
        });
      }, this.eventEmitterSettings.bufferTimeout);
    }
  }
  _emitEventStack(event, initialValue, metasObj) {
    return __awaiter$g(this, void 0, void 0, function* () {
      let currentCallbackReturnedValue = initialValue;
      if (!this._eventsStacks || Object.keys(this._eventsStacks).length === 0)
        return currentCallbackReturnedValue;
      if (!this._eventsStacks[event]) {
        this._registerNewEventsStacks(event);
      }
      let eventStackArray = [];
      const eventStackObj = this._eventsStacks[event];
      if (eventStackObj && eventStackObj.callStack) {
        eventStackArray = [
          ...eventStackArray,
          ...eventStackObj.callStack
        ];
      }
      Object.keys(this._eventsStacks).forEach((stackName) => {
        if (stackName === event)
          return currentCallbackReturnedValue;
        if (minimatch_1(event, stackName) && this._eventsStacks[stackName] !== void 0) {
          eventStackArray = [
            ...eventStackArray,
            ...this._eventsStacks[stackName].callStack
          ];
        }
      });
      eventStackArray.map((item) => item.called++);
      eventStackArray = eventStackArray.filter((item) => {
        if (item.callNumber === -1)
          return true;
        if (item.called <= item.callNumber)
          return true;
        return false;
      });
      for (let i2 = 0; i2 < eventStackArray.length; i2++) {
        const item = eventStackArray[i2];
        if (!item.callback)
          return currentCallbackReturnedValue;
        if (item.filter && !item.filter(currentCallbackReturnedValue, metasObj))
          continue;
        if (item.processor) {
          const res = item.processor(currentCallbackReturnedValue, metasObj);
          if (Array.isArray(res) && res.length === 2) {
            currentCallbackReturnedValue = res[0];
            metasObj = res[1];
          } else if (typeof res === "object" && res.value !== void 0 && res.metas !== void 0) {
            currentCallbackReturnedValue = res.value;
            metasObj = res.metas;
          } else {
            currentCallbackReturnedValue = res;
          }
        }
        const callbackResult = yield item.callback(currentCallbackReturnedValue, metasObj, (metasObj === null || metasObj === void 0 ? void 0 : metasObj.askId) ? (answer) => {
          this.constructor.global.emit(`answer.${metasObj.askId}`, answer, metasObj);
        } : void 0);
        if (callbackResult !== void 0) {
          currentCallbackReturnedValue = callbackResult;
        }
      }
      return currentCallbackReturnedValue;
    });
  }
  _emitEvents(events, initialValue, metas) {
    return new Promise((resolve2, reject) => __awaiter$g(this, void 0, void 0, function* () {
      if (!events)
        return this;
      if (typeof events === "string")
        events = events.split(",").map((s2) => s2.trim());
      let currentStackResult = initialValue;
      for (let i2 = 0; i2 < events.length; i2++) {
        const stackResult = yield this._emitEventStack(events[i2], currentStackResult, metas);
        if (stackResult !== void 0) {
          currentStackResult = stackResult;
        }
      }
      resolve2(currentStackResult);
    }));
  }
  on(events, callback, settings) {
    const set2 = __deepMerge$7({
      filter: void 0,
      processor: void 0,
      id: void 0
    }, settings);
    if (typeof events === "string")
      events = events.split(",").map((s2) => s2.trim());
    events.forEach((name2) => {
      const splitedName = name2.split(":");
      let callNumber = -1;
      if (splitedName.length === 2) {
        name2 = splitedName[0];
        callNumber = parseInt(splitedName[1]);
      }
      this._registerCallbackInEventStack(name2, callback, {
        callNumber,
        filter: set2.filter,
        processor: set2.processor,
        id: set2.id
      });
    });
    return this;
  }
  off(event, callback) {
    if (!callback) {
      if (this._eventsStacks[event]) {
        delete this._eventsStacks[event];
      } else if (this._onStackById[event]) {
        this._onStackById[event].forEach((onStackByIdObj) => {
          this.off(onStackByIdObj.event, onStackByIdObj.callback);
        });
        delete this._onStackById[event];
      }
      return this;
    }
    const eventStackObj = this._eventsStacks[event];
    if (!eventStackObj)
      return this;
    eventStackObj.callStack = eventStackObj.callStack.filter((item) => {
      if (item.callback === callback)
        return false;
      return true;
    });
    this._eventsStacks[event] = eventStackObj;
    return this;
  }
  destroy() {
    this._eventsStacks = {};
  }
}
SEventEmitter.usableAsMixin = true;
const fn$3 = function treatAsValue(promise, settings = {}) {
  settings = Object.assign({ during: -1 }, settings);
  let during = settings.during || -1;
  try {
    const proxy = Proxy.revocable(promise, {
      get(target, prop, receiver) {
        if (prop === "then") {
          return target;
        }
        if (during > 0)
          during--;
        else if (during === 0) {
          proxy.revoke();
        }
        return Reflect.get(...arguments);
      }
    });
    proxy.proxy.restorePromiseBehavior = () => {
      proxy.revoke();
      return promise;
    };
    return proxy.proxy;
  } catch (e20) {
    return promise;
  }
};
var __awaiter$f = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e20) {
        reject(e20);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e20) {
        reject(e20);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SPromise extends SClass.extends(Promise) {
  constructor(executorFnOrSettings = {}, settings) {
    let executorFn, resolvers = {};
    super(__deepMerge$7({
      promise: {
        treatCancelAs: "resolve",
        destroyTimeout: 1,
        preventRejectOnThrow: true,
        emitErrorEventOnThrow: true,
        resolveAtResolveEvent: false,
        rejectAtRejectEvent: false,
        proxies: {
          resolve: [],
          reject: []
        }
      }
    }, typeof executorFnOrSettings === "object" ? executorFnOrSettings : {}, settings !== null && settings !== void 0 ? settings : {}), (resolve2, reject) => {
      resolvers.resolve = resolve2;
      new Promise((rejectPromiseResolve, rejectPromiseReject) => {
        resolvers.reject = (...args) => {
          rejectPromiseReject(...args);
          if (this.promiseSettings.preventRejectOnThrow) {
            resolve2(...args);
          } else {
            reject(...args);
          }
        };
      }).catch((e20) => {
        this.emit("catch", e20);
      });
    });
    this._promiseState = "pending";
    this._eventEmitter = new SEventEmitter(__deepMerge$7({
      metas: Object.assign({}, this.metas),
      eventEmitter: {}
    }, this._settings));
    this.expose(this._eventEmitter, {
      as: "eventEmitter",
      props: [
        "on",
        "off",
        "emit",
        "pipe",
        "pipeErrors",
        "pipeFrom",
        "pipeTo",
        "eventEmitterSettings"
      ]
    });
    this._resolvers = resolvers;
    if (this._settings.promise.destroyTimeout !== -1) {
      this.on("finally", (v2, m2) => {
        setTimeout(() => {
          this.destroy();
        }, this._settings.promise.destroyTimeout);
      });
    }
    executorFn = typeof executorFnOrSettings === "function" ? executorFnOrSettings : null;
    if (executorFn) {
      const api = {};
      getMethods(this).forEach((func) => {
        if (func.slice(0, 1) === "_")
          return;
        api[func] = this[func].bind(this);
      });
      (() => __awaiter$f(this, void 0, void 0, function* () {
        yield wait$1(0);
        try {
          yield executorFn(api);
        } catch (e20) {
          if (this.promiseSettings.emitErrorEventOnThrow) {
            this.emit("log", {
              type: SLog.TYPE_ERROR,
              value: e20
            });
          }
          this.reject(e20);
        }
      }))();
    }
    if (this.promiseSettings.resolveAtResolveEvent) {
      this.on("resolve", (data, metas) => {
        this.resolve(data);
      });
    }
    if (this.promiseSettings.rejectAtRejectEvent) {
      this.on("reject", (data, metas) => {
        this.reject(data);
      });
    }
  }
  static treatAsValue(promise, settings = {}) {
    return fn$3(promise, settings);
  }
  get promiseSettings() {
    return this._settings.promise;
  }
  static get [Symbol.species]() {
    return Promise;
  }
  get [Symbol.toStringTag]() {
    return "SPromise";
  }
  get promiseState() {
    return this._promiseState;
  }
  treatAsValue(settings = {}) {
    return fn$3(this, settings);
  }
  registerProxy(point, proxy) {
    const ar2 = point.split(",").map((l2) => l2.trim());
    ar2.forEach((a2) => {
      this._settings.promise.proxies[a2].push(proxy);
    });
  }
  is(status) {
    const statusArray = status.split(",").map((l2) => l2.trim());
    if (statusArray.indexOf(this._promiseState) !== -1)
      return true;
    return false;
  }
  isPending() {
    return this._promiseState === "pending";
  }
  isResolved() {
    return this._promiseState === "resolved";
  }
  isRejected() {
    return this._promiseState === "rejected";
  }
  isCanceled() {
    return this._promiseState === "canceled";
  }
  isDestroyed() {
    return this._promiseState === "destroyed";
  }
  resolve(arg, stacksOrder = "resolve,finally") {
    return this._resolve(arg, stacksOrder);
  }
  _resolve(arg, stacksOrder = "resolve,finally") {
    return __awaiter$f(this, void 0, void 0, function* () {
      if (this._promiseState === "destroyed")
        return;
      this._promiseState = "resolved";
      const stacksOrderArray = stacksOrder.split(",").map((l2) => l2.trim());
      for (let i2 = 0; i2 < stacksOrderArray.length; i2++) {
        const stack = stacksOrderArray[i2];
        arg = yield this.eventEmitter.emit(stack, arg);
      }
      for (const proxyFn of this._settings.promise.proxies.resolve || []) {
        arg = yield proxyFn(arg);
      }
      this._resolvers.resolve(arg);
      return arg;
    });
  }
  reject(arg, stacksOrder = `catch,reject,finally`) {
    return this._reject(arg, stacksOrder);
  }
  _reject(arg, stacksOrder = `catch,reject,finally`) {
    return __awaiter$f(this, void 0, void 0, function* () {
      if (this._promiseState === "destroyed")
        return;
      this._promiseState = "rejected";
      const stacksOrderArray = stacksOrder.split(",").map((l2) => l2.trim());
      for (let i2 = 0; i2 < stacksOrderArray.length; i2++) {
        const stack = stacksOrderArray[i2];
        arg = yield this.eventEmitter.emit(stack, arg);
      }
      for (const proxyFn of this._settings.promise.proxies.reject || []) {
        arg = yield proxyFn(arg);
      }
      this._resolvers.reject(arg);
      return arg;
    });
  }
  cancel(arg, stacksOrder = "cancel,finally") {
    return this._cancel(arg, stacksOrder);
  }
  _cancel(arg, stacksOrder = "cancel,finally") {
    if (this._promiseState === "destroyed")
      return;
    return new Promise((resolve2, reject) => __awaiter$f(this, void 0, void 0, function* () {
      this._promiseState = "canceled";
      const stacksOrderArray = stacksOrder.split(",").map((l2) => l2.trim());
      for (let i2 = 0; i2 < stacksOrderArray.length; i2++) {
        const stack = stacksOrderArray[i2];
        arg = yield this.eventEmitter.emit(stack, arg);
      }
      if (this._settings.promise.treatCancelAs === "reject") {
        this._resolvers.reject(arg);
      } else {
        this._resolvers.resolve(arg);
      }
      resolve2(arg);
    }));
  }
  catch(...args) {
    super.catch(...args);
    return this.on("catch", ...args);
  }
  finally(...args) {
    return this.on("finally", ...args);
  }
  destroy() {
    this._eventEmitter.destroy();
    this._promiseState = "destroyed";
  }
}
function inViewport(elm, settings = {}) {
  return new Promise((resolve2) => {
    settings = Object.assign({ offset: 10 }, settings);
    const observer = new IntersectionObserver((entries, observer2) => {
      if (!entries.length)
        return;
      const entry = entries[0];
      if (elm.tagName.toLowerCase() === "ck-search") {
        console.log(entry.intersectionRatio);
      }
      if (entry.intersectionRatio > 0) {
        resolve2(true);
      } else {
        resolve2(false);
      }
      observer2.disconnect();
    }, {
      root: null,
      rootMargin: `${settings.offset}px`,
      threshold: [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]
    });
    observer.observe(elm);
  });
}
var __awaiter$e = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e20) {
        reject(e20);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e20) {
        reject(e20);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function whenInViewport(elm, settings = {}) {
  settings = Object.assign({ offset: 10 }, settings);
  return new Promise((resolve2) => __awaiter$e(this, void 0, void 0, function* () {
    const options = {
      root: null,
      rootMargin: `${settings.offset}px`,
      threshold: 1
    };
    function onChange(changes, observer2) {
      changes.forEach((change) => {
        if (change.intersectionRatio > 0) {
          observer2.disconnect();
          resolve2(elm);
        }
      });
    }
    const observer = new IntersectionObserver(onChange, options);
    observer.observe(elm);
  }));
}
function whenOutOfViewport(elm, settings = {}) {
  return new Promise((resolve2, reject) => {
    settings = Object.assign({ offset: 10 }, settings);
    let isInViewport = false;
    const _cb2 = () => {
      if (!isInViewport) {
        observer.disconnect();
        resolve2(elm);
      }
    };
    const observer = new IntersectionObserver((entries, observer2) => {
      if (!entries.length)
        return;
      const entry = entries[0];
      if (entry.intersectionRatio > 0) {
        isInViewport = true;
      } else {
        isInViewport = false;
      }
      _cb2();
    }, {
      root: null,
      rootMargin: `${settings.offset}px`,
      threshold: [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]
    });
    observer.observe(elm);
  });
}
var __awaiter$d = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e20) {
        reject(e20);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e20) {
        reject(e20);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function inViewportStatusChange($elm, settings) {
  let isFinished = false;
  settings = Object.assign({ offset: 10 }, settings !== null && settings !== void 0 ? settings : {});
  return new SPromise(({ emit }) => __awaiter$d(this, void 0, void 0, function* () {
    function _whenIn() {
      if (isFinished)
        return;
      whenInViewport($elm, settings).then(() => {
        emit("enter", $elm);
        _whenOut();
      });
    }
    function _whenOut() {
      if (isFinished)
        return;
      whenOutOfViewport($elm, settings).then(() => {
        emit("leave", $elm);
        _whenIn();
      });
    }
    if (yield inViewport($elm, settings)) {
      emit("enter", $elm);
      _whenOut();
    } else {
      emit("leave", $elm);
      _whenIn();
    }
  }), {
    id: "inViewportStatisChange"
  }).on("finally", () => {
    isFinished = true;
  });
}
class SComponentDefaultInterface extends SInterface {
  static get _definition() {
    return {
      id: {
        type: "String",
        physical: true
      },
      mounted: {
        type: "Boolean",
        default: false,
        physical: true
      },
      mountWhen: {
        type: "String",
        values: ["directly", "inViewport"],
        default: "directly"
      },
      adoptStyle: {
        type: "Boolean",
        default: true,
        physical: true
      },
      bare: {
        type: "Boolean",
        default: false,
        physical: true
      }
    };
  }
}
class SComponent extends SClass {
  constructor(node, props, settings = {}) {
    var _a2, _b2;
    var _c2;
    super(__deepMerge$7({
      componentUtils: {}
    }, settings));
    this.state = "pending";
    this._isInViewport = false;
    this.node = node;
    this._props = props;
    this.inViewportStatusChange.on("enter", () => {
      this._isInViewport = true;
    }).on("leave", () => {
      this._isInViewport = false;
    });
    let InterfaceToApply = (_c2 = class InlineSComponentUtilsInterface extends SInterface {
    }, _c2.definition = {}, _c2);
    InterfaceToApply.definition = Object.assign(Object.assign({}, Object.assign({}, SComponentDefaultInterface.definition)), (_b2 = (_a2 = this.componentUtilsSettings.interface) === null || _a2 === void 0 ? void 0 : _a2.definition) !== null && _b2 !== void 0 ? _b2 : {});
    this.InterfaceToApply = InterfaceToApply;
    const styleStr = this.componentUtilsSettings.style;
    this.injectStyle(styleStr !== null && styleStr !== void 0 ? styleStr : "");
    this._whenMountPromise = new Promise((resolve2) => {
      switch (this.props.mountWhen) {
        case "inViewport":
          this.inViewportStatusChange.on("enter", () => {
            resolve2();
          });
          break;
        case "directly":
        default:
          resolve2();
          break;
      }
    });
  }
  get name() {
    var _a2;
    return (_a2 = this.componentUtilsSettings.name) !== null && _a2 !== void 0 ? _a2 : this.node.tagName.toLowerCase();
  }
  static setDefaultProps(selector, props) {
    selector = Array.isArray(selector) ? selector : [selector];
    selector.forEach((sel) => {
      var _a2;
      this._defaultProps[sel] = Object.assign(Object.assign({}, (_a2 = this._defaultProps[sel]) !== null && _a2 !== void 0 ? _a2 : {}), props);
    });
  }
  static getDefaultProps(selector) {
    var _a2;
    return (_a2 = this._defaultProps[selector]) !== null && _a2 !== void 0 ? _a2 : {};
  }
  get componentUtilsSettings() {
    return this._settings.componentUtils;
  }
  get isInViewport() {
    return this._isInViewport;
  }
  get inViewportStatusChange() {
    if (this._inViewportStatusChangePromise)
      return this._inViewportStatusChangePromise;
    this._inViewportStatusChangePromise = inViewportStatusChange(this.node);
    return this._inViewportStatusChangePromise;
  }
  waitOnMountState() {
    return this._whenMountPromise;
  }
  adoptStyleInShadowRoot($shadowRoot, $context) {
    return adoptStyleInShadowRoot($shadowRoot, $context);
  }
  get props() {
    if (this._finalProps)
      return this._finalProps;
    const props = this._props;
    let passedProps = {};
    if (props.constructor.name === "NamedNodeMap") {
      Object.keys(props).forEach((key) => {
        var _a2, _b2, _c2;
        let value;
        if (((_a2 = props[key]) === null || _a2 === void 0 ? void 0 : _a2.nodeValue) !== void 0) {
          if (props[key].nodeValue === "")
            value = true;
          else
            value = props[key].nodeValue;
        }
        if (!value)
          return;
        passedProps[camelCase((_c2 = (_b2 = props[key]) === null || _b2 === void 0 ? void 0 : _b2.name) !== null && _c2 !== void 0 ? _c2 : key)] = autoCast$1(value);
      });
    } else {
      j;
      passedProps = props;
    }
    this._finalProps = __deepMerge$7(this.defaultProps, this.InterfaceToApply.apply(passedProps, {
      descriptor: {
        defaults: false
      }
    }));
    const _this = this;
    this._finalProps = new Proxy(this._finalProps, {
      get(target, prop, receiver) {
        return target[prop];
      },
      set(obj2, prop, value) {
        const propDef = _this.InterfaceToApply.definition[prop];
        if (propDef === null || propDef === void 0 ? void 0 : propDef.physical) {
          if (value === false || value === void 0 || value === null) {
            _this.node.removeAttribute(dashCase(prop));
          } else {
            _this.node.setAttribute(dashCase(prop), String(value));
          }
        }
        obj2[prop] = value;
        return true;
      }
    });
    Object.keys(this._finalProps).forEach((prop) => {
      this._finalProps[prop] = this._finalProps[prop];
    });
    return this._finalProps;
  }
  get defaultProps() {
    var _a2, _b2, _c2;
    if (this._defaultProps)
      return Object.assign({}, this._defaultProps);
    this._defaultProps = Object.assign({}, __deepMerge$7(this.InterfaceToApply.defaults(), (_a2 = this.componentUtilsSettings.defaultProps) !== null && _a2 !== void 0 ? _a2 : {}, (_b2 = this.constructor._defaultProps["*"]) !== null && _b2 !== void 0 ? _b2 : {}, (_c2 = this.constructor._defaultProps[this.name]) !== null && _c2 !== void 0 ? _c2 : {}));
    return this._defaultProps;
  }
  static getFinalInterface(int) {
    class InlineSComponentUtilsInterface extends SInterface {
    }
    InlineSComponentUtilsInterface.definition = SComponentDefaultInterface.definition;
    if (int) {
      InlineSComponentUtilsInterface.definition = Object.assign(Object.assign({}, SComponentDefaultInterface.definition), int.definition);
    }
    return InlineSComponentUtilsInterface;
  }
  injectStyle(css2, id2 = this.tagName) {
    if (this.constructor._injectedStyles.indexOf(id2) !== -1)
      return;
    this.constructor._injectedStyles.push(id2);
    injectStyle(css2, id2);
  }
  exposeApi(apiObj, ctx = this.node) {
    setTimeout(() => {
      let $on = this.node;
      Object.keys(apiObj).forEach((apiFnName) => {
        const apiFn = apiObj[apiFnName].bind(ctx);
        $on[apiFnName] = apiFn;
      });
    });
  }
  className(cls2 = "", style = "") {
    let clsString = cls2.split(" ").map((clsName) => `${this.node.tagName.toLowerCase()}${clsName && !clsName.match(/^__/) ? "-" : ""}${clsName}`).join(" ");
    if (style && !this.props.bare) {
      clsString += ` ${style}`;
    }
    return clsString;
  }
  isMounted() {
    var _a2;
    return (_a2 = this.node) === null || _a2 === void 0 ? void 0 : _a2.hasAttribute("mounted");
  }
}
SComponent._defaultProps = {};
SComponent._injectedStyles = [];
/**
* @license
* Copyright 2019 Google LLC
* SPDX-License-Identifier: BSD-3-Clause
*/
const supportsAdoptingStyleSheets = window.ShadowRoot && (window.ShadyCSS === void 0 || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
const constructionToken = Symbol();
const styleSheetCache = new Map();
class CSSResult {
  constructor(cssText, safeToken) {
    this["_$cssResult$"] = true;
    if (safeToken !== constructionToken) {
      throw new Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    }
    this.cssText = cssText;
  }
  get styleSheet() {
    let styleSheet = styleSheetCache.get(this.cssText);
    if (supportsAdoptingStyleSheets && styleSheet === void 0) {
      styleSheetCache.set(this.cssText, styleSheet = new CSSStyleSheet());
      styleSheet.replaceSync(this.cssText);
    }
    return styleSheet;
  }
  toString() {
    return this.cssText;
  }
}
const textFromCSSResult = (value) => {
  if (value["_$cssResult$"] === true) {
    return value.cssText;
  } else if (typeof value === "number") {
    return value;
  } else {
    throw new Error(`Value passed to 'css' function must be a 'css' function result: ${value}. Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.`);
  }
};
const unsafeCSS = (value) => new CSSResult(typeof value === "string" ? value : String(value), constructionToken);
const css$1 = (strings, ...values) => {
  const cssText = strings.length === 1 ? strings[0] : values.reduce((acc, v2, idx) => acc + textFromCSSResult(v2) + strings[idx + 1], strings[0]);
  return new CSSResult(cssText, constructionToken);
};
const adoptStyles = (renderRoot, styles2) => {
  if (supportsAdoptingStyleSheets) {
    renderRoot.adoptedStyleSheets = styles2.map((s2) => s2 instanceof CSSStyleSheet ? s2 : s2.styleSheet);
  } else {
    styles2.forEach((s2) => {
      const style = document.createElement("style");
      const nonce = window["litNonce"];
      if (nonce !== void 0) {
        style.setAttribute("nonce", nonce);
      }
      style.textContent = s2.cssText;
      renderRoot.appendChild(style);
    });
  }
};
const cssResultFromStyleSheet = (sheet) => {
  let cssText = "";
  for (const rule of sheet.cssRules) {
    cssText += rule.cssText;
  }
  return unsafeCSS(cssText);
};
const getCompatibleStyle = supportsAdoptingStyleSheets ? (s2) => s2 : (s2) => s2 instanceof CSSStyleSheet ? cssResultFromStyleSheet(s2) : s2;
/**
* @license
* Copyright 2017 Google LLC
* SPDX-License-Identifier: BSD-3-Clause
*/
var _a$6, _b$6, _c$6;
var _d$4;
let requestUpdateThenable;
let issueWarning$3;
const polyfillSupport$3 = window.reactiveElementPolyfillSupportDevMode;
{
  const issuedWarnings = (_a$6 = globalThis.litIssuedWarnings) !== null && _a$6 !== void 0 ? _a$6 : globalThis.litIssuedWarnings = new Set();
  issueWarning$3 = (code4, warning) => {
    warning += ` See https://lit.dev/msg/${code4} for more information.`;
    if (!issuedWarnings.has(warning)) {
      console.warn(warning);
      issuedWarnings.add(warning);
    }
  };
  issueWarning$3("dev-mode", `Lit is in dev mode. Not recommended for production!`);
  if (((_b$6 = window.ShadyDOM) === null || _b$6 === void 0 ? void 0 : _b$6.inUse) && polyfillSupport$3 === void 0) {
    issueWarning$3("polyfill-support-missing", `Shadow DOM is being polyfilled via \`ShadyDOM\` but the \`polyfill-support\` module has not been loaded.`);
  }
  requestUpdateThenable = (name2) => ({
    then: (onfulfilled, _onrejected) => {
      issueWarning$3("request-update-promise", `The \`requestUpdate\` method should no longer return a Promise but does so on \`${name2}\`. Use \`updateComplete\` instead.`);
      if (onfulfilled !== void 0) {
        onfulfilled(false);
      }
    }
  });
}
const JSCompiler_renameProperty = (prop, _obj2) => prop;
const defaultConverter = {
  toAttribute(value, type) {
    switch (type) {
      case Boolean:
        value = value ? "" : null;
        break;
      case Object:
      case Array:
        value = value == null ? value : JSON.stringify(value);
        break;
    }
    return value;
  },
  fromAttribute(value, type) {
    let fromValue = value;
    switch (type) {
      case Boolean:
        fromValue = value !== null;
        break;
      case Number:
        fromValue = value === null ? null : Number(value);
        break;
      case Object:
      case Array:
        try {
          fromValue = JSON.parse(value);
        } catch (e20) {
          fromValue = null;
        }
        break;
    }
    return fromValue;
  }
};
const notEqual = (value, old) => {
  return old !== value && (old === old || value === value);
};
const defaultPropertyDeclaration = {
  attribute: true,
  type: String,
  converter: defaultConverter,
  reflect: false,
  hasChanged: notEqual
};
const finalized = "finalized";
class ReactiveElement extends HTMLElement {
  constructor() {
    super();
    this.__instanceProperties = new Map();
    this.isUpdatePending = false;
    this.hasUpdated = false;
    this.__reflectingProperty = null;
    this._initialize();
  }
  static addInitializer(initializer) {
    var _a2;
    (_a2 = this._initializers) !== null && _a2 !== void 0 ? _a2 : this._initializers = [];
    this._initializers.push(initializer);
  }
  static get observedAttributes() {
    this.finalize();
    const attributes = [];
    this.elementProperties.forEach((v2, p2) => {
      const attr = this.__attributeNameForProperty(p2, v2);
      if (attr !== void 0) {
        this.__attributeToPropertyMap.set(attr, p2);
        attributes.push(attr);
      }
    });
    return attributes;
  }
  static createProperty(name2, options = defaultPropertyDeclaration) {
    if (options.state) {
      options.attribute = false;
    }
    this.finalize();
    this.elementProperties.set(name2, options);
    if (!options.noAccessor && !this.prototype.hasOwnProperty(name2)) {
      const key = typeof name2 === "symbol" ? Symbol() : `__${name2}`;
      const descriptor2 = this.getPropertyDescriptor(name2, key, options);
      if (descriptor2 !== void 0) {
        Object.defineProperty(this.prototype, name2, descriptor2);
      }
    }
  }
  static getPropertyDescriptor(name2, key, options) {
    return {
      get() {
        return this[key];
      },
      set(value) {
        const oldValue = this[name2];
        this[key] = value;
        this.requestUpdate(name2, oldValue, options);
      },
      configurable: true,
      enumerable: true
    };
  }
  static getPropertyOptions(name2) {
    return this.elementProperties.get(name2) || defaultPropertyDeclaration;
  }
  static finalize() {
    if (this.hasOwnProperty(finalized)) {
      return false;
    }
    this[finalized] = true;
    const superCtor = Object.getPrototypeOf(this);
    superCtor.finalize();
    this.elementProperties = new Map(superCtor.elementProperties);
    this.__attributeToPropertyMap = new Map();
    if (this.hasOwnProperty(JSCompiler_renameProperty("properties"))) {
      const props = this.properties;
      const propKeys = [
        ...Object.getOwnPropertyNames(props),
        ...Object.getOwnPropertySymbols(props)
      ];
      for (const p2 of propKeys) {
        this.createProperty(p2, props[p2]);
      }
    }
    this.elementStyles = this.finalizeStyles(this.styles);
    {
      const warnRemovedOrRenamed = (name2, renamed = false) => {
        if (this.prototype.hasOwnProperty(name2)) {
          issueWarning$3(renamed ? "renamed-api" : "removed-api", `\`${name2}\` is implemented on class ${this.name}. It has been ${renamed ? "renamed" : "removed"} in this version of LitElement.`);
        }
      };
      warnRemovedOrRenamed("initialize");
      warnRemovedOrRenamed("requestUpdateInternal");
      warnRemovedOrRenamed("_getUpdateComplete", true);
    }
    return true;
  }
  static finalizeStyles(styles2) {
    const elementStyles = [];
    if (Array.isArray(styles2)) {
      const set2 = new Set(styles2.flat(Infinity).reverse());
      for (const s2 of set2) {
        elementStyles.unshift(getCompatibleStyle(s2));
      }
    } else if (styles2 !== void 0) {
      elementStyles.push(getCompatibleStyle(styles2));
    }
    return elementStyles;
  }
  static __attributeNameForProperty(name2, options) {
    const attribute = options.attribute;
    return attribute === false ? void 0 : typeof attribute === "string" ? attribute : typeof name2 === "string" ? name2.toLowerCase() : void 0;
  }
  _initialize() {
    var _a2;
    this.__updatePromise = new Promise((res) => this.enableUpdating = res);
    this._$changedProperties = new Map();
    this.__saveInstanceProperties();
    this.requestUpdate();
    (_a2 = this.constructor._initializers) === null || _a2 === void 0 ? void 0 : _a2.forEach((i2) => i2(this));
  }
  addController(controller) {
    var _a2, _b2;
    ((_a2 = this.__controllers) !== null && _a2 !== void 0 ? _a2 : this.__controllers = []).push(controller);
    if (this.renderRoot !== void 0 && this.isConnected) {
      (_b2 = controller.hostConnected) === null || _b2 === void 0 ? void 0 : _b2.call(controller);
    }
  }
  removeController(controller) {
    var _a2;
    (_a2 = this.__controllers) === null || _a2 === void 0 ? void 0 : _a2.splice(this.__controllers.indexOf(controller) >>> 0, 1);
  }
  __saveInstanceProperties() {
    this.constructor.elementProperties.forEach((_v2, p2) => {
      if (this.hasOwnProperty(p2)) {
        this.__instanceProperties.set(p2, this[p2]);
        delete this[p2];
      }
    });
  }
  createRenderRoot() {
    var _a2;
    const renderRoot = (_a2 = this.shadowRoot) !== null && _a2 !== void 0 ? _a2 : this.attachShadow(this.constructor.shadowRootOptions);
    adoptStyles(renderRoot, this.constructor.elementStyles);
    return renderRoot;
  }
  connectedCallback() {
    var _a2;
    if (this.renderRoot === void 0) {
      this.renderRoot = this.createRenderRoot();
    }
    this.enableUpdating(true);
    (_a2 = this.__controllers) === null || _a2 === void 0 ? void 0 : _a2.forEach((c2) => {
      var _a3;
      return (_a3 = c2.hostConnected) === null || _a3 === void 0 ? void 0 : _a3.call(c2);
    });
  }
  enableUpdating(_requestedUpdate) {
  }
  disconnectedCallback() {
    var _a2;
    (_a2 = this.__controllers) === null || _a2 === void 0 ? void 0 : _a2.forEach((c2) => {
      var _a3;
      return (_a3 = c2.hostDisconnected) === null || _a3 === void 0 ? void 0 : _a3.call(c2);
    });
  }
  attributeChangedCallback(name2, _old, value) {
    this._$attributeToProperty(name2, value);
  }
  __propertyToAttribute(name2, value, options = defaultPropertyDeclaration) {
    var _a2, _b2;
    const attr = this.constructor.__attributeNameForProperty(name2, options);
    if (attr !== void 0 && options.reflect === true) {
      const toAttribute = (_b2 = (_a2 = options.converter) === null || _a2 === void 0 ? void 0 : _a2.toAttribute) !== null && _b2 !== void 0 ? _b2 : defaultConverter.toAttribute;
      const attrValue = toAttribute(value, options.type);
      if (this.constructor.enabledWarnings.indexOf("migration") >= 0 && attrValue === void 0) {
        issueWarning$3("undefined-attribute-value", `The attribute value for the ${name2} property is undefined on element ${this.localName}. The attribute will be removed, but in the previous version of \`ReactiveElement\`, the attribute would not have changed.`);
      }
      this.__reflectingProperty = name2;
      if (attrValue == null) {
        this.removeAttribute(attr);
      } else {
        this.setAttribute(attr, attrValue);
      }
      this.__reflectingProperty = null;
    }
  }
  _$attributeToProperty(name2, value) {
    var _a2, _b2, _c2;
    const ctor = this.constructor;
    const propName = ctor.__attributeToPropertyMap.get(name2);
    if (propName !== void 0 && this.__reflectingProperty !== propName) {
      const options = ctor.getPropertyOptions(propName);
      const converter = options.converter;
      const fromAttribute = (_c2 = (_b2 = (_a2 = converter) === null || _a2 === void 0 ? void 0 : _a2.fromAttribute) !== null && _b2 !== void 0 ? _b2 : typeof converter === "function" ? converter : null) !== null && _c2 !== void 0 ? _c2 : defaultConverter.fromAttribute;
      this.__reflectingProperty = propName;
      this[propName] = fromAttribute(value, options.type);
      this.__reflectingProperty = null;
    }
  }
  requestUpdate(name2, oldValue, options) {
    let shouldRequestUpdate = true;
    if (name2 !== void 0) {
      options = options || this.constructor.getPropertyOptions(name2);
      const hasChanged = options.hasChanged || notEqual;
      if (hasChanged(this[name2], oldValue)) {
        if (!this._$changedProperties.has(name2)) {
          this._$changedProperties.set(name2, oldValue);
        }
        if (options.reflect === true && this.__reflectingProperty !== name2) {
          if (this.__reflectingProperties === void 0) {
            this.__reflectingProperties = new Map();
          }
          this.__reflectingProperties.set(name2, options);
        }
      } else {
        shouldRequestUpdate = false;
      }
    }
    if (!this.isUpdatePending && shouldRequestUpdate) {
      this.__updatePromise = this.__enqueueUpdate();
    }
    return requestUpdateThenable(this.localName);
  }
  async __enqueueUpdate() {
    this.isUpdatePending = true;
    try {
      await this.__updatePromise;
    } catch (e20) {
      Promise.reject(e20);
    }
    const result = this.scheduleUpdate();
    if (result != null) {
      await result;
    }
    return !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var _a2;
    if (!this.isUpdatePending) {
      return;
    }
    if (!this.hasUpdated) {
      {
        const shadowedProperties = [];
        this.constructor.elementProperties.forEach((_v2, p2) => {
          var _a3;
          if (this.hasOwnProperty(p2) && !((_a3 = this.__instanceProperties) === null || _a3 === void 0 ? void 0 : _a3.has(p2))) {
            shadowedProperties.push(p2);
          }
        });
        if (shadowedProperties.length) {
          throw new Error(`The following properties on element ${this.localName} will not trigger updates as expected because they are set using class fields: ${shadowedProperties.join(", ")}. Native class fields and some compiled output will overwrite accessors used for detecting changes. See https://lit.dev/msg/class-field-shadowing for more information.`);
        }
      }
    }
    if (this.__instanceProperties) {
      this.__instanceProperties.forEach((v2, p2) => this[p2] = v2);
      this.__instanceProperties = void 0;
    }
    let shouldUpdate = false;
    const changedProperties = this._$changedProperties;
    try {
      shouldUpdate = this.shouldUpdate(changedProperties);
      if (shouldUpdate) {
        this.willUpdate(changedProperties);
        (_a2 = this.__controllers) === null || _a2 === void 0 ? void 0 : _a2.forEach((c2) => {
          var _a3;
          return (_a3 = c2.hostUpdate) === null || _a3 === void 0 ? void 0 : _a3.call(c2);
        });
        this.update(changedProperties);
      } else {
        this.__markUpdated();
      }
    } catch (e20) {
      shouldUpdate = false;
      this.__markUpdated();
      throw e20;
    }
    if (shouldUpdate) {
      this._$didUpdate(changedProperties);
    }
  }
  willUpdate(_changedProperties) {
  }
  _$didUpdate(changedProperties) {
    var _a2;
    (_a2 = this.__controllers) === null || _a2 === void 0 ? void 0 : _a2.forEach((c2) => {
      var _a3;
      return (_a3 = c2.hostUpdated) === null || _a3 === void 0 ? void 0 : _a3.call(c2);
    });
    if (!this.hasUpdated) {
      this.hasUpdated = true;
      this.firstUpdated(changedProperties);
    }
    this.updated(changedProperties);
    if (this.isUpdatePending && this.constructor.enabledWarnings.indexOf("change-in-update") >= 0) {
      issueWarning$3("change-in-update", `Element ${this.localName} scheduled an update (generally because a property was set) after an update completed, causing a new update to be scheduled. This is inefficient and should be avoided unless the next update can only be scheduled as a side effect of the previous update.`);
    }
  }
  __markUpdated() {
    this._$changedProperties = new Map();
    this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this.__updatePromise;
  }
  shouldUpdate(_changedProperties) {
    return true;
  }
  update(_changedProperties) {
    if (this.__reflectingProperties !== void 0) {
      this.__reflectingProperties.forEach((v2, k2) => this.__propertyToAttribute(k2, this[k2], v2));
      this.__reflectingProperties = void 0;
    }
    this.__markUpdated();
  }
  updated(_changedProperties) {
  }
  firstUpdated(_changedProperties) {
  }
}
_d$4 = finalized;
ReactiveElement[_d$4] = true;
ReactiveElement.elementProperties = new Map();
ReactiveElement.elementStyles = [];
ReactiveElement.shadowRootOptions = { mode: "open" };
polyfillSupport$3 === null || polyfillSupport$3 === void 0 ? void 0 : polyfillSupport$3({ ReactiveElement });
{
  ReactiveElement.enabledWarnings = ["change-in-update"];
  const ensureOwnWarnings = function(ctor) {
    if (!ctor.hasOwnProperty(JSCompiler_renameProperty("enabledWarnings"))) {
      ctor.enabledWarnings = ctor.enabledWarnings.slice();
    }
  };
  ReactiveElement.enableWarning = function(warning) {
    ensureOwnWarnings(this);
    if (this.enabledWarnings.indexOf(warning) < 0) {
      this.enabledWarnings.push(warning);
    }
  };
  ReactiveElement.disableWarning = function(warning) {
    ensureOwnWarnings(this);
    const i2 = this.enabledWarnings.indexOf(warning);
    if (i2 >= 0) {
      this.enabledWarnings.splice(i2, 1);
    }
  };
}
((_c$6 = globalThis.reactiveElementVersions) !== null && _c$6 !== void 0 ? _c$6 : globalThis.reactiveElementVersions = []).push("1.0.1");
if (globalThis.reactiveElementVersions.length > 1) {
  issueWarning$3("multiple-versions", `Multiple versions of Lit loaded. Loading multiple versions is not recommended.`);
}
/**
* @license
* Copyright 2017 Google LLC
* SPDX-License-Identifier: BSD-3-Clause
*/
var _a$5, _b$5, _c$5, _d$3;
let issueWarning$2;
{
  (_a$5 = globalThis.litIssuedWarnings) !== null && _a$5 !== void 0 ? _a$5 : globalThis.litIssuedWarnings = new Set();
  issueWarning$2 = (code4, warning) => {
    warning += code4 ? ` See https://lit.dev/msg/${code4} for more information.` : "";
    if (!globalThis.litIssuedWarnings.has(warning)) {
      console.warn(warning);
      globalThis.litIssuedWarnings.add(warning);
    }
  };
  issueWarning$2("dev-mode", `Lit is in dev mode. Not recommended for production!`);
}
const wrap$3 = ((_b$5 = window.ShadyDOM) === null || _b$5 === void 0 ? void 0 : _b$5.inUse) && ((_c$5 = window.ShadyDOM) === null || _c$5 === void 0 ? void 0 : _c$5.noPatch) === true ? window.ShadyDOM.wrap : (node) => node;
const trustedTypes$2 = globalThis.trustedTypes;
const policy$2 = trustedTypes$2 ? trustedTypes$2.createPolicy("lit-html", {
  createHTML: (s2) => s2
}) : void 0;
const identityFunction$2 = (value) => value;
const noopSanitizer$2 = (_node, _name, _type) => identityFunction$2;
const setSanitizer = (newSanitizer) => {
  if (sanitizerFactoryInternal$2 !== noopSanitizer$2) {
    throw new Error(`Attempted to overwrite existing lit-html security policy. setSanitizeDOMValueFactory should be called at most once.`);
  }
  sanitizerFactoryInternal$2 = newSanitizer;
};
const _testOnlyClearSanitizerFactoryDoNotCallOrElse = () => {
  sanitizerFactoryInternal$2 = noopSanitizer$2;
};
const createSanitizer$2 = (node, name2, type) => {
  return sanitizerFactoryInternal$2(node, name2, type);
};
const boundAttributeSuffix$2 = "$lit$";
const marker$2 = `lit$${String(Math.random()).slice(9)}$`;
const markerMatch$2 = "?" + marker$2;
const nodeMarker$2 = `<${markerMatch$2}>`;
const d$5 = document;
const createMarker$2 = (v2 = "") => d$5.createComment(v2);
const isPrimitive$2 = (value) => value === null || typeof value != "object" && typeof value != "function";
const isArray$4 = Array.isArray;
const isIterable$2 = (value) => {
  var _a2;
  return isArray$4(value) || typeof ((_a2 = value) === null || _a2 === void 0 ? void 0 : _a2[Symbol.iterator]) === "function";
};
const SPACE_CHAR$2 = `[ 	
\f\r]`;
const ATTR_VALUE_CHAR$2 = `[^ 	
\f\r"'\`<>=]`;
const NAME_CHAR$2 = `[^\\s"'>=/]`;
const textEndRegex$2 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
const COMMENT_START$2 = 1;
const TAG_NAME$2 = 2;
const DYNAMIC_TAG_NAME$2 = 3;
const commentEndRegex$2 = /-->/g;
const comment2EndRegex$2 = />/g;
const tagEndRegex$2 = new RegExp(`>|${SPACE_CHAR$2}(?:(${NAME_CHAR$2}+)(${SPACE_CHAR$2}*=${SPACE_CHAR$2}*(?:${ATTR_VALUE_CHAR$2}|("|')|))|$)`, "g");
const ENTIRE_MATCH$2 = 0;
const ATTRIBUTE_NAME$2 = 1;
const SPACES_AND_EQUALS$2 = 2;
const QUOTE_CHAR$2 = 3;
const singleQuoteAttrEndRegex$2 = /'/g;
const doubleQuoteAttrEndRegex$2 = /"/g;
const rawTextElement$2 = /^(?:script|style|textarea)$/i;
const HTML_RESULT$2 = 1;
const SVG_RESULT$2 = 2;
const ATTRIBUTE_PART$2 = 1;
const CHILD_PART$2 = 2;
const PROPERTY_PART$2 = 3;
const BOOLEAN_ATTRIBUTE_PART$2 = 4;
const EVENT_PART$2 = 5;
const ELEMENT_PART$2 = 6;
const COMMENT_PART$2 = 7;
const tag$2 = (type) => (strings, ...values) => {
  if (strings.some((s2) => s2 === void 0)) {
    console.warn("Some template strings are undefined.\nThis is probably caused by illegal octal escape sequences.");
  }
  return {
    ["_$litType$"]: type,
    strings,
    values
  };
};
const html$2 = tag$2(HTML_RESULT$2);
const noChange$2 = Symbol.for("lit-noChange");
const nothing$2 = Symbol.for("lit-nothing");
const templateCache$2 = new WeakMap();
const render = (value, container, options) => {
  var _a2, _b2, _c2;
  const partOwnerNode = (_a2 = options === null || options === void 0 ? void 0 : options.renderBefore) !== null && _a2 !== void 0 ? _a2 : container;
  let part = partOwnerNode["_$litPart$"];
  if (part === void 0) {
    const endNode = (_b2 = options === null || options === void 0 ? void 0 : options.renderBefore) !== null && _b2 !== void 0 ? _b2 : null;
    if (((_c2 = options) === null || _c2 === void 0 ? void 0 : _c2.clearContainerForLit2MigrationOnly) === true) {
      let n2 = container.firstChild;
      while (n2 && n2 !== endNode) {
        const next = n2.nextSibling;
        n2.remove();
        n2 = next;
      }
    }
    partOwnerNode["_$litPart$"] = part = new ChildPart$2(container.insertBefore(createMarker$2(), endNode), endNode, void 0, options !== null && options !== void 0 ? options : {});
  }
  part._$setValue(value);
  return part;
};
{
  render.setSanitizer = setSanitizer;
  render.createSanitizer = createSanitizer$2;
  {
    render._testOnlyClearSanitizerFactoryDoNotCallOrElse = _testOnlyClearSanitizerFactoryDoNotCallOrElse;
  }
}
const walker$2 = d$5.createTreeWalker(d$5, 129, null, false);
let sanitizerFactoryInternal$2 = noopSanitizer$2;
const getTemplateHtml$2 = (strings, type) => {
  const l2 = strings.length - 1;
  const attrNames = [];
  let html2 = type === SVG_RESULT$2 ? "<svg>" : "";
  let rawTextEndRegex;
  let regex = textEndRegex$2;
  for (let i2 = 0; i2 < l2; i2++) {
    const s2 = strings[i2];
    let attrNameEndIndex = -1;
    let attrName;
    let lastIndex = 0;
    let match5;
    while (lastIndex < s2.length) {
      regex.lastIndex = lastIndex;
      match5 = regex.exec(s2);
      if (match5 === null) {
        break;
      }
      lastIndex = regex.lastIndex;
      if (regex === textEndRegex$2) {
        if (match5[COMMENT_START$2] === "!--") {
          regex = commentEndRegex$2;
        } else if (match5[COMMENT_START$2] !== void 0) {
          regex = comment2EndRegex$2;
        } else if (match5[TAG_NAME$2] !== void 0) {
          if (rawTextElement$2.test(match5[TAG_NAME$2])) {
            rawTextEndRegex = new RegExp(`</${match5[TAG_NAME$2]}`, "g");
          }
          regex = tagEndRegex$2;
        } else if (match5[DYNAMIC_TAG_NAME$2] !== void 0) {
          {
            throw new Error("Bindings in tag names are not supported. Please use static templates instead. See https://lit.dev/docs/templates/expressions/#static-expressions");
          }
        }
      } else if (regex === tagEndRegex$2) {
        if (match5[ENTIRE_MATCH$2] === ">") {
          regex = rawTextEndRegex !== null && rawTextEndRegex !== void 0 ? rawTextEndRegex : textEndRegex$2;
          attrNameEndIndex = -1;
        } else if (match5[ATTRIBUTE_NAME$2] === void 0) {
          attrNameEndIndex = -2;
        } else {
          attrNameEndIndex = regex.lastIndex - match5[SPACES_AND_EQUALS$2].length;
          attrName = match5[ATTRIBUTE_NAME$2];
          regex = match5[QUOTE_CHAR$2] === void 0 ? tagEndRegex$2 : match5[QUOTE_CHAR$2] === '"' ? doubleQuoteAttrEndRegex$2 : singleQuoteAttrEndRegex$2;
        }
      } else if (regex === doubleQuoteAttrEndRegex$2 || regex === singleQuoteAttrEndRegex$2) {
        regex = tagEndRegex$2;
      } else if (regex === commentEndRegex$2 || regex === comment2EndRegex$2) {
        regex = textEndRegex$2;
      } else {
        regex = tagEndRegex$2;
        rawTextEndRegex = void 0;
      }
    }
    {
      console.assert(attrNameEndIndex === -1 || regex === tagEndRegex$2 || regex === singleQuoteAttrEndRegex$2 || regex === doubleQuoteAttrEndRegex$2, "unexpected parse state B");
    }
    const end = regex === tagEndRegex$2 && strings[i2 + 1].startsWith("/>") ? " " : "";
    html2 += regex === textEndRegex$2 ? s2 + nodeMarker$2 : attrNameEndIndex >= 0 ? (attrNames.push(attrName), s2.slice(0, attrNameEndIndex) + boundAttributeSuffix$2 + s2.slice(attrNameEndIndex)) + marker$2 + end : s2 + marker$2 + (attrNameEndIndex === -2 ? (attrNames.push(void 0), i2) : end);
  }
  const htmlResult = html2 + (strings[l2] || "<?>") + (type === SVG_RESULT$2 ? "</svg>" : "");
  return [
    policy$2 !== void 0 ? policy$2.createHTML(htmlResult) : htmlResult,
    attrNames
  ];
};
class Template$2 {
  constructor({ strings, ["_$litType$"]: type }, options) {
    this.parts = [];
    let node;
    let nodeIndex = 0;
    let attrNameIndex = 0;
    const partCount = strings.length - 1;
    const parts = this.parts;
    const [html2, attrNames] = getTemplateHtml$2(strings, type);
    this.el = Template$2.createElement(html2, options);
    walker$2.currentNode = this.el.content;
    if (type === SVG_RESULT$2) {
      const content = this.el.content;
      const svgElement = content.firstChild;
      svgElement.remove();
      content.append(...svgElement.childNodes);
    }
    while ((node = walker$2.nextNode()) !== null && parts.length < partCount) {
      if (node.nodeType === 1) {
        {
          const tag2 = node.localName;
          if (/^(?:textarea|template)$/i.test(tag2) && node.innerHTML.includes(marker$2)) {
            const m2 = `Expressions are not supported inside \`${tag2}\` elements. See https://lit.dev/msg/expression-in-${tag2} for more information.`;
            if (tag2 === "template") {
              throw new Error(m2);
            } else
              issueWarning$2("", m2);
          }
        }
        if (node.hasAttributes()) {
          const attrsToRemove = [];
          for (const name2 of node.getAttributeNames()) {
            if (name2.endsWith(boundAttributeSuffix$2) || name2.startsWith(marker$2)) {
              const realName = attrNames[attrNameIndex++];
              attrsToRemove.push(name2);
              if (realName !== void 0) {
                const value = node.getAttribute(realName.toLowerCase() + boundAttributeSuffix$2);
                const statics = value.split(marker$2);
                const m2 = /([.?@])?(.*)/.exec(realName);
                parts.push({
                  type: ATTRIBUTE_PART$2,
                  index: nodeIndex,
                  name: m2[2],
                  strings: statics,
                  ctor: m2[1] === "." ? PropertyPart$2 : m2[1] === "?" ? BooleanAttributePart$2 : m2[1] === "@" ? EventPart$2 : AttributePart$2
                });
              } else {
                parts.push({
                  type: ELEMENT_PART$2,
                  index: nodeIndex
                });
              }
            }
          }
          for (const name2 of attrsToRemove) {
            node.removeAttribute(name2);
          }
        }
        if (rawTextElement$2.test(node.tagName)) {
          const strings2 = node.textContent.split(marker$2);
          const lastIndex = strings2.length - 1;
          if (lastIndex > 0) {
            node.textContent = trustedTypes$2 ? trustedTypes$2.emptyScript : "";
            for (let i2 = 0; i2 < lastIndex; i2++) {
              node.append(strings2[i2], createMarker$2());
              walker$2.nextNode();
              parts.push({ type: CHILD_PART$2, index: ++nodeIndex });
            }
            node.append(strings2[lastIndex], createMarker$2());
          }
        }
      } else if (node.nodeType === 8) {
        const data = node.data;
        if (data === markerMatch$2) {
          parts.push({ type: CHILD_PART$2, index: nodeIndex });
        } else {
          let i2 = -1;
          while ((i2 = node.data.indexOf(marker$2, i2 + 1)) !== -1) {
            parts.push({ type: COMMENT_PART$2, index: nodeIndex });
            i2 += marker$2.length - 1;
          }
        }
      }
      nodeIndex++;
    }
  }
  static createElement(html2, _options) {
    const el2 = d$5.createElement("template");
    el2.innerHTML = html2;
    return el2;
  }
}
function resolveDirective$2(part, value, parent = part, attributeIndex) {
  var _a2, _b2, _c2;
  var _d2;
  if (value === noChange$2) {
    return value;
  }
  let currentDirective = attributeIndex !== void 0 ? (_a2 = parent.__directives) === null || _a2 === void 0 ? void 0 : _a2[attributeIndex] : parent.__directive;
  const nextDirectiveConstructor = isPrimitive$2(value) ? void 0 : value["_$litDirective$"];
  if ((currentDirective === null || currentDirective === void 0 ? void 0 : currentDirective.constructor) !== nextDirectiveConstructor) {
    (_b2 = currentDirective === null || currentDirective === void 0 ? void 0 : currentDirective["_$notifyDirectiveConnectionChanged"]) === null || _b2 === void 0 ? void 0 : _b2.call(currentDirective, false);
    if (nextDirectiveConstructor === void 0) {
      currentDirective = void 0;
    } else {
      currentDirective = new nextDirectiveConstructor(part);
      currentDirective._$initialize(part, parent, attributeIndex);
    }
    if (attributeIndex !== void 0) {
      ((_c2 = (_d2 = parent).__directives) !== null && _c2 !== void 0 ? _c2 : _d2.__directives = [])[attributeIndex] = currentDirective;
    } else {
      parent.__directive = currentDirective;
    }
  }
  if (currentDirective !== void 0) {
    value = resolveDirective$2(part, currentDirective._$resolve(part, value.values), currentDirective, attributeIndex);
  }
  return value;
}
class TemplateInstance$2 {
  constructor(template2, parent) {
    this._parts = [];
    this._$disconnectableChildren = void 0;
    this._$template = template2;
    this._$parent = parent;
  }
  get parentNode() {
    return this._$parent.parentNode;
  }
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  _clone(options) {
    var _a2;
    const { el: { content }, parts } = this._$template;
    const fragment2 = ((_a2 = options === null || options === void 0 ? void 0 : options.creationScope) !== null && _a2 !== void 0 ? _a2 : d$5).importNode(content, true);
    walker$2.currentNode = fragment2;
    let node = walker$2.nextNode();
    let nodeIndex = 0;
    let partIndex = 0;
    let templatePart = parts[0];
    while (templatePart !== void 0) {
      if (nodeIndex === templatePart.index) {
        let part;
        if (templatePart.type === CHILD_PART$2) {
          part = new ChildPart$2(node, node.nextSibling, this, options);
        } else if (templatePart.type === ATTRIBUTE_PART$2) {
          part = new templatePart.ctor(node, templatePart.name, templatePart.strings, this, options);
        } else if (templatePart.type === ELEMENT_PART$2) {
          part = new ElementPart$2(node, this, options);
        }
        this._parts.push(part);
        templatePart = parts[++partIndex];
      }
      if (nodeIndex !== (templatePart === null || templatePart === void 0 ? void 0 : templatePart.index)) {
        node = walker$2.nextNode();
        nodeIndex++;
      }
    }
    return fragment2;
  }
  _update(values) {
    let i2 = 0;
    for (const part of this._parts) {
      if (part !== void 0) {
        if (part.strings !== void 0) {
          part._$setValue(values, part, i2);
          i2 += part.strings.length - 2;
        } else {
          part._$setValue(values[i2]);
        }
      }
      i2++;
    }
  }
}
class ChildPart$2 {
  constructor(startNode, endNode, parent, options) {
    var _a2;
    this.type = CHILD_PART$2;
    this._$committedValue = nothing$2;
    this._$disconnectableChildren = void 0;
    this._$startNode = startNode;
    this._$endNode = endNode;
    this._$parent = parent;
    this.options = options;
    this.__isConnected = (_a2 = options === null || options === void 0 ? void 0 : options.isConnected) !== null && _a2 !== void 0 ? _a2 : true;
    {
      this._textSanitizer = void 0;
    }
  }
  get _$isConnected() {
    var _a2, _b2;
    return (_b2 = (_a2 = this._$parent) === null || _a2 === void 0 ? void 0 : _a2._$isConnected) !== null && _b2 !== void 0 ? _b2 : this.__isConnected;
  }
  get parentNode() {
    let parentNode = wrap$3(this._$startNode).parentNode;
    const parent = this._$parent;
    if (parent !== void 0 && parentNode.nodeType === 11) {
      parentNode = parent.parentNode;
    }
    return parentNode;
  }
  get startNode() {
    return this._$startNode;
  }
  get endNode() {
    return this._$endNode;
  }
  _$setValue(value, directiveParent = this) {
    if (this.parentNode === null) {
      throw new Error(`This \`ChildPart\` has no \`parentNode\` and therefore cannot accept a value. This likely means the element containing the part was manipulated in an unsupported way outside of Lit's control such that the part's marker nodes were ejected from DOM. For example, setting the element's \`innerHTML\` or \`textContent\` can do this.`);
    }
    value = resolveDirective$2(this, value, directiveParent);
    if (isPrimitive$2(value)) {
      if (value === nothing$2 || value == null || value === "") {
        if (this._$committedValue !== nothing$2) {
          this._$clear();
        }
        this._$committedValue = nothing$2;
      } else if (value !== this._$committedValue && value !== noChange$2) {
        this._commitText(value);
      }
    } else if (value["_$litType$"] !== void 0) {
      this._commitTemplateResult(value);
    } else if (value.nodeType !== void 0) {
      this._commitNode(value);
    } else if (isIterable$2(value)) {
      this._commitIterable(value);
    } else {
      this._commitText(value);
    }
  }
  _insert(node, ref = this._$endNode) {
    return wrap$3(wrap$3(this._$startNode).parentNode).insertBefore(node, ref);
  }
  _commitNode(value) {
    var _a2;
    if (this._$committedValue !== value) {
      this._$clear();
      if (sanitizerFactoryInternal$2 !== noopSanitizer$2) {
        const parentNodeName = (_a2 = this._$startNode.parentNode) === null || _a2 === void 0 ? void 0 : _a2.nodeName;
        if (parentNodeName === "STYLE" || parentNodeName === "SCRIPT") {
          let message = "Forbidden";
          {
            if (parentNodeName === "STYLE") {
              message = `Lit does not support binding inside style nodes. This is a security risk, as style injection attacks can exfiltrate data and spoof UIs. Consider instead using css\`...\` literals to compose styles, and make do dynamic styling with css custom properties, ::parts, <slot>s, and by mutating the DOM rather than stylesheets.`;
            } else {
              message = `Lit does not support binding inside script nodes. This is a security risk, as it could allow arbitrary code execution.`;
            }
          }
          throw new Error(message);
        }
      }
      this._$committedValue = this._insert(value);
    }
  }
  _commitText(value) {
    if (this._$committedValue !== nothing$2 && isPrimitive$2(this._$committedValue)) {
      const node = wrap$3(this._$startNode).nextSibling;
      {
        if (this._textSanitizer === void 0) {
          this._textSanitizer = createSanitizer$2(node, "data", "property");
        }
        value = this._textSanitizer(value);
      }
      node.data = value;
    } else {
      {
        const textNode = document.createTextNode("");
        this._commitNode(textNode);
        if (this._textSanitizer === void 0) {
          this._textSanitizer = createSanitizer$2(textNode, "data", "property");
        }
        value = this._textSanitizer(value);
        textNode.data = value;
      }
    }
    this._$committedValue = value;
  }
  _commitTemplateResult(result) {
    var _a2;
    const { values, ["_$litType$"]: type } = result;
    const template2 = typeof type === "number" ? this._$getTemplate(result) : (type.el === void 0 && (type.el = Template$2.createElement(type.h, this.options)), type);
    if (((_a2 = this._$committedValue) === null || _a2 === void 0 ? void 0 : _a2._$template) === template2) {
      this._$committedValue._update(values);
    } else {
      const instance = new TemplateInstance$2(template2, this);
      const fragment2 = instance._clone(this.options);
      instance._update(values);
      this._commitNode(fragment2);
      this._$committedValue = instance;
    }
  }
  _$getTemplate(result) {
    let template2 = templateCache$2.get(result.strings);
    if (template2 === void 0) {
      templateCache$2.set(result.strings, template2 = new Template$2(result));
    }
    return template2;
  }
  _commitIterable(value) {
    if (!isArray$4(this._$committedValue)) {
      this._$committedValue = [];
      this._$clear();
    }
    const itemParts = this._$committedValue;
    let partIndex = 0;
    let itemPart;
    for (const item of value) {
      if (partIndex === itemParts.length) {
        itemParts.push(itemPart = new ChildPart$2(this._insert(createMarker$2()), this._insert(createMarker$2()), this, this.options));
      } else {
        itemPart = itemParts[partIndex];
      }
      itemPart._$setValue(item);
      partIndex++;
    }
    if (partIndex < itemParts.length) {
      this._$clear(itemPart && wrap$3(itemPart._$endNode).nextSibling, partIndex);
      itemParts.length = partIndex;
    }
  }
  _$clear(start = wrap$3(this._$startNode).nextSibling, from2) {
    var _a2;
    (_a2 = this._$notifyConnectionChanged) === null || _a2 === void 0 ? void 0 : _a2.call(this, false, true, from2);
    while (start && start !== this._$endNode) {
      const n2 = wrap$3(start).nextSibling;
      wrap$3(start).remove();
      start = n2;
    }
  }
  setConnected(isConnected) {
    var _a2;
    if (this._$parent === void 0) {
      this.__isConnected = isConnected;
      (_a2 = this._$notifyConnectionChanged) === null || _a2 === void 0 ? void 0 : _a2.call(this, isConnected);
    } else {
      throw new Error("part.setConnected() may only be called on a RootPart returned from render().");
    }
  }
}
class AttributePart$2 {
  constructor(element, name2, strings, parent, options) {
    this.type = ATTRIBUTE_PART$2;
    this._$committedValue = nothing$2;
    this._$disconnectableChildren = void 0;
    this.element = element;
    this.name = name2;
    this._$parent = parent;
    this.options = options;
    if (strings.length > 2 || strings[0] !== "" || strings[1] !== "") {
      this._$committedValue = new Array(strings.length - 1).fill(new String());
      this.strings = strings;
    } else {
      this._$committedValue = nothing$2;
    }
    {
      this._sanitizer = void 0;
    }
  }
  get tagName() {
    return this.element.tagName;
  }
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  _$setValue(value, directiveParent = this, valueIndex, noCommit) {
    const strings = this.strings;
    let change = false;
    if (strings === void 0) {
      value = resolveDirective$2(this, value, directiveParent, 0);
      change = !isPrimitive$2(value) || value !== this._$committedValue && value !== noChange$2;
      if (change) {
        this._$committedValue = value;
      }
    } else {
      const values = value;
      value = strings[0];
      let i2, v2;
      for (i2 = 0; i2 < strings.length - 1; i2++) {
        v2 = resolveDirective$2(this, values[valueIndex + i2], directiveParent, i2);
        if (v2 === noChange$2) {
          v2 = this._$committedValue[i2];
        }
        change || (change = !isPrimitive$2(v2) || v2 !== this._$committedValue[i2]);
        if (v2 === nothing$2) {
          value = nothing$2;
        } else if (value !== nothing$2) {
          value += (v2 !== null && v2 !== void 0 ? v2 : "") + strings[i2 + 1];
        }
        this._$committedValue[i2] = v2;
      }
    }
    if (change && !noCommit) {
      this._commitValue(value);
    }
  }
  _commitValue(value) {
    if (value === nothing$2) {
      wrap$3(this.element).removeAttribute(this.name);
    } else {
      {
        if (this._sanitizer === void 0) {
          this._sanitizer = sanitizerFactoryInternal$2(this.element, this.name, "attribute");
        }
        value = this._sanitizer(value !== null && value !== void 0 ? value : "");
      }
      wrap$3(this.element).setAttribute(this.name, value !== null && value !== void 0 ? value : "");
    }
  }
}
class PropertyPart$2 extends AttributePart$2 {
  constructor() {
    super(...arguments);
    this.type = PROPERTY_PART$2;
  }
  _commitValue(value) {
    {
      if (this._sanitizer === void 0) {
        this._sanitizer = sanitizerFactoryInternal$2(this.element, this.name, "property");
      }
      value = this._sanitizer(value);
    }
    this.element[this.name] = value === nothing$2 ? void 0 : value;
  }
}
class BooleanAttributePart$2 extends AttributePart$2 {
  constructor() {
    super(...arguments);
    this.type = BOOLEAN_ATTRIBUTE_PART$2;
  }
  _commitValue(value) {
    if (value && value !== nothing$2) {
      wrap$3(this.element).setAttribute(this.name, "");
    } else {
      wrap$3(this.element).removeAttribute(this.name);
    }
  }
}
class EventPart$2 extends AttributePart$2 {
  constructor(element, name2, strings, parent, options) {
    super(element, name2, strings, parent, options);
    this.type = EVENT_PART$2;
    if (this.strings !== void 0) {
      throw new Error(`A \`<${element.localName}>\` has a \`@${name2}=...\` listener with invalid content. Event listeners in templates must have exactly one expression and no surrounding text.`);
    }
  }
  _$setValue(newListener, directiveParent = this) {
    var _a2;
    newListener = (_a2 = resolveDirective$2(this, newListener, directiveParent, 0)) !== null && _a2 !== void 0 ? _a2 : nothing$2;
    if (newListener === noChange$2) {
      return;
    }
    const oldListener = this._$committedValue;
    const shouldRemoveListener = newListener === nothing$2 && oldListener !== nothing$2 || newListener.capture !== oldListener.capture || newListener.once !== oldListener.once || newListener.passive !== oldListener.passive;
    const shouldAddListener = newListener !== nothing$2 && (oldListener === nothing$2 || shouldRemoveListener);
    if (shouldRemoveListener) {
      this.element.removeEventListener(this.name, this, oldListener);
    }
    if (shouldAddListener) {
      this.element.addEventListener(this.name, this, newListener);
    }
    this._$committedValue = newListener;
  }
  handleEvent(event) {
    var _a2, _b2;
    if (typeof this._$committedValue === "function") {
      this._$committedValue.call((_b2 = (_a2 = this.options) === null || _a2 === void 0 ? void 0 : _a2.host) !== null && _b2 !== void 0 ? _b2 : this.element, event);
    } else {
      this._$committedValue.handleEvent(event);
    }
  }
}
class ElementPart$2 {
  constructor(element, parent, options) {
    this.element = element;
    this.type = ELEMENT_PART$2;
    this._$disconnectableChildren = void 0;
    this._$parent = parent;
    this.options = options;
  }
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  _$setValue(value) {
    resolveDirective$2(this, value);
  }
}
const polyfillSupport$2 = window.litHtmlPolyfillSupportDevMode;
polyfillSupport$2 === null || polyfillSupport$2 === void 0 ? void 0 : polyfillSupport$2(Template$2, ChildPart$2);
((_d$3 = globalThis.litHtmlVersions) !== null && _d$3 !== void 0 ? _d$3 : globalThis.litHtmlVersions = []).push("2.0.1");
if (globalThis.litHtmlVersions.length > 1) {
  issueWarning$2("multiple-versions", `Multiple versions of Lit loaded. Loading multiple versions is not recommended.`);
}
/**
* @license
* Copyright 2017 Google LLC
* SPDX-License-Identifier: BSD-3-Clause
*/
var _a$4, _b$4, _c$4;
let issueWarning$1;
{
  const issuedWarnings = (_a$4 = globalThis.litIssuedWarnings) !== null && _a$4 !== void 0 ? _a$4 : globalThis.litIssuedWarnings = new Set();
  issueWarning$1 = (code4, warning) => {
    warning += ` See https://lit.dev/msg/${code4} for more information.`;
    if (!issuedWarnings.has(warning)) {
      console.warn(warning);
      issuedWarnings.add(warning);
    }
  };
}
class LitElement extends ReactiveElement {
  constructor() {
    super(...arguments);
    this.renderOptions = { host: this };
    this.__childPart = void 0;
  }
  createRenderRoot() {
    var _a2;
    var _b2;
    const renderRoot = super.createRenderRoot();
    (_a2 = (_b2 = this.renderOptions).renderBefore) !== null && _a2 !== void 0 ? _a2 : _b2.renderBefore = renderRoot.firstChild;
    return renderRoot;
  }
  update(changedProperties) {
    const value = this.render();
    if (!this.hasUpdated) {
      this.renderOptions.isConnected = this.isConnected;
    }
    super.update(changedProperties);
    this.__childPart = render(value, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var _a2;
    super.connectedCallback();
    (_a2 = this.__childPart) === null || _a2 === void 0 ? void 0 : _a2.setConnected(true);
  }
  disconnectedCallback() {
    var _a2;
    super.disconnectedCallback();
    (_a2 = this.__childPart) === null || _a2 === void 0 ? void 0 : _a2.setConnected(false);
  }
  render() {
    return noChange$2;
  }
}
LitElement["finalized"] = true;
LitElement["_$litElement$"] = true;
(_b$4 = globalThis.litElementHydrateSupport) === null || _b$4 === void 0 ? void 0 : _b$4.call(globalThis, { LitElement });
const polyfillSupport$1 = globalThis.litElementPolyfillSupportDevMode;
polyfillSupport$1 === null || polyfillSupport$1 === void 0 ? void 0 : polyfillSupport$1({ LitElement });
{
  LitElement["finalize"] = function() {
    const finalized2 = ReactiveElement.finalize.call(this);
    if (!finalized2) {
      return false;
    }
    const warnRemovedOrRenamed = (obj2, name2, renamed = false) => {
      if (obj2.hasOwnProperty(name2)) {
        const ctorName = (typeof obj2 === "function" ? obj2 : obj2.constructor).name;
        issueWarning$1(renamed ? "renamed-api" : "removed-api", `\`${name2}\` is implemented on class ${ctorName}. It has been ${renamed ? "renamed" : "removed"} in this version of LitElement.`);
      }
    };
    warnRemovedOrRenamed(this, "render");
    warnRemovedOrRenamed(this, "getStyles", true);
    warnRemovedOrRenamed(this.prototype, "adoptStyles");
    return true;
  };
}
((_c$4 = globalThis.litElementVersions) !== null && _c$4 !== void 0 ? _c$4 : globalThis.litElementVersions = []).push("3.0.1");
if (globalThis.litElementVersions.length > 1) {
  issueWarning$1("multiple-versions", `Multiple versions of Lit loaded. Loading multiple versions is not recommended.`);
}
var __awaiter$c = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e20) {
        reject(e20);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e20) {
        reject(e20);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SLitComponent extends LitElement {
  constructor(settings = {}) {
    var _a2, _b2, _c2, _d2, _e2, _f3, _g2;
    super();
    this._settings = {};
    this._shouldUpdate = false;
    this._settings = __deepMerge$7({
      componentUtils: {},
      litComponent: {
        shadowDom: true,
        get rootNode() {
          var _a3;
          return (_a3 = this.shadowRoot) === null || _a3 === void 0 ? void 0 : _a3.querySelector("*:first-child");
        }
      }
    }, settings);
    this.componentUtils = new SComponent(this, this.attributes, {
      componentUtils: Object.assign(Object.assign({}, (_a2 = this._settings.componentUtils) !== null && _a2 !== void 0 ? _a2 : {}), { style: (_e2 = (_c2 = (_b2 = this.constructor.styles) === null || _b2 === void 0 ? void 0 : _b2.cssText) !== null && _c2 !== void 0 ? _c2 : (_d2 = this._settings.componentUtils) === null || _d2 === void 0 ? void 0 : _d2.style) !== null && _e2 !== void 0 ? _e2 : "" })
    });
    this.props = this.componentUtils.props;
    if (this.litComponentSettings.shadowDom === false) {
      this.createRenderRoot = () => {
        return this;
      };
    }
    Object.keys(this.componentUtils.props).forEach((prop) => {
      this[prop] = this.componentUtils.props[prop];
    });
    const nodeFirstUpdated = (_f3 = this.firstUpdated) === null || _f3 === void 0 ? void 0 : _f3.bind(this);
    this.firstUpdated = () => __awaiter$c(this, void 0, void 0, function* () {
      if (nodeFirstUpdated) {
        yield nodeFirstUpdated();
      }
      this.mounted = true;
    });
    const nodeShouldUpdate = (_g2 = this.shouldUpdate) === null || _g2 === void 0 ? void 0 : _g2.bind(this);
    this.shouldUpdate = () => {
      if (nodeShouldUpdate) {
        const res = nodeShouldUpdate();
        if (!res)
          return false;
      }
      return this._shouldUpdate;
    };
    (() => __awaiter$c(this, void 0, void 0, function* () {
      yield this.componentUtils.waitOnMountState();
      console.log("MOUNT", this);
      yield this.mount();
    }))();
  }
  static setDefaultProps(selector, props) {
    SComponent.setDefaultProps(selector, props);
  }
  get litComponentSettings() {
    return this._settings.litComponent;
  }
  static properties(properties, int) {
    const propertiesObj = {};
    const InterfaceToApply = SComponent.getFinalInterface(int);
    Object.keys(InterfaceToApply.definition).forEach((prop) => {
      var _a2, _b2, _c2, _d2, _e2, _f3;
      const definition = InterfaceToApply.definition[prop];
      propertiesObj[prop] = Object.assign({}, (_a2 = definition.lit) !== null && _a2 !== void 0 ? _a2 : {});
      if (definition.physical || ((_c2 = (_b2 = definition.type) === null || _b2 === void 0 ? void 0 : _b2.toLowerCase) === null || _c2 === void 0 ? void 0 : _c2.call(_b2)) === "boolean" || ((_f3 = (_e2 = (_d2 = definition.type) === null || _d2 === void 0 ? void 0 : _d2.type) === null || _e2 === void 0 ? void 0 : _e2.toLowerCase) === null || _f3 === void 0 ? void 0 : _f3.call(_e2)) === "boolean") {
        propertiesObj[prop].reflect = true;
        propertiesObj[prop].attribute = dashCase(prop);
        propertiesObj[prop].converter = {
          toAttribute(value) {
            if (value === false || value === null)
              return null;
            return String(value);
          }
        };
      }
    });
    const props = Object.assign(Object.assign({}, propertiesObj), properties !== null && properties !== void 0 ? properties : {});
    return props;
  }
  mount() {
    var _a2, _b2;
    return __awaiter$c(this, void 0, void 0, function* () {
      this._shouldUpdate = true;
      this.requestUpdate();
      this.componentUtils.injectStyle((_b2 = (_a2 = this.constructor.styles) === null || _a2 === void 0 ? void 0 : _a2.cssText) !== null && _b2 !== void 0 ? _b2 : "", this.tagName);
      yield wait$1();
      if (this.componentUtils.props.adoptStyle && this.shadowRoot) {
        yield this.componentUtils.adoptStyleInShadowRoot(this.shadowRoot);
      }
      return true;
    });
  }
}
/**
* @license
* Copyright 2017 Google LLC
* SPDX-License-Identifier: BSD-3-Clause
*/
const standardProperty$3 = (options, element) => {
  if (element.kind === "method" && element.descriptor && !("value" in element.descriptor)) {
    return __spreadProps(__spreadValues({}, element), {
      finisher(clazz) {
        clazz.createProperty(element.key, options);
      }
    });
  } else {
    return {
      kind: "field",
      key: Symbol(),
      placement: "own",
      descriptor: {},
      originalKey: element.key,
      initializer() {
        if (typeof element.initializer === "function") {
          this[element.key] = element.initializer.call(this);
        }
      },
      finisher(clazz) {
        clazz.createProperty(element.key, options);
      }
    };
  }
};
const legacyProperty$3 = (options, proto2, name2) => {
  proto2.constructor.createProperty(name2, options);
};
function property$3(options) {
  return (protoOrDescriptor, name2) => name2 !== void 0 ? legacyProperty$3(options, protoOrDescriptor, name2) : standardProperty$3(options, protoOrDescriptor);
}
var axios$2 = { exports: {} };
var bind$2 = function bind2(fn2, thisArg) {
  return function wrap2() {
    var args = new Array(arguments.length);
    for (var i2 = 0; i2 < args.length; i2++) {
      args[i2] = arguments[i2];
    }
    return fn2.apply(thisArg, args);
  };
};
var bind$1 = bind$2;
var toString$3 = Object.prototype.toString;
function isArray$3(val) {
  return toString$3.call(val) === "[object Array]";
}
function isUndefined$1(val) {
  return typeof val === "undefined";
}
function isBuffer(val) {
  return val !== null && !isUndefined$1(val) && val.constructor !== null && !isUndefined$1(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
}
function isArrayBuffer(val) {
  return toString$3.call(val) === "[object ArrayBuffer]";
}
function isFormData(val) {
  return typeof FormData !== "undefined" && val instanceof FormData;
}
function isArrayBufferView(val) {
  var result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }
  return result;
}
function isString$1(val) {
  return typeof val === "string";
}
function isNumber$1(val) {
  return typeof val === "number";
}
function isObject$1(val) {
  return val !== null && typeof val === "object";
}
function isPlainObject(val) {
  if (toString$3.call(val) !== "[object Object]") {
    return false;
  }
  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}
function isDate$1(val) {
  return toString$3.call(val) === "[object Date]";
}
function isFile(val) {
  return toString$3.call(val) === "[object File]";
}
function isBlob(val) {
  return toString$3.call(val) === "[object Blob]";
}
function isFunction$1(val) {
  return toString$3.call(val) === "[object Function]";
}
function isStream(val) {
  return isObject$1(val) && isFunction$1(val.pipe);
}
function isURLSearchParams(val) {
  return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
}
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
}
function isStandardBrowserEnv() {
  if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function forEach(obj2, fn2) {
  if (obj2 === null || typeof obj2 === "undefined") {
    return;
  }
  if (typeof obj2 !== "object") {
    obj2 = [obj2];
  }
  if (isArray$3(obj2)) {
    for (var i2 = 0, l2 = obj2.length; i2 < l2; i2++) {
      fn2.call(null, obj2[i2], i2, obj2);
    }
  } else {
    for (var key in obj2) {
      if (Object.prototype.hasOwnProperty.call(obj2, key)) {
        fn2.call(null, obj2[key], key, obj2);
      }
    }
  }
}
function merge() {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray$3(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }
  for (var i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
    forEach(arguments[i2], assignValue);
  }
  return result;
}
function extend$1(a2, b2, thisArg) {
  forEach(b2, function assignValue(val, key) {
    if (thisArg && typeof val === "function") {
      a2[key] = bind$1(val, thisArg);
    } else {
      a2[key] = val;
    }
  });
  return a2;
}
function stripBOM(content) {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
}
var utils$d = {
  isArray: isArray$3,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString: isString$1,
  isNumber: isNumber$1,
  isObject: isObject$1,
  isPlainObject,
  isUndefined: isUndefined$1,
  isDate: isDate$1,
  isFile,
  isBlob,
  isFunction: isFunction$1,
  isStream,
  isURLSearchParams,
  isStandardBrowserEnv,
  forEach,
  merge,
  extend: extend$1,
  trim,
  stripBOM
};
var utils$c = utils$d;
function encode$1(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL$2 = function buildURL2(url, params, paramsSerializer) {
  if (!params) {
    return url;
  }
  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils$c.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils$c.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === "undefined") {
        return;
      }
      if (utils$c.isArray(val)) {
        key = key + "[]";
      } else {
        val = [val];
      }
      utils$c.forEach(val, function parseValue(v2) {
        if (utils$c.isDate(v2)) {
          v2 = v2.toISOString();
        } else if (utils$c.isObject(v2)) {
          v2 = JSON.stringify(v2);
        }
        parts.push(encode$1(key) + "=" + encode$1(v2));
      });
    });
    serializedParams = parts.join("&");
  }
  if (serializedParams) {
    var hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
};
var utils$b = utils$d;
function InterceptorManager$1() {
  this.handlers = [];
}
InterceptorManager$1.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled,
    rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};
InterceptorManager$1.prototype.eject = function eject(id2) {
  if (this.handlers[id2]) {
    this.handlers[id2] = null;
  }
};
InterceptorManager$1.prototype.forEach = function forEach2(fn2) {
  utils$b.forEach(this.handlers, function forEachHandler(h2) {
    if (h2 !== null) {
      fn2(h2);
    }
  });
};
var InterceptorManager_1 = InterceptorManager$1;
var utils$a = utils$d;
var normalizeHeaderName$1 = function normalizeHeaderName2(headers, normalizedName) {
  utils$a.forEach(headers, function processHeader(value, name2) {
    if (name2 !== normalizedName && name2.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name2];
    }
  });
};
var enhanceError$2 = function enhanceError2(error2, config, code4, request2, response) {
  error2.config = config;
  if (code4) {
    error2.code = code4;
  }
  error2.request = request2;
  error2.response = response;
  error2.isAxiosError = true;
  error2.toJSON = function toJSON2() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: this.config,
      code: this.code
    };
  };
  return error2;
};
var enhanceError$1 = enhanceError$2;
var createError$2 = function createError2(message, config, code4, request2, response) {
  var error2 = new Error(message);
  return enhanceError$1(error2, config, code4, request2, response);
};
var createError$1 = createError$2;
var settle$1 = function settle2(resolve2, reject, response) {
  var validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve2(response);
  } else {
    reject(createError$1("Request failed with status code " + response.status, response.config, null, response.request, response));
  }
};
var utils$9 = utils$d;
var cookies$1 = utils$9.isStandardBrowserEnv() ? function standardBrowserEnv() {
  return {
    write: function write(name2, value, expires, path2, domain, secure) {
      var cookie = [];
      cookie.push(name2 + "=" + encodeURIComponent(value));
      if (utils$9.isNumber(expires)) {
        cookie.push("expires=" + new Date(expires).toGMTString());
      }
      if (utils$9.isString(path2)) {
        cookie.push("path=" + path2);
      }
      if (utils$9.isString(domain)) {
        cookie.push("domain=" + domain);
      }
      if (secure === true) {
        cookie.push("secure");
      }
      document.cookie = cookie.join("; ");
    },
    read: function read(name2) {
      var match5 = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
      return match5 ? decodeURIComponent(match5[3]) : null;
    },
    remove: function remove(name2) {
      this.write(name2, "", Date.now() - 864e5);
    }
  };
}() : function nonStandardBrowserEnv() {
  return {
    write: function write() {
    },
    read: function read() {
      return null;
    },
    remove: function remove() {
    }
  };
}();
var isAbsoluteURL$1 = function isAbsoluteURL2(url) {
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};
var combineURLs$1 = function combineURLs2(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
};
var isAbsoluteURL = isAbsoluteURL$1;
var combineURLs = combineURLs$1;
var buildFullPath$1 = function buildFullPath2(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};
var utils$8 = utils$d;
var ignoreDuplicateOf = [
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
];
var parseHeaders$1 = function parseHeaders2(headers) {
  var parsed = {};
  var key;
  var val;
  var i2;
  if (!headers) {
    return parsed;
  }
  utils$8.forEach(headers.split("\n"), function parser(line) {
    i2 = line.indexOf(":");
    key = utils$8.trim(line.substr(0, i2)).toLowerCase();
    val = utils$8.trim(line.substr(i2 + 1));
    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === "set-cookie") {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
      }
    }
  });
  return parsed;
};
var utils$7 = utils$d;
var isURLSameOrigin$1 = utils$7.isStandardBrowserEnv() ? function standardBrowserEnv2() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement("a");
  var originURL;
  function resolveURL(url) {
    var href = url;
    if (msie) {
      urlParsingNode.setAttribute("href", href);
      href = urlParsingNode.href;
    }
    urlParsingNode.setAttribute("href", href);
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
    };
  }
  originURL = resolveURL(window.location.href);
  return function isURLSameOrigin2(requestURL) {
    var parsed = utils$7.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() : function nonStandardBrowserEnv2() {
  return function isURLSameOrigin2() {
    return true;
  };
}();
var utils$6 = utils$d;
var settle = settle$1;
var cookies = cookies$1;
var buildURL$1 = buildURL$2;
var buildFullPath = buildFullPath$1;
var parseHeaders = parseHeaders$1;
var isURLSameOrigin = isURLSameOrigin$1;
var createError = createError$2;
var xhr = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve2, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;
    if (utils$6.isFormData(requestData)) {
      delete requestHeaders["Content-Type"];
    }
    var request2 = new XMLHttpRequest();
    if (config.auth) {
      var username = config.auth.username || "";
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
      requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
    }
    var fullPath = buildFullPath(config.baseURL, config.url);
    request2.open(config.method.toUpperCase(), buildURL$1(fullPath, config.params, config.paramsSerializer), true);
    request2.timeout = config.timeout;
    function onloadend() {
      if (!request2) {
        return;
      }
      var responseHeaders = "getAllResponseHeaders" in request2 ? parseHeaders(request2.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
      var response = {
        data: responseData,
        status: request2.status,
        statusText: request2.statusText,
        headers: responseHeaders,
        config,
        request: request2
      };
      settle(resolve2, reject, response);
      request2 = null;
    }
    if ("onloadend" in request2) {
      request2.onloadend = onloadend;
    } else {
      request2.onreadystatechange = function handleLoad() {
        if (!request2 || request2.readyState !== 4) {
          return;
        }
        if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request2.onabort = function handleAbort() {
      if (!request2) {
        return;
      }
      reject(createError("Request aborted", config, "ECONNABORTED", request2));
      request2 = null;
    };
    request2.onerror = function handleError() {
      reject(createError("Network Error", config, null, request2));
      request2 = null;
    };
    request2.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = "timeout of " + config.timeout + "ms exceeded";
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(timeoutErrorMessage, config, config.transitional && config.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", request2));
      request2 = null;
    };
    if (utils$6.isStandardBrowserEnv()) {
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }
    if ("setRequestHeader" in request2) {
      utils$6.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
          delete requestHeaders[key];
        } else {
          request2.setRequestHeader(key, val);
        }
      });
    }
    if (!utils$6.isUndefined(config.withCredentials)) {
      request2.withCredentials = !!config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request2.responseType = config.responseType;
    }
    if (typeof config.onDownloadProgress === "function") {
      request2.addEventListener("progress", config.onDownloadProgress);
    }
    if (typeof config.onUploadProgress === "function" && request2.upload) {
      request2.upload.addEventListener("progress", config.onUploadProgress);
    }
    if (config.cancelToken) {
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request2) {
          return;
        }
        request2.abort();
        reject(cancel);
        request2 = null;
      });
    }
    if (!requestData) {
      requestData = null;
    }
    request2.send(requestData);
  });
};
var utils$5 = utils$d;
var normalizeHeaderName = normalizeHeaderName$1;
var enhanceError = enhanceError$2;
var DEFAULT_CONTENT_TYPE = {
  "Content-Type": "application/x-www-form-urlencoded"
};
function setContentTypeIfUnset(headers, value) {
  if (!utils$5.isUndefined(headers) && utils$5.isUndefined(headers["Content-Type"])) {
    headers["Content-Type"] = value;
  }
}
function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== "undefined") {
    adapter = xhr;
  } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
    adapter = xhr;
  }
  return adapter;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils$5.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$5.trim(rawValue);
    } catch (e20) {
      if (e20.name !== "SyntaxError") {
        throw e20;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults$4 = {
  transitional: {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  },
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, "Accept");
    normalizeHeaderName(headers, "Content-Type");
    if (utils$5.isFormData(data) || utils$5.isArrayBuffer(data) || utils$5.isBuffer(data) || utils$5.isStream(data) || utils$5.isFile(data) || utils$5.isBlob(data)) {
      return data;
    }
    if (utils$5.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$5.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
      return data.toString();
    }
    if (utils$5.isObject(data) || headers && headers["Content-Type"] === "application/json") {
      setContentTypeIfUnset(headers, "application/json");
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    var transitional2 = this.transitional;
    var silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
    var forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
    if (strictJSONParsing || forcedJSONParsing && utils$5.isString(data) && data.length) {
      try {
        return JSON.parse(data);
      } catch (e20) {
        if (strictJSONParsing) {
          if (e20.name === "SyntaxError") {
            throw enhanceError(e20, this, "E_JSON_PARSE");
          }
          throw e20;
        }
      }
    }
    return data;
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};
defaults$4.headers = {
  common: {
    "Accept": "application/json, text/plain, */*"
  }
};
utils$5.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
  defaults$4.headers[method] = {};
});
utils$5.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  defaults$4.headers[method] = utils$5.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_1 = defaults$4;
var utils$4 = utils$d;
var defaults$3 = defaults_1;
var transformData$1 = function transformData2(data, headers, fns) {
  var context = this || defaults$3;
  utils$4.forEach(fns, function transform(fn2) {
    data = fn2.call(context, data, headers);
  });
  return data;
};
var isCancel$1 = function isCancel2(value) {
  return !!(value && value.__CANCEL__);
};
var utils$3 = utils$d;
var transformData = transformData$1;
var isCancel = isCancel$1;
var defaults$2 = defaults_1;
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}
var dispatchRequest$1 = function dispatchRequest2(config) {
  throwIfCancellationRequested(config);
  config.headers = config.headers || {};
  config.data = transformData.call(config, config.data, config.headers, config.transformRequest);
  config.headers = utils$3.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
  utils$3.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
    delete config.headers[method];
  });
  var adapter = config.adapter || defaults$2.adapter;
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(config, response.data, response.headers, config.transformResponse);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(config, reason.response.data, reason.response.headers, config.transformResponse);
      }
    }
    return Promise.reject(reason);
  });
};
var utils$2 = utils$d;
var mergeConfig$2 = function mergeConfig2(config1, config2) {
  config2 = config2 || {};
  var config = {};
  var valueFromConfig2Keys = ["url", "method", "data"];
  var mergeDeepPropertiesKeys = ["headers", "auth", "proxy", "params"];
  var defaultToConfig2Keys = [
    "baseURL",
    "transformRequest",
    "transformResponse",
    "paramsSerializer",
    "timeout",
    "timeoutMessage",
    "withCredentials",
    "adapter",
    "responseType",
    "xsrfCookieName",
    "xsrfHeaderName",
    "onUploadProgress",
    "onDownloadProgress",
    "decompress",
    "maxContentLength",
    "maxBodyLength",
    "maxRedirects",
    "transport",
    "httpAgent",
    "httpsAgent",
    "cancelToken",
    "socketPath",
    "responseEncoding"
  ];
  var directMergeKeys = ["validateStatus"];
  function getMergedValue(target, source3) {
    if (utils$2.isPlainObject(target) && utils$2.isPlainObject(source3)) {
      return utils$2.merge(target, source3);
    } else if (utils$2.isPlainObject(source3)) {
      return utils$2.merge({}, source3);
    } else if (utils$2.isArray(source3)) {
      return source3.slice();
    }
    return source3;
  }
  function mergeDeepProperties(prop) {
    if (!utils$2.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils$2.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(void 0, config1[prop]);
    }
  }
  utils$2.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils$2.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(void 0, config2[prop]);
    }
  });
  utils$2.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
  utils$2.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils$2.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(void 0, config2[prop]);
    } else if (!utils$2.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(void 0, config1[prop]);
    }
  });
  utils$2.forEach(directMergeKeys, function merge2(prop) {
    if (prop in config2) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config[prop] = getMergedValue(void 0, config1[prop]);
    }
  });
  var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
  var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
    return axiosKeys.indexOf(key) === -1;
  });
  utils$2.forEach(otherKeys, mergeDeepProperties);
  return config;
};
const name = "axios";
const version$1 = "0.21.4";
const description = "Promise based HTTP client for the browser and node.js";
const main = "index.js";
const scripts = {
  test: "grunt test",
  start: "node ./sandbox/server.js",
  build: "NODE_ENV=production grunt build",
  preversion: "npm test",
  version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
  postversion: "git push && git push --tags",
  examples: "node ./examples/server.js",
  coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
  fix: "eslint --fix lib/**/*.js"
};
const repository = {
  type: "git",
  url: "https://github.com/axios/axios.git"
};
const keywords = [
  "xhr",
  "http",
  "ajax",
  "promise",
  "node"
];
const author = "Matt Zabriskie";
const license = "MIT";
const bugs = {
  url: "https://github.com/axios/axios/issues"
};
const homepage = "https://axios-http.com";
const devDependencies = {
  coveralls: "^3.0.0",
  "es6-promise": "^4.2.4",
  grunt: "^1.3.0",
  "grunt-banner": "^0.6.0",
  "grunt-cli": "^1.2.0",
  "grunt-contrib-clean": "^1.1.0",
  "grunt-contrib-watch": "^1.0.0",
  "grunt-eslint": "^23.0.0",
  "grunt-karma": "^4.0.0",
  "grunt-mocha-test": "^0.13.3",
  "grunt-ts": "^6.0.0-beta.19",
  "grunt-webpack": "^4.0.2",
  "istanbul-instrumenter-loader": "^1.0.0",
  "jasmine-core": "^2.4.1",
  karma: "^6.3.2",
  "karma-chrome-launcher": "^3.1.0",
  "karma-firefox-launcher": "^2.1.0",
  "karma-jasmine": "^1.1.1",
  "karma-jasmine-ajax": "^0.1.13",
  "karma-safari-launcher": "^1.0.0",
  "karma-sauce-launcher": "^4.3.6",
  "karma-sinon": "^1.0.5",
  "karma-sourcemap-loader": "^0.3.8",
  "karma-webpack": "^4.0.2",
  "load-grunt-tasks": "^3.5.2",
  minimist: "^1.2.0",
  mocha: "^8.2.1",
  sinon: "^4.5.0",
  "terser-webpack-plugin": "^4.2.3",
  typescript: "^4.0.5",
  "url-search-params": "^0.10.0",
  webpack: "^4.44.2",
  "webpack-dev-server": "^3.11.0"
};
const browser = {
  "./lib/adapters/http.js": "./lib/adapters/xhr.js"
};
const jsdelivr = "dist/axios.min.js";
const unpkg = "dist/axios.min.js";
const typings = "./index.d.ts";
const dependencies = {
  "follow-redirects": "^1.14.0"
};
const bundlesize = [
  {
    path: "./dist/axios.min.js",
    threshold: "5kB"
  }
];
var require$$0 = {
  name,
  version: version$1,
  description,
  main,
  scripts,
  repository,
  keywords,
  author,
  license,
  bugs,
  homepage,
  devDependencies,
  browser,
  jsdelivr,
  unpkg,
  typings,
  dependencies,
  bundlesize
};
var pkg = require$$0;
var validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i2) {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
var currentVerArr = pkg.version.split(".");
function isOlderVersion(version2, thanVersion) {
  var pkgVersionArr = thanVersion ? thanVersion.split(".") : currentVerArr;
  var destVer = version2.split(".");
  for (var i2 = 0; i2 < 3; i2++) {
    if (pkgVersionArr[i2] > destVer[i2]) {
      return true;
    } else if (pkgVersionArr[i2] < destVer[i2]) {
      return false;
    }
  }
  return false;
}
validators$1.transitional = function transitional(validator2, version2, message) {
  var isDeprecated = version2 && isOlderVersion(version2);
  function formatMessage(opt, desc) {
    return "[Axios v" + pkg.version + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return function(value, opt, opts) {
    if (validator2 === false) {
      throw new Error(formatMessage(opt, " has been removed in " + version2));
    }
    if (isDeprecated && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(formatMessage(opt, " has been deprecated since v" + version2 + " and will be removed in the near future"));
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new TypeError("options must be an object");
  }
  var keys2 = Object.keys(options);
  var i2 = keys2.length;
  while (i2-- > 0) {
    var opt = keys2[i2];
    var validator2 = schema[opt];
    if (validator2) {
      var value = options[opt];
      var result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new TypeError("option " + opt + " must be " + result);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw Error("Unknown option " + opt);
    }
  }
}
var validator$1 = {
  isOlderVersion,
  assertOptions,
  validators: validators$1
};
var utils$1 = utils$d;
var buildURL = buildURL$2;
var InterceptorManager = InterceptorManager_1;
var dispatchRequest = dispatchRequest$1;
var mergeConfig$1 = mergeConfig$2;
var validator = validator$1;
var validators = validator.validators;
function Axios$1(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
Axios$1.prototype.request = function request(config) {
  if (typeof config === "string") {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }
  config = mergeConfig$1(this.defaults, config);
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = "get";
  }
  var transitional2 = config.transitional;
  if (transitional2 !== void 0) {
    validator.assertOptions(transitional2, {
      silentJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
      forcedJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
      clarifyTimeoutError: validators.transitional(validators.boolean, "1.0.0")
    }, false);
  }
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
      return;
    }
    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });
  var promise;
  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, void 0];
    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);
    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }
    return promise;
  }
  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error2) {
      onRejected(error2);
      break;
    }
  }
  try {
    promise = dispatchRequest(newConfig);
  } catch (error2) {
    return Promise.reject(error2);
  }
  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }
  return promise;
};
Axios$1.prototype.getUri = function getUri(config) {
  config = mergeConfig$1(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
};
utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios$1.prototype[method] = function(url, config) {
    return this.request(mergeConfig$1(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  Axios$1.prototype[method] = function(url, data, config) {
    return this.request(mergeConfig$1(config || {}, {
      method,
      url,
      data
    }));
  };
});
var Axios_1 = Axios$1;
function Cancel$1(message) {
  this.message = message;
}
Cancel$1.prototype.toString = function toString2() {
  return "Cancel" + (this.message ? ": " + this.message : "");
};
Cancel$1.prototype.__CANCEL__ = true;
var Cancel_1 = Cancel$1;
var Cancel = Cancel_1;
function CancelToken(executor) {
  if (typeof executor !== "function") {
    throw new TypeError("executor must be a function.");
  }
  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve2) {
    resolvePromise = resolve2;
  });
  var token2 = this;
  executor(function cancel(message) {
    if (token2.reason) {
      return;
    }
    token2.reason = new Cancel(message);
    resolvePromise(token2.reason);
  });
}
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};
CancelToken.source = function source2() {
  var cancel;
  var token2 = new CancelToken(function executor(c2) {
    cancel = c2;
  });
  return {
    token: token2,
    cancel
  };
};
var CancelToken_1 = CancelToken;
var spread = function spread2(callback) {
  return function wrap2(arr) {
    return callback.apply(null, arr);
  };
};
var isAxiosError = function isAxiosError2(payload) {
  return typeof payload === "object" && payload.isAxiosError === true;
};
var utils = utils$d;
var bind = bind$2;
var Axios = Axios_1;
var mergeConfig = mergeConfig$2;
var defaults$1 = defaults_1;
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);
  utils.extend(instance, Axios.prototype, context);
  utils.extend(instance, context);
  return instance;
}
var axios$1 = createInstance(defaults$1);
axios$1.Axios = Axios;
axios$1.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios$1.defaults, instanceConfig));
};
axios$1.Cancel = Cancel_1;
axios$1.CancelToken = CancelToken_1;
axios$1.isCancel = isCancel$1;
axios$1.all = function all(promises) {
  return Promise.all(promises);
};
axios$1.spread = spread;
axios$1.isAxiosError = isAxiosError;
axios$2.exports = axios$1;
axios$2.exports.default = axios$1;
var axios = axios$2.exports;
function strToHtml(string2) {
  if (document !== void 0 && document.createElement !== void 0) {
    const cont = document.createElement("div");
    cont.innerHTML = string2;
    if (cont.children.length === 1) {
      return cont.children[0];
    } else {
      return cont;
    }
  }
  return string2;
}
function toStringFn(html2, deep = true) {
  if (document !== void 0 && document.createElement !== void 0) {
    const cont = document.createElement("div");
    cont.appendChild(html2.cloneNode(deep));
    return cont.innerHTML;
  }
  return html2;
}
function convert(from2, to2 = "ms") {
  let fromMs = from2;
  if (typeof from2 === "string") {
    const fromNumber = parseFloat(from2);
    const fromLength = fromNumber.toString().length;
    const fromString2 = from2.slice(fromLength);
    if (fromString2 === "ms" || fromString2 === "millisecond" || fromString2 === "milliseconds") {
      fromMs = fromNumber;
    } else if (fromString2 === "s" || fromString2 === "second" || fromString2 === "seconds") {
      fromMs = fromNumber * 1e3;
    } else if (fromString2 === "m" || fromString2 === "minute" || fromString2 === "minutes") {
      fromMs = fromNumber * 60 * 1e3;
    } else if (fromString2 === "h" || fromString2 === "hour" || fromString2 === "hours") {
      fromMs = fromNumber * 60 * 60 * 1e3;
    } else if (fromString2 === "d" || fromString2 === "day" || fromString2 === "days") {
      fromMs = fromNumber * 24 * 60 * 60 * 1e3;
    } else if (fromString2 === "w" || fromString2 === "week" || fromString2 === "weeks") {
      fromMs = fromNumber * 7 * 24 * 60 * 60 * 1e3;
    } else if (fromString2 === "month" || fromString2 === "months") {
      fromMs = fromNumber * 31 * 24 * 60 * 60 * 1e3;
    } else if (fromString2 === "y" || fromString2 === "year" || fromString2 === "years") {
      fromMs = fromNumber * 365 * 24 * 60 * 60 * 1e3;
    }
  }
  switch (to2) {
    case "ms":
    case "millisecond":
    case "milliseconds":
      return fromMs;
    case "s":
    case "second":
    case "seconds":
      return fromMs / 1e3;
    case "m":
    case "minute":
    case "minutes":
      return fromMs / 1e3 / 60;
    case "h":
    case "hour":
    case "hours":
      return fromMs / 1e3 / 60 / 60;
    case "d":
    case "day":
    case "days":
      return fromMs / 1e3 / 60 / 60 / 24;
    case "w":
    case "week":
    case "weeks":
      return fromMs / 1e3 / 60 / 60 / 24 / 7;
    case "month":
    case "months":
      return fromMs / 1e3 / 60 / 60 / 24 / 31;
    case "y":
    case "year":
    case "years":
      return fromMs / 1e3 / 60 / 60 / 24 / 365;
    default:
      throw new Error(`You try to convert "${from2}" to "${to2}" but this format does not exist... The valids formats are "ms,s,m,h,d,w,month,y"...`);
  }
}
convert.MILLISECOND = "ms";
convert.SECOND = "s";
convert.MINUTE = "m";
convert.HOUR = "h";
convert.DAY = "d";
convert.WEEK = "w";
convert.MONTH = "month";
convert.YEAR = "y";
class SRequestConfig {
  constructor(params) {
    this.url = null;
    this.baseURL = null;
    this.method = "GET";
    this.headers = {};
    this.params = {};
    this.data = {};
    this.timeout = 0;
    this.sendInterval = 1e3;
    this.sendCount = 1;
    this.everyResponse = null;
    this.responseType = "json";
    if (params.timeout && typeof params.timeout === "string")
      params.timeout = convert(params.timeout, "ms");
    if (params.sendInterval && typeof params.sendInterval === "string")
      params.sendInterval = convert(params.sendInterval, "ms");
    Object.assign(this, params);
  }
}
class SRequest extends SClass {
  constructor(request2, settings) {
    super(__deepMerge$7({
      request: {}
    }, settings !== null && settings !== void 0 ? settings : {}));
    this._defaultRequestSettings = {};
    this._currentRequestSettings = {};
    this._requestsCount = 0;
    if (!(request2 instanceof SRequestConfig)) {
      this._defaultRequestSettings = new SRequestConfig(request2);
    } else {
      this._defaultRequestSettings = request2;
    }
  }
  get requestSettings() {
    return this._settings.request;
  }
  _onSuccess(response) {
    let finalResponse = response.data;
    const contentType = response.headers["content-type"] || "text/plain";
    const hash = this._currentRequestSettings.url.indexOf("#") !== -1 ? this._currentRequestSettings.url.split("#")[1] : false;
    if (contentType === "text/html" && hash !== false && document !== void 0 && document.querySelector !== void 0) {
      const $html = strToHtml(response.data);
      if ($html.id === hash) {
        finalResponse = toStringFn($html);
      } else {
        const $part = $html.querySelector(`#${hash}`);
        if ($part) {
          finalResponse = toStringFn($part);
        }
      }
    } else if (contentType === "application/json") {
      finalResponse = JSON.parse(response.data);
    }
    response.data = finalResponse;
    delete response.config;
    delete response.request;
    this._responsesArray.push(response);
    if (this._currentRequestSettings.everyResponse) {
      this._currentRequestSettings.everyResponse(Object.assign({}, response), this._requestsCount);
    }
    const lastResponse = this._responsesArray.slice(-1)[0];
    if (this._requestsCount >= this._currentRequestSettings.sendCount) {
      this._resolve({
        status: lastResponse.status,
        statusText: lastResponse.statusText,
        data: lastResponse.data,
        count: this._responsesArray.length,
        response: lastResponse,
        responses: this._responsesArray
      });
    } else {
      this._send();
    }
  }
  _onError(error2) {
    this._reject(error2);
  }
  _send(requestSettings = {}) {
    this._requestsCount++;
    requestSettings = __deepMerge$7(this._defaultRequestSettings, requestSettings);
    if (requestSettings.beforeSend) {
      requestSettings = requestSettings.beforeSend(requestSettings, this._requestsCount);
    }
    this._currentRequestSettings = Object.assign(requestSettings);
    axios(requestSettings).then(this._onSuccess.bind(this)).catch(this._onError.bind(this));
  }
  retry() {
    return this.send();
  }
  send(requestSettings = {}) {
    return new Promise((resolve2, reject) => {
      this._requestsCount = 0;
      this._responsesArray = [];
      this._resolve = resolve2;
      this._reject = reject;
      this._send(requestSettings);
    });
  }
}
function filter$2(object, filter2) {
  const result = {};
  Object.keys(object).forEach((propertyName) => {
    if (filter2(propertyName, object[propertyName])) {
      result[propertyName] = object[propertyName];
    }
  });
  return result;
}
var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __decorateClass$1 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$1(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$1(target, key, result);
  return result;
};
class ApiNav extends SLitComponent {
  constructor() {
    super({
      litComponent: {
        shadowDom: false
      },
      componentUtils: {}
    });
    this._openedNamespaces = [];
    this._menuStack = {};
    this._menuStates = {};
    this._loaded = false;
  }
  async firstUpdated() {
    var _a2, _b2;
    const request2 = new SRequest({
      url: "/docmap.json",
      method: "get"
    });
    this._menuStates = JSON.parse((_a2 = window.localStorage.getItem("apiNavStates")) != null ? _a2 : "{}");
    const cachedNav = JSON.parse((_b2 = window.localStorage.getItem("apiNav")) != null ? _b2 : "{}");
    if (Object.keys(cachedNav).length) {
      this._menuStack = cachedNav;
      this._loaded = true;
    }
    const res = await request2.send();
    const types = [];
    res.data.map = filter$2(res.data.map, (key, item) => {
      const supportedTypes = [
        "function",
        "class",
        "cssmixin",
        "cssfunction",
        "object",
        "customelement",
        "feature"
      ];
      if (types.indexOf(item.type) === -1)
        types.push(item.type);
      if (supportedTypes.indexOf(item.type.toLowerCase()) === -1)
        return false;
      return true;
    });
    console.log(types);
    this._menuStack = {};
    Object.keys(res.data.map).forEach((namespace) => {
      __set(this._menuStack, namespace, res.data.map[namespace]);
    });
    window.localStorage.setItem("apiNav", JSON.stringify(this._menuStack));
    this._loaded = true;
    this.requestUpdate();
  }
  _isAcive(namespace) {
    var _a2;
    return (_a2 = this._menuStates[namespace]) == null ? void 0 : _a2.opened;
  }
  _toggle(namespace) {
    if (!this._menuStates[namespace]) {
      this._menuStates[namespace] = {
        opened: true
      };
    } else {
      this._menuStates[namespace].opened = !this._menuStates[namespace].opened;
    }
    window.localStorage.setItem("apiNavStates", JSON.stringify(this._menuStates));
    this.requestUpdate();
  }
  _renderList(obj2, currentNamespace = "") {
    const items = Object.keys(obj2).map((itemName) => {
      var _a2;
      const itemObj = obj2[itemName];
      const itemNamespace = `${currentNamespace ? `${currentNamespace}.` : ""}${itemName}`;
      if (itemObj.name && itemObj.namespace) {
        let icon = itemObj.platform[0].name;
        return html$2`
                    <li>
                        <i
                            class="s-icon:file-${icon} s-tc:extension-${icon}"
                        ></i>
                        <a href="/api/${itemNamespace}">${itemObj.name}</a>
                    </li>
                `;
      } else {
        return html$2`
                    <li class="${this._isAcive(itemNamespace) ? "active" : ""}">
                        <i
                            class="s-icon:folder-opened s-tc:info s-when:active"
                        ></i>
                        <i class="s-icon:folder"></i>
                        <span
                            @click=${() => {
          this._toggle(itemNamespace);
        }}
                        >
                            ${itemName}
                        </span>
                        ${((_a2 = this._menuStates[itemNamespace]) == null ? void 0 : _a2.opened) ? html$2`
                                  ${this._renderList(get$3(this._menuStack, itemNamespace), itemNamespace)}
                              ` : ""}
                    </li>
                `;
      }
    });
    return html$2`
            <ul class="${!currentNamespace ? "s-fs-tree" : ""}">
                ${items}
            </ul>
        `;
  }
  render() {
    if (!this._loaded) {
      return html$2`
                <div class="s-until:sibling:mounted">
                    <i class="s-loader:spinner s-color:accent"></i>
                    &nbsp;
                    <p class="s-typo:p s-display:inline-block">
                        Loading API navigation.<br />Please wait...
                    </p>
                </div>
            `;
    }
    return html$2`
            <div class="${this.componentUtils.className("")}">
                ${this._renderList(this._menuStack)}
            </div>
        `;
  }
}
__decorateClass$1([
  property$3()
], ApiNav.prototype, "_loaded", 2);
if (!customElements.get("api-nav")) {
  customElements.define("api-nav", ApiNav);
}
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
class ConfigExplorerNav extends SLitComponent {
  constructor() {
    super({
      litComponent: {
        shadowDom: false
      },
      componentUtils: {}
    });
    this._openedNamespaces = [];
    this._menuStack = {};
    this._menuStates = {};
    this._loaded = false;
  }
  async firstUpdated() {
    var _a2, _b2;
    const request2 = new SRequest({
      url: "/api/docmap",
      method: "get"
    });
    this._menuStates = JSON.parse((_a2 = window.localStorage.getItem("ConfigExplorerNavStates")) != null ? _a2 : "{}");
    const cachedNav = JSON.parse((_b2 = window.localStorage.getItem("ConfigExplorerNav")) != null ? _b2 : "{}");
    if (Object.keys(cachedNav).length) {
      this._menuStack = cachedNav;
      this._loaded = true;
    }
    const res = await request2.send();
    res.data.map = filter$2(res.data.map, (key, item) => {
      if (key.includes("imagesBuilder"))
        console.log("S", key);
      if (!key.match(/[a-zA-Z0-9]+\.config\.[a-zA-Z0-9]+/))
        return false;
      key.replace(/.*\.config\./, "");
      return true;
    });
    return;
  }
  _isAcive(namespace) {
    var _a2;
    return (_a2 = this._menuStates[namespace]) == null ? void 0 : _a2.opened;
  }
  _toggle(namespace) {
    if (!this._menuStates[namespace]) {
      this._menuStates[namespace] = {
        opened: true
      };
    } else {
      this._menuStates[namespace].opened = !this._menuStates[namespace].opened;
    }
    window.localStorage.setItem("ConfigExplorerNavStates", JSON.stringify(this._menuStates));
    this.requestUpdate();
  }
  _renderList(obj2, currentNamespace = "") {
    const items = Object.keys(obj2).map((itemName) => {
      var _a2;
      const itemObj = obj2[itemName];
      const itemNamespace = `${currentNamespace ? `${currentNamespace}.` : ""}${itemName}`;
      if (itemObj.name && itemObj.namespace) {
        let icon = itemObj.platform[0].name;
        return html$2`
                    <li>
                        <i
                            class="s-icon:file-${icon} s-tc:extension-${icon}"
                        ></i>
                        <a href="/api/${itemNamespace}">${itemObj.name}</a>
                    </li>
                `;
      } else {
        return html$2`
                    <li class="${this._isAcive(itemNamespace) ? "active" : ""}">
                        <i
                            class="s-icon:folder-opened s-tc:info s-when:active"
                        ></i>
                        <i class="s-icon:folder"></i>
                        <span
                            @click=${() => {
          this._toggle(itemNamespace);
        }}
                        >
                            ${itemName}
                        </span>
                        ${((_a2 = this._menuStates[itemNamespace]) == null ? void 0 : _a2.opened) ? html$2`
                                  ${this._renderList(get$3(this._menuStack, itemNamespace), itemNamespace)}
                              ` : ""}
                    </li>
                `;
      }
    });
    return html$2`
            <ul class="${!currentNamespace ? "s-fs-tree" : ""}">
                ${items}
            </ul>
        `;
  }
  render() {
    if (!this._loaded) {
      return html$2`
                <div class="s-until:sibling:mounted">
                    <i class="s-loader:spinner s-color:accent"></i>
                    &nbsp;
                    <p class="s-typo:p s-display:inline-block">
                        Loading API navigation.<br />Please wait...
                    </p>
                </div>
            `;
    }
    return html$2`
            <div class="${this.componentUtils.className("")}">
                ${this._renderList(this._menuStack)}
            </div>
        `;
  }
}
__decorateClass([
  property$3()
], ConfigExplorerNav.prototype, "_loaded", 2);
if (!customElements.get("config-explorer-nav")) {
  customElements.define("config-explorer-nav", ConfigExplorerNav);
}
class SDuration {
  constructor(settings = {}) {
    this._settings = {};
    this.startTime = null;
    this.endTime = null;
    this.duration = null;
    this._settings = __deepMerge$7({
      format: "s",
      suffix: true
    }, settings);
    this.start();
  }
  toObject(settings = {}) {
    settings = __deepMerge$7(this._settings, settings);
    if (!this.endTime || !this.startTime)
      this.end();
    const durationMs = this.endTime - this.startTime;
    this.duration = durationMs;
    const convertedDuration = convert(durationMs, settings.format);
    const formatedDuration = settings.suffix ? convertedDuration + (settings.suffix === true ? settings.format : settings.suffix) : parseFloat(convertedDuration);
    return {
      startTime: this.startTime || -1,
      endTime: this.endTime || -1,
      duration: this.duration || -1,
      convertedDuration,
      formatedDuration
    };
  }
  start(startTime = null) {
    this.startTime = startTime || Date.now();
    return this;
  }
  end(settings = {}) {
    settings = __deepMerge$7(this._settings, settings);
    this.endTime = Date.now();
    return this.toObject(settings);
  }
}
/*! clipboard-copy. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var clipboardCopy_1 = clipboardCopy;
function makeError() {
  return new DOMException("The request is not allowed", "NotAllowedError");
}
async function copyClipboardApi(text) {
  if (!navigator.clipboard) {
    throw makeError();
  }
  return navigator.clipboard.writeText(text);
}
async function copyExecCommand(text) {
  const span = document.createElement("span");
  span.textContent = text;
  span.style.whiteSpace = "pre";
  span.style.webkitUserSelect = "auto";
  span.style.userSelect = "all";
  document.body.appendChild(span);
  const selection = window.getSelection();
  const range2 = window.document.createRange();
  selection.removeAllRanges();
  range2.selectNode(span);
  selection.addRange(range2);
  let success = false;
  try {
    success = window.document.execCommand("copy");
  } finally {
    selection.removeAllRanges();
    window.document.body.removeChild(span);
  }
  if (!success)
    throw makeError();
}
async function clipboardCopy(text) {
  try {
    await copyClipboardApi(text);
  } catch (err) {
    try {
      await copyExecCommand(text);
    } catch (err2) {
      throw err2 || err || makeError();
    }
  }
}
/**
* @license
* Copyright 2017 Google LLC
* SPDX-License-Identifier: BSD-3-Clause
*/
const standardProperty$2 = (options, element) => {
  if (element.kind === "method" && element.descriptor && !("value" in element.descriptor)) {
    return __spreadProps(__spreadValues({}, element), {
      finisher(clazz) {
        clazz.createProperty(element.key, options);
      }
    });
  } else {
    return {
      kind: "field",
      key: Symbol(),
      placement: "own",
      descriptor: {},
      originalKey: element.key,
      initializer() {
        if (typeof element.initializer === "function") {
          this[element.key] = element.initializer.call(this);
        }
      },
      finisher(clazz) {
        clazz.createProperty(element.key, options);
      }
    };
  }
};
const legacyProperty$2 = (options, proto2, name2) => {
  proto2.constructor.createProperty(name2, options);
};
function property$2(options) {
  return (protoOrDescriptor, name2) => name2 !== void 0 ? legacyProperty$2(options, protoOrDescriptor, name2) : standardProperty$2(options, protoOrDescriptor);
}
class SHighlightJsComponentInterface$1 extends SInterface {
}
SHighlightJsComponentInterface$1.definition = {
  successTimeout: {
    type: "Number",
    default: 1500
  },
  errorTimeout: {
    type: "Number",
    default: 3e3
  }
};
function copy(text) {
  return clipboardCopy_1(text);
}
function plainObject$6(object) {
  if (!object)
    return false;
  if (typeof object !== "object")
    return false;
  if (object.constructor && object.constructor.name !== "Object")
    return false;
  if (Object.prototype.toString.call(object) !== "[object Object]")
    return false;
  if (object !== Object(object))
    return false;
  return true;
}
function __deepMerge$6(...args) {
  function merge2(firstObj, secondObj) {
    const newObj = {};
    if (!firstObj && secondObj)
      return secondObj;
    if (!secondObj && firstObj)
      return firstObj;
    if (!firstObj && !secondObj)
      return {};
    const firstProps = Object.getOwnPropertyNames(firstObj);
    firstProps.forEach((key) => {
      const desc = Object.getOwnPropertyDescriptor(firstObj, key);
      if (desc.set || desc.get) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = firstObj[key];
      }
    });
    const secondProps = Object.getOwnPropertyNames(secondObj);
    secondProps.forEach((key) => {
      const desc = Object.getOwnPropertyDescriptor(secondObj, key);
      if (desc.set || desc.get) {
        Object.defineProperty(newObj, key, desc);
      } else if (plainObject$6(newObj[key]) && plainObject$6(secondObj[key])) {
        newObj[key] = merge2(newObj[key], secondObj[key]);
      } else {
        newObj[key] = secondObj[key];
      }
    });
    return newObj;
  }
  let currentObj = {};
  for (let i2 = 0; i2 < args.length; i2++) {
    const toMergeObj = args[i2];
    currentObj = merge2(currentObj, toMergeObj);
  }
  return currentObj;
}
var __css$7 = ".s-clipboard-copy {\n    display: inline-block;\n    width: 1em;\n    height: 1em;\n    position: relative;\n    cursor: pointer;\n}\n\n    .s-clipboard-copy:not([mounted]) > * {\n        opacity: 0.001;\n        pointer-events: none;\n    }\n\n    .s-clipboard-copy[state='pending'] .icon-copy {\n            opacity: 1;\n        }\n\n    .s-clipboard-copy[state='copy'] .icon-copy {\n            opacity: 1;\n        }\n\n    .s-clipboard-copy[state='success'] {\n        color: hsla(calc(var(--s-theme-color-success-h, 0) + var(--s-theme-color-success-spin ,0)),calc((var(--s-theme-color-success-s, 0) + var(--s-theme-color-success-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-success-l, 0) + var(--s-theme-color-success-lightness-offset, 0)) * 1%),var(--s-theme-color-success-a, 1));\n    }\n\n    .s-clipboard-copy[state='success'] .icon-success {\n            opacity: 1;\n        }\n\n    .s-clipboard-copy[state='error'] {\n        color: hsla(calc(var(--s-theme-color-error-h, 0) + var(--s-theme-color-error-spin ,0)),calc((var(--s-theme-color-error-s, 0) + var(--s-theme-color-error-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-error-l, 0) + var(--s-theme-color-error-lightness-offset, 0)) * 1%),var(--s-theme-color-error-a, 1));\n    }\n\n    .s-clipboard-copy[state='error'] .icon-error {\n            opacity: 1;\n        }\n\n    .s-clipboard-copy svg {\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -50%);\n        display: block;\n        width: 1em;\n        height: 1em;\n        background-size: contain;\n        opacity: 0;\n        pointer-events: none;\n    }\n";
var __decorate$4 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d2 = decorators[i2])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
class SClipboardCopy extends SLitComponent {
  constructor() {
    super(__deepMerge$6({
      litComponent: {
        interface: SHighlightJsComponentInterface$1
      }
    }));
    this._state = "pending";
  }
  static get styles() {
    return css$1`
            ${unsafeCSS(__css$7)}
        `;
  }
  copy(text) {
    this._state = "copy";
    copy(text).then(() => {
      this._state = "success";
      setTimeout(() => {
        this._state = "pending";
      }, this.props.successTimeout);
    }).catch((e20) => {
      this._state = "error";
      setTimeout(() => {
        this._state = "pending";
      }, this.props.errorTimeout);
    });
  }
  render() {
    return html$2`
            <div class="${this.componentUtils.className("")}" state="${this._state}">
                <svg
                    ref="svg"
                    class="icon-copy"
                    width="20"
                    height="20"
                    viewBox="0 0 20 20"
                    fill="none"
                    xmlns="http://www.w3.org/2000/svg"
                >
                    <g clip-path="url(#clip0)">
                        <path d="M4.55512 0.00402832L2.07324 2.4859H4.55512V0.00402832Z" fill="currentColor" />
                        <path
                            d="M14.9937 0H5.72598V3.65762H2.06836V17.0624H14.9937V0H14.9937ZM12.5801 11.3218H4.48195V10.1499H12.5801V11.3218ZM12.5801 8.83219H4.48195V7.66031H12.5801V8.83219ZM12.5801 6.34254H4.48195V5.17066H12.5801V6.34254Z"
                            fill="currentColor"
                        />
                        <path d="M16.1655 2.93762V18.2343H5.00586V20H17.9312V2.93762H16.1655Z" fill="currentColor" />
                    </g>
                    <defs>
                        <clipPath id="clip0">
                            <rect width="20" height="20" fill="currentColor" />
                        </clipPath>
                    </defs>
                </svg>
                <svg
                    class="icon-success"
                    xmlns="http://www.w3.org/2000/svg"
                    width="24"
                    height="24"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                >
                    <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                    <polyline points="22 4 12 14.01 9 11.01"></polyline>
                </svg>
                <svg
                    class="icon-error"
                    xmlns="http://www.w3.org/2000/svg"
                    width="24"
                    height="24"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                >
                    <polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon>
                    <line x1="15" y1="9" x2="9" y2="15"></line>
                    <line x1="9" y1="9" x2="15" y2="15"></line>
                </svg>
            </div>
        `;
  }
}
__decorate$4([
  property$2()
], SClipboardCopy.prototype, "_state", void 0);
function define$e(props = {}, tagName = "s-clipboard-copy") {
  SLitComponent.setDefaultProps(tagName, props);
  customElements.define(tagName, SClipboardCopy);
}
function plainObject$5(object) {
  if (!object)
    return false;
  if (typeof object !== "object")
    return false;
  if (object.constructor && object.constructor.name !== "Object")
    return false;
  if (Object.prototype.toString.call(object) !== "[object Object]")
    return false;
  if (object !== Object(object))
    return false;
  return true;
}
function __deepMerge$5(...args) {
  function merge2(firstObj, secondObj) {
    const newObj = {};
    if (!firstObj && secondObj)
      return secondObj;
    if (!secondObj && firstObj)
      return firstObj;
    if (!firstObj && !secondObj)
      return {};
    const firstProps = Object.getOwnPropertyNames(firstObj);
    firstProps.forEach((key) => {
      const desc = Object.getOwnPropertyDescriptor(firstObj, key);
      if (desc.set || desc.get) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = firstObj[key];
      }
    });
    const secondProps = Object.getOwnPropertyNames(secondObj);
    secondProps.forEach((key) => {
      const desc = Object.getOwnPropertyDescriptor(secondObj, key);
      if (desc.set || desc.get) {
        Object.defineProperty(newObj, key, desc);
      } else if (plainObject$5(newObj[key]) && plainObject$5(secondObj[key])) {
        newObj[key] = merge2(newObj[key], secondObj[key]);
      } else {
        newObj[key] = secondObj[key];
      }
    });
    return newObj;
  }
  let currentObj = {};
  for (let i2 = 0; i2 < args.length; i2++) {
    const toMergeObj = args[i2];
    currentObj = merge2(currentObj, toMergeObj);
  }
  return currentObj;
}
function wait(timeout = 0) {
  return new Promise((resolve2) => {
    setTimeout(() => {
      resolve2();
    }, timeout);
  });
}
var deepFreezeEs6 = { exports: {} };
function deepFreeze(obj2) {
  if (obj2 instanceof Map) {
    obj2.clear = obj2.delete = obj2.set = function() {
      throw new Error("map is read-only");
    };
  } else if (obj2 instanceof Set) {
    obj2.add = obj2.clear = obj2.delete = function() {
      throw new Error("set is read-only");
    };
  }
  Object.freeze(obj2);
  Object.getOwnPropertyNames(obj2).forEach(function(name2) {
    var prop = obj2[name2];
    if (typeof prop == "object" && !Object.isFrozen(prop)) {
      deepFreeze(prop);
    }
  });
  return obj2;
}
deepFreezeEs6.exports = deepFreeze;
deepFreezeEs6.exports.default = deepFreeze;
var deepFreeze$1 = deepFreezeEs6.exports;
class Response$1 {
  constructor(mode) {
    if (mode.data === void 0)
      mode.data = {};
    this.data = mode.data;
    this.isMatchIgnored = false;
  }
  ignoreMatch() {
    this.isMatchIgnored = true;
  }
}
function escapeHTML(value) {
  return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}
function inherit$1(original, ...objects) {
  const result = Object.create(null);
  for (const key in original) {
    result[key] = original[key];
  }
  objects.forEach(function(obj2) {
    for (const key in obj2) {
      result[key] = obj2[key];
    }
  });
  return result;
}
const SPAN_CLOSE = "</span>";
const emitsWrappingTags = (node) => {
  return !!node.kind;
};
const expandScopeName = (name2, { prefix }) => {
  if (name2.includes(".")) {
    const pieces = name2.split(".");
    return [
      `${prefix}${pieces.shift()}`,
      ...pieces.map((x2, i2) => `${x2}${"_".repeat(i2 + 1)}`)
    ].join(" ");
  }
  return `${prefix}${name2}`;
};
class HTMLRenderer {
  constructor(parseTree, options) {
    this.buffer = "";
    this.classPrefix = options.classPrefix;
    parseTree.walk(this);
  }
  addText(text) {
    this.buffer += escapeHTML(text);
  }
  openNode(node) {
    if (!emitsWrappingTags(node))
      return;
    let scope = node.kind;
    if (node.sublanguage) {
      scope = `language-${scope}`;
    } else {
      scope = expandScopeName(scope, { prefix: this.classPrefix });
    }
    this.span(scope);
  }
  closeNode(node) {
    if (!emitsWrappingTags(node))
      return;
    this.buffer += SPAN_CLOSE;
  }
  value() {
    return this.buffer;
  }
  span(className) {
    this.buffer += `<span class="${className}">`;
  }
}
class TokenTree {
  constructor() {
    this.rootNode = { children: [] };
    this.stack = [this.rootNode];
  }
  get top() {
    return this.stack[this.stack.length - 1];
  }
  get root() {
    return this.rootNode;
  }
  add(node) {
    this.top.children.push(node);
  }
  openNode(kind) {
    const node = { kind, children: [] };
    this.add(node);
    this.stack.push(node);
  }
  closeNode() {
    if (this.stack.length > 1) {
      return this.stack.pop();
    }
    return void 0;
  }
  closeAllNodes() {
    while (this.closeNode())
      ;
  }
  toJSON() {
    return JSON.stringify(this.rootNode, null, 4);
  }
  walk(builder) {
    return this.constructor._walk(builder, this.rootNode);
  }
  static _walk(builder, node) {
    if (typeof node === "string") {
      builder.addText(node);
    } else if (node.children) {
      builder.openNode(node);
      node.children.forEach((child) => this._walk(builder, child));
      builder.closeNode(node);
    }
    return builder;
  }
  static _collapse(node) {
    if (typeof node === "string")
      return;
    if (!node.children)
      return;
    if (node.children.every((el2) => typeof el2 === "string")) {
      node.children = [node.children.join("")];
    } else {
      node.children.forEach((child) => {
        TokenTree._collapse(child);
      });
    }
  }
}
class TokenTreeEmitter extends TokenTree {
  constructor(options) {
    super();
    this.options = options;
  }
  addKeyword(text, kind) {
    if (text === "") {
      return;
    }
    this.openNode(kind);
    this.addText(text);
    this.closeNode();
  }
  addText(text) {
    if (text === "") {
      return;
    }
    this.add(text);
  }
  addSublanguage(emitter, name2) {
    const node = emitter.root;
    node.kind = name2;
    node.sublanguage = true;
    this.add(node);
  }
  toHTML() {
    const renderer = new HTMLRenderer(this, this.options);
    return renderer.value();
  }
  finalize() {
    return true;
  }
}
function source(re2) {
  if (!re2)
    return null;
  if (typeof re2 === "string")
    return re2;
  return re2.source;
}
function lookahead(re2) {
  return concat("(?=", re2, ")");
}
function anyNumberOfTimes(re2) {
  return concat("(?:", re2, ")*");
}
function optional(re2) {
  return concat("(?:", re2, ")?");
}
function concat(...args) {
  const joined = args.map((x2) => source(x2)).join("");
  return joined;
}
function stripOptionsFromArgs(args) {
  const opts = args[args.length - 1];
  if (typeof opts === "object" && opts.constructor === Object) {
    args.splice(args.length - 1, 1);
    return opts;
  } else {
    return {};
  }
}
function either(...args) {
  const opts = stripOptionsFromArgs(args);
  const joined = "(" + (opts.capture ? "" : "?:") + args.map((x2) => source(x2)).join("|") + ")";
  return joined;
}
function countMatchGroups(re2) {
  return new RegExp(re2.toString() + "|").exec("").length - 1;
}
function startsWith(re2, lexeme) {
  const match5 = re2 && re2.exec(lexeme);
  return match5 && match5.index === 0;
}
const BACKREF_RE = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
function _rewriteBackreferences(regexps, { joinWith }) {
  let numCaptures = 0;
  return regexps.map((regex) => {
    numCaptures += 1;
    const offset2 = numCaptures;
    let re2 = source(regex);
    let out = "";
    while (re2.length > 0) {
      const match5 = BACKREF_RE.exec(re2);
      if (!match5) {
        out += re2;
        break;
      }
      out += re2.substring(0, match5.index);
      re2 = re2.substring(match5.index + match5[0].length);
      if (match5[0][0] === "\\" && match5[1]) {
        out += "\\" + String(Number(match5[1]) + offset2);
      } else {
        out += match5[0];
        if (match5[0] === "(") {
          numCaptures++;
        }
      }
    }
    return out;
  }).map((re2) => `(${re2})`).join(joinWith);
}
const MATCH_NOTHING_RE = /\b\B/;
const IDENT_RE$1 = "[a-zA-Z]\\w*";
const UNDERSCORE_IDENT_RE = "[a-zA-Z_]\\w*";
const NUMBER_RE = "\\b\\d+(\\.\\d+)?";
const C_NUMBER_RE = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";
const BINARY_NUMBER_RE = "\\b(0b[01]+)";
const RE_STARTERS_RE = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";
const SHEBANG = (opts = {}) => {
  const beginShebang = /^#![ ]*\//;
  if (opts.binary) {
    opts.begin = concat(beginShebang, /.*\b/, opts.binary, /\b.*/);
  }
  return inherit$1({
    scope: "meta",
    begin: beginShebang,
    end: /$/,
    relevance: 0,
    "on:begin": (m2, resp) => {
      if (m2.index !== 0)
        resp.ignoreMatch();
    }
  }, opts);
};
const BACKSLASH_ESCAPE = {
  begin: "\\\\[\\s\\S]",
  relevance: 0
};
const APOS_STRING_MODE = {
  scope: "string",
  begin: "'",
  end: "'",
  illegal: "\\n",
  contains: [BACKSLASH_ESCAPE]
};
const QUOTE_STRING_MODE = {
  scope: "string",
  begin: '"',
  end: '"',
  illegal: "\\n",
  contains: [BACKSLASH_ESCAPE]
};
const PHRASAL_WORDS_MODE = {
  begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
};
const COMMENT = function(begin, end, modeOptions = {}) {
  const mode = inherit$1({
    scope: "comment",
    begin,
    end,
    contains: []
  }, modeOptions);
  mode.contains.push({
    scope: "doctag",
    begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
    excludeBegin: true,
    relevance: 0
  });
  const ENGLISH_WORD = either("I", "a", "is", "so", "us", "to", "at", "if", "in", "it", "on", /[A-Za-z]+['](d|ve|re|ll|t|s|n)/, /[A-Za-z]+[-][a-z]+/, /[A-Za-z][a-z]{2,}/);
  mode.contains.push({
    begin: concat(/[ ]+/, "(", ENGLISH_WORD, /[.]?[:]?([.][ ]|[ ])/, "){3}")
  });
  return mode;
};
const C_LINE_COMMENT_MODE = COMMENT("//", "$");
const C_BLOCK_COMMENT_MODE = COMMENT("/\\*", "\\*/");
const HASH_COMMENT_MODE = COMMENT("#", "$");
const NUMBER_MODE = {
  scope: "number",
  begin: NUMBER_RE,
  relevance: 0
};
const C_NUMBER_MODE = {
  scope: "number",
  begin: C_NUMBER_RE,
  relevance: 0
};
const BINARY_NUMBER_MODE = {
  scope: "number",
  begin: BINARY_NUMBER_RE,
  relevance: 0
};
const REGEXP_MODE = {
  begin: /(?=\/[^/\n]*\/)/,
  contains: [
    {
      scope: "regexp",
      begin: /\//,
      end: /\/[gimuy]*/,
      illegal: /\n/,
      contains: [
        BACKSLASH_ESCAPE,
        {
          begin: /\[/,
          end: /\]/,
          relevance: 0,
          contains: [BACKSLASH_ESCAPE]
        }
      ]
    }
  ]
};
const TITLE_MODE = {
  scope: "title",
  begin: IDENT_RE$1,
  relevance: 0
};
const UNDERSCORE_TITLE_MODE = {
  scope: "title",
  begin: UNDERSCORE_IDENT_RE,
  relevance: 0
};
const METHOD_GUARD = {
  begin: "\\.\\s*" + UNDERSCORE_IDENT_RE,
  relevance: 0
};
const END_SAME_AS_BEGIN = function(mode) {
  return Object.assign(mode, {
    "on:begin": (m2, resp) => {
      resp.data._beginMatch = m2[1];
    },
    "on:end": (m2, resp) => {
      if (resp.data._beginMatch !== m2[1])
        resp.ignoreMatch();
    }
  });
};
var MODES$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MATCH_NOTHING_RE,
  IDENT_RE: IDENT_RE$1,
  UNDERSCORE_IDENT_RE,
  NUMBER_RE,
  C_NUMBER_RE,
  BINARY_NUMBER_RE,
  RE_STARTERS_RE,
  SHEBANG,
  BACKSLASH_ESCAPE,
  APOS_STRING_MODE,
  QUOTE_STRING_MODE,
  PHRASAL_WORDS_MODE,
  COMMENT,
  C_LINE_COMMENT_MODE,
  C_BLOCK_COMMENT_MODE,
  HASH_COMMENT_MODE,
  NUMBER_MODE,
  C_NUMBER_MODE,
  BINARY_NUMBER_MODE,
  REGEXP_MODE,
  TITLE_MODE,
  UNDERSCORE_TITLE_MODE,
  METHOD_GUARD,
  END_SAME_AS_BEGIN
});
function skipIfHasPrecedingDot(match5, response) {
  const before = match5.input[match5.index - 1];
  if (before === ".") {
    response.ignoreMatch();
  }
}
function scopeClassName(mode, _parent) {
  if (mode.className !== void 0) {
    mode.scope = mode.className;
    delete mode.className;
  }
}
function beginKeywords(mode, parent) {
  if (!parent)
    return;
  if (!mode.beginKeywords)
    return;
  mode.begin = "\\b(" + mode.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)";
  mode.__beforeBegin = skipIfHasPrecedingDot;
  mode.keywords = mode.keywords || mode.beginKeywords;
  delete mode.beginKeywords;
  if (mode.relevance === void 0)
    mode.relevance = 0;
}
function compileIllegal(mode, _parent) {
  if (!Array.isArray(mode.illegal))
    return;
  mode.illegal = either(...mode.illegal);
}
function compileMatch(mode, _parent) {
  if (!mode.match)
    return;
  if (mode.begin || mode.end)
    throw new Error("begin & end are not supported with match");
  mode.begin = mode.match;
  delete mode.match;
}
function compileRelevance(mode, _parent) {
  if (mode.relevance === void 0)
    mode.relevance = 1;
}
const beforeMatchExt = (mode, parent) => {
  if (!mode.beforeMatch)
    return;
  if (mode.starts)
    throw new Error("beforeMatch cannot be used with starts");
  const originalMode = Object.assign({}, mode);
  Object.keys(mode).forEach((key) => {
    delete mode[key];
  });
  mode.keywords = originalMode.keywords;
  mode.begin = concat(originalMode.beforeMatch, lookahead(originalMode.begin));
  mode.starts = {
    relevance: 0,
    contains: [Object.assign(originalMode, { endsParent: true })]
  };
  mode.relevance = 0;
  delete originalMode.beforeMatch;
};
const COMMON_KEYWORDS = [
  "of",
  "and",
  "for",
  "in",
  "not",
  "or",
  "if",
  "then",
  "parent",
  "list",
  "value"
];
const DEFAULT_KEYWORD_SCOPE = "keyword";
function compileKeywords(rawKeywords, caseInsensitive, scopeName = DEFAULT_KEYWORD_SCOPE) {
  const compiledKeywords = Object.create(null);
  if (typeof rawKeywords === "string") {
    compileList(scopeName, rawKeywords.split(" "));
  } else if (Array.isArray(rawKeywords)) {
    compileList(scopeName, rawKeywords);
  } else {
    Object.keys(rawKeywords).forEach(function(scopeName2) {
      Object.assign(compiledKeywords, compileKeywords(rawKeywords[scopeName2], caseInsensitive, scopeName2));
    });
  }
  return compiledKeywords;
  function compileList(scopeName2, keywordList) {
    if (caseInsensitive) {
      keywordList = keywordList.map((x2) => x2.toLowerCase());
    }
    keywordList.forEach(function(keyword) {
      const pair = keyword.split("|");
      compiledKeywords[pair[0]] = [
        scopeName2,
        scoreForKeyword(pair[0], pair[1])
      ];
    });
  }
}
function scoreForKeyword(keyword, providedScore) {
  if (providedScore) {
    return Number(providedScore);
  }
  return commonKeyword(keyword) ? 0 : 1;
}
function commonKeyword(keyword) {
  return COMMON_KEYWORDS.includes(keyword.toLowerCase());
}
const seenDeprecations = {};
const error = (message) => {
  console.error(message);
};
const warn$1 = (message, ...args) => {
  console.log(`WARN: ${message}`, ...args);
};
const deprecated = (version2, message) => {
  if (seenDeprecations[`${version2}/${message}`])
    return;
  console.log(`Deprecated as of ${version2}. ${message}`);
  seenDeprecations[`${version2}/${message}`] = true;
};
const MultiClassError = new Error();
function remapScopeNames(mode, regexes2, { key }) {
  let offset2 = 0;
  const scopeNames = mode[key];
  const emit = {};
  const positions = {};
  for (let i2 = 1; i2 <= regexes2.length; i2++) {
    positions[i2 + offset2] = scopeNames[i2];
    emit[i2 + offset2] = true;
    offset2 += countMatchGroups(regexes2[i2 - 1]);
  }
  mode[key] = positions;
  mode[key]._emit = emit;
  mode[key]._multi = true;
}
function beginMultiClass(mode) {
  if (!Array.isArray(mode.begin))
    return;
  if (mode.skip || mode.excludeBegin || mode.returnBegin) {
    error("skip, excludeBegin, returnBegin not compatible with beginScope: {}");
    throw MultiClassError;
  }
  if (typeof mode.beginScope !== "object" || mode.beginScope === null) {
    error("beginScope must be object");
    throw MultiClassError;
  }
  remapScopeNames(mode, mode.begin, { key: "beginScope" });
  mode.begin = _rewriteBackreferences(mode.begin, { joinWith: "" });
}
function endMultiClass(mode) {
  if (!Array.isArray(mode.end))
    return;
  if (mode.skip || mode.excludeEnd || mode.returnEnd) {
    error("skip, excludeEnd, returnEnd not compatible with endScope: {}");
    throw MultiClassError;
  }
  if (typeof mode.endScope !== "object" || mode.endScope === null) {
    error("endScope must be object");
    throw MultiClassError;
  }
  remapScopeNames(mode, mode.end, { key: "endScope" });
  mode.end = _rewriteBackreferences(mode.end, { joinWith: "" });
}
function scopeSugar(mode) {
  if (mode.scope && typeof mode.scope === "object" && mode.scope !== null) {
    mode.beginScope = mode.scope;
    delete mode.scope;
  }
}
function MultiClass(mode) {
  scopeSugar(mode);
  if (typeof mode.beginScope === "string") {
    mode.beginScope = { _wrap: mode.beginScope };
  }
  if (typeof mode.endScope === "string") {
    mode.endScope = { _wrap: mode.endScope };
  }
  beginMultiClass(mode);
  endMultiClass(mode);
}
function compileLanguage(language) {
  function langRe(value, global2) {
    return new RegExp(source(value), "m" + (language.case_insensitive ? "i" : "") + (language.unicodeRegex ? "u" : "") + (global2 ? "g" : ""));
  }
  class MultiRegex {
    constructor() {
      this.matchIndexes = {};
      this.regexes = [];
      this.matchAt = 1;
      this.position = 0;
    }
    addRule(re2, opts) {
      opts.position = this.position++;
      this.matchIndexes[this.matchAt] = opts;
      this.regexes.push([opts, re2]);
      this.matchAt += countMatchGroups(re2) + 1;
    }
    compile() {
      if (this.regexes.length === 0) {
        this.exec = () => null;
      }
      const terminators = this.regexes.map((el2) => el2[1]);
      this.matcherRe = langRe(_rewriteBackreferences(terminators, { joinWith: "|" }), true);
      this.lastIndex = 0;
    }
    exec(s2) {
      this.matcherRe.lastIndex = this.lastIndex;
      const match5 = this.matcherRe.exec(s2);
      if (!match5) {
        return null;
      }
      const i2 = match5.findIndex((el2, i3) => i3 > 0 && el2 !== void 0);
      const matchData = this.matchIndexes[i2];
      match5.splice(0, i2);
      return Object.assign(match5, matchData);
    }
  }
  class ResumableMultiRegex {
    constructor() {
      this.rules = [];
      this.multiRegexes = [];
      this.count = 0;
      this.lastIndex = 0;
      this.regexIndex = 0;
    }
    getMatcher(index) {
      if (this.multiRegexes[index])
        return this.multiRegexes[index];
      const matcher = new MultiRegex();
      this.rules.slice(index).forEach(([re2, opts]) => matcher.addRule(re2, opts));
      matcher.compile();
      this.multiRegexes[index] = matcher;
      return matcher;
    }
    resumingScanAtSamePosition() {
      return this.regexIndex !== 0;
    }
    considerAll() {
      this.regexIndex = 0;
    }
    addRule(re2, opts) {
      this.rules.push([re2, opts]);
      if (opts.type === "begin")
        this.count++;
    }
    exec(s2) {
      const m2 = this.getMatcher(this.regexIndex);
      m2.lastIndex = this.lastIndex;
      let result = m2.exec(s2);
      if (this.resumingScanAtSamePosition()) {
        if (result && result.index === this.lastIndex)
          ;
        else {
          const m22 = this.getMatcher(0);
          m22.lastIndex = this.lastIndex + 1;
          result = m22.exec(s2);
        }
      }
      if (result) {
        this.regexIndex += result.position + 1;
        if (this.regexIndex === this.count) {
          this.considerAll();
        }
      }
      return result;
    }
  }
  function buildModeRegex(mode) {
    const mm2 = new ResumableMultiRegex();
    mode.contains.forEach((term) => mm2.addRule(term.begin, { rule: term, type: "begin" }));
    if (mode.terminatorEnd) {
      mm2.addRule(mode.terminatorEnd, { type: "end" });
    }
    if (mode.illegal) {
      mm2.addRule(mode.illegal, { type: "illegal" });
    }
    return mm2;
  }
  function compileMode(mode, parent) {
    const cmode = mode;
    if (mode.isCompiled)
      return cmode;
    [
      scopeClassName,
      compileMatch,
      MultiClass,
      beforeMatchExt
    ].forEach((ext2) => ext2(mode, parent));
    language.compilerExtensions.forEach((ext2) => ext2(mode, parent));
    mode.__beforeBegin = null;
    [
      beginKeywords,
      compileIllegal,
      compileRelevance
    ].forEach((ext2) => ext2(mode, parent));
    mode.isCompiled = true;
    let keywordPattern = null;
    if (typeof mode.keywords === "object" && mode.keywords.$pattern) {
      mode.keywords = Object.assign({}, mode.keywords);
      keywordPattern = mode.keywords.$pattern;
      delete mode.keywords.$pattern;
    }
    keywordPattern = keywordPattern || /\w+/;
    if (mode.keywords) {
      mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);
    }
    cmode.keywordPatternRe = langRe(keywordPattern, true);
    if (parent) {
      if (!mode.begin)
        mode.begin = /\B|\b/;
      cmode.beginRe = langRe(cmode.begin);
      if (!mode.end && !mode.endsWithParent)
        mode.end = /\B|\b/;
      if (mode.end)
        cmode.endRe = langRe(cmode.end);
      cmode.terminatorEnd = source(cmode.end) || "";
      if (mode.endsWithParent && parent.terminatorEnd) {
        cmode.terminatorEnd += (mode.end ? "|" : "") + parent.terminatorEnd;
      }
    }
    if (mode.illegal)
      cmode.illegalRe = langRe(mode.illegal);
    if (!mode.contains)
      mode.contains = [];
    mode.contains = [].concat(...mode.contains.map(function(c2) {
      return expandOrCloneMode(c2 === "self" ? mode : c2);
    }));
    mode.contains.forEach(function(c2) {
      compileMode(c2, cmode);
    });
    if (mode.starts) {
      compileMode(mode.starts, parent);
    }
    cmode.matcher = buildModeRegex(cmode);
    return cmode;
  }
  if (!language.compilerExtensions)
    language.compilerExtensions = [];
  if (language.contains && language.contains.includes("self")) {
    throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
  }
  language.classNameAliases = inherit$1(language.classNameAliases || {});
  return compileMode(language);
}
function dependencyOnParent(mode) {
  if (!mode)
    return false;
  return mode.endsWithParent || dependencyOnParent(mode.starts);
}
function expandOrCloneMode(mode) {
  if (mode.variants && !mode.cachedVariants) {
    mode.cachedVariants = mode.variants.map(function(variant) {
      return inherit$1(mode, { variants: null }, variant);
    });
  }
  if (mode.cachedVariants) {
    return mode.cachedVariants;
  }
  if (dependencyOnParent(mode)) {
    return inherit$1(mode, {
      starts: mode.starts ? inherit$1(mode.starts) : null
    });
  }
  if (Object.isFrozen(mode)) {
    return inherit$1(mode);
  }
  return mode;
}
var version = "11.3.1";
class HTMLInjectionError extends Error {
  constructor(reason, html2) {
    super(reason);
    this.name = "HTMLInjectionError";
    this.html = html2;
  }
}
const escape$1 = escapeHTML;
const inherit = inherit$1;
const NO_MATCH = Symbol("nomatch");
const MAX_KEYWORD_HITS = 7;
const HLJS = function(hljs) {
  const languages = Object.create(null);
  const aliases2 = Object.create(null);
  const plugins = [];
  let SAFE_MODE = true;
  const LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
  const PLAINTEXT_LANGUAGE = {
    disableAutodetect: true,
    name: "Plain text",
    contains: []
  };
  let options = {
    ignoreUnescapedHTML: false,
    throwUnescapedHTML: false,
    noHighlightRe: /^(no-?highlight)$/i,
    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
    classPrefix: "hljs-",
    cssSelector: "pre code",
    languages: null,
    __emitter: TokenTreeEmitter
  };
  function shouldNotHighlight(languageName) {
    return options.noHighlightRe.test(languageName);
  }
  function blockLanguage(block) {
    let classes = block.className + " ";
    classes += block.parentNode ? block.parentNode.className : "";
    const match5 = options.languageDetectRe.exec(classes);
    if (match5) {
      const language = getLanguage(match5[1]);
      if (!language) {
        warn$1(LANGUAGE_NOT_FOUND.replace("{}", match5[1]));
        warn$1("Falling back to no-highlight mode for this block.", block);
      }
      return language ? match5[1] : "no-highlight";
    }
    return classes.split(/\s+/).find((_class) => shouldNotHighlight(_class) || getLanguage(_class));
  }
  function highlight2(codeOrLanguageName, optionsOrCode, ignoreIllegals) {
    let code4 = "";
    let languageName = "";
    if (typeof optionsOrCode === "object") {
      code4 = codeOrLanguageName;
      ignoreIllegals = optionsOrCode.ignoreIllegals;
      languageName = optionsOrCode.language;
    } else {
      deprecated("10.7.0", "highlight(lang, code, ...args) has been deprecated.");
      deprecated("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277");
      languageName = codeOrLanguageName;
      code4 = optionsOrCode;
    }
    if (ignoreIllegals === void 0) {
      ignoreIllegals = true;
    }
    const context = {
      code: code4,
      language: languageName
    };
    fire("before:highlight", context);
    const result = context.result ? context.result : _highlight(context.language, context.code, ignoreIllegals);
    result.code = context.code;
    fire("after:highlight", result);
    return result;
  }
  function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
    const keywordHits = Object.create(null);
    function keywordData(mode, matchText) {
      return mode.keywords[matchText];
    }
    function processKeywords() {
      if (!top.keywords) {
        emitter.addText(modeBuffer);
        return;
      }
      let lastIndex = 0;
      top.keywordPatternRe.lastIndex = 0;
      let match5 = top.keywordPatternRe.exec(modeBuffer);
      let buf = "";
      while (match5) {
        buf += modeBuffer.substring(lastIndex, match5.index);
        const word = language.case_insensitive ? match5[0].toLowerCase() : match5[0];
        const data = keywordData(top, word);
        if (data) {
          const [kind, keywordRelevance] = data;
          emitter.addText(buf);
          buf = "";
          keywordHits[word] = (keywordHits[word] || 0) + 1;
          if (keywordHits[word] <= MAX_KEYWORD_HITS)
            relevance += keywordRelevance;
          if (kind.startsWith("_")) {
            buf += match5[0];
          } else {
            const cssClass = language.classNameAliases[kind] || kind;
            emitter.addKeyword(match5[0], cssClass);
          }
        } else {
          buf += match5[0];
        }
        lastIndex = top.keywordPatternRe.lastIndex;
        match5 = top.keywordPatternRe.exec(modeBuffer);
      }
      buf += modeBuffer.substr(lastIndex);
      emitter.addText(buf);
    }
    function processSubLanguage() {
      if (modeBuffer === "")
        return;
      let result2 = null;
      if (typeof top.subLanguage === "string") {
        if (!languages[top.subLanguage]) {
          emitter.addText(modeBuffer);
          return;
        }
        result2 = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);
        continuations[top.subLanguage] = result2._top;
      } else {
        result2 = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);
      }
      if (top.relevance > 0) {
        relevance += result2.relevance;
      }
      emitter.addSublanguage(result2._emitter, result2.language);
    }
    function processBuffer() {
      if (top.subLanguage != null) {
        processSubLanguage();
      } else {
        processKeywords();
      }
      modeBuffer = "";
    }
    function emitMultiClass(scope, match5) {
      let i2 = 1;
      while (match5[i2] !== void 0) {
        if (!scope._emit[i2]) {
          i2++;
          continue;
        }
        const klass = language.classNameAliases[scope[i2]] || scope[i2];
        const text = match5[i2];
        if (klass) {
          emitter.addKeyword(text, klass);
        } else {
          modeBuffer = text;
          processKeywords();
          modeBuffer = "";
        }
        i2++;
      }
    }
    function startNewMode(mode, match5) {
      if (mode.scope && typeof mode.scope === "string") {
        emitter.openNode(language.classNameAliases[mode.scope] || mode.scope);
      }
      if (mode.beginScope) {
        if (mode.beginScope._wrap) {
          emitter.addKeyword(modeBuffer, language.classNameAliases[mode.beginScope._wrap] || mode.beginScope._wrap);
          modeBuffer = "";
        } else if (mode.beginScope._multi) {
          emitMultiClass(mode.beginScope, match5);
          modeBuffer = "";
        }
      }
      top = Object.create(mode, { parent: { value: top } });
      return top;
    }
    function endOfMode(mode, match5, matchPlusRemainder) {
      let matched = startsWith(mode.endRe, matchPlusRemainder);
      if (matched) {
        if (mode["on:end"]) {
          const resp = new Response$1(mode);
          mode["on:end"](match5, resp);
          if (resp.isMatchIgnored)
            matched = false;
        }
        if (matched) {
          while (mode.endsParent && mode.parent) {
            mode = mode.parent;
          }
          return mode;
        }
      }
      if (mode.endsWithParent) {
        return endOfMode(mode.parent, match5, matchPlusRemainder);
      }
    }
    function doIgnore(lexeme) {
      if (top.matcher.regexIndex === 0) {
        modeBuffer += lexeme[0];
        return 1;
      } else {
        resumeScanAtSamePosition = true;
        return 0;
      }
    }
    function doBeginMatch(match5) {
      const lexeme = match5[0];
      const newMode = match5.rule;
      const resp = new Response$1(newMode);
      const beforeCallbacks = [
        newMode.__beforeBegin,
        newMode["on:begin"]
      ];
      for (const cb2 of beforeCallbacks) {
        if (!cb2)
          continue;
        cb2(match5, resp);
        if (resp.isMatchIgnored)
          return doIgnore(lexeme);
      }
      if (newMode.skip) {
        modeBuffer += lexeme;
      } else {
        if (newMode.excludeBegin) {
          modeBuffer += lexeme;
        }
        processBuffer();
        if (!newMode.returnBegin && !newMode.excludeBegin) {
          modeBuffer = lexeme;
        }
      }
      startNewMode(newMode, match5);
      return newMode.returnBegin ? 0 : lexeme.length;
    }
    function doEndMatch(match5) {
      const lexeme = match5[0];
      const matchPlusRemainder = codeToHighlight.substr(match5.index);
      const endMode = endOfMode(top, match5, matchPlusRemainder);
      if (!endMode) {
        return NO_MATCH;
      }
      const origin = top;
      if (top.endScope && top.endScope._wrap) {
        processBuffer();
        emitter.addKeyword(lexeme, top.endScope._wrap);
      } else if (top.endScope && top.endScope._multi) {
        processBuffer();
        emitMultiClass(top.endScope, match5);
      } else if (origin.skip) {
        modeBuffer += lexeme;
      } else {
        if (!(origin.returnEnd || origin.excludeEnd)) {
          modeBuffer += lexeme;
        }
        processBuffer();
        if (origin.excludeEnd) {
          modeBuffer = lexeme;
        }
      }
      do {
        if (top.scope) {
          emitter.closeNode();
        }
        if (!top.skip && !top.subLanguage) {
          relevance += top.relevance;
        }
        top = top.parent;
      } while (top !== endMode.parent);
      if (endMode.starts) {
        startNewMode(endMode.starts, match5);
      }
      return origin.returnEnd ? 0 : lexeme.length;
    }
    function processContinuations() {
      const list = [];
      for (let current = top; current !== language; current = current.parent) {
        if (current.scope) {
          list.unshift(current.scope);
        }
      }
      list.forEach((item) => emitter.openNode(item));
    }
    let lastMatch = {};
    function processLexeme(textBeforeMatch, match5) {
      const lexeme = match5 && match5[0];
      modeBuffer += textBeforeMatch;
      if (lexeme == null) {
        processBuffer();
        return 0;
      }
      if (lastMatch.type === "begin" && match5.type === "end" && lastMatch.index === match5.index && lexeme === "") {
        modeBuffer += codeToHighlight.slice(match5.index, match5.index + 1);
        if (!SAFE_MODE) {
          const err = new Error(`0 width match regex (${languageName})`);
          err.languageName = languageName;
          err.badRule = lastMatch.rule;
          throw err;
        }
        return 1;
      }
      lastMatch = match5;
      if (match5.type === "begin") {
        return doBeginMatch(match5);
      } else if (match5.type === "illegal" && !ignoreIllegals) {
        const err = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.scope || "<unnamed>") + '"');
        err.mode = top;
        throw err;
      } else if (match5.type === "end") {
        const processed = doEndMatch(match5);
        if (processed !== NO_MATCH) {
          return processed;
        }
      }
      if (match5.type === "illegal" && lexeme === "") {
        return 1;
      }
      if (iterations > 1e5 && iterations > match5.index * 3) {
        const err = new Error("potential infinite loop, way more iterations than matches");
        throw err;
      }
      modeBuffer += lexeme;
      return lexeme.length;
    }
    const language = getLanguage(languageName);
    if (!language) {
      error(LANGUAGE_NOT_FOUND.replace("{}", languageName));
      throw new Error('Unknown language: "' + languageName + '"');
    }
    const md2 = compileLanguage(language);
    let result = "";
    let top = continuation || md2;
    const continuations = {};
    const emitter = new options.__emitter(options);
    processContinuations();
    let modeBuffer = "";
    let relevance = 0;
    let index = 0;
    let iterations = 0;
    let resumeScanAtSamePosition = false;
    try {
      top.matcher.considerAll();
      for (; ; ) {
        iterations++;
        if (resumeScanAtSamePosition) {
          resumeScanAtSamePosition = false;
        } else {
          top.matcher.considerAll();
        }
        top.matcher.lastIndex = index;
        const match5 = top.matcher.exec(codeToHighlight);
        if (!match5)
          break;
        const beforeMatch = codeToHighlight.substring(index, match5.index);
        const processedCount = processLexeme(beforeMatch, match5);
        index = match5.index + processedCount;
      }
      processLexeme(codeToHighlight.substr(index));
      emitter.closeAllNodes();
      emitter.finalize();
      result = emitter.toHTML();
      return {
        language: languageName,
        value: result,
        relevance,
        illegal: false,
        _emitter: emitter,
        _top: top
      };
    } catch (err) {
      if (err.message && err.message.includes("Illegal")) {
        return {
          language: languageName,
          value: escape$1(codeToHighlight),
          illegal: true,
          relevance: 0,
          _illegalBy: {
            message: err.message,
            index,
            context: codeToHighlight.slice(index - 100, index + 100),
            mode: err.mode,
            resultSoFar: result
          },
          _emitter: emitter
        };
      } else if (SAFE_MODE) {
        return {
          language: languageName,
          value: escape$1(codeToHighlight),
          illegal: false,
          relevance: 0,
          errorRaised: err,
          _emitter: emitter,
          _top: top
        };
      } else {
        throw err;
      }
    }
  }
  function justTextHighlightResult(code4) {
    const result = {
      value: escape$1(code4),
      illegal: false,
      relevance: 0,
      _top: PLAINTEXT_LANGUAGE,
      _emitter: new options.__emitter(options)
    };
    result._emitter.addText(code4);
    return result;
  }
  function highlightAuto(code4, languageSubset) {
    languageSubset = languageSubset || options.languages || Object.keys(languages);
    const plaintext = justTextHighlightResult(code4);
    const results = languageSubset.filter(getLanguage).filter(autoDetection).map((name2) => _highlight(name2, code4, false));
    results.unshift(plaintext);
    const sorted = results.sort((a2, b2) => {
      if (a2.relevance !== b2.relevance)
        return b2.relevance - a2.relevance;
      if (a2.language && b2.language) {
        if (getLanguage(a2.language).supersetOf === b2.language) {
          return 1;
        } else if (getLanguage(b2.language).supersetOf === a2.language) {
          return -1;
        }
      }
      return 0;
    });
    const [best, secondBest] = sorted;
    const result = best;
    result.secondBest = secondBest;
    return result;
  }
  function updateClassName(element, currentLang, resultLang) {
    const language = currentLang && aliases2[currentLang] || resultLang;
    element.classList.add("hljs");
    element.classList.add(`language-${language}`);
  }
  function highlightElement(element) {
    let node = null;
    const language = blockLanguage(element);
    if (shouldNotHighlight(language))
      return;
    fire("before:highlightElement", { el: element, language });
    if (element.children.length > 0) {
      if (!options.ignoreUnescapedHTML) {
        console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk.");
        console.warn("https://github.com/highlightjs/highlight.js/issues/2886");
        console.warn(element);
      }
      if (options.throwUnescapedHTML) {
        const err = new HTMLInjectionError("One of your code blocks includes unescaped HTML.", element.innerHTML);
        throw err;
      }
    }
    node = element;
    const text = node.textContent;
    const result = language ? highlight2(text, { language, ignoreIllegals: true }) : highlightAuto(text);
    element.innerHTML = result.value;
    updateClassName(element, language, result.language);
    element.result = {
      language: result.language,
      re: result.relevance,
      relevance: result.relevance
    };
    if (result.secondBest) {
      element.secondBest = {
        language: result.secondBest.language,
        relevance: result.secondBest.relevance
      };
    }
    fire("after:highlightElement", { el: element, result, text });
  }
  function configure(userOptions) {
    options = inherit(options, userOptions);
  }
  const initHighlighting = () => {
    highlightAll();
    deprecated("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
  };
  function initHighlightingOnLoad() {
    highlightAll();
    deprecated("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
  }
  let wantsHighlight = false;
  function highlightAll() {
    if (document.readyState === "loading") {
      wantsHighlight = true;
      return;
    }
    const blocks = document.querySelectorAll(options.cssSelector);
    blocks.forEach(highlightElement);
  }
  function boot() {
    if (wantsHighlight)
      highlightAll();
  }
  if (typeof window !== "undefined" && window.addEventListener) {
    window.addEventListener("DOMContentLoaded", boot, false);
  }
  function registerLanguage(languageName, languageDefinition) {
    let lang2 = null;
    try {
      lang2 = languageDefinition(hljs);
    } catch (error$1) {
      error("Language definition for '{}' could not be registered.".replace("{}", languageName));
      if (!SAFE_MODE) {
        throw error$1;
      } else {
        error(error$1);
      }
      lang2 = PLAINTEXT_LANGUAGE;
    }
    if (!lang2.name)
      lang2.name = languageName;
    languages[languageName] = lang2;
    lang2.rawDefinition = languageDefinition.bind(null, hljs);
    if (lang2.aliases) {
      registerAliases(lang2.aliases, { languageName });
    }
  }
  function unregisterLanguage(languageName) {
    delete languages[languageName];
    for (const alias of Object.keys(aliases2)) {
      if (aliases2[alias] === languageName) {
        delete aliases2[alias];
      }
    }
  }
  function listLanguages() {
    return Object.keys(languages);
  }
  function getLanguage(name2) {
    name2 = (name2 || "").toLowerCase();
    return languages[name2] || languages[aliases2[name2]];
  }
  function registerAliases(aliasList, { languageName }) {
    if (typeof aliasList === "string") {
      aliasList = [aliasList];
    }
    aliasList.forEach((alias) => {
      aliases2[alias.toLowerCase()] = languageName;
    });
  }
  function autoDetection(name2) {
    const lang2 = getLanguage(name2);
    return lang2 && !lang2.disableAutodetect;
  }
  function upgradePluginAPI(plugin) {
    if (plugin["before:highlightBlock"] && !plugin["before:highlightElement"]) {
      plugin["before:highlightElement"] = (data) => {
        plugin["before:highlightBlock"](Object.assign({ block: data.el }, data));
      };
    }
    if (plugin["after:highlightBlock"] && !plugin["after:highlightElement"]) {
      plugin["after:highlightElement"] = (data) => {
        plugin["after:highlightBlock"](Object.assign({ block: data.el }, data));
      };
    }
  }
  function addPlugin(plugin) {
    upgradePluginAPI(plugin);
    plugins.push(plugin);
  }
  function fire(event, args) {
    const cb2 = event;
    plugins.forEach(function(plugin) {
      if (plugin[cb2]) {
        plugin[cb2](args);
      }
    });
  }
  function deprecateHighlightBlock(el2) {
    deprecated("10.7.0", "highlightBlock will be removed entirely in v12.0");
    deprecated("10.7.0", "Please use highlightElement now.");
    return highlightElement(el2);
  }
  Object.assign(hljs, {
    highlight: highlight2,
    highlightAuto,
    highlightAll,
    highlightElement,
    highlightBlock: deprecateHighlightBlock,
    configure,
    initHighlighting,
    initHighlightingOnLoad,
    registerLanguage,
    unregisterLanguage,
    listLanguages,
    getLanguage,
    registerAliases,
    autoDetection,
    inherit,
    addPlugin
  });
  hljs.debugMode = function() {
    SAFE_MODE = false;
  };
  hljs.safeMode = function() {
    SAFE_MODE = true;
  };
  hljs.versionString = version;
  hljs.regex = {
    concat,
    lookahead,
    either,
    optional,
    anyNumberOfTimes
  };
  for (const key in MODES$1) {
    if (typeof MODES$1[key] === "object") {
      deepFreeze$1(MODES$1[key]);
    }
  }
  Object.assign(hljs, MODES$1);
  return hljs;
};
var highlight = HLJS({});
var core = highlight;
highlight.HighlightJS = highlight;
highlight.default = highlight;
function bash(hljs) {
  const regex = hljs.regex;
  const VAR = {};
  const BRACED_VAR = {
    begin: /\$\{/,
    end: /\}/,
    contains: [
      "self",
      {
        begin: /:-/,
        contains: [VAR]
      }
    ]
  };
  Object.assign(VAR, {
    className: "variable",
    variants: [
      {
        begin: regex.concat(/\$[\w\d#@][\w\d_]*/, `(?![\\w\\d])(?![$])`)
      },
      BRACED_VAR
    ]
  });
  const SUBST = {
    className: "subst",
    begin: /\$\(/,
    end: /\)/,
    contains: [hljs.BACKSLASH_ESCAPE]
  };
  const HERE_DOC = {
    begin: /<<-?\s*(?=\w+)/,
    starts: {
      contains: [
        hljs.END_SAME_AS_BEGIN({
          begin: /(\w+)/,
          end: /(\w+)/,
          className: "string"
        })
      ]
    }
  };
  const QUOTE_STRING = {
    className: "string",
    begin: /"/,
    end: /"/,
    contains: [hljs.BACKSLASH_ESCAPE, VAR, SUBST]
  };
  SUBST.contains.push(QUOTE_STRING);
  const ESCAPED_QUOTE = {
    className: "",
    begin: /\\"/
  };
  const APOS_STRING = {
    className: "string",
    begin: /'/,
    end: /'/
  };
  const ARITHMETIC = {
    begin: /\$\(\(/,
    end: /\)\)/,
    contains: [
      { begin: /\d+#[0-9a-f]+/, className: "number" },
      hljs.NUMBER_MODE,
      VAR
    ]
  };
  const SH_LIKE_SHELLS = [
    "fish",
    "bash",
    "zsh",
    "sh",
    "csh",
    "ksh",
    "tcsh",
    "dash",
    "scsh"
  ];
  const KNOWN_SHEBANG = hljs.SHEBANG({
    binary: `(${SH_LIKE_SHELLS.join("|")})`,
    relevance: 10
  });
  const FUNCTION = {
    className: "function",
    begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
    returnBegin: true,
    contains: [hljs.inherit(hljs.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
    relevance: 0
  };
  const KEYWORDS2 = [
    "if",
    "then",
    "else",
    "elif",
    "fi",
    "for",
    "while",
    "in",
    "do",
    "done",
    "case",
    "esac",
    "function"
  ];
  const LITERALS2 = ["true", "false"];
  const PATH_MODE = {
    match: /(\/[a-z._-]+)+/
  };
  const SHELL_BUILT_INS = [
    "break",
    "cd",
    "continue",
    "eval",
    "exec",
    "exit",
    "export",
    "getopts",
    "hash",
    "pwd",
    "readonly",
    "return",
    "shift",
    "test",
    "times",
    "trap",
    "umask",
    "unset"
  ];
  const BASH_BUILT_INS = [
    "alias",
    "bind",
    "builtin",
    "caller",
    "command",
    "declare",
    "echo",
    "enable",
    "help",
    "let",
    "local",
    "logout",
    "mapfile",
    "printf",
    "read",
    "readarray",
    "source",
    "type",
    "typeset",
    "ulimit",
    "unalias"
  ];
  const ZSH_BUILT_INS = [
    "autoload",
    "bg",
    "bindkey",
    "bye",
    "cap",
    "chdir",
    "clone",
    "comparguments",
    "compcall",
    "compctl",
    "compdescribe",
    "compfiles",
    "compgroups",
    "compquote",
    "comptags",
    "comptry",
    "compvalues",
    "dirs",
    "disable",
    "disown",
    "echotc",
    "echoti",
    "emulate",
    "fc",
    "fg",
    "float",
    "functions",
    "getcap",
    "getln",
    "history",
    "integer",
    "jobs",
    "kill",
    "limit",
    "log",
    "noglob",
    "popd",
    "print",
    "pushd",
    "pushln",
    "rehash",
    "sched",
    "setcap",
    "setopt",
    "stat",
    "suspend",
    "ttyctl",
    "unfunction",
    "unhash",
    "unlimit",
    "unsetopt",
    "vared",
    "wait",
    "whence",
    "where",
    "which",
    "zcompile",
    "zformat",
    "zftp",
    "zle",
    "zmodload",
    "zparseopts",
    "zprof",
    "zpty",
    "zregexparse",
    "zsocket",
    "zstyle",
    "ztcp"
  ];
  const GNU_CORE_UTILS = [
    "chcon",
    "chgrp",
    "chown",
    "chmod",
    "cp",
    "dd",
    "df",
    "dir",
    "dircolors",
    "ln",
    "ls",
    "mkdir",
    "mkfifo",
    "mknod",
    "mktemp",
    "mv",
    "realpath",
    "rm",
    "rmdir",
    "shred",
    "sync",
    "touch",
    "truncate",
    "vdir",
    "b2sum",
    "base32",
    "base64",
    "cat",
    "cksum",
    "comm",
    "csplit",
    "cut",
    "expand",
    "fmt",
    "fold",
    "head",
    "join",
    "md5sum",
    "nl",
    "numfmt",
    "od",
    "paste",
    "ptx",
    "pr",
    "sha1sum",
    "sha224sum",
    "sha256sum",
    "sha384sum",
    "sha512sum",
    "shuf",
    "sort",
    "split",
    "sum",
    "tac",
    "tail",
    "tr",
    "tsort",
    "unexpand",
    "uniq",
    "wc",
    "arch",
    "basename",
    "chroot",
    "date",
    "dirname",
    "du",
    "echo",
    "env",
    "expr",
    "factor",
    "groups",
    "hostid",
    "id",
    "link",
    "logname",
    "nice",
    "nohup",
    "nproc",
    "pathchk",
    "pinky",
    "printenv",
    "printf",
    "pwd",
    "readlink",
    "runcon",
    "seq",
    "sleep",
    "stat",
    "stdbuf",
    "stty",
    "tee",
    "test",
    "timeout",
    "tty",
    "uname",
    "unlink",
    "uptime",
    "users",
    "who",
    "whoami",
    "yes"
  ];
  return {
    name: "Bash",
    aliases: ["sh"],
    keywords: {
      $pattern: /\b[a-z._-]+\b/,
      keyword: KEYWORDS2,
      literal: LITERALS2,
      built_in: [
        ...SHELL_BUILT_INS,
        ...BASH_BUILT_INS,
        "set",
        "shopt",
        ...ZSH_BUILT_INS,
        ...GNU_CORE_UTILS
      ]
    },
    contains: [
      KNOWN_SHEBANG,
      hljs.SHEBANG(),
      FUNCTION,
      ARITHMETIC,
      hljs.HASH_COMMENT_MODE,
      HERE_DOC,
      PATH_MODE,
      QUOTE_STRING,
      ESCAPED_QUOTE,
      APOS_STRING,
      VAR
    ]
  };
}
const MODES = (hljs) => {
  return {
    IMPORTANT: {
      scope: "meta",
      begin: "!important"
    },
    BLOCK_COMMENT: hljs.C_BLOCK_COMMENT_MODE,
    HEXCOLOR: {
      scope: "number",
      begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
    },
    FUNCTION_DISPATCH: {
      className: "built_in",
      begin: /[\w-]+(?=\()/
    },
    ATTRIBUTE_SELECTOR_MODE: {
      scope: "selector-attr",
      begin: /\[/,
      end: /\]/,
      illegal: "$",
      contains: [hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE]
    },
    CSS_NUMBER_MODE: {
      scope: "number",
      begin: hljs.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
      relevance: 0
    },
    CSS_VARIABLE: {
      className: "attr",
      begin: /--[A-Za-z][A-Za-z0-9_-]*/
    }
  };
};
const TAGS = [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "audio",
  "b",
  "blockquote",
  "body",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "mark",
  "menu",
  "nav",
  "object",
  "ol",
  "p",
  "q",
  "quote",
  "samp",
  "section",
  "span",
  "strong",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "ul",
  "var",
  "video"
];
const MEDIA_FEATURES = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  "min-width",
  "max-width",
  "min-height",
  "max-height"
];
const PSEUDO_CLASSES = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  "host",
  "host-context",
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  "lang",
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  "nth-child",
  "nth-col",
  "nth-last-child",
  "nth-last-col",
  "nth-last-of-type",
  "nth-of-type",
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
];
const PSEUDO_ELEMENTS = [
  "after",
  "backdrop",
  "before",
  "cue",
  "cue-region",
  "first-letter",
  "first-line",
  "grammar-error",
  "marker",
  "part",
  "placeholder",
  "selection",
  "slotted",
  "spelling-error"
];
const ATTRIBUTES = [
  "align-content",
  "align-items",
  "align-self",
  "all",
  "animation",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-timing-function",
  "backface-visibility",
  "background",
  "background-attachment",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-repeat",
  "background-size",
  "border",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "bottom",
  "box-decoration-break",
  "box-shadow",
  "box-sizing",
  "break-after",
  "break-before",
  "break-inside",
  "caption-side",
  "caret-color",
  "clear",
  "clip",
  "clip-path",
  "clip-rule",
  "color",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columns",
  "contain",
  "content",
  "content-visibility",
  "counter-increment",
  "counter-reset",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "direction",
  "display",
  "empty-cells",
  "filter",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "float",
  "flow",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-size",
  "font-size-adjust",
  "font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-variant",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "gap",
  "glyph-orientation-vertical",
  "grid",
  "grid-area",
  "grid-auto-columns",
  "grid-auto-flow",
  "grid-auto-rows",
  "grid-column",
  "grid-column-end",
  "grid-column-start",
  "grid-gap",
  "grid-row",
  "grid-row-end",
  "grid-row-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "hyphens",
  "icon",
  "image-orientation",
  "image-rendering",
  "image-resolution",
  "ime-mode",
  "isolation",
  "justify-content",
  "left",
  "letter-spacing",
  "line-break",
  "line-height",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "margin",
  "margin-bottom",
  "margin-left",
  "margin-right",
  "margin-top",
  "marks",
  "mask",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "mask-clip",
  "mask-composite",
  "mask-image",
  "mask-mode",
  "mask-origin",
  "mask-position",
  "mask-repeat",
  "mask-size",
  "mask-type",
  "max-height",
  "max-width",
  "min-height",
  "min-width",
  "mix-blend-mode",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "none",
  "normal",
  "object-fit",
  "object-position",
  "opacity",
  "order",
  "orphans",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "overflow",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "padding",
  "padding-bottom",
  "padding-left",
  "padding-right",
  "padding-top",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "pause",
  "pause-after",
  "pause-before",
  "perspective",
  "perspective-origin",
  "pointer-events",
  "position",
  "quotes",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "right",
  "row-gap",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-align",
  "scroll-snap-stop",
  "scroll-snap-type",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "speak",
  "speak-as",
  "src",
  "tab-size",
  "table-layout",
  "text-align",
  "text-align-all",
  "text-align-last",
  "text-combine-upright",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-style",
  "text-emphasis",
  "text-emphasis-color",
  "text-emphasis-position",
  "text-emphasis-style",
  "text-indent",
  "text-justify",
  "text-orientation",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-transform",
  "text-underline-position",
  "top",
  "transform",
  "transform-box",
  "transform-origin",
  "transform-style",
  "transition",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "unicode-bidi",
  "vertical-align",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "white-space",
  "widows",
  "width",
  "will-change",
  "word-break",
  "word-spacing",
  "word-wrap",
  "writing-mode",
  "z-index"
].reverse();
function css(hljs) {
  const regex = hljs.regex;
  const modes = MODES(hljs);
  const VENDOR_PREFIX = {
    begin: /-(webkit|moz|ms|o)-(?=[a-z])/
  };
  const AT_MODIFIERS = "and or not only";
  const AT_PROPERTY_RE = /@-?\w[\w]*(-\w+)*/;
  const IDENT_RE2 = "[a-zA-Z-][a-zA-Z0-9_-]*";
  const STRINGS = [hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE];
  return {
    name: "CSS",
    case_insensitive: true,
    illegal: /[=|'\$]/,
    keywords: {
      keyframePosition: "from to"
    },
    classNameAliases: {
      keyframePosition: "selector-tag"
    },
    contains: [
      modes.BLOCK_COMMENT,
      VENDOR_PREFIX,
      modes.CSS_NUMBER_MODE,
      {
        className: "selector-id",
        begin: /#[A-Za-z0-9_-]+/,
        relevance: 0
      },
      {
        className: "selector-class",
        begin: "\\." + IDENT_RE2,
        relevance: 0
      },
      modes.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-pseudo",
        variants: [
          {
            begin: ":(" + PSEUDO_CLASSES.join("|") + ")"
          },
          {
            begin: ":(:)?(" + PSEUDO_ELEMENTS.join("|") + ")"
          }
        ]
      },
      modes.CSS_VARIABLE,
      {
        className: "attribute",
        begin: "\\b(" + ATTRIBUTES.join("|") + ")\\b"
      },
      {
        begin: /:/,
        end: /[;}{]/,
        contains: [
          modes.BLOCK_COMMENT,
          modes.HEXCOLOR,
          modes.IMPORTANT,
          modes.CSS_NUMBER_MODE,
          ...STRINGS,
          {
            begin: /(url|data-uri)\(/,
            end: /\)/,
            relevance: 0,
            keywords: {
              built_in: "url data-uri"
            },
            contains: [
              {
                className: "string",
                begin: /[^)]/,
                endsWithParent: true,
                excludeEnd: true
              }
            ]
          },
          modes.FUNCTION_DISPATCH
        ]
      },
      {
        begin: regex.lookahead(/@/),
        end: "[{;]",
        relevance: 0,
        illegal: /:/,
        contains: [
          {
            className: "keyword",
            begin: AT_PROPERTY_RE
          },
          {
            begin: /\s/,
            endsWithParent: true,
            excludeEnd: true,
            relevance: 0,
            keywords: {
              $pattern: /[a-z-]+/,
              keyword: AT_MODIFIERS,
              attribute: MEDIA_FEATURES.join(" ")
            },
            contains: [
              {
                begin: /[a-z-]+(?=:)/,
                className: "attribute"
              },
              ...STRINGS,
              modes.CSS_NUMBER_MODE
            ]
          }
        ]
      },
      {
        className: "selector-tag",
        begin: "\\b(" + TAGS.join("|") + ")\\b"
      }
    ]
  };
}
const IDENT_RE = "[A-Za-z$_][0-9A-Za-z$_]*";
const KEYWORDS = [
  "as",
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends"
];
const LITERALS = ["true", "false", "null", "undefined", "NaN", "Infinity"];
const TYPES = [
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  "Math",
  "Date",
  "Number",
  "BigInt",
  "String",
  "RegExp",
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  "Reflect",
  "Proxy",
  "Intl",
  "WebAssembly"
];
const ERROR_TYPES = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
];
const BUILT_IN_GLOBALS = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
];
const BUILT_IN_VARIABLES = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "module",
  "global"
];
const BUILT_INS = [].concat(BUILT_IN_GLOBALS, TYPES, ERROR_TYPES);
function javascript(hljs) {
  const regex = hljs.regex;
  const hasClosingTag = (match5, { after }) => {
    const tag2 = "</" + match5[0].slice(1);
    const pos = match5.input.indexOf(tag2, after);
    return pos !== -1;
  };
  const IDENT_RE$12 = IDENT_RE;
  const FRAGMENT = {
    begin: "<>",
    end: "</>"
  };
  const XML_SELF_CLOSING = /<[A-Za-z0-9\\._:-]+\s*\/>/;
  const XML_TAG = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    isTrulyOpeningTag: (match5, response) => {
      const afterMatchIndex = match5[0].length + match5.index;
      const nextChar = match5.input[afterMatchIndex];
      if (nextChar === "<" || nextChar === ",") {
        response.ignoreMatch();
        return;
      }
      if (nextChar === ">") {
        if (!hasClosingTag(match5, { after: afterMatchIndex })) {
          response.ignoreMatch();
        }
      }
      let m2;
      const afterMatch = match5.input.substr(afterMatchIndex);
      if (m2 = afterMatch.match(/^\s+extends\s+/)) {
        if (m2.index === 0) {
          response.ignoreMatch();
          return;
        }
      }
    }
  };
  const KEYWORDS$1 = {
    $pattern: IDENT_RE,
    keyword: KEYWORDS,
    literal: LITERALS,
    built_in: BUILT_INS,
    "variable.language": BUILT_IN_VARIABLES
  };
  const decimalDigits = "[0-9](_?[0-9])*";
  const frac = `\\.(${decimalDigits})`;
  const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
  const NUMBER = {
    className: "number",
    variants: [
      {
        begin: `(\\b(${decimalInteger})((${frac})|\\.)?|(${frac}))[eE][+-]?(${decimalDigits})\\b`
      },
      {
        begin: `\\b(${decimalInteger})\\b((${frac})\\b|\\.)?|(${frac})\\b`
      },
      { begin: `\\b(0|[1-9](_?[0-9])*)n\\b` },
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  };
  const SUBST = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: KEYWORDS$1,
    contains: []
  };
  const HTML_TEMPLATE = {
    begin: "html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [hljs.BACKSLASH_ESCAPE, SUBST],
      subLanguage: "xml"
    }
  };
  const CSS_TEMPLATE = {
    begin: "css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [hljs.BACKSLASH_ESCAPE, SUBST],
      subLanguage: "css"
    }
  };
  const TEMPLATE_STRING = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [hljs.BACKSLASH_ESCAPE, SUBST]
  };
  const JSDOC_COMMENT = hljs.COMMENT(/\/\*\*(?!\/)/, "\\*/", {
    relevance: 0,
    contains: [
      {
        begin: "(?=@[A-Za-z]+)",
        relevance: 0,
        contains: [
          {
            className: "doctag",
            begin: "@[A-Za-z]+"
          },
          {
            className: "type",
            begin: "\\{",
            end: "\\}",
            excludeEnd: true,
            excludeBegin: true,
            relevance: 0
          },
          {
            className: "variable",
            begin: IDENT_RE$12 + "(?=\\s*(-)|$)",
            endsParent: true,
            relevance: 0
          },
          {
            begin: /(?=[^\n])\s/,
            relevance: 0
          }
        ]
      }
    ]
  });
  const COMMENT2 = {
    className: "comment",
    variants: [
      JSDOC_COMMENT,
      hljs.C_BLOCK_COMMENT_MODE,
      hljs.C_LINE_COMMENT_MODE
    ]
  };
  const SUBST_INTERNALS = [
    hljs.APOS_STRING_MODE,
    hljs.QUOTE_STRING_MODE,
    HTML_TEMPLATE,
    CSS_TEMPLATE,
    TEMPLATE_STRING,
    NUMBER
  ];
  SUBST.contains = SUBST_INTERNALS.concat({
    begin: /\{/,
    end: /\}/,
    keywords: KEYWORDS$1,
    contains: ["self"].concat(SUBST_INTERNALS)
  });
  const SUBST_AND_COMMENTS = [].concat(COMMENT2, SUBST.contains);
  const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
    {
      begin: /\(/,
      end: /\)/,
      keywords: KEYWORDS$1,
      contains: ["self"].concat(SUBST_AND_COMMENTS)
    }
  ]);
  const PARAMS = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    excludeBegin: true,
    excludeEnd: true,
    keywords: KEYWORDS$1,
    contains: PARAMS_CONTAINS
  };
  const CLASS_OR_EXTENDS = {
    variants: [
      {
        match: [
          /class/,
          /\s+/,
          IDENT_RE$12,
          /\s+/,
          /extends/,
          /\s+/,
          regex.concat(IDENT_RE$12, "(", regex.concat(/\./, IDENT_RE$12), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      {
        match: [/class/, /\s+/, IDENT_RE$12],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  };
  const CLASS_REFERENCE = {
    relevance: 0,
    match: regex.either(/\bJSON/, /\b[A-Z][a-z]+([A-Z][a-z]+|\d)*/, /\b[A-Z]{2,}([A-Z][a-z]+|\d)+/),
    className: "title.class",
    keywords: {
      _: [
        ...TYPES,
        ...ERROR_TYPES
      ]
    }
  };
  const USE_STRICT = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  };
  const FUNCTION_DEFINITION = {
    variants: [
      {
        match: [/function/, /\s+/, IDENT_RE$12, /(?=\s*\()/]
      },
      {
        match: [/function/, /\s*(?=\()/]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [PARAMS],
    illegal: /%/
  };
  const UPPER_CASE_CONSTANT = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function noneOf(list) {
    return regex.concat("(?!", list.join("|"), ")");
  }
  const FUNCTION_CALL = {
    match: regex.concat(/\b/, noneOf([...BUILT_IN_GLOBALS, "super"]), IDENT_RE$12, regex.lookahead(/\(/)),
    className: "title.function",
    relevance: 0
  };
  const PROPERTY_ACCESS = {
    begin: regex.concat(/\./, regex.lookahead(regex.concat(IDENT_RE$12, /(?![0-9A-Za-z$_(])/))),
    end: IDENT_RE$12,
    excludeBegin: true,
    keywords: "prototype",
    className: "property",
    relevance: 0
  };
  const GETTER_OR_SETTER = {
    match: [/get|set/, /\s+/, IDENT_RE$12, /(?=\()/],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        begin: /\(\)/
      },
      PARAMS
    ]
  };
  const FUNC_LEAD_IN_RE = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + hljs.UNDERSCORE_IDENT_RE + ")\\s*=>";
  const FUNCTION_VARIABLE = {
    match: [
      /const|var|let/,
      /\s+/,
      IDENT_RE$12,
      /\s*/,
      /=\s*/,
      regex.lookahead(FUNC_LEAD_IN_RE)
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [PARAMS]
  };
  return {
    name: "Javascript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: KEYWORDS$1,
    exports: { PARAMS_CONTAINS, CLASS_REFERENCE },
    illegal: /#(?![$_A-z])/,
    contains: [
      hljs.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      USE_STRICT,
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      HTML_TEMPLATE,
      CSS_TEMPLATE,
      TEMPLATE_STRING,
      COMMENT2,
      NUMBER,
      CLASS_REFERENCE,
      {
        className: "attr",
        begin: IDENT_RE$12 + regex.lookahead(":"),
        relevance: 0
      },
      FUNCTION_VARIABLE,
      {
        begin: "(" + hljs.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          COMMENT2,
          hljs.REGEXP_MODE,
          {
            className: "function",
            begin: FUNC_LEAD_IN_RE,
            returnBegin: true,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: hljs.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: true
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: true,
                    excludeEnd: true,
                    keywords: KEYWORDS$1,
                    contains: PARAMS_CONTAINS
                  }
                ]
              }
            ]
          },
          {
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            variants: [
              { begin: FRAGMENT.begin, end: FRAGMENT.end },
              { match: XML_SELF_CLOSING },
              {
                begin: XML_TAG.begin,
                "on:begin": XML_TAG.isTrulyOpeningTag,
                end: XML_TAG.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: XML_TAG.begin,
                end: XML_TAG.end,
                skip: true,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      FUNCTION_DEFINITION,
      {
        beginKeywords: "while if switch catch for"
      },
      {
        begin: "\\b(?!function)" + hljs.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        returnBegin: true,
        label: "func.def",
        contains: [
          PARAMS,
          hljs.inherit(hljs.TITLE_MODE, {
            begin: IDENT_RE$12,
            className: "title.function"
          })
        ]
      },
      {
        match: /\.\.\./,
        relevance: 0
      },
      PROPERTY_ACCESS,
      {
        match: "\\$" + IDENT_RE$12,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [PARAMS]
      },
      FUNCTION_CALL,
      UPPER_CASE_CONSTANT,
      CLASS_OR_EXTENDS,
      GETTER_OR_SETTER,
      {
        match: /\$[(.]/
      }
    ]
  };
}
function php(hljs) {
  const VARIABLE = {
    className: "variable",
    begin: `\\$+[a-zA-Z_\x7F-\xFF][a-zA-Z0-9_\x7F-\xFF]*(?![A-Za-z0-9])(?![$])`
  };
  const PREPROCESSOR = {
    className: "meta",
    variants: [
      { begin: /<\?php/, relevance: 10 },
      { begin: /<\?[=]?/ },
      { begin: /\?>/ }
    ]
  };
  const SUBST = {
    className: "subst",
    variants: [{ begin: /\$\w+/ }, { begin: /\{\$/, end: /\}/ }]
  };
  const SINGLE_QUOTED = hljs.inherit(hljs.APOS_STRING_MODE, {
    illegal: null
  });
  const DOUBLE_QUOTED = hljs.inherit(hljs.QUOTE_STRING_MODE, {
    illegal: null,
    contains: hljs.QUOTE_STRING_MODE.contains.concat(SUBST)
  });
  const HEREDOC = hljs.END_SAME_AS_BEGIN({
    begin: /<<<[ \t]*(\w+)\n/,
    end: /[ \t]*(\w+)\b/,
    contains: hljs.QUOTE_STRING_MODE.contains.concat(SUBST)
  });
  const STRING = {
    className: "string",
    contains: [hljs.BACKSLASH_ESCAPE, PREPROCESSOR],
    variants: [
      hljs.inherit(SINGLE_QUOTED, {
        begin: "b'",
        end: "'"
      }),
      hljs.inherit(DOUBLE_QUOTED, {
        begin: 'b"',
        end: '"'
      }),
      DOUBLE_QUOTED,
      SINGLE_QUOTED,
      HEREDOC
    ]
  };
  const NUMBER = {
    className: "number",
    variants: [
      { begin: `\\b0b[01]+(?:_[01]+)*\\b` },
      { begin: `\\b0o[0-7]+(?:_[0-7]+)*\\b` },
      { begin: `\\b0x[\\da-f]+(?:_[\\da-f]+)*\\b` },
      {
        begin: `(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:e[+-]?\\d+)?`
      }
    ],
    relevance: 0
  };
  const KEYWORDS2 = {
    keyword: "__CLASS__ __DIR__ __FILE__ __FUNCTION__ __LINE__ __METHOD__ __NAMESPACE__ __TRAIT__ die echo exit include include_once print require require_once array abstract and as binary bool boolean break callable case catch class clone const continue declare default do double else elseif empty enddeclare endfor endforeach endif endswitch endwhile enum eval extends final finally float for foreach from global goto if implements instanceof insteadof int integer interface isset iterable list match|0 mixed new object or private protected public real return string switch throw trait try unset use var void while xor yield",
    literal: "false null true",
    built_in: "Error|0 AppendIterator ArgumentCountError ArithmeticError ArrayIterator ArrayObject AssertionError BadFunctionCallException BadMethodCallException CachingIterator CallbackFilterIterator CompileError Countable DirectoryIterator DivisionByZeroError DomainException EmptyIterator ErrorException Exception FilesystemIterator FilterIterator GlobIterator InfiniteIterator InvalidArgumentException IteratorIterator LengthException LimitIterator LogicException MultipleIterator NoRewindIterator OutOfBoundsException OutOfRangeException OuterIterator OverflowException ParentIterator ParseError RangeException RecursiveArrayIterator RecursiveCachingIterator RecursiveCallbackFilterIterator RecursiveDirectoryIterator RecursiveFilterIterator RecursiveIterator RecursiveIteratorIterator RecursiveRegexIterator RecursiveTreeIterator RegexIterator RuntimeException SeekableIterator SplDoublyLinkedList SplFileInfo SplFileObject SplFixedArray SplHeap SplMaxHeap SplMinHeap SplObjectStorage SplObserver SplObserver SplPriorityQueue SplQueue SplStack SplSubject SplSubject SplTempFileObject TypeError UnderflowException UnexpectedValueException UnhandledMatchError ArrayAccess Closure Generator Iterator IteratorAggregate Serializable Stringable Throwable Traversable WeakReference WeakMap Directory __PHP_Incomplete_Class parent php_user_filter self static stdClass"
  };
  return {
    case_insensitive: true,
    keywords: KEYWORDS2,
    contains: [
      hljs.HASH_COMMENT_MODE,
      hljs.COMMENT("//", "$", { contains: [PREPROCESSOR] }),
      hljs.COMMENT("/\\*", "\\*/", {
        contains: [
          {
            className: "doctag",
            begin: "@[A-Za-z]+"
          }
        ]
      }),
      hljs.COMMENT("__halt_compiler.+?;", false, {
        endsWithParent: true,
        keywords: "__halt_compiler"
      }),
      PREPROCESSOR,
      {
        className: "keyword",
        begin: /\$this\b/
      },
      VARIABLE,
      {
        begin: /(::|->)+[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/
      },
      {
        className: "function",
        relevance: 0,
        beginKeywords: "fn function",
        end: /[;{]/,
        excludeEnd: true,
        illegal: "[$%\\[]",
        contains: [
          {
            beginKeywords: "use"
          },
          hljs.UNDERSCORE_TITLE_MODE,
          {
            begin: "=>",
            endsParent: true
          },
          {
            className: "params",
            begin: "\\(",
            end: "\\)",
            excludeBegin: true,
            excludeEnd: true,
            keywords: KEYWORDS2,
            contains: [
              "self",
              VARIABLE,
              hljs.C_BLOCK_COMMENT_MODE,
              STRING,
              NUMBER
            ]
          }
        ]
      },
      {
        className: "class",
        variants: [
          { beginKeywords: "enum", illegal: /[($"]/ },
          {
            beginKeywords: "class interface trait",
            illegal: /[:($"]/
          }
        ],
        relevance: 0,
        end: /\{/,
        excludeEnd: true,
        contains: [
          { beginKeywords: "extends implements" },
          hljs.UNDERSCORE_TITLE_MODE
        ]
      },
      {
        beginKeywords: "namespace",
        relevance: 0,
        end: ";",
        illegal: /[.']/,
        contains: [hljs.UNDERSCORE_TITLE_MODE]
      },
      {
        beginKeywords: "use",
        relevance: 0,
        end: ";",
        contains: [hljs.UNDERSCORE_TITLE_MODE]
      },
      STRING,
      NUMBER
    ]
  };
}
function xml(hljs) {
  const regex = hljs.regex;
  const TAG_NAME_RE = regex.concat(/[A-Z_]/, regex.optional(/[A-Z0-9_.-]*:/), /[A-Z0-9_.-]*/);
  const XML_IDENT_RE = /[A-Za-z0-9._:-]+/;
  const XML_ENTITIES = {
    className: "symbol",
    begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
  };
  const XML_META_KEYWORDS = {
    begin: /\s/,
    contains: [
      {
        className: "keyword",
        begin: /#?[a-z_][a-z1-9_-]+/,
        illegal: /\n/
      }
    ]
  };
  const XML_META_PAR_KEYWORDS = hljs.inherit(XML_META_KEYWORDS, {
    begin: /\(/,
    end: /\)/
  });
  const APOS_META_STRING_MODE = hljs.inherit(hljs.APOS_STRING_MODE, {
    className: "string"
  });
  const QUOTE_META_STRING_MODE = hljs.inherit(hljs.QUOTE_STRING_MODE, {
    className: "string"
  });
  const TAG_INTERNALS = {
    endsWithParent: true,
    illegal: /</,
    relevance: 0,
    contains: [
      {
        className: "attr",
        begin: XML_IDENT_RE,
        relevance: 0
      },
      {
        begin: /=\s*/,
        relevance: 0,
        contains: [
          {
            className: "string",
            endsParent: true,
            variants: [
              {
                begin: /"/,
                end: /"/,
                contains: [XML_ENTITIES]
              },
              {
                begin: /'/,
                end: /'/,
                contains: [XML_ENTITIES]
              },
              {
                begin: /[^\s"'=<>`]+/
              }
            ]
          }
        ]
      }
    ]
  };
  return {
    name: "HTML, XML",
    aliases: [
      "html",
      "xhtml",
      "rss",
      "atom",
      "xjb",
      "xsd",
      "xsl",
      "plist",
      "wsf",
      "svg"
    ],
    case_insensitive: true,
    contains: [
      {
        className: "meta",
        begin: /<![a-z]/,
        end: />/,
        relevance: 10,
        contains: [
          XML_META_KEYWORDS,
          QUOTE_META_STRING_MODE,
          APOS_META_STRING_MODE,
          XML_META_PAR_KEYWORDS,
          {
            begin: /\[/,
            end: /\]/,
            contains: [
              {
                className: "meta",
                begin: /<![a-z]/,
                end: />/,
                contains: [
                  XML_META_KEYWORDS,
                  XML_META_PAR_KEYWORDS,
                  QUOTE_META_STRING_MODE,
                  APOS_META_STRING_MODE
                ]
              }
            ]
          }
        ]
      },
      hljs.COMMENT(/<!--/, /-->/, {
        relevance: 10
      }),
      {
        begin: /<!\[CDATA\[/,
        end: /\]\]>/,
        relevance: 10
      },
      XML_ENTITIES,
      {
        className: "meta",
        begin: /<\?xml/,
        end: /\?>/,
        relevance: 10
      },
      {
        className: "tag",
        begin: /<style(?=\s|>)/,
        end: />/,
        keywords: {
          name: "style"
        },
        contains: [TAG_INTERNALS],
        starts: {
          end: /<\/style>/,
          returnEnd: true,
          subLanguage: ["css", "xml"]
        }
      },
      {
        className: "tag",
        begin: /<script(?=\s|>)/,
        end: />/,
        keywords: {
          name: "script"
        },
        contains: [TAG_INTERNALS],
        starts: {
          end: /<\/script>/,
          returnEnd: true,
          subLanguage: ["javascript", "handlebars", "xml"]
        }
      },
      {
        className: "tag",
        begin: /<>|<\/>/
      },
      {
        className: "tag",
        begin: regex.concat(/</, regex.lookahead(regex.concat(TAG_NAME_RE, regex.either(/\/>/, />/, /\s/)))),
        end: /\/?>/,
        contains: [
          {
            className: "name",
            begin: TAG_NAME_RE,
            relevance: 0,
            starts: TAG_INTERNALS
          }
        ]
      },
      {
        className: "tag",
        begin: regex.concat(/<\//, regex.lookahead(regex.concat(TAG_NAME_RE, />/))),
        contains: [
          {
            className: "name",
            begin: TAG_NAME_RE,
            relevance: 0
          },
          {
            begin: />/,
            relevance: 0,
            endsParent: true
          }
        ]
      }
    ]
  };
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const standardProperty$1 = (options, element) => {
  if (element.kind === "method" && element.descriptor && !("value" in element.descriptor)) {
    return __spreadProps(__spreadValues({}, element), {
      finisher(clazz) {
        clazz.createProperty(element.key, options);
      }
    });
  } else {
    return {
      kind: "field",
      key: Symbol(),
      placement: "own",
      descriptor: {},
      originalKey: element.key,
      initializer() {
        if (typeof element.initializer === "function") {
          this[element.key] = element.initializer.call(this);
        }
      },
      finisher(clazz) {
        clazz.createProperty(element.key, options);
      }
    };
  }
};
const legacyProperty$1 = (options, proto2, name2) => {
  proto2.constructor.createProperty(name2, options);
};
function property$1(options) {
  return (protoOrDescriptor, name2) => name2 !== void 0 ? legacyProperty$1(options, protoOrDescriptor, name2) : standardProperty$1(options, protoOrDescriptor);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const decorateProperty$1 = ({ finisher, descriptor: descriptor2 }) => (protoOrDescriptor, name2) => {
  var _a2;
  if (name2 !== void 0) {
    const ctor = protoOrDescriptor.constructor;
    if (descriptor2 !== void 0) {
      Object.defineProperty(protoOrDescriptor, name2, descriptor2(name2));
    }
    finisher === null || finisher === void 0 ? void 0 : finisher(ctor, name2);
  } else {
    const key = (_a2 = protoOrDescriptor.originalKey) !== null && _a2 !== void 0 ? _a2 : protoOrDescriptor.key;
    const info = descriptor2 != void 0 ? {
      kind: "method",
      placement: "prototype",
      key,
      descriptor: descriptor2(protoOrDescriptor.key)
    } : __spreadProps(__spreadValues({}, protoOrDescriptor), { key });
    if (finisher != void 0) {
      info.finisher = function(ctor) {
        finisher(ctor, key);
      };
    }
    return info;
  }
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function query(selector, cache) {
  return decorateProperty$1({
    descriptor: (name2) => {
      const descriptor2 = {
        get() {
          var _a2, _b2;
          return (_b2 = (_a2 = this.renderRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector(selector)) !== null && _b2 !== void 0 ? _b2 : null;
        },
        enumerable: true,
        configurable: true
      };
      if (cache) {
        const key = typeof name2 === "symbol" ? Symbol() : `__${name2}`;
        descriptor2.get = function() {
          var _a2, _b2;
          if (this[key] === void 0) {
            this[key] = (_b2 = (_a2 = this.renderRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector(selector)) !== null && _b2 !== void 0 ? _b2 : null;
          }
          return this[key];
        };
      }
      return descriptor2;
    }
  });
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function queryAssignedNodes(slotName = "", flatten2 = false, selector = "") {
  return decorateProperty$1({
    descriptor: (_name) => ({
      get() {
        var _a2, _b2, _c2;
        const slotSelector = `slot${slotName ? `[name=${slotName}]` : ":not([name])"}`;
        const slot = (_a2 = this.renderRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector(slotSelector);
        let nodes = (_c2 = (_b2 = slot) === null || _b2 === void 0 ? void 0 : _b2.assignedNodes({ flatten: flatten2 })) !== null && _c2 !== void 0 ? _c2 : [];
        if (selector) {
          nodes = nodes.filter((node) => node.nodeType === Node.ELEMENT_NODE && node.matches(selector));
        }
        return nodes;
      },
      enumerable: true,
      configurable: true
    })
  });
}
function decodeHtmlEntities(string2) {
  const txt = document.createElement("textarea");
  txt.innerHTML = string2;
  return txt.value;
}
var __css$6 = ".hljs {\n    font-size: calc(1rem * var(--s-scale, 1));\n    display: block;\n    overflow: hidden;\n    padding: var(--s-theme-ui-code-paddingBlock, 3rem) var(--s-theme-ui-code-paddingInline, 3rem);\n    background-color: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-surface-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-surface-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-surface-lightness-offset, 0)) * 1%),var(--s-theme-color-current-surface-a, 1));\n    border-radius: var(--s-theme-ui-code-borderRadius, 10px);\n    color: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-surfaceForeground-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-surfaceForeground-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-surfaceForeground-lightness-offset, 0)) * 1%),var(--s-theme-color-current-surfaceForeground-a, 1));\n    line-height: 1.5 !important;\n}\n\n    .hljs,\n    .hljs.hljs-subst {\n        color: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-surfaceForeground-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-surfaceForeground-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-surfaceForeground-lightness-offset, 0)) * 1%),var(--s-theme-color-current-surfaceForeground-a, 1));\n    }\n\n    .hljs .hljs-selector-tag {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),1);\n    }\n\n    .hljs .hljs-selector-id {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0)) * 1%),var(--s-theme-color-info-a, 1));\n        font-weight: bold;\n    }\n\n    .hljs .hljs-selector-class {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-selector-attr {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-selector-pseudo {\n        color: #88C0D0;\n    }\n\n    .hljs .hljs-addition {\n        background-color: rgba(163, 190, 140, 0.5);\n    }\n\n    .hljs .hljs-deletion {\n        background-color: rgba(191, 97, 106, 0.5);\n    }\n\n    .hljs .hljs-built_in,\n    .hljs .hljs-type {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-class {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-function {\n        color: #88C0D0;\n    }\n\n    .hljs .hljs-function > .hljs-title {\n        color: #88C0D0;\n    }\n\n    .hljs .hljs-keyword,\n    .hljs .hljs-literal,\n    .hljs .hljs-symbol {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),1);\n    }\n\n    .hljs .hljs-number {\n        color: #B48EAD;\n    }\n\n    .hljs .hljs-regexp {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,0)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs .hljs-string {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,0)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs .hljs-title {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-params {\n        color: hsla(calc(var(--s-theme-color-text-h, 0) + var(--s-theme-color-text-spin ,0)),calc((var(--s-theme-color-text-s, 0)) * 1%),calc((var(--s-theme-color-text-l, 0)) * 1%),var(--s-theme-color-text-a, 1));\n    }\n\n    .hljs .hljs-bullet {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),1);\n    }\n\n    .hljs .hljs-code {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-emphasis {\n        font-style: italic;\n    }\n\n    .hljs .hljs-formula {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-strong {\n        font-weight: bold;\n    }\n\n    .hljs .hljs-link:hover {\n        text-decoration: underline;\n    }\n\n    .hljs .hljs-quote {\n        color: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-30-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-30-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-30-lightness-offset, 0)) * 1%),var(--s-theme-color-current-30-a, 1));\n    }\n\n    .hljs .hljs-comment {\n        color: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-30-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-30-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-30-lightness-offset, 0)) * 1%),var(--s-theme-color-current-30-a, 1));\n    }\n\n    .hljs .hljs-doctag {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-meta,\n    .hljs .hljs-meta-keyword {\n        color: #5E81AC;\n    }\n\n    .hljs .hljs-meta-string {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,0)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs .hljs-attr {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs .hljs-attribute {\n        color: hsla(calc(var(--s-theme-color-text-h, 0) + var(--s-theme-color-text-30-spin ,0)),calc((var(--s-theme-color-text-s, 0) + var(--s-theme-color-text-30-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-text-l, 0) + var(--s-theme-color-text-30-lightness-offset, 0)) * 1%),var(--s-theme-color-text-30-a, 1));\n    }\n\n    .hljs .hljs-builtin-name {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),1);\n    }\n\n    .hljs .hljs-name {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),1);\n    }\n\n    .hljs .hljs-section {\n        color: #88C0D0;\n    }\n\n    .hljs .hljs-tag {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),1);\n    }\n\n    .hljs .hljs-variable {\n        color: hsla(calc(var(--s-theme-color-text-h, 0) + var(--s-theme-color-text-spin ,0)),calc((var(--s-theme-color-text-s, 0)) * 1%),calc((var(--s-theme-color-text-l, 0)) * 1%),var(--s-theme-color-text-a, 1));\n    }\n\n    .hljs .hljs-template-variable {\n        color: hsla(calc(var(--s-theme-color-text-h, 0) + var(--s-theme-color-text-spin ,0)),calc((var(--s-theme-color-text-s, 0)) * 1%),calc((var(--s-theme-color-text-l, 0)) * 1%),var(--s-theme-color-text-a, 1));\n    }\n\n    .hljs .hljs-template-tag {\n        color: #5E81AC;\n    }\n\n    .hljs.abnf .hljs-attribute {\n        color: #88C0D0;\n    }\n\n    .hljs.abnf .hljs-symbol {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,0)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs.apache .hljs-attribute {\n        color: #88C0D0;\n    }\n\n    .hljs.apache .hljs-section {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),1);\n    }\n\n    .hljs.arduino .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.aspectj .hljs-meta {\n        color: #D08770;\n    }\n\n    .hljs.aspectj > .hljs-title {\n        color: #88C0D0;\n    }\n\n    .hljs.bnf .hljs-attribute {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs.clojure .hljs-name {\n        color: #88C0D0;\n    }\n\n    .hljs.clojure .hljs-symbol {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,0)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n    }\n\n    .hljs.coq .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.cpp .hljs-meta-string {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs.css .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.css .hljs-keyword {\n        color: #D08770;\n    }\n\n    .hljs.diff .hljs-meta {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs.ebnf .hljs-attribute {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs.glsl .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.groovy .hljs-meta:not(:first-child) {\n        color: #D08770;\n    }\n\n    .hljs.haxe .hljs-meta {\n        color: #D08770;\n    }\n\n    .hljs.java .hljs-meta {\n        color: #D08770;\n    }\n\n    .hljs.ldif .hljs-attribute {\n        color: hsla(calc(var(--s-theme-color-info-h, 0) + var(--s-theme-color-info-spin ,0)),calc((var(--s-theme-color-info-s, 0)) * 1%),calc((var(--s-theme-color-info-l, 0)) * 1%),var(--s-theme-color-info-a, 1));\n    }\n\n    .hljs.lisp .hljs-name {\n        color: #88C0D0;\n    }\n\n    .hljs.lua .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.moonscript .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.nginx .hljs-attribute {\n        color: #88C0D0;\n    }\n\n    .hljs.nginx .hljs-section {\n        color: #5E81AC;\n    }\n\n    .hljs.pf .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.processing .hljs-built_in {\n        color: #88C0D0;\n    }\n\n    .hljs.scss .hljs-keyword {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),1);\n    }\n\n    .hljs.stylus .hljs-keyword {\n        color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,340)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),1);\n    }\n\n    .hljs.swift .hljs-meta {\n        color: #D08770;\n    }\n\n    .hljs.vim .hljs-built_in {\n        color: #88C0D0;\n        font-style: italic;\n    }\n\n    .hljs.yaml .hljs-meta {\n        color: #D08770;\n    }\n\n:host {\n    display: block;\n}\n\n.s-code-example > * {\n        display: none;\n    }\n\n.s-code-example[mounted] > * {\n            display: block;\n        }\n\n.hljs {\n    overflow: visible;\n    white-space: pre-wrap;\n}\n\n.s-code-example__slot {\n    display: none;\n}\n\n.s-code-example__nav {\n    position: relative;\n    z-index: 1;\n}\n\n.s-code-example__tabs {\n    display: flex;\n    list-style: none;\n}\n\n.s-code-example__tab {\n}\n\n.s-code-example__content {\n    position: relative;\n    --paddingBlock: var(--s-theme-ui-code-paddingBlock, 3rem);\n    overflow: hidden;\n}\n\n.s-code-example[lines] .s-code-example__content {\n        max-height: calc(1.5em * var(--max-lines) + (var(--paddingBlock) * 2));\n    }\n\n.s-code-example--more .s-code-example__content {\n        max-height: 99999px !important;\n    }\n\n:not([bare]) .s-code-example__content {\n    transition: var(--s-theme-ui-code-transition, 0);\n    border-radius: var(--s-theme-ui-code-borderRadius, 10px);box-shadow: var(--s-theme-ui-code-depth, 0);\n}\n\n.s-code-example__more-bar {\n    position: absolute;\n    bottom: 0;\n    left: 0;\n    height: 50%;\n    width: 100%;\n    opacity: 0;\n    pointer-events: none;\n    display: flex;\n    align-items: flex-end;\n}\n\n.s-code-example[lines] .s-code-example__more-bar {\n        opacity: 1;\n        pointer-events: all;\n    }\n\n:not([bare]) .s-code-example__more-bar {\n    text-align: center;\n    padding-inline: var(--s-theme-ui-default-paddingInline, 1.5em);\n    padding-block: var(--s-theme-ui-default-paddingBlock, 0.75em);\n    justify-content: center;\n}\n\n:not([bare]) .s-code-example__more-bar:before {\n        content: '';\n        position: absolute;\n        bottom: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;background: linear-gradient(0deg, hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-surface-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-surface-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-surface-lightness-offset, 0)) * 1%),var(--s-theme-color-current-surface-a, 1)) 0%, hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-spin ,0)),calc((var(--s-theme-color-current-s, 0)) * 1%),calc((var(--s-theme-color-current-l, 0)) * 1%),0) 100%);\n    }\n\n.s-code-example__code {\n    display: none;\n    line-height: 0;\n}\n\n.s-code-example__code[active] {\n        display: block;\n    }\n\n.s-code-example__code > code {\n        line-height: 1;\n    }\n\n.s-code-example__toolbar {\n    position: absolute;\n    right: var(--s-theme-space-20, 0.75rem);\n    top: var(--s-theme-space-20, 0.75rem);\n}\n\n.s-code-example__toolbar > * {\n        font-size: 20px;\n        opacity: 0.5;\n    }\n\n.s-code-example__toolbar > *:hover {\n            opacity: 1;\n        }\n\n[toolbar-position='nav'] .s-code-example__toolbar {\n    right: var(--s-theme-space-20, 0.75rem);\n    top: var(--s-theme-space-20, 0.75rem);\n    /* transform: translate(0, -50%); */\n}\n";
class SCodeExampleInterface extends SInterface {
  static get _definition() {
    return {
      theme: {
        description: "Specify the theme you want to use for your code example",
        type: "String",
        default: "https://gitcdn.link/repo/PrismJS/prism-themes/master/themes/prism-nord.css"
      },
      active: {
        type: "String"
      },
      toolbar: {
        type: "Array<String>",
        values: ["copy"],
        default: ["copy"]
      },
      toolbarPosition: {
        type: "String",
        values: ["content", "nav"],
        default: "nav"
      },
      languages: {
        type: "Object",
        default: {}
      },
      lines: {
        type: "Number"
      },
      moreLabel: {
        type: "String",
        default: "Show more"
      },
      lessLabel: {
        type: "String",
        default: "Show less"
      },
      moreAction: {
        type: "String",
        default: "toggle"
      },
      more: {
        type: "Boolean",
        default: false
      }
    };
  }
}
var e$3 = { version: "2.4.1" }, t$3 = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
function n$3(e20) {
  return e20 && Object.prototype.hasOwnProperty.call(e20, "default") ? e20.default : e20;
}
function r$3(e20) {
  var t2 = { exports: {} };
  return e20(t2, t2.exports), t2.exports;
}
var i$3 = r$3(function(e20, t2) {
  function n2() {
  }
  function r2(e21, t3, n3, r3, i3) {
    for (var u2 = 0, o2 = t3.length, s2 = 0, a2 = 0; u2 < o2; u2++) {
      var c2 = t3[u2];
      if (c2.removed) {
        if (c2.value = e21.join(r3.slice(a2, a2 + c2.count)), a2 += c2.count, u2 && t3[u2 - 1].added) {
          var l2 = t3[u2 - 1];
          t3[u2 - 1] = t3[u2], t3[u2] = l2;
        }
      } else {
        if (!c2.added && i3) {
          var p2 = n3.slice(s2, s2 + c2.count);
          p2 = p2.map(function(e22, t4) {
            var n4 = r3[a2 + t4];
            return n4.length > e22.length ? n4 : e22;
          }), c2.value = e21.join(p2);
        } else
          c2.value = e21.join(n3.slice(s2, s2 + c2.count));
        s2 += c2.count, c2.added || (a2 += c2.count);
      }
    }
    var f2 = t3[o2 - 1];
    return o2 > 1 && typeof f2.value == "string" && (f2.added || f2.removed) && e21.equals("", f2.value) && (t3[o2 - 2].value += f2.value, t3.pop()), t3;
  }
  function i2(e21) {
    return { newPos: e21.newPos, components: e21.components.slice(0) };
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = n2, n2.prototype = {
    diff: function(e21, t3) {
      var n3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, u2 = n3.callback;
      typeof n3 == "function" && (u2 = n3, n3 = {}), this.options = n3;
      var o2 = this;
      function s2(e22) {
        return u2 ? (setTimeout(function() {
          u2(void 0, e22);
        }, 0), true) : e22;
      }
      e21 = this.castInput(e21), t3 = this.castInput(t3), e21 = this.removeEmpty(this.tokenize(e21));
      var a2 = (t3 = this.removeEmpty(this.tokenize(t3))).length, c2 = e21.length, l2 = 1, p2 = a2 + c2, f2 = [{ newPos: -1, components: [] }], d2 = this.extractCommon(f2[0], t3, e21, 0);
      if (f2[0].newPos + 1 >= a2 && d2 + 1 >= c2)
        return s2([{ value: this.join(t3), count: t3.length }]);
      function h2() {
        for (var n4 = -1 * l2; n4 <= l2; n4 += 2) {
          var u3 = void 0, p3 = f2[n4 - 1], d3 = f2[n4 + 1], h3 = (d3 ? d3.newPos : 0) - n4;
          p3 && (f2[n4 - 1] = void 0);
          var g3 = p3 && p3.newPos + 1 < a2, m2 = d3 && 0 <= h3 && h3 < c2;
          if (g3 || m2) {
            if (!g3 || m2 && p3.newPos < d3.newPos ? (u3 = i2(d3), o2.pushComponent(u3.components, void 0, true)) : ((u3 = p3).newPos++, o2.pushComponent(u3.components, true, void 0)), h3 = o2.extractCommon(u3, t3, e21, n4), u3.newPos + 1 >= a2 && h3 + 1 >= c2)
              return s2(r2(o2, u3.components, t3, e21, o2.useLongestToken));
            f2[n4] = u3;
          } else
            f2[n4] = void 0;
        }
        l2++;
      }
      if (u2)
        !function e22() {
          setTimeout(function() {
            if (l2 > p2)
              return u2();
            h2() || e22();
          }, 0);
        }();
      else
        for (; l2 <= p2; ) {
          var g2 = h2();
          if (g2)
            return g2;
        }
    },
    pushComponent: function(e21, t3, n3) {
      var r3 = e21[e21.length - 1];
      r3 && r3.added === t3 && r3.removed === n3 ? e21[e21.length - 1] = {
        count: r3.count + 1,
        added: t3,
        removed: n3
      } : e21.push({ count: 1, added: t3, removed: n3 });
    },
    extractCommon: function(e21, t3, n3, r3) {
      for (var i3 = t3.length, u2 = n3.length, o2 = e21.newPos, s2 = o2 - r3, a2 = 0; o2 + 1 < i3 && s2 + 1 < u2 && this.equals(t3[o2 + 1], n3[s2 + 1]); )
        o2++, s2++, a2++;
      return a2 && e21.components.push({ count: a2 }), e21.newPos = o2, s2;
    },
    equals: function(e21, t3) {
      return this.options.comparator ? this.options.comparator(e21, t3) : e21 === t3 || this.options.ignoreCase && e21.toLowerCase() === t3.toLowerCase();
    },
    removeEmpty: function(e21) {
      for (var t3 = [], n3 = 0; n3 < e21.length; n3++)
        e21[n3] && t3.push(e21[n3]);
      return t3;
    },
    castInput: function(e21) {
      return e21;
    },
    tokenize: function(e21) {
      return e21.split("");
    },
    join: function(e21) {
      return e21.join("");
    }
  };
}), u$3 = r$3(function(e20, t2) {
  var n2;
  Object.defineProperty(t2, "__esModule", { value: true }), t2.diffChars = function(e21, t3, n3) {
    return r2.diff(e21, t3, n3);
  }, t2.characterDiff = void 0;
  var r2 = new ((n2 = i$3) && n2.__esModule ? n2 : { default: n2 }).default();
  t2.characterDiff = r2;
}), o$3 = function(e20, t2) {
  if (typeof e20 == "function")
    t2.callback = e20;
  else if (e20)
    for (var n2 in e20)
      e20.hasOwnProperty(n2) && (t2[n2] = e20[n2]);
  return t2;
};
var s$3, a$3, c$3 = Object.defineProperty({ generateOptions: o$3 }, "__esModule", {
  value: true
}), l$3 = r$3(function(e20, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.diffWords = function(e21, t3, n3) {
    return n3 = (0, c$3.generateOptions)(n3, { ignoreWhitespace: true }), s2.diff(e21, t3, n3);
  }, t2.diffWordsWithSpace = function(e21, t3, n3) {
    return s2.diff(e21, t3, n3);
  }, t2.wordDiff = void 0;
  var n2, r2 = (n2 = i$3) && n2.__esModule ? n2 : { default: n2 };
  var u2 = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/, o2 = /\S/, s2 = new r2.default();
  t2.wordDiff = s2, s2.equals = function(e21, t3) {
    return this.options.ignoreCase && (e21 = e21.toLowerCase(), t3 = t3.toLowerCase()), e21 === t3 || this.options.ignoreWhitespace && !o2.test(e21) && !o2.test(t3);
  }, s2.tokenize = function(e21) {
    for (var t3 = e21.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/), n3 = 0; n3 < t3.length - 1; n3++)
      !t3[n3 + 1] && t3[n3 + 2] && u2.test(t3[n3]) && u2.test(t3[n3 + 2]) && (t3[n3] += t3[n3 + 2], t3.splice(n3 + 1, 2), n3--);
    return t3;
  };
}), p$3 = r$3(function(e20, t2) {
  var n2;
  Object.defineProperty(t2, "__esModule", { value: true }), t2.diffLines = function(e21, t3, n3) {
    return r2.diff(e21, t3, n3);
  }, t2.diffTrimmedLines = function(e21, t3, n3) {
    var i2 = (0, c$3.generateOptions)(n3, { ignoreWhitespace: true });
    return r2.diff(e21, t3, i2);
  }, t2.lineDiff = void 0;
  var r2 = new ((n2 = i$3) && n2.__esModule ? n2 : { default: n2 }).default();
  t2.lineDiff = r2, r2.tokenize = function(e21) {
    var t3 = [], n3 = e21.split(/(\n|\r\n)/);
    n3[n3.length - 1] || n3.pop();
    for (var r3 = 0; r3 < n3.length; r3++) {
      var i2 = n3[r3];
      r3 % 2 && !this.options.newlineIsToken ? t3[t3.length - 1] += i2 : (this.options.ignoreWhitespace && (i2 = i2.trim()), t3.push(i2));
    }
    return t3;
  };
}), f$3 = r$3(function(e20, t2) {
  var n2;
  Object.defineProperty(t2, "__esModule", { value: true }), t2.diffSentences = function(e21, t3, n3) {
    return r2.diff(e21, t3, n3);
  }, t2.sentenceDiff = void 0;
  var r2 = new ((n2 = i$3) && n2.__esModule ? n2 : { default: n2 }).default();
  t2.sentenceDiff = r2, r2.tokenize = function(e21) {
    return e21.split(/(\S.+?[.!?])(?=\s+|$)/);
  };
}), d$3 = r$3(function(e20, t2) {
  var n2;
  Object.defineProperty(t2, "__esModule", { value: true }), t2.diffCss = function(e21, t3, n3) {
    return r2.diff(e21, t3, n3);
  }, t2.cssDiff = void 0;
  var r2 = new ((n2 = i$3) && n2.__esModule ? n2 : { default: n2 }).default();
  t2.cssDiff = r2, r2.tokenize = function(e21) {
    return e21.split(/([{}:;,]|\s+)/);
  };
}), h$3 = function(e20) {
  return e20 && e20.Math == Math && e20;
}, g$3 = h$3(typeof globalThis == "object" && globalThis) || h$3(typeof window == "object" && window) || h$3(typeof self == "object" && self) || h$3(typeof t$3 == "object" && t$3) || function() {
  return this;
}() || Function("return this")(), m$3 = function(e20) {
  try {
    return !!e20();
  } catch (e21) {
    return true;
  }
}, y$3 = !m$3(function() {
  return Object.defineProperty({}, 1, {
    get: function() {
      return 7;
    }
  })[1] != 7;
}), D$3 = {}.propertyIsEnumerable, E$3 = Object.getOwnPropertyDescriptor, C$3 = {
  f: E$3 && !D$3.call({ 1: 2 }, 1) ? function(e20) {
    var t2 = E$3(this, e20);
    return !!t2 && t2.enumerable;
  } : D$3
}, b$3 = function(e20, t2) {
  return {
    enumerable: !(1 & e20),
    configurable: !(2 & e20),
    writable: !(4 & e20),
    value: t2
  };
}, A$3 = {}.toString, v$3 = function(e20) {
  return A$3.call(e20).slice(8, -1);
}, F$3 = "".split, S$3 = m$3(function() {
  return !Object("z").propertyIsEnumerable(0);
}) ? function(e20) {
  return v$3(e20) == "String" ? F$3.call(e20, "") : Object(e20);
} : Object, x$3 = function(e20) {
  if (e20 == null)
    throw TypeError("Can't call method on " + e20);
  return e20;
}, w$3 = function(e20) {
  return S$3(x$3(e20));
}, T$3 = function(e20) {
  return typeof e20 == "object" ? e20 !== null : typeof e20 == "function";
}, B$3 = function(e20) {
  return typeof e20 == "function" ? e20 : void 0;
}, N$3 = function(e20, t2) {
  return arguments.length < 2 ? B$3(g$3[e20]) : g$3[e20] && g$3[e20][t2];
}, k$3 = N$3("navigator", "userAgent") || "", P$3 = g$3.process, O$3 = g$3.Deno, I$3 = P$3 && P$3.versions || O$3 && O$3.version, L$3 = I$3 && I$3.v8;
L$3 ? a$3 = (s$3 = L$3.split("."))[0] < 4 ? 1 : s$3[0] + s$3[1] : k$3 && (!(s$3 = k$3.match(/Edge\/(\d+)/)) || s$3[1] >= 74) && (s$3 = k$3.match(/Chrome\/(\d+)/)) && (a$3 = s$3[1]);
var j$3 = a$3 && +a$3, _$3 = !!Object.getOwnPropertySymbols && !m$3(function() {
  var e20 = Symbol();
  return !String(e20) || !(Object(e20) instanceof Symbol) || !Symbol.sham && j$3 && j$3 < 41;
}), M$3 = _$3 && !Symbol.sham && typeof Symbol.iterator == "symbol", R$3 = M$3 ? function(e20) {
  return typeof e20 == "symbol";
} : function(e20) {
  var t2 = N$3("Symbol");
  return typeof t2 == "function" && Object(e20) instanceof t2;
}, $$3 = function(e20, t2) {
  try {
    Object.defineProperty(g$3, e20, {
      value: t2,
      configurable: true,
      writable: true
    });
  } catch (n2) {
    g$3[e20] = t2;
  }
  return t2;
}, V$3 = g$3["__core-js_shared__"] || $$3("__core-js_shared__", {}), W$3 = r$3(function(e20) {
  (e20.exports = function(e21, t2) {
    return V$3[e21] || (V$3[e21] = t2 !== void 0 ? t2 : {});
  })("versions", []).push({
    version: "3.17.3",
    mode: "global",
    copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)"
  });
}), q$3 = function(e20) {
  return Object(x$3(e20));
}, U$3 = {}.hasOwnProperty, z$3 = Object.hasOwn || function(e20, t2) {
  return U$3.call(q$3(e20), t2);
}, G$3 = 0, H$3 = Math.random(), J$3 = function(e20) {
  return "Symbol(" + String(e20 === void 0 ? "" : e20) + ")_" + (++G$3 + H$3).toString(36);
}, X$3 = W$3("wks"), Y$3 = g$3.Symbol, K$3 = M$3 ? Y$3 : Y$3 && Y$3.withoutSetter || J$3, Q$3 = function(e20) {
  return z$3(X$3, e20) && (_$3 || typeof X$3[e20] == "string") || (_$3 && z$3(Y$3, e20) ? X$3[e20] = Y$3[e20] : X$3[e20] = K$3("Symbol." + e20)), X$3[e20];
}, Z$3 = Q$3("toPrimitive"), ee$3 = function(e20, t2) {
  if (!T$3(e20) || R$3(e20))
    return e20;
  var n2, r2 = e20[Z$3];
  if (r2 !== void 0) {
    if (t2 === void 0 && (t2 = "default"), n2 = r2.call(e20, t2), !T$3(n2) || R$3(n2))
      return n2;
    throw TypeError("Can't convert object to primitive value");
  }
  return t2 === void 0 && (t2 = "number"), function(e21, t3) {
    var n3, r3;
    if (t3 === "string" && typeof (n3 = e21.toString) == "function" && !T$3(r3 = n3.call(e21)))
      return r3;
    if (typeof (n3 = e21.valueOf) == "function" && !T$3(r3 = n3.call(e21)))
      return r3;
    if (t3 !== "string" && typeof (n3 = e21.toString) == "function" && !T$3(r3 = n3.call(e21)))
      return r3;
    throw TypeError("Can't convert object to primitive value");
  }(e20, t2);
}, te$3 = function(e20) {
  var t2 = ee$3(e20, "string");
  return R$3(t2) ? t2 : String(t2);
}, ne$3 = g$3.document, re$3 = T$3(ne$3) && T$3(ne$3.createElement), ie$3 = !y$3 && !m$3(function() {
  return Object.defineProperty((e20 = "div", re$3 ? ne$3.createElement(e20) : {}), "a", {
    get: function() {
      return 7;
    }
  }).a != 7;
  var e20;
}), ue$3 = Object.getOwnPropertyDescriptor, oe$3 = {
  f: y$3 ? ue$3 : function(e20, t2) {
    if (e20 = w$3(e20), t2 = te$3(t2), ie$3)
      try {
        return ue$3(e20, t2);
      } catch (e21) {
      }
    if (z$3(e20, t2))
      return b$3(!C$3.f.call(e20, t2), e20[t2]);
  }
}, se$3 = function(e20) {
  if (!T$3(e20))
    throw TypeError(String(e20) + " is not an object");
  return e20;
}, ae$3 = Object.defineProperty, ce$3 = {
  f: y$3 ? ae$3 : function(e20, t2, n2) {
    if (se$3(e20), t2 = te$3(t2), se$3(n2), ie$3)
      try {
        return ae$3(e20, t2, n2);
      } catch (e21) {
      }
    if ("get" in n2 || "set" in n2)
      throw TypeError("Accessors not supported");
    return "value" in n2 && (e20[t2] = n2.value), e20;
  }
}, le$3 = y$3 ? function(e20, t2, n2) {
  return ce$3.f(e20, t2, b$3(1, n2));
} : function(e20, t2, n2) {
  return e20[t2] = n2, e20;
}, pe$3 = Function.toString;
typeof V$3.inspectSource != "function" && (V$3.inspectSource = function(e20) {
  return pe$3.call(e20);
});
var fe$3, de$3, he$3, ge$3, me$3 = V$3.inspectSource, ye$3 = g$3.WeakMap, De$3 = typeof ye$3 == "function" && /native code/.test(me$3(ye$3)), Ee$3 = W$3("keys"), Ce$3 = {}, be$3 = g$3.WeakMap;
if (De$3 || V$3.state) {
  var Ae$3 = V$3.state || (V$3.state = new be$3()), ve$3 = Ae$3.get, Fe$3 = Ae$3.has, Se$3 = Ae$3.set;
  fe$3 = function(e20, t2) {
    if (Fe$3.call(Ae$3, e20))
      throw new TypeError("Object already initialized");
    return t2.facade = e20, Se$3.call(Ae$3, e20, t2), t2;
  }, de$3 = function(e20) {
    return ve$3.call(Ae$3, e20) || {};
  }, he$3 = function(e20) {
    return Fe$3.call(Ae$3, e20);
  };
} else {
  var xe$3 = Ee$3[ge$3 = "state"] || (Ee$3[ge$3] = J$3(ge$3));
  Ce$3[xe$3] = true, fe$3 = function(e20, t2) {
    if (z$3(e20, xe$3))
      throw new TypeError("Object already initialized");
    return t2.facade = e20, le$3(e20, xe$3, t2), t2;
  }, de$3 = function(e20) {
    return z$3(e20, xe$3) ? e20[xe$3] : {};
  }, he$3 = function(e20) {
    return z$3(e20, xe$3);
  };
}
var we$3, Te$3, Be$3 = {
  set: fe$3,
  get: de$3,
  has: he$3,
  enforce: function(e20) {
    return he$3(e20) ? de$3(e20) : fe$3(e20, {});
  },
  getterFor: function(e20) {
    return function(t2) {
      var n2;
      if (!T$3(t2) || (n2 = de$3(t2)).type !== e20)
        throw TypeError("Incompatible receiver, " + e20 + " required");
      return n2;
    };
  }
}, Ne$3 = r$3(function(e20) {
  var t2 = Be$3.get, n2 = Be$3.enforce, r2 = String(String).split("String");
  (e20.exports = function(e21, t3, i2, u2) {
    var o2, s2 = !!u2 && !!u2.unsafe, a2 = !!u2 && !!u2.enumerable, c2 = !!u2 && !!u2.noTargetGet;
    typeof i2 == "function" && (typeof t3 != "string" || z$3(i2, "name") || le$3(i2, "name", t3), (o2 = n2(i2)).source || (o2.source = r2.join(typeof t3 == "string" ? t3 : ""))), e21 !== g$3 ? (s2 ? !c2 && e21[t3] && (a2 = true) : delete e21[t3], a2 ? e21[t3] = i2 : le$3(e21, t3, i2)) : a2 ? e21[t3] = i2 : $$3(t3, i2);
  })(Function.prototype, "toString", function() {
    return typeof this == "function" && t2(this).source || me$3(this);
  });
}), ke$3 = Math.ceil, Pe$3 = Math.floor, Oe$3 = function(e20) {
  return isNaN(e20 = +e20) ? 0 : (e20 > 0 ? Pe$3 : ke$3)(e20);
}, Ie$3 = Math.min, Le$3 = function(e20) {
  return e20 > 0 ? Ie$3(Oe$3(e20), 9007199254740991) : 0;
}, je$3 = Math.max, _e$3 = Math.min, Me$3 = function(e20) {
  return function(t2, n2, r2) {
    var i2, u2 = w$3(t2), o2 = Le$3(u2.length), s2 = function(e21, t3) {
      var n3 = Oe$3(e21);
      return n3 < 0 ? je$3(n3 + t3, 0) : _e$3(n3, t3);
    }(r2, o2);
    if (e20 && n2 != n2) {
      for (; o2 > s2; )
        if ((i2 = u2[s2++]) != i2)
          return true;
    } else
      for (; o2 > s2; s2++)
        if ((e20 || s2 in u2) && u2[s2] === n2)
          return e20 || s2 || 0;
    return !e20 && -1;
  };
}, Re$3 = { includes: Me$3(true), indexOf: Me$3(false) }.indexOf, $e$3 = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf"
].concat("length", "prototype"), Ve$3 = {
  f: Object.getOwnPropertyNames || function(e20) {
    return function(e21, t2) {
      var n2, r2 = w$3(e21), i2 = 0, u2 = [];
      for (n2 in r2)
        !z$3(Ce$3, n2) && z$3(r2, n2) && u2.push(n2);
      for (; t2.length > i2; )
        z$3(r2, n2 = t2[i2++]) && (~Re$3(u2, n2) || u2.push(n2));
      return u2;
    }(e20, $e$3);
  }
}, We$3 = { f: Object.getOwnPropertySymbols }, qe$3 = N$3("Reflect", "ownKeys") || function(e20) {
  var t2 = Ve$3.f(se$3(e20)), n2 = We$3.f;
  return n2 ? t2.concat(n2(e20)) : t2;
}, Ue$3 = function(e20, t2) {
  for (var n2 = qe$3(t2), r2 = ce$3.f, i2 = oe$3.f, u2 = 0; u2 < n2.length; u2++) {
    var o2 = n2[u2];
    z$3(e20, o2) || r2(e20, o2, i2(t2, o2));
  }
}, ze$3 = /#|\.prototype\./, Ge$3 = function(e20, t2) {
  var n2 = Je$3[He$3(e20)];
  return n2 == Ye$3 || n2 != Xe$3 && (typeof t2 == "function" ? m$3(t2) : !!t2);
}, He$3 = Ge$3.normalize = function(e20) {
  return String(e20).replace(ze$3, ".").toLowerCase();
}, Je$3 = Ge$3.data = {}, Xe$3 = Ge$3.NATIVE = "N", Ye$3 = Ge$3.POLYFILL = "P", Ke$3 = Ge$3, Qe$3 = oe$3.f, Ze$3 = function(e20, t2) {
  var n2, r2, i2, u2, o2, s2 = e20.target, a2 = e20.global, c2 = e20.stat;
  if (n2 = a2 ? g$3 : c2 ? g$3[s2] || $$3(s2, {}) : (g$3[s2] || {}).prototype)
    for (r2 in t2) {
      if (u2 = t2[r2], i2 = e20.noTargetGet ? (o2 = Qe$3(n2, r2)) && o2.value : n2[r2], !Ke$3(a2 ? r2 : s2 + (c2 ? "." : "#") + r2, e20.forced) && i2 !== void 0) {
        if (typeof u2 == typeof i2)
          continue;
        Ue$3(u2, i2);
      }
      (e20.sham || i2 && i2.sham) && le$3(u2, "sham", true), Ne$3(n2, r2, u2, e20);
    }
}, et$3 = function(e20) {
  if (typeof e20 != "function")
    throw TypeError(String(e20) + " is not a function");
  return e20;
}, tt$3 = function(e20) {
  if (R$3(e20))
    throw TypeError("Cannot convert a Symbol value to a string");
  return String(e20);
}, nt$3 = Math.floor, rt$3 = function(e20, t2) {
  var n2 = e20.length, r2 = nt$3(n2 / 2);
  return n2 < 8 ? it$3(e20, t2) : ut$3(rt$3(e20.slice(0, r2), t2), rt$3(e20.slice(r2), t2), t2);
}, it$3 = function(e20, t2) {
  for (var n2, r2, i2 = e20.length, u2 = 1; u2 < i2; ) {
    for (r2 = u2, n2 = e20[u2]; r2 && t2(e20[r2 - 1], n2) > 0; )
      e20[r2] = e20[--r2];
    r2 !== u2++ && (e20[r2] = n2);
  }
  return e20;
}, ut$3 = function(e20, t2, n2) {
  for (var r2 = e20.length, i2 = t2.length, u2 = 0, o2 = 0, s2 = []; u2 < r2 || o2 < i2; )
    u2 < r2 && o2 < i2 ? s2.push(n2(e20[u2], t2[o2]) <= 0 ? e20[u2++] : t2[o2++]) : s2.push(u2 < r2 ? e20[u2++] : t2[o2++]);
  return s2;
}, ot$3 = rt$3, st$3 = k$3.match(/firefox\/(\d+)/i), at$3 = !!st$3 && +st$3[1], ct$3 = /MSIE|Trident/.test(k$3), lt$3 = k$3.match(/AppleWebKit\/(\d+)\./), pt$3 = !!lt$3 && +lt$3[1], ft$3 = [], dt$3 = ft$3.sort, ht$3 = m$3(function() {
  ft$3.sort(void 0);
}), gt$3 = m$3(function() {
  ft$3.sort(null);
}), mt$3 = !!(Te$3 = []["sort"]) && m$3(function() {
  Te$3.call(null, we$3 || function() {
    throw 1;
  }, 1);
}), yt$3 = !m$3(function() {
  if (j$3)
    return j$3 < 70;
  if (!(at$3 && at$3 > 3)) {
    if (ct$3)
      return true;
    if (pt$3)
      return pt$3 < 603;
    var e20, t2, n2, r2, i2 = "";
    for (e20 = 65; e20 < 76; e20++) {
      switch (t2 = String.fromCharCode(e20), e20) {
        case 66:
        case 69:
        case 70:
        case 72:
          n2 = 3;
          break;
        case 68:
        case 71:
          n2 = 4;
          break;
        default:
          n2 = 2;
      }
      for (r2 = 0; r2 < 47; r2++)
        ft$3.push({ k: t2 + r2, v: n2 });
    }
    for (ft$3.sort(function(e21, t3) {
      return t3.v - e21.v;
    }), r2 = 0; r2 < ft$3.length; r2++)
      t2 = ft$3[r2].k.charAt(0), i2.charAt(i2.length - 1) !== t2 && (i2 += t2);
    return i2 !== "DGBEFHACIJK";
  }
});
Ze$3({ target: "Array", proto: true, forced: ht$3 || !gt$3 || !mt$3 || !yt$3 }, {
  sort: function(e20) {
    e20 !== void 0 && et$3(e20);
    var t2 = q$3(this);
    if (yt$3)
      return e20 === void 0 ? dt$3.call(t2) : dt$3.call(t2, e20);
    var n2, r2, i2 = [], u2 = Le$3(t2.length);
    for (r2 = 0; r2 < u2; r2++)
      r2 in t2 && i2.push(t2[r2]);
    for (n2 = (i2 = ot$3(i2, function(e21) {
      return function(t3, n3) {
        return n3 === void 0 ? -1 : t3 === void 0 ? 1 : e21 !== void 0 ? +e21(t3, n3) || 0 : tt$3(t3) > tt$3(n3) ? 1 : -1;
      };
    }(e20))).length, r2 = 0; r2 < n2; )
      t2[r2] = i2[r2++];
    for (; r2 < u2; )
      delete t2[r2++];
    return t2;
  }
});
var Dt$3 = r$3(function(e20, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.diffJson = function(e21, t3, n3) {
    return s2.diff(e21, t3, n3);
  }, t2.canonicalize = a2, t2.jsonDiff = void 0;
  var n2, r2 = (n2 = i$3) && n2.__esModule ? n2 : { default: n2 };
  function u2(e21) {
    return (u2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e22) {
      return typeof e22;
    } : function(e22) {
      return e22 && typeof Symbol == "function" && e22.constructor === Symbol && e22 !== Symbol.prototype ? "symbol" : typeof e22;
    })(e21);
  }
  var o2 = Object.prototype.toString, s2 = new r2.default();
  function a2(e21, t3, n3, r3, i2) {
    var s3, c2;
    for (t3 = t3 || [], n3 = n3 || [], r3 && (e21 = r3(i2, e21)), s3 = 0; s3 < t3.length; s3 += 1)
      if (t3[s3] === e21)
        return n3[s3];
    if (o2.call(e21) === "[object Array]") {
      for (t3.push(e21), c2 = new Array(e21.length), n3.push(c2), s3 = 0; s3 < e21.length; s3 += 1)
        c2[s3] = a2(e21[s3], t3, n3, r3, i2);
      return t3.pop(), n3.pop(), c2;
    }
    if (e21 && e21.toJSON && (e21 = e21.toJSON()), u2(e21) === "object" && e21 !== null) {
      t3.push(e21), c2 = {}, n3.push(c2);
      var l2, p2 = [];
      for (l2 in e21)
        e21.hasOwnProperty(l2) && p2.push(l2);
      for (p2.sort(), s3 = 0; s3 < p2.length; s3 += 1)
        c2[l2 = p2[s3]] = a2(e21[l2], t3, n3, r3, l2);
      t3.pop(), n3.pop();
    } else
      c2 = e21;
    return c2;
  }
  t2.jsonDiff = s2, s2.useLongestToken = true, s2.tokenize = p$3.lineDiff.tokenize, s2.castInput = function(e21) {
    var t3 = this.options, n3 = t3.undefinedReplacement, r3 = t3.stringifyReplacer, i2 = r3 === void 0 ? function(e22, t4) {
      return t4 === void 0 ? n3 : t4;
    } : r3;
    return typeof e21 == "string" ? e21 : JSON.stringify(a2(e21, null, null, i2), i2, "  ");
  }, s2.equals = function(e21, t3) {
    return r2.default.prototype.equals.call(s2, e21.replace(/,([\r\n])/g, "$1"), t3.replace(/,([\r\n])/g, "$1"));
  };
}), Et$3 = r$3(function(e20, t2) {
  var n2;
  Object.defineProperty(t2, "__esModule", { value: true }), t2.diffArrays = function(e21, t3, n3) {
    return r2.diff(e21, t3, n3);
  }, t2.arrayDiff = void 0;
  var r2 = new ((n2 = i$3) && n2.__esModule ? n2 : { default: n2 }).default();
  t2.arrayDiff = r2, r2.tokenize = function(e21) {
    return e21.slice();
  }, r2.join = r2.removeEmpty = function(e21) {
    return e21;
  };
}), Ct$3 = function(e20) {
  var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n2 = e20.split(/\r\n|[\n\v\f\r\x85]/), r2 = e20.match(/\r\n|[\n\v\f\r\x85]/g) || [], i2 = [], u2 = 0;
  function o2() {
    var e21 = {};
    for (i2.push(e21); u2 < n2.length; ) {
      var r3 = n2[u2];
      if (/^(\-\-\-|\+\+\+|@@)\s/.test(r3))
        break;
      var o3 = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(r3);
      o3 && (e21.index = o3[1]), u2++;
    }
    for (s2(e21), s2(e21), e21.hunks = []; u2 < n2.length; ) {
      var c2 = n2[u2];
      if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(c2))
        break;
      if (/^@@/.test(c2))
        e21.hunks.push(a2());
      else {
        if (c2 && t2.strict)
          throw new Error("Unknown line " + (u2 + 1) + " " + JSON.stringify(c2));
        u2++;
      }
    }
  }
  function s2(e21) {
    var t3 = /^(---|\+\+\+)\s+(.*)$/.exec(n2[u2]);
    if (t3) {
      var r3 = t3[1] === "---" ? "old" : "new", i3 = t3[2].split("	", 2), o3 = i3[0].replace(/\\\\/g, "\\");
      /^".*"$/.test(o3) && (o3 = o3.substr(1, o3.length - 2)), e21[r3 + "FileName"] = o3, e21[r3 + "Header"] = (i3[1] || "").trim(), u2++;
    }
  }
  function a2() {
    var e21 = u2, i3 = n2[u2++].split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/), o3 = {
      oldStart: +i3[1],
      oldLines: i3[2] === void 0 ? 1 : +i3[2],
      newStart: +i3[3],
      newLines: i3[4] === void 0 ? 1 : +i3[4],
      lines: [],
      linedelimiters: []
    };
    o3.oldLines === 0 && (o3.oldStart += 1), o3.newLines === 0 && (o3.newStart += 1);
    for (var s3 = 0, a3 = 0; u2 < n2.length && !(n2[u2].indexOf("--- ") === 0 && u2 + 2 < n2.length && n2[u2 + 1].indexOf("+++ ") === 0 && n2[u2 + 2].indexOf("@@") === 0); u2++) {
      var c2 = n2[u2].length == 0 && u2 != n2.length - 1 ? " " : n2[u2][0];
      if (c2 !== "+" && c2 !== "-" && c2 !== " " && c2 !== "\\")
        break;
      o3.lines.push(n2[u2]), o3.linedelimiters.push(r2[u2] || "\n"), c2 === "+" ? s3++ : c2 === "-" ? a3++ : c2 === " " && (s3++, a3++);
    }
    if (s3 || o3.newLines !== 1 || (o3.newLines = 0), a3 || o3.oldLines !== 1 || (o3.oldLines = 0), t2.strict) {
      if (s3 !== o3.newLines)
        throw new Error("Added line count did not match for hunk at line " + (e21 + 1));
      if (a3 !== o3.oldLines)
        throw new Error("Removed line count did not match for hunk at line " + (e21 + 1));
    }
    return o3;
  }
  for (; u2 < n2.length; )
    o2();
  return i2;
};
var bt$3, At$3 = Object.defineProperty({ parsePatch: Ct$3 }, "__esModule", {
  value: true
}), vt$3 = r$3(function(e20, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e21, t3, n2) {
    var r2 = true, i2 = false, u2 = false, o2 = 1;
    return function s2() {
      if (r2 && !u2) {
        if (i2 ? o2++ : r2 = false, e21 + o2 <= n2)
          return o2;
        u2 = true;
      }
      if (!i2)
        return u2 || (r2 = true), t3 <= e21 - o2 ? -o2++ : (i2 = true, s2());
    };
  };
}), Ft$3 = wt$3, St$2 = function(e20, t2) {
  typeof e20 == "string" && (e20 = (0, At$3.parsePatch)(e20));
  var n2 = 0;
  !function r2() {
    var i2 = e20[n2++];
    if (!i2)
      return t2.complete();
    t2.loadFile(i2, function(e21, n3) {
      if (e21)
        return t2.complete(e21);
      var u2 = wt$3(n3, i2, t2);
      t2.patched(i2, u2, function(e22) {
        if (e22)
          return t2.complete(e22);
        r2();
      });
    });
  }();
}, xt$3 = (bt$3 = vt$3) && bt$3.__esModule ? bt$3 : { default: bt$3 };
function wt$3(e20, t2) {
  var n2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (typeof t2 == "string" && (t2 = (0, At$3.parsePatch)(t2)), Array.isArray(t2)) {
    if (t2.length > 1)
      throw new Error("applyPatch only works with a single input.");
    t2 = t2[0];
  }
  var r2, i2, u2 = e20.split(/\r\n|[\n\v\f\r\x85]/), o2 = e20.match(/\r\n|[\n\v\f\r\x85]/g) || [], s2 = t2.hunks, a2 = n2.compareLine || function(e21, t3, n3, r3) {
    return t3 === r3;
  }, c2 = 0, l2 = n2.fuzzFactor || 0, p2 = 0, f2 = 0;
  function d2(e21, t3) {
    for (var n3 = 0; n3 < e21.lines.length; n3++) {
      var r3 = e21.lines[n3], i3 = r3.length > 0 ? r3[0] : " ", o3 = r3.length > 0 ? r3.substr(1) : r3;
      if (i3 === " " || i3 === "-") {
        if (!a2(t3 + 1, u2[t3], i3, o3) && ++c2 > l2)
          return false;
        t3++;
      }
    }
    return true;
  }
  for (var h2 = 0; h2 < s2.length; h2++) {
    for (var g2 = s2[h2], m2 = u2.length - g2.oldLines, y2 = 0, D2 = f2 + g2.oldStart - 1, E2 = (0, xt$3.default)(D2, p2, m2); y2 !== void 0; y2 = E2())
      if (d2(g2, D2 + y2)) {
        g2.offset = f2 += y2;
        break;
      }
    if (y2 === void 0)
      return false;
    p2 = g2.offset + g2.oldStart + g2.oldLines;
  }
  for (var C2 = 0, b2 = 0; b2 < s2.length; b2++) {
    var A2 = s2[b2], v2 = A2.oldStart + A2.offset + C2 - 1;
    C2 += A2.newLines - A2.oldLines;
    for (var F2 = 0; F2 < A2.lines.length; F2++) {
      var S2 = A2.lines[F2], x2 = S2.length > 0 ? S2[0] : " ", w2 = S2.length > 0 ? S2.substr(1) : S2, T2 = A2.linedelimiters[F2];
      if (x2 === " ")
        v2++;
      else if (x2 === "-")
        u2.splice(v2, 1), o2.splice(v2, 1);
      else if (x2 === "+")
        u2.splice(v2, 0, w2), o2.splice(v2, 0, T2), v2++;
      else if (x2 === "\\") {
        var B2 = A2.lines[F2 - 1] ? A2.lines[F2 - 1][0] : null;
        B2 === "+" ? r2 = true : B2 === "-" && (i2 = true);
      }
    }
  }
  if (r2)
    for (; !u2[u2.length - 1]; )
      u2.pop(), o2.pop();
  else
    i2 && (u2.push(""), o2.push("\n"));
  for (var N2 = 0; N2 < u2.length - 1; N2++)
    u2[N2] = u2[N2] + o2[N2];
  return u2.join("");
}
var Tt$2 = Object.defineProperty({ applyPatch: Ft$3, applyPatches: St$2 }, "__esModule", { value: true }), Bt$2 = Lt$2, Nt$2 = jt$2, kt$3 = _t$2, Pt$2 = function(e20, t2, n2, r2, i2, u2) {
  return _t$2(e20, e20, t2, n2, r2, i2, u2);
};
function Ot$3(e20) {
  return function(e21) {
    if (Array.isArray(e21))
      return It$2(e21);
  }(e20) || function(e21) {
    if (typeof Symbol != "undefined" && Symbol.iterator in Object(e21))
      return Array.from(e21);
  }(e20) || function(e21, t2) {
    if (!e21)
      return;
    if (typeof e21 == "string")
      return It$2(e21, t2);
    var n2 = Object.prototype.toString.call(e21).slice(8, -1);
    n2 === "Object" && e21.constructor && (n2 = e21.constructor.name);
    if (n2 === "Map" || n2 === "Set")
      return Array.from(e21);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return It$2(e21, t2);
  }(e20) || function() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }();
}
function It$2(e20, t2) {
  (t2 == null || t2 > e20.length) && (t2 = e20.length);
  for (var n2 = 0, r2 = new Array(t2); n2 < t2; n2++)
    r2[n2] = e20[n2];
  return r2;
}
function Lt$2(e20, t2, n2, r2, i2, u2, o2) {
  o2 || (o2 = {}), o2.context === void 0 && (o2.context = 4);
  var s2 = (0, p$3.diffLines)(n2, r2, o2);
  function a2(e21) {
    return e21.map(function(e22) {
      return " " + e22;
    });
  }
  s2.push({ value: "", lines: [] });
  for (var c2 = [], l2 = 0, f2 = 0, d2 = [], h2 = 1, g2 = 1, m2 = function(e21) {
    var t3 = s2[e21], i3 = t3.lines || t3.value.replace(/\n$/, "").split("\n");
    if (t3.lines = i3, t3.added || t3.removed) {
      var u3;
      if (!l2) {
        var p2 = s2[e21 - 1];
        l2 = h2, f2 = g2, p2 && (d2 = o2.context > 0 ? a2(p2.lines.slice(-o2.context)) : [], l2 -= d2.length, f2 -= d2.length);
      }
      (u3 = d2).push.apply(u3, Ot$3(i3.map(function(e22) {
        return (t3.added ? "+" : "-") + e22;
      }))), t3.added ? g2 += i3.length : h2 += i3.length;
    } else {
      if (l2)
        if (i3.length <= 2 * o2.context && e21 < s2.length - 2) {
          var m3;
          (m3 = d2).push.apply(m3, Ot$3(a2(i3)));
        } else {
          var y3, D2 = Math.min(i3.length, o2.context);
          (y3 = d2).push.apply(y3, Ot$3(a2(i3.slice(0, D2))));
          var E2 = {
            oldStart: l2,
            oldLines: h2 - l2 + D2,
            newStart: f2,
            newLines: g2 - f2 + D2,
            lines: d2
          };
          if (e21 >= s2.length - 2 && i3.length <= o2.context) {
            var C2 = /\n$/.test(n2), b2 = /\n$/.test(r2), A2 = i3.length == 0 && d2.length > E2.oldLines;
            !C2 && A2 && n2.length > 0 && d2.splice(E2.oldLines, 0, "\\ No newline at end of file"), (C2 || A2) && b2 || d2.push("\\ No newline at end of file");
          }
          c2.push(E2), l2 = 0, f2 = 0, d2 = [];
        }
      h2 += i3.length, g2 += i3.length;
    }
  }, y2 = 0; y2 < s2.length; y2++)
    m2(y2);
  return {
    oldFileName: e20,
    newFileName: t2,
    oldHeader: i2,
    newHeader: u2,
    hunks: c2
  };
}
function jt$2(e20) {
  var t2 = [];
  e20.oldFileName == e20.newFileName && t2.push("Index: " + e20.oldFileName), t2.push("==================================================================="), t2.push("--- " + e20.oldFileName + (e20.oldHeader === void 0 ? "" : "	" + e20.oldHeader)), t2.push("+++ " + e20.newFileName + (e20.newHeader === void 0 ? "" : "	" + e20.newHeader));
  for (var n2 = 0; n2 < e20.hunks.length; n2++) {
    var r2 = e20.hunks[n2];
    r2.oldLines === 0 && (r2.oldStart -= 1), r2.newLines === 0 && (r2.newStart -= 1), t2.push("@@ -" + r2.oldStart + "," + r2.oldLines + " +" + r2.newStart + "," + r2.newLines + " @@"), t2.push.apply(t2, r2.lines);
  }
  return t2.join("\n") + "\n";
}
function _t$2(e20, t2, n2, r2, i2, u2, o2) {
  return jt$2(Lt$2(e20, t2, n2, r2, i2, u2, o2));
}
var Mt$2 = Object.defineProperty({
  structuredPatch: Bt$2,
  formatPatch: Nt$2,
  createTwoFilesPatch: kt$3,
  createPatch: Pt$2
}, "__esModule", { value: true }), Rt$2 = function(e20, t2) {
  if (e20.length !== t2.length)
    return false;
  return Vt$2(e20, t2);
}, $t$2 = Vt$2;
function Vt$2(e20, t2) {
  if (t2.length > e20.length)
    return false;
  for (var n2 = 0; n2 < t2.length; n2++)
    if (t2[n2] !== e20[n2])
      return false;
  return true;
}
var Wt$2 = Object.defineProperty({ arrayEqual: Rt$2, arrayStartsWith: $t$2 }, "__esModule", { value: true }), qt$2 = Ht$2, Ut$2 = function(e20, t2, n2) {
  e20 = Jt$2(e20, n2), t2 = Jt$2(t2, n2);
  var r2 = {};
  (e20.index || t2.index) && (r2.index = e20.index || t2.index);
  (e20.newFileName || t2.newFileName) && (Xt$2(e20) ? Xt$2(t2) ? (r2.oldFileName = Yt$2(r2, e20.oldFileName, t2.oldFileName), r2.newFileName = Yt$2(r2, e20.newFileName, t2.newFileName), r2.oldHeader = Yt$2(r2, e20.oldHeader, t2.oldHeader), r2.newHeader = Yt$2(r2, e20.newHeader, t2.newHeader)) : (r2.oldFileName = e20.oldFileName, r2.newFileName = e20.newFileName, r2.oldHeader = e20.oldHeader, r2.newHeader = e20.newHeader) : (r2.oldFileName = t2.oldFileName || e20.oldFileName, r2.newFileName = t2.newFileName || e20.newFileName, r2.oldHeader = t2.oldHeader || e20.oldHeader, r2.newHeader = t2.newHeader || e20.newHeader));
  r2.hunks = [];
  var i2 = 0, u2 = 0, o2 = 0, s2 = 0;
  for (; i2 < e20.hunks.length || u2 < t2.hunks.length; ) {
    var a2 = e20.hunks[i2] || { oldStart: 1 / 0 }, c2 = t2.hunks[u2] || { oldStart: 1 / 0 };
    if (Kt$2(a2, c2))
      r2.hunks.push(Qt$2(a2, o2)), i2++, s2 += a2.newLines - a2.oldLines;
    else if (Kt$2(c2, a2))
      r2.hunks.push(Qt$2(c2, s2)), u2++, o2 += c2.newLines - c2.oldLines;
    else {
      var l2 = {
        oldStart: Math.min(a2.oldStart, c2.oldStart),
        oldLines: 0,
        newStart: Math.min(a2.newStart + o2, c2.oldStart + s2),
        newLines: 0,
        lines: []
      };
      Zt$2(l2, a2.oldStart, a2.lines, c2.oldStart, c2.lines), u2++, i2++, r2.hunks.push(l2);
    }
  }
  return r2;
};
function zt$2(e20) {
  return function(e21) {
    if (Array.isArray(e21))
      return Gt$2(e21);
  }(e20) || function(e21) {
    if (typeof Symbol != "undefined" && Symbol.iterator in Object(e21))
      return Array.from(e21);
  }(e20) || function(e21, t2) {
    if (!e21)
      return;
    if (typeof e21 == "string")
      return Gt$2(e21, t2);
    var n2 = Object.prototype.toString.call(e21).slice(8, -1);
    n2 === "Object" && e21.constructor && (n2 = e21.constructor.name);
    if (n2 === "Map" || n2 === "Set")
      return Array.from(e21);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return Gt$2(e21, t2);
  }(e20) || function() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }();
}
function Gt$2(e20, t2) {
  (t2 == null || t2 > e20.length) && (t2 = e20.length);
  for (var n2 = 0, r2 = new Array(t2); n2 < t2; n2++)
    r2[n2] = e20[n2];
  return r2;
}
function Ht$2(e20) {
  var t2 = cn$2(e20.lines), n2 = t2.oldLines, r2 = t2.newLines;
  n2 !== void 0 ? e20.oldLines = n2 : delete e20.oldLines, r2 !== void 0 ? e20.newLines = r2 : delete e20.newLines;
}
function Jt$2(e20, t2) {
  if (typeof e20 == "string") {
    if (/^@@/m.test(e20) || /^Index:/m.test(e20))
      return (0, At$3.parsePatch)(e20)[0];
    if (!t2)
      throw new Error("Must provide a base reference or pass in a patch");
    return (0, Mt$2.structuredPatch)(void 0, void 0, t2, e20);
  }
  return e20;
}
function Xt$2(e20) {
  return e20.newFileName && e20.newFileName !== e20.oldFileName;
}
function Yt$2(e20, t2, n2) {
  return t2 === n2 ? t2 : (e20.conflict = true, { mine: t2, theirs: n2 });
}
function Kt$2(e20, t2) {
  return e20.oldStart < t2.oldStart && e20.oldStart + e20.oldLines < t2.oldStart;
}
function Qt$2(e20, t2) {
  return {
    oldStart: e20.oldStart,
    oldLines: e20.oldLines,
    newStart: e20.newStart + t2,
    newLines: e20.newLines,
    lines: e20.lines
  };
}
function Zt$2(e20, t2, n2, r2, i2) {
  var u2 = { offset: t2, lines: n2, index: 0 }, o2 = { offset: r2, lines: i2, index: 0 };
  for (rn$2(e20, u2, o2), rn$2(e20, o2, u2); u2.index < u2.lines.length && o2.index < o2.lines.length; ) {
    var s2 = u2.lines[u2.index], a2 = o2.lines[o2.index];
    if (s2[0] !== "-" && s2[0] !== "+" || a2[0] !== "-" && a2[0] !== "+")
      if (s2[0] === "+" && a2[0] === " ") {
        var c2;
        (c2 = e20.lines).push.apply(c2, zt$2(on$2(u2)));
      } else if (a2[0] === "+" && s2[0] === " ") {
        var l2;
        (l2 = e20.lines).push.apply(l2, zt$2(on$2(o2)));
      } else
        s2[0] === "-" && a2[0] === " " ? tn$2(e20, u2, o2) : a2[0] === "-" && s2[0] === " " ? tn$2(e20, o2, u2, true) : s2 === a2 ? (e20.lines.push(s2), u2.index++, o2.index++) : nn$2(e20, on$2(u2), on$2(o2));
    else
      en$2(e20, u2, o2);
  }
  un$2(e20, u2), un$2(e20, o2), Ht$2(e20);
}
function en$2(e20, t2, n2) {
  var r2 = on$2(t2), i2 = on$2(n2);
  if (sn$2(r2) && sn$2(i2)) {
    var u2, o2;
    if ((0, Wt$2.arrayStartsWith)(r2, i2) && an$2(n2, r2, r2.length - i2.length))
      return void (u2 = e20.lines).push.apply(u2, zt$2(r2));
    if ((0, Wt$2.arrayStartsWith)(i2, r2) && an$2(t2, i2, i2.length - r2.length))
      return void (o2 = e20.lines).push.apply(o2, zt$2(i2));
  } else if ((0, Wt$2.arrayEqual)(r2, i2)) {
    var s2;
    return void (s2 = e20.lines).push.apply(s2, zt$2(r2));
  }
  nn$2(e20, r2, i2);
}
function tn$2(e20, t2, n2, r2) {
  var i2, u2 = on$2(t2), o2 = function(e21, t3) {
    var n3 = [], r3 = [], i3 = 0, u3 = false, o3 = false;
    for (; i3 < t3.length && e21.index < e21.lines.length; ) {
      var s2 = e21.lines[e21.index], a2 = t3[i3];
      if (a2[0] === "+")
        break;
      if (u3 = u3 || s2[0] !== " ", r3.push(a2), i3++, s2[0] === "+")
        for (o3 = true; s2[0] === "+"; )
          n3.push(s2), s2 = e21.lines[++e21.index];
      a2.substr(1) === s2.substr(1) ? (n3.push(s2), e21.index++) : o3 = true;
    }
    (t3[i3] || "")[0] === "+" && u3 && (o3 = true);
    if (o3)
      return n3;
    for (; i3 < t3.length; )
      r3.push(t3[i3++]);
    return { merged: r3, changes: n3 };
  }(n2, u2);
  o2.merged ? (i2 = e20.lines).push.apply(i2, zt$2(o2.merged)) : nn$2(e20, r2 ? o2 : u2, r2 ? u2 : o2);
}
function nn$2(e20, t2, n2) {
  e20.conflict = true, e20.lines.push({ conflict: true, mine: t2, theirs: n2 });
}
function rn$2(e20, t2, n2) {
  for (; t2.offset < n2.offset && t2.index < t2.lines.length; ) {
    var r2 = t2.lines[t2.index++];
    e20.lines.push(r2), t2.offset++;
  }
}
function un$2(e20, t2) {
  for (; t2.index < t2.lines.length; ) {
    var n2 = t2.lines[t2.index++];
    e20.lines.push(n2);
  }
}
function on$2(e20) {
  for (var t2 = [], n2 = e20.lines[e20.index][0]; e20.index < e20.lines.length; ) {
    var r2 = e20.lines[e20.index];
    if (n2 === "-" && r2[0] === "+" && (n2 = "+"), n2 !== r2[0])
      break;
    t2.push(r2), e20.index++;
  }
  return t2;
}
function sn$2(e20) {
  return e20.reduce(function(e21, t2) {
    return e21 && t2[0] === "-";
  }, true);
}
function an$2(e20, t2, n2) {
  for (var r2 = 0; r2 < n2; r2++) {
    var i2 = t2[t2.length - n2 + r2].substr(1);
    if (e20.lines[e20.index + r2] !== " " + i2)
      return false;
  }
  return e20.index += n2, true;
}
function cn$2(e20) {
  var t2 = 0, n2 = 0;
  return e20.forEach(function(e21) {
    if (typeof e21 != "string") {
      var r2 = cn$2(e21.mine), i2 = cn$2(e21.theirs);
      t2 !== void 0 && (r2.oldLines === i2.oldLines ? t2 += r2.oldLines : t2 = void 0), n2 !== void 0 && (r2.newLines === i2.newLines ? n2 += r2.newLines : n2 = void 0);
    } else
      n2 === void 0 || e21[0] !== "+" && e21[0] !== " " || n2++, t2 === void 0 || e21[0] !== "-" && e21[0] !== " " || t2++;
  }), { oldLines: t2, newLines: n2 };
}
var ln$2 = Object.defineProperty({ calcLineCount: qt$2, merge: Ut$2 }, "__esModule", { value: true }), pn$2 = function(e20) {
  for (var t2, n2, r2 = [], i2 = 0; i2 < e20.length; i2++)
    t2 = e20[i2], n2 = t2.added ? 1 : t2.removed ? -1 : 0, r2.push([n2, t2.value]);
  return r2;
};
var fn$2 = Object.defineProperty({ convertChangesToDMP: pn$2 }, "__esModule", {
  value: true
}), dn$2 = function(e20) {
  for (var t2 = [], n2 = 0; n2 < e20.length; n2++) {
    var r2 = e20[n2];
    r2.added ? t2.push("<ins>") : r2.removed && t2.push("<del>"), t2.push(hn$2(r2.value)), r2.added ? t2.push("</ins>") : r2.removed && t2.push("</del>");
  }
  return t2.join("");
};
function hn$2(e20) {
  var t2 = e20;
  return t2 = (t2 = (t2 = (t2 = t2.replace(/&/g, "&amp;")).replace(/</g, "&lt;")).replace(/>/g, "&gt;")).replace(/"/g, "&quot;");
}
var gn$2 = Object.defineProperty({ convertChangesToXML: dn$2 }, "__esModule", {
  value: true
}), mn$2 = r$3(function(e20, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "Diff", {
    enumerable: true,
    get: function() {
      return n2.default;
    }
  }), Object.defineProperty(t2, "diffChars", {
    enumerable: true,
    get: function() {
      return u$3.diffChars;
    }
  }), Object.defineProperty(t2, "diffWords", {
    enumerable: true,
    get: function() {
      return l$3.diffWords;
    }
  }), Object.defineProperty(t2, "diffWordsWithSpace", {
    enumerable: true,
    get: function() {
      return l$3.diffWordsWithSpace;
    }
  }), Object.defineProperty(t2, "diffLines", {
    enumerable: true,
    get: function() {
      return p$3.diffLines;
    }
  }), Object.defineProperty(t2, "diffTrimmedLines", {
    enumerable: true,
    get: function() {
      return p$3.diffTrimmedLines;
    }
  }), Object.defineProperty(t2, "diffSentences", {
    enumerable: true,
    get: function() {
      return f$3.diffSentences;
    }
  }), Object.defineProperty(t2, "diffCss", {
    enumerable: true,
    get: function() {
      return d$3.diffCss;
    }
  }), Object.defineProperty(t2, "diffJson", {
    enumerable: true,
    get: function() {
      return Dt$3.diffJson;
    }
  }), Object.defineProperty(t2, "canonicalize", {
    enumerable: true,
    get: function() {
      return Dt$3.canonicalize;
    }
  }), Object.defineProperty(t2, "diffArrays", {
    enumerable: true,
    get: function() {
      return Et$3.diffArrays;
    }
  }), Object.defineProperty(t2, "applyPatch", {
    enumerable: true,
    get: function() {
      return Tt$2.applyPatch;
    }
  }), Object.defineProperty(t2, "applyPatches", {
    enumerable: true,
    get: function() {
      return Tt$2.applyPatches;
    }
  }), Object.defineProperty(t2, "parsePatch", {
    enumerable: true,
    get: function() {
      return At$3.parsePatch;
    }
  }), Object.defineProperty(t2, "merge", {
    enumerable: true,
    get: function() {
      return ln$2.merge;
    }
  }), Object.defineProperty(t2, "structuredPatch", {
    enumerable: true,
    get: function() {
      return Mt$2.structuredPatch;
    }
  }), Object.defineProperty(t2, "createTwoFilesPatch", {
    enumerable: true,
    get: function() {
      return Mt$2.createTwoFilesPatch;
    }
  }), Object.defineProperty(t2, "createPatch", {
    enumerable: true,
    get: function() {
      return Mt$2.createPatch;
    }
  }), Object.defineProperty(t2, "convertChangesToDMP", {
    enumerable: true,
    get: function() {
      return fn$2.convertChangesToDMP;
    }
  }), Object.defineProperty(t2, "convertChangesToXML", {
    enumerable: true,
    get: function() {
      return gn$2.convertChangesToXML;
    }
  });
  var n2 = function(e21) {
    return e21 && e21.__esModule ? e21 : { default: e21 };
  }(i$3);
});
function yn$2(e20) {
  return { type: "concat", parts: e20 };
}
function Dn$2(e20) {
  return { type: "indent", contents: e20 };
}
function En$2(e20, t2) {
  return { type: "align", contents: t2, n: e20 };
}
function Cn$2(e20, t2 = {}) {
  return {
    type: "group",
    id: t2.id,
    contents: e20,
    break: Boolean(t2.shouldBreak),
    expandedStates: t2.expandedStates
  };
}
const bn$2 = { type: "break-parent" }, An$2 = { type: "line", hard: true }, vn$2 = { type: "line", hard: true, literal: true }, Fn$2 = yn$2([An$2, bn$2]), Sn$2 = yn$2([vn$2, bn$2]);
var xn$2 = {
  concat: yn$2,
  join: function(e20, t2) {
    const n2 = [];
    for (let r2 = 0; r2 < t2.length; r2++)
      r2 !== 0 && n2.push(e20), n2.push(t2[r2]);
    return yn$2(n2);
  },
  line: { type: "line" },
  softline: { type: "line", soft: true },
  hardline: Fn$2,
  literalline: Sn$2,
  group: Cn$2,
  conditionalGroup: function(e20, t2) {
    return Cn$2(e20[0], Object.assign(Object.assign({}, t2), {}, { expandedStates: e20 }));
  },
  fill: function(e20) {
    return { type: "fill", parts: e20 };
  },
  lineSuffix: function(e20) {
    return { type: "line-suffix", contents: e20 };
  },
  lineSuffixBoundary: { type: "line-suffix-boundary" },
  cursor: { type: "cursor", placeholder: Symbol("cursor") },
  breakParent: bn$2,
  ifBreak: function(e20, t2, n2 = {}) {
    return {
      type: "if-break",
      breakContents: e20,
      flatContents: t2,
      groupId: n2.groupId
    };
  },
  trim: { type: "trim" },
  indent: Dn$2,
  indentIfBreak: function(e20, t2) {
    return {
      type: "indent-if-break",
      contents: e20,
      groupId: t2.groupId,
      negate: t2.negate
    };
  },
  align: En$2,
  addAlignmentToDoc: function(e20, t2, n2) {
    let r2 = e20;
    if (t2 > 0) {
      for (let e21 = 0; e21 < Math.floor(t2 / n2); ++e21)
        r2 = Dn$2(r2);
      r2 = En$2(t2 % n2, r2), r2 = En$2(Number.NEGATIVE_INFINITY, r2);
    }
    return r2;
  },
  markAsRoot: function(e20) {
    return En$2({ type: "root" }, e20);
  },
  dedentToRoot: function(e20) {
    return En$2(Number.NEGATIVE_INFINITY, e20);
  },
  dedent: function(e20) {
    return En$2(-1, e20);
  },
  hardlineWithoutBreakParent: An$2,
  literallineWithoutBreakParent: vn$2,
  label: function(e20, t2) {
    return { type: "label", label: e20, contents: t2 };
  }
}, wn$2 = (e20) => typeof e20 == "string" ? e20.replace((({ onlyFirst: e21 = false } = {}) => {
  const t2 = [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
  ].join("|");
  return new RegExp(t2, e21 ? void 0 : "g");
})(), "") : e20;
const Tn$2 = (e20) => !Number.isNaN(e20) && e20 >= 4352 && (e20 <= 4447 || e20 === 9001 || e20 === 9002 || 11904 <= e20 && e20 <= 12871 && e20 !== 12351 || 12880 <= e20 && e20 <= 19903 || 19968 <= e20 && e20 <= 42182 || 43360 <= e20 && e20 <= 43388 || 44032 <= e20 && e20 <= 55203 || 63744 <= e20 && e20 <= 64255 || 65040 <= e20 && e20 <= 65049 || 65072 <= e20 && e20 <= 65131 || 65281 <= e20 && e20 <= 65376 || 65504 <= e20 && e20 <= 65510 || 110592 <= e20 && e20 <= 110593 || 127488 <= e20 && e20 <= 127569 || 131072 <= e20 && e20 <= 262141);
var Bn$2 = Tn$2, Nn$2 = Tn$2;
Bn$2.default = Nn$2;
const kn$2 = (e20) => {
  if (typeof e20 != "string" || e20.length === 0)
    return 0;
  if ((e20 = wn$2(e20)).length === 0)
    return 0;
  e20 = e20.replace(/\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g, "  ");
  let t2 = 0;
  for (let n2 = 0; n2 < e20.length; n2++) {
    const r2 = e20.codePointAt(n2);
    r2 <= 31 || r2 >= 127 && r2 <= 159 || r2 >= 768 && r2 <= 879 || (r2 > 65535 && n2++, t2 += Bn$2(r2) ? 2 : 1);
  }
  return t2;
};
var Pn$2 = kn$2, On$2 = kn$2;
Pn$2.default = On$2;
var In$2 = (e20) => {
  if (typeof e20 != "string")
    throw new TypeError("Expected a string");
  return e20.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
};
var Ln$2 = (e20) => e20[e20.length - 1];
function jn$2(e20, t2) {
  if (e20 == null)
    return {};
  var n2, r2, i2 = function(e21, t3) {
    if (e21 == null)
      return {};
    var n3, r3, i3 = {}, u3 = Object.keys(e21);
    for (r3 = 0; r3 < u3.length; r3++)
      n3 = u3[r3], t3.indexOf(n3) >= 0 || (i3[n3] = e21[n3]);
    return i3;
  }(e20, t2);
  if (Object.getOwnPropertySymbols) {
    var u2 = Object.getOwnPropertySymbols(e20);
    for (r2 = 0; r2 < u2.length; r2++)
      n2 = u2[r2], t2.indexOf(n2) >= 0 || Object.prototype.propertyIsEnumerable.call(e20, n2) && (i2[n2] = e20[n2]);
  }
  return i2;
}
var _n$2 = Array.isArray || function(e20) {
  return v$3(e20) == "Array";
}, Mn$2 = function(e20, t2, n2) {
  if (et$3(e20), t2 === void 0)
    return e20;
  switch (n2) {
    case 0:
      return function() {
        return e20.call(t2);
      };
    case 1:
      return function(n3) {
        return e20.call(t2, n3);
      };
    case 2:
      return function(n3, r2) {
        return e20.call(t2, n3, r2);
      };
    case 3:
      return function(n3, r2, i2) {
        return e20.call(t2, n3, r2, i2);
      };
  }
  return function() {
    return e20.apply(t2, arguments);
  };
}, Rn$2 = function(e20, t2, n2, r2, i2, u2, o2, s2) {
  for (var a2, c2 = i2, l2 = 0, p2 = !!o2 && Mn$2(o2, s2, 3); l2 < r2; ) {
    if (l2 in n2) {
      if (a2 = p2 ? p2(n2[l2], l2, t2) : n2[l2], u2 > 0 && _n$2(a2))
        c2 = Rn$2(e20, t2, a2, Le$3(a2.length), c2, u2 - 1) - 1;
      else {
        if (c2 >= 9007199254740991)
          throw TypeError("Exceed the acceptable array length");
        e20[c2] = a2;
      }
      c2++;
    }
    l2++;
  }
  return c2;
}, $n$2 = Rn$2, Vn$2 = Q$3("species"), Wn$2 = function(e20, t2) {
  return new (function(e21) {
    var t3;
    return _n$2(e21) && (typeof (t3 = e21.constructor) != "function" || t3 !== Array && !_n$2(t3.prototype) ? T$3(t3) && (t3 = t3[Vn$2]) === null && (t3 = void 0) : t3 = void 0), t3 === void 0 ? Array : t3;
  }(e20))(t2 === 0 ? 0 : t2);
};
Ze$3({ target: "Array", proto: true }, {
  flatMap: function(e20) {
    var t2, n2 = q$3(this), r2 = Le$3(n2.length);
    return et$3(e20), (t2 = Wn$2(n2, 0)).length = $n$2(t2, n2, n2, r2, 0, 1, e20, arguments.length > 1 ? arguments[1] : void 0), t2;
  }
});
var qn$2 = {}, Un$2 = Q$3("iterator"), zn$2 = Array.prototype, Gn$2 = {};
Gn$2[Q$3("toStringTag")] = "z";
var Hn$2 = String(Gn$2) === "[object z]", Jn$2 = Q$3("toStringTag"), Xn$2 = v$3(function() {
  return arguments;
}()) == "Arguments", Yn$2 = Hn$2 ? v$3 : function(e20) {
  var t2, n2, r2;
  return e20 === void 0 ? "Undefined" : e20 === null ? "Null" : typeof (n2 = function(e21, t3) {
    try {
      return e21[t3];
    } catch (e22) {
    }
  }(t2 = Object(e20), Jn$2)) == "string" ? n2 : Xn$2 ? v$3(t2) : (r2 = v$3(t2)) == "Object" && typeof t2.callee == "function" ? "Arguments" : r2;
}, Kn$2 = Q$3("iterator"), Qn$2 = function(e20) {
  if (e20 != null)
    return e20[Kn$2] || e20["@@iterator"] || qn$2[Yn$2(e20)];
}, Zn$2 = function(e20, t2, n2) {
  var r2, i2;
  se$3(e20);
  try {
    if ((r2 = e20.return) === void 0) {
      if (t2 === "throw")
        throw n2;
      return n2;
    }
    r2 = r2.call(e20);
  } catch (e21) {
    i2 = true, r2 = e21;
  }
  if (t2 === "throw")
    throw n2;
  if (i2)
    throw r2;
  return se$3(r2), n2;
}, er$2 = function(e20, t2) {
  this.stopped = e20, this.result = t2;
}, tr$2 = function(e20, t2, n2) {
  var r2, i2, u2, o2, s2, a2, c2, l2, p2 = n2 && n2.that, f2 = !(!n2 || !n2.AS_ENTRIES), d2 = !(!n2 || !n2.IS_ITERATOR), h2 = !(!n2 || !n2.INTERRUPTED), g2 = Mn$2(t2, p2, 1 + f2 + h2), m2 = function(e21) {
    return r2 && Zn$2(r2, "normal", e21), new er$2(true, e21);
  }, y2 = function(e21) {
    return f2 ? (se$3(e21), h2 ? g2(e21[0], e21[1], m2) : g2(e21[0], e21[1])) : h2 ? g2(e21, m2) : g2(e21);
  };
  if (d2)
    r2 = e20;
  else {
    if (typeof (i2 = Qn$2(e20)) != "function")
      throw TypeError("Target is not iterable");
    if ((l2 = i2) !== void 0 && (qn$2.Array === l2 || zn$2[Un$2] === l2)) {
      for (u2 = 0, o2 = Le$3(e20.length); o2 > u2; u2++)
        if ((s2 = y2(e20[u2])) && s2 instanceof er$2)
          return s2;
      return new er$2(false);
    }
    r2 = function(e21, t3) {
      var n3 = arguments.length < 2 ? Qn$2(e21) : t3;
      if (typeof n3 != "function")
        throw TypeError(String(e21) + " is not iterable");
      return se$3(n3.call(e21));
    }(e20, i2);
  }
  for (a2 = r2.next; !(c2 = a2.call(r2)).done; ) {
    try {
      s2 = y2(c2.value);
    } catch (e21) {
      Zn$2(r2, "throw", e21);
    }
    if (typeof s2 == "object" && s2 && s2 instanceof er$2)
      return s2;
  }
  return new er$2(false);
};
Ze$3({ target: "Object", stat: true }, {
  fromEntries: function(e20) {
    var t2 = {};
    return tr$2(e20, function(e21, n2) {
      !function(e22, t3, n3) {
        var r2 = te$3(t3);
        r2 in e22 ? ce$3.f(e22, r2, b$3(0, n3)) : e22[r2] = n3;
      }(t2, e21, n2);
    }, { AS_ENTRIES: true }), t2;
  }
});
var nr$2 = nr$2 !== void 0 ? nr$2 : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {};
function rr$2() {
  throw new Error("setTimeout has not been defined");
}
function ir$2() {
  throw new Error("clearTimeout has not been defined");
}
var ur$2 = rr$2, or$2 = ir$2;
function sr$2(e20) {
  if (ur$2 === setTimeout)
    return setTimeout(e20, 0);
  if ((ur$2 === rr$2 || !ur$2) && setTimeout)
    return ur$2 = setTimeout, setTimeout(e20, 0);
  try {
    return ur$2(e20, 0);
  } catch (t2) {
    try {
      return ur$2.call(null, e20, 0);
    } catch (t3) {
      return ur$2.call(this, e20, 0);
    }
  }
}
typeof nr$2.setTimeout == "function" && (ur$2 = setTimeout), typeof nr$2.clearTimeout == "function" && (or$2 = clearTimeout);
var ar$2, cr$2 = [], lr$2 = false, pr$2 = -1;
function fr$2() {
  lr$2 && ar$2 && (lr$2 = false, ar$2.length ? cr$2 = ar$2.concat(cr$2) : pr$2 = -1, cr$2.length && dr$2());
}
function dr$2() {
  if (!lr$2) {
    var e20 = sr$2(fr$2);
    lr$2 = true;
    for (var t2 = cr$2.length; t2; ) {
      for (ar$2 = cr$2, cr$2 = []; ++pr$2 < t2; )
        ar$2 && ar$2[pr$2].run();
      pr$2 = -1, t2 = cr$2.length;
    }
    ar$2 = null, lr$2 = false, function(e21) {
      if (or$2 === clearTimeout)
        return clearTimeout(e21);
      if ((or$2 === ir$2 || !or$2) && clearTimeout)
        return or$2 = clearTimeout, clearTimeout(e21);
      try {
        or$2(e21);
      } catch (t3) {
        try {
          return or$2.call(null, e21);
        } catch (t4) {
          return or$2.call(this, e21);
        }
      }
    }(e20);
  }
}
function hr$2(e20, t2) {
  this.fun = e20, this.array = t2;
}
hr$2.prototype.run = function() {
  this.fun.apply(null, this.array);
};
function gr$2() {
}
var mr$2 = gr$2, yr$2 = gr$2, Dr$2 = gr$2, Er$2 = gr$2, Cr$2 = gr$2, br$2 = gr$2, Ar$2 = gr$2;
var vr$2 = nr$2.performance || {}, Fr$2 = vr$2.now || vr$2.mozNow || vr$2.msNow || vr$2.oNow || vr$2.webkitNow || function() {
  return new Date().getTime();
};
var Sr$2 = new Date();
var xr$2 = {
  nextTick: function(e20) {
    var t2 = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var n2 = 1; n2 < arguments.length; n2++)
        t2[n2 - 1] = arguments[n2];
    cr$2.push(new hr$2(e20, t2)), cr$2.length !== 1 || lr$2 || sr$2(dr$2);
  },
  title: "browser",
  browser: true,
  env: {},
  argv: [],
  version: "",
  versions: {},
  on: mr$2,
  addListener: yr$2,
  once: Dr$2,
  off: Er$2,
  removeListener: Cr$2,
  removeAllListeners: br$2,
  emit: Ar$2,
  binding: function(e20) {
    throw new Error("process.binding is not supported");
  },
  cwd: function() {
    return "/";
  },
  chdir: function(e20) {
    throw new Error("process.chdir is not supported");
  },
  umask: function() {
    return 0;
  },
  hrtime: function(e20) {
    var t2 = 1e-3 * Fr$2.call(vr$2), n2 = Math.floor(t2), r2 = Math.floor(t2 % 1 * 1e9);
    return e20 && (n2 -= e20[0], (r2 -= e20[1]) < 0 && (n2--, r2 += 1e9)), [n2, r2];
  },
  platform: "browser",
  release: {},
  config: {},
  uptime: function() {
    return (new Date() - Sr$2) / 1e3;
  }
};
var wr$2 = typeof xr$2 == "object" && xr$2.env && xr$2.env.NODE_DEBUG && /\bsemver\b/i.test(xr$2.env.NODE_DEBUG) ? (...e20) => console.error("SEMVER", ...e20) : () => {
};
var Tr$2 = {
  SEMVER_SPEC_VERSION: "2.0.0",
  MAX_LENGTH: 256,
  MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991,
  MAX_SAFE_COMPONENT_LENGTH: 16
}, Br$2 = r$3(function(e20, t2) {
  const { MAX_SAFE_COMPONENT_LENGTH: n2 } = Tr$2, r2 = (t2 = e20.exports = {}).re = [], i2 = t2.src = [], u2 = t2.t = {};
  let o2 = 0;
  const s2 = (e21, t3, n3) => {
    const s3 = o2++;
    wr$2(s3, t3), u2[e21] = s3, i2[s3] = t3, r2[s3] = new RegExp(t3, n3 ? "g" : void 0);
  };
  s2("NUMERICIDENTIFIER", "0|[1-9]\\d*"), s2("NUMERICIDENTIFIERLOOSE", "[0-9]+"), s2("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), s2("MAINVERSION", `(${i2[u2.NUMERICIDENTIFIER]})\\.(${i2[u2.NUMERICIDENTIFIER]})\\.(${i2[u2.NUMERICIDENTIFIER]})`), s2("MAINVERSIONLOOSE", `(${i2[u2.NUMERICIDENTIFIERLOOSE]})\\.(${i2[u2.NUMERICIDENTIFIERLOOSE]})\\.(${i2[u2.NUMERICIDENTIFIERLOOSE]})`), s2("PRERELEASEIDENTIFIER", `(?:${i2[u2.NUMERICIDENTIFIER]}|${i2[u2.NONNUMERICIDENTIFIER]})`), s2("PRERELEASEIDENTIFIERLOOSE", `(?:${i2[u2.NUMERICIDENTIFIERLOOSE]}|${i2[u2.NONNUMERICIDENTIFIER]})`), s2("PRERELEASE", `(?:-(${i2[u2.PRERELEASEIDENTIFIER]}(?:\\.${i2[u2.PRERELEASEIDENTIFIER]})*))`), s2("PRERELEASELOOSE", `(?:-?(${i2[u2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${i2[u2.PRERELEASEIDENTIFIERLOOSE]})*))`), s2("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), s2("BUILD", `(?:\\+(${i2[u2.BUILDIDENTIFIER]}(?:\\.${i2[u2.BUILDIDENTIFIER]})*))`), s2("FULLPLAIN", `v?${i2[u2.MAINVERSION]}${i2[u2.PRERELEASE]}?${i2[u2.BUILD]}?`), s2("FULL", `^${i2[u2.FULLPLAIN]}$`), s2("LOOSEPLAIN", `[v=\\s]*${i2[u2.MAINVERSIONLOOSE]}${i2[u2.PRERELEASELOOSE]}?${i2[u2.BUILD]}?`), s2("LOOSE", `^${i2[u2.LOOSEPLAIN]}$`), s2("GTLT", "((?:<|>)?=?)"), s2("XRANGEIDENTIFIERLOOSE", `${i2[u2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), s2("XRANGEIDENTIFIER", `${i2[u2.NUMERICIDENTIFIER]}|x|X|\\*`), s2("XRANGEPLAIN", `[v=\\s]*(${i2[u2.XRANGEIDENTIFIER]})(?:\\.(${i2[u2.XRANGEIDENTIFIER]})(?:\\.(${i2[u2.XRANGEIDENTIFIER]})(?:${i2[u2.PRERELEASE]})?${i2[u2.BUILD]}?)?)?`), s2("XRANGEPLAINLOOSE", `[v=\\s]*(${i2[u2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i2[u2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i2[u2.XRANGEIDENTIFIERLOOSE]})(?:${i2[u2.PRERELEASELOOSE]})?${i2[u2.BUILD]}?)?)?`), s2("XRANGE", `^${i2[u2.GTLT]}\\s*${i2[u2.XRANGEPLAIN]}$`), s2("XRANGELOOSE", `^${i2[u2.GTLT]}\\s*${i2[u2.XRANGEPLAINLOOSE]}$`), s2("COERCE", `(^|[^\\d])(\\d{1,${n2}})(?:\\.(\\d{1,${n2}}))?(?:\\.(\\d{1,${n2}}))?(?:$|[^\\d])`), s2("COERCERTL", i2[u2.COERCE], true), s2("LONETILDE", "(?:~>?)"), s2("TILDETRIM", `(\\s*)${i2[u2.LONETILDE]}\\s+`, true), t2.tildeTrimReplace = "$1~", s2("TILDE", `^${i2[u2.LONETILDE]}${i2[u2.XRANGEPLAIN]}$`), s2("TILDELOOSE", `^${i2[u2.LONETILDE]}${i2[u2.XRANGEPLAINLOOSE]}$`), s2("LONECARET", "(?:\\^)"), s2("CARETTRIM", `(\\s*)${i2[u2.LONECARET]}\\s+`, true), t2.caretTrimReplace = "$1^", s2("CARET", `^${i2[u2.LONECARET]}${i2[u2.XRANGEPLAIN]}$`), s2("CARETLOOSE", `^${i2[u2.LONECARET]}${i2[u2.XRANGEPLAINLOOSE]}$`), s2("COMPARATORLOOSE", `^${i2[u2.GTLT]}\\s*(${i2[u2.LOOSEPLAIN]})$|^$`), s2("COMPARATOR", `^${i2[u2.GTLT]}\\s*(${i2[u2.FULLPLAIN]})$|^$`), s2("COMPARATORTRIM", `(\\s*)${i2[u2.GTLT]}\\s*(${i2[u2.LOOSEPLAIN]}|${i2[u2.XRANGEPLAIN]})`, true), t2.comparatorTrimReplace = "$1$2$3", s2("HYPHENRANGE", `^\\s*(${i2[u2.XRANGEPLAIN]})\\s+-\\s+(${i2[u2.XRANGEPLAIN]})\\s*$`), s2("HYPHENRANGELOOSE", `^\\s*(${i2[u2.XRANGEPLAINLOOSE]})\\s+-\\s+(${i2[u2.XRANGEPLAINLOOSE]})\\s*$`), s2("STAR", "(<|>)?=?\\s*\\*"), s2("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), s2("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
});
const Nr$2 = ["includePrerelease", "loose", "rtl"];
var kr$2 = (e20) => e20 ? typeof e20 != "object" ? { loose: true } : Nr$2.filter((t2) => e20[t2]).reduce((e21, t2) => (e21[t2] = true, e21), {}) : {};
const Pr$2 = /^[0-9]+$/, Or$2 = (e20, t2) => {
  const n2 = Pr$2.test(e20), r2 = Pr$2.test(t2);
  return n2 && r2 && (e20 = +e20, t2 = +t2), e20 === t2 ? 0 : n2 && !r2 ? -1 : r2 && !n2 ? 1 : e20 < t2 ? -1 : 1;
};
var Ir$2 = {
  compareIdentifiers: Or$2,
  rcompareIdentifiers: (e20, t2) => Or$2(t2, e20)
};
const { MAX_LENGTH: Lr$2, MAX_SAFE_INTEGER: jr$2 } = Tr$2, { re: _r$2, t: Mr$2 } = Br$2, { compareIdentifiers: Rr$2 } = Ir$2;
class $r$2 {
  constructor(e20, t2) {
    if (t2 = kr$2(t2), e20 instanceof $r$2) {
      if (e20.loose === !!t2.loose && e20.includePrerelease === !!t2.includePrerelease)
        return e20;
      e20 = e20.version;
    } else if (typeof e20 != "string")
      throw new TypeError(`Invalid Version: ${e20}`);
    if (e20.length > Lr$2)
      throw new TypeError(`version is longer than ${Lr$2} characters`);
    wr$2("SemVer", e20, t2), this.options = t2, this.loose = !!t2.loose, this.includePrerelease = !!t2.includePrerelease;
    const n2 = e20.trim().match(t2.loose ? _r$2[Mr$2.LOOSE] : _r$2[Mr$2.FULL]);
    if (!n2)
      throw new TypeError(`Invalid Version: ${e20}`);
    if (this.raw = e20, this.major = +n2[1], this.minor = +n2[2], this.patch = +n2[3], this.major > jr$2 || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > jr$2 || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > jr$2 || this.patch < 0)
      throw new TypeError("Invalid patch version");
    n2[4] ? this.prerelease = n2[4].split(".").map((e21) => {
      if (/^[0-9]+$/.test(e21)) {
        const t3 = +e21;
        if (t3 >= 0 && t3 < jr$2)
          return t3;
      }
      return e21;
    }) : this.prerelease = [], this.build = n2[5] ? n2[5].split(".") : [], this.format();
  }
  format() {
    return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
  }
  toString() {
    return this.version;
  }
  compare(e20) {
    if (wr$2("SemVer.compare", this.version, this.options, e20), !(e20 instanceof $r$2)) {
      if (typeof e20 == "string" && e20 === this.version)
        return 0;
      e20 = new $r$2(e20, this.options);
    }
    return e20.version === this.version ? 0 : this.compareMain(e20) || this.comparePre(e20);
  }
  compareMain(e20) {
    return e20 instanceof $r$2 || (e20 = new $r$2(e20, this.options)), Rr$2(this.major, e20.major) || Rr$2(this.minor, e20.minor) || Rr$2(this.patch, e20.patch);
  }
  comparePre(e20) {
    if (e20 instanceof $r$2 || (e20 = new $r$2(e20, this.options)), this.prerelease.length && !e20.prerelease.length)
      return -1;
    if (!this.prerelease.length && e20.prerelease.length)
      return 1;
    if (!this.prerelease.length && !e20.prerelease.length)
      return 0;
    let t2 = 0;
    do {
      const n2 = this.prerelease[t2], r2 = e20.prerelease[t2];
      if (wr$2("prerelease compare", t2, n2, r2), n2 === void 0 && r2 === void 0)
        return 0;
      if (r2 === void 0)
        return 1;
      if (n2 === void 0)
        return -1;
      if (n2 !== r2)
        return Rr$2(n2, r2);
    } while (++t2);
  }
  compareBuild(e20) {
    e20 instanceof $r$2 || (e20 = new $r$2(e20, this.options));
    let t2 = 0;
    do {
      const n2 = this.build[t2], r2 = e20.build[t2];
      if (wr$2("prerelease compare", t2, n2, r2), n2 === void 0 && r2 === void 0)
        return 0;
      if (r2 === void 0)
        return 1;
      if (n2 === void 0)
        return -1;
      if (n2 !== r2)
        return Rr$2(n2, r2);
    } while (++t2);
  }
  inc(e20, t2) {
    switch (e20) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t2);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t2);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", t2), this.inc("pre", t2);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", t2), this.inc("pre", t2);
        break;
      case "major":
        this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0)
          this.prerelease = [0];
        else {
          let e21 = this.prerelease.length;
          for (; --e21 >= 0; )
            typeof this.prerelease[e21] == "number" && (this.prerelease[e21]++, e21 = -2);
          e21 === -1 && this.prerelease.push(0);
        }
        t2 && (this.prerelease[0] === t2 ? isNaN(this.prerelease[1]) && (this.prerelease = [t2, 0]) : this.prerelease = [t2, 0]);
        break;
      default:
        throw new Error(`invalid increment argument: ${e20}`);
    }
    return this.format(), this.raw = this.version, this;
  }
}
var Vr$2 = $r$2;
var Wr$2 = (e20, t2, n2) => new Vr$2(e20, n2).compare(new Vr$2(t2, n2));
var qr$2 = (e20, t2, n2) => Wr$2(e20, t2, n2) < 0;
var Ur$2 = (e20, t2, n2) => Wr$2(e20, t2, n2) >= 0, zr$2 = r$3(function(e20, t2) {
  function n2() {
    for (var e21 = [], t3 = 0; t3 < arguments.length; t3++)
      e21[t3] = arguments[t3];
  }
  function r2() {
    return typeof WeakMap != "undefined" ? new WeakMap() : {
      add: n2,
      delete: n2,
      get: n2,
      set: n2,
      has: function(e21) {
        return false;
      }
    };
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.outdent = void 0;
  var i2 = Object.prototype.hasOwnProperty, u2 = function(e21, t3) {
    return i2.call(e21, t3);
  };
  function o2(e21, t3) {
    for (var n3 in t3)
      u2(t3, n3) && (e21[n3] = t3[n3]);
    return e21;
  }
  var s2 = /^[ \t]*(?:\r\n|\r|\n)/, a2 = /(?:\r\n|\r|\n)[ \t]*$/, c2 = /^(?:[\r\n]|$)/, l2 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, p2 = /^[ \t]*[\r\n][ \t\r\n]*$/;
  function f2(e21, t3, n3) {
    var r3 = 0, i3 = e21[0].match(l2);
    i3 && (r3 = i3[1].length);
    var u3 = new RegExp("(\\r\\n|\\r|\\n).{0," + r3 + "}", "g");
    t3 && (e21 = e21.slice(1));
    var o3 = n3.newline, c3 = n3.trimLeadingNewline, p3 = n3.trimTrailingNewline, f3 = typeof o3 == "string", d3 = e21.length;
    return e21.map(function(e22, t4) {
      return e22 = e22.replace(u3, "$1"), t4 === 0 && c3 && (e22 = e22.replace(s2, "")), t4 === d3 - 1 && p3 && (e22 = e22.replace(a2, "")), f3 && (e22 = e22.replace(/\r\n|\n|\r/g, function(e23) {
        return o3;
      })), e22;
    });
  }
  function d2(e21, t3) {
    for (var n3 = "", r3 = 0, i3 = e21.length; r3 < i3; r3++)
      n3 += e21[r3], r3 < i3 - 1 && (n3 += t3[r3]);
    return n3;
  }
  function h2(e21) {
    return u2(e21, "raw") && u2(e21, "length");
  }
  var g2 = function e21(t3) {
    var n3 = r2(), i3 = r2();
    return o2(function r3(u3) {
      for (var s3 = [], a3 = 1; a3 < arguments.length; a3++)
        s3[a3 - 1] = arguments[a3];
      if (h2(u3)) {
        var l3 = u3, m2 = (s3[0] === r3 || s3[0] === g2) && p2.test(l3[0]) && c2.test(l3[1]), y2 = m2 ? i3 : n3, D2 = y2.get(l3);
        if (D2 || (D2 = f2(l3, m2, t3), y2.set(l3, D2)), s3.length === 0)
          return D2[0];
        var E2 = d2(D2, m2 ? s3.slice(1) : s3);
        return E2;
      }
      return e21(o2(o2({}, t3), u3 || {}));
    }, {
      string: function(e22) {
        return f2([e22], false, t3)[0];
      }
    });
  }({ trimLeadingNewline: true, trimTrailingNewline: true });
  t2.outdent = g2, t2.default = g2;
  try {
    e20.exports = g2, Object.defineProperty(g2, "__esModule", { value: true }), g2.default = g2, g2.outdent = g2;
  } catch (e21) {
  }
});
const { outdent: Gr$2 } = zr$2, Hr$2 = {
  cursorOffset: {
    since: "1.4.0",
    category: "Special",
    type: "int",
    default: -1,
    range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 },
    description: Gr$2`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `,
    cliCategory: "Editor"
  },
  endOfLine: {
    since: "1.15.0",
    category: "Global",
    type: "choice",
    default: [
      { since: "1.15.0", value: "auto" },
      { since: "2.0.0", value: "lf" }
    ],
    description: "Which end of line characters to apply.",
    choices: [
      {
        value: "lf",
        description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos"
      },
      {
        value: "crlf",
        description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows"
      },
      {
        value: "cr",
        description: "Carriage Return character only (\\r), used very rarely"
      },
      {
        value: "auto",
        description: Gr$2`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        `
      }
    ]
  },
  filepath: {
    since: "1.4.0",
    category: "Special",
    type: "path",
    description: "Specify the input filepath. This will be used to do parser inference.",
    cliName: "stdin-filepath",
    cliCategory: "Other",
    cliDescription: "Path to the file to pretend that stdin comes from."
  },
  insertPragma: {
    since: "1.8.0",
    category: "Special",
    type: "boolean",
    default: false,
    description: "Insert @format pragma into file's first docblock comment.",
    cliCategory: "Other"
  },
  parser: {
    since: "0.0.10",
    category: "Global",
    type: "choice",
    default: [
      { since: "0.0.10", value: "babylon" },
      { since: "1.13.0", value: void 0 }
    ],
    description: "Which parser to use.",
    exception: (e20) => typeof e20 == "string" || typeof e20 == "function",
    choices: [
      { value: "flow", description: "Flow" },
      { value: "babel", since: "1.16.0", description: "JavaScript" },
      { value: "babel-flow", since: "1.16.0", description: "Flow" },
      {
        value: "babel-ts",
        since: "2.0.0",
        description: "TypeScript"
      },
      {
        value: "typescript",
        since: "1.4.0",
        description: "TypeScript"
      },
      { value: "espree", since: "2.2.0", description: "JavaScript" },
      { value: "meriyah", since: "2.2.0", description: "JavaScript" },
      { value: "css", since: "1.7.1", description: "CSS" },
      { value: "less", since: "1.7.1", description: "Less" },
      { value: "scss", since: "1.7.1", description: "SCSS" },
      { value: "json", since: "1.5.0", description: "JSON" },
      { value: "json5", since: "1.13.0", description: "JSON5" },
      {
        value: "json-stringify",
        since: "1.13.0",
        description: "JSON.stringify"
      },
      { value: "graphql", since: "1.5.0", description: "GraphQL" },
      { value: "markdown", since: "1.8.0", description: "Markdown" },
      { value: "mdx", since: "1.15.0", description: "MDX" },
      { value: "vue", since: "1.10.0", description: "Vue" },
      { value: "yaml", since: "1.14.0", description: "YAML" },
      {
        value: "glimmer",
        since: "2.3.0",
        description: "Ember / Handlebars"
      },
      { value: "html", since: "1.15.0", description: "HTML" },
      { value: "angular", since: "1.15.0", description: "Angular" },
      {
        value: "lwc",
        since: "1.17.0",
        description: "Lightning Web Components"
      }
    ]
  },
  plugins: {
    since: "1.10.0",
    type: "path",
    array: true,
    default: [{ value: [] }],
    category: "Global",
    description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.",
    exception: (e20) => typeof e20 == "string" || typeof e20 == "object",
    cliName: "plugin",
    cliCategory: "Config"
  },
  pluginSearchDirs: {
    since: "1.13.0",
    type: "path",
    array: true,
    default: [{ value: [] }],
    category: "Global",
    description: Gr$2`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `,
    exception: (e20) => typeof e20 == "string" || typeof e20 == "object",
    cliName: "plugin-search-dir",
    cliCategory: "Config"
  },
  printWidth: {
    since: "0.0.0",
    category: "Global",
    type: "int",
    default: 80,
    description: "The line length where Prettier will try wrap.",
    range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }
  },
  rangeEnd: {
    since: "1.4.0",
    category: "Special",
    type: "int",
    default: Number.POSITIVE_INFINITY,
    range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 },
    description: Gr$2`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `,
    cliCategory: "Editor"
  },
  rangeStart: {
    since: "1.4.0",
    category: "Special",
    type: "int",
    default: 0,
    range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 },
    description: Gr$2`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `,
    cliCategory: "Editor"
  },
  requirePragma: {
    since: "1.7.0",
    category: "Special",
    type: "boolean",
    default: false,
    description: Gr$2`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `,
    cliCategory: "Other"
  },
  tabWidth: {
    type: "int",
    category: "Global",
    default: 2,
    description: "Number of spaces per indentation level.",
    range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }
  },
  useTabs: {
    since: "1.0.0",
    category: "Global",
    type: "boolean",
    default: false,
    description: "Indent with tabs instead of spaces."
  },
  embeddedLanguageFormatting: {
    since: "2.1.0",
    category: "Global",
    type: "choice",
    default: [{ since: "2.1.0", value: "auto" }],
    description: "Control how Prettier formats quoted code embedded in the file.",
    choices: [
      {
        value: "auto",
        description: "Format embedded code if Prettier can automatically identify it."
      },
      {
        value: "off",
        description: "Never automatically format embedded code."
      }
    ]
  }
};
const Jr$2 = ["cliName", "cliCategory", "cliDescription"], Xr$2 = { compare: Wr$2, lt: qr$2, gte: Ur$2 }, Yr$2 = e$3.version, Kr$2 = {
  CATEGORY_CONFIG: "Config",
  CATEGORY_EDITOR: "Editor",
  CATEGORY_FORMAT: "Format",
  CATEGORY_OTHER: "Other",
  CATEGORY_OUTPUT: "Output",
  CATEGORY_GLOBAL: "Global",
  CATEGORY_SPECIAL: "Special",
  options: Hr$2
}.options;
var Qr$2 = {
  getSupportInfo: function({
    plugins: e20 = [],
    showUnreleased: t2 = false,
    showDeprecated: n2 = false,
    showInternal: r2 = false
  } = {}) {
    const i2 = Yr$2.split("-", 1)[0], u2 = e20.flatMap((e21) => e21.languages || []).filter(s2), o2 = ((e21, t3) => Object.entries(e21).map(([e22, n3]) => Object.assign({ [t3]: e22 }, n3)))(Object.assign({}, ...e20.map(({ options: e21 }) => e21), Kr$2), "name").filter((e21) => s2(e21) && a2(e21)).sort((e21, t3) => e21.name === t3.name ? 0 : e21.name < t3.name ? -1 : 1).map(function(e21) {
      if (r2)
        return e21;
      return jn$2(e21, Jr$2);
    }).map((t3) => {
      t3 = Object.assign({}, t3), Array.isArray(t3.default) && (t3.default = t3.default.length === 1 ? t3.default[0].value : t3.default.filter(s2).sort((e21, t4) => Xr$2.compare(t4.since, e21.since))[0].value), Array.isArray(t3.choices) && (t3.choices = t3.choices.filter((e21) => s2(e21) && a2(e21)), t3.name === "parser" && function(e21, t4, n4) {
        const r3 = new Set(e21.choices.map((e22) => e22.value));
        for (const i3 of t4)
          if (i3.parsers) {
            for (const t5 of i3.parsers)
              if (!r3.has(t5)) {
                r3.add(t5);
                const u3 = n4.find((e22) => e22.parsers && e22.parsers[t5]);
                let o3 = i3.name;
                u3 && u3.name && (o3 += ` (plugin: ${u3.name})`), e21.choices.push({
                  value: t5,
                  description: o3
                });
              }
          }
      }(t3, u2, e20));
      const n3 = Object.fromEntries(e20.filter((e21) => e21.defaultOptions && e21.defaultOptions[t3.name] !== void 0).map((e21) => [e21.name, e21.defaultOptions[t3.name]]));
      return Object.assign(Object.assign({}, t3), {}, { pluginDefaults: n3 });
    });
    return { languages: u2, options: o2 };
    function s2(e21) {
      return t2 || !("since" in e21) || e21.since && Xr$2.gte(i2, e21.since);
    }
    function a2(e21) {
      return n2 || !("deprecated" in e21) || e21.deprecated && Xr$2.lt(i2, e21.deprecated);
    }
  }
};
const { getSupportInfo: Zr$2 } = Qr$2, ei$2 = /[^\x20-\x7F]/;
function ti$2(e20) {
  return (t2, n2, r2) => {
    const i2 = r2 && r2.backwards;
    if (n2 === false)
      return false;
    const { length: u2 } = t2;
    let o2 = n2;
    for (; o2 >= 0 && o2 < u2; ) {
      const n3 = t2.charAt(o2);
      if (e20 instanceof RegExp) {
        if (!e20.test(n3))
          return o2;
      } else if (!e20.includes(n3))
        return o2;
      i2 ? o2-- : o2++;
    }
    return (o2 === -1 || o2 === u2) && o2;
  };
}
const ni$2 = ti$2(/\s/), ri$2 = ti$2(" 	"), ii$2 = ti$2(",; 	"), ui$2 = ti$2(/[^\n\r]/);
function oi$2(e20, t2) {
  if (t2 === false)
    return false;
  if (e20.charAt(t2) === "/" && e20.charAt(t2 + 1) === "*") {
    for (let n2 = t2 + 2; n2 < e20.length; ++n2)
      if (e20.charAt(n2) === "*" && e20.charAt(n2 + 1) === "/")
        return n2 + 2;
  }
  return t2;
}
function si$2(e20, t2) {
  return t2 !== false && (e20.charAt(t2) === "/" && e20.charAt(t2 + 1) === "/" ? ui$2(e20, t2) : t2);
}
function ai$2(e20, t2, n2) {
  const r2 = n2 && n2.backwards;
  if (t2 === false)
    return false;
  const i2 = e20.charAt(t2);
  if (r2) {
    if (e20.charAt(t2 - 1) === "\r" && i2 === "\n")
      return t2 - 2;
    if (i2 === "\n" || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
      return t2 - 1;
  } else {
    if (i2 === "\r" && e20.charAt(t2 + 1) === "\n")
      return t2 + 2;
    if (i2 === "\n" || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
      return t2 + 1;
  }
  return t2;
}
function ci$2(e20, t2, n2 = {}) {
  const r2 = ri$2(e20, n2.backwards ? t2 - 1 : t2, n2);
  return r2 !== ai$2(e20, r2, n2);
}
function li$2(e20, t2) {
  let n2 = null, r2 = t2;
  for (; r2 !== n2; )
    n2 = r2, r2 = ii$2(e20, r2), r2 = oi$2(e20, r2), r2 = ri$2(e20, r2);
  return r2 = si$2(e20, r2), r2 = ai$2(e20, r2), r2 !== false && ci$2(e20, r2);
}
function pi$2(e20, t2) {
  let n2 = null, r2 = t2;
  for (; r2 !== n2; )
    n2 = r2, r2 = ri$2(e20, r2), r2 = oi$2(e20, r2), r2 = si$2(e20, r2), r2 = ai$2(e20, r2);
  return r2;
}
function fi$2(e20, t2, n2) {
  return pi$2(e20, n2(t2));
}
function di$2(e20, t2, n2 = 0) {
  let r2 = 0;
  for (let i2 = n2; i2 < e20.length; ++i2)
    e20[i2] === "	" ? r2 = r2 + t2 - r2 % t2 : r2++;
  return r2;
}
function hi$2(e20, t2) {
  const n2 = e20.slice(1, -1), r2 = { quote: '"', regex: /"/g }, i2 = { quote: "'", regex: /'/g }, u2 = t2 === "'" ? i2 : r2, o2 = u2 === i2 ? r2 : i2;
  let s2 = u2.quote;
  if (n2.includes(u2.quote) || n2.includes(o2.quote)) {
    s2 = (n2.match(u2.regex) || []).length > (n2.match(o2.regex) || []).length ? o2.quote : u2.quote;
  }
  return s2;
}
function gi$2(e20, t2, n2) {
  const r2 = t2 === '"' ? "'" : '"', i2 = e20.replace(/\\(.)|(["'])/gs, (e21, i3, u2) => i3 === r2 ? i3 : u2 === t2 ? "\\" + u2 : u2 || (n2 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(i3) ? i3 : "\\" + i3));
  return t2 + i2 + t2;
}
function mi$2(e20, t2) {
  (e20.comments || (e20.comments = [])).push(t2), t2.printed = false, t2.nodeDescription = function(e21) {
    const t3 = e21.type || e21.kind || "(unknown type)";
    let n2 = String(e21.name || e21.id && (typeof e21.id == "object" ? e21.id.name : e21.id) || e21.key && (typeof e21.key == "object" ? e21.key.name : e21.key) || e21.value && (typeof e21.value == "object" ? "" : String(e21.value)) || e21.operator || "");
    n2.length > 20 && (n2 = n2.slice(0, 19) + "\u2026");
    return t3 + (n2 ? " " + n2 : "");
  }(e20);
}
var yi$2 = {
  inferParserByLanguage: function(e20, t2) {
    const { languages: n2 } = Zr$2({ plugins: t2.plugins }), r2 = n2.find(({ name: t3 }) => t3.toLowerCase() === e20) || n2.find(({ aliases: t3 }) => Array.isArray(t3) && t3.includes(e20)) || n2.find(({ extensions: t3 }) => Array.isArray(t3) && t3.includes(`.${e20}`));
    return r2 && r2.parsers[0];
  },
  getStringWidth: function(e20) {
    return e20 ? ei$2.test(e20) ? Pn$2(e20) : e20.length : 0;
  },
  getMaxContinuousCount: function(e20, t2) {
    const n2 = e20.match(new RegExp(`(${In$2(t2)})+`, "g"));
    return n2 === null ? 0 : n2.reduce((e21, n3) => Math.max(e21, n3.length / t2.length), 0);
  },
  getMinNotPresentContinuousCount: function(e20, t2) {
    const n2 = e20.match(new RegExp(`(${In$2(t2)})+`, "g"));
    if (n2 === null)
      return 0;
    const r2 = new Map();
    let i2 = 0;
    for (const e21 of n2) {
      const n3 = e21.length / t2.length;
      r2.set(n3, true), n3 > i2 && (i2 = n3);
    }
    for (let e21 = 1; e21 < i2; e21++)
      if (!r2.get(e21))
        return e21;
    return i2 + 1;
  },
  getPenultimate: (e20) => e20[e20.length - 2],
  getLast: Ln$2,
  getNextNonSpaceNonCommentCharacterIndexWithStartIndex: pi$2,
  getNextNonSpaceNonCommentCharacterIndex: fi$2,
  getNextNonSpaceNonCommentCharacter: function(e20, t2, n2) {
    return e20.charAt(fi$2(e20, t2, n2));
  },
  skip: ti$2,
  skipWhitespace: ni$2,
  skipSpaces: ri$2,
  skipToLineEnd: ii$2,
  skipEverythingButNewLine: ui$2,
  skipInlineComment: oi$2,
  skipTrailingComment: si$2,
  skipNewline: ai$2,
  isNextLineEmptyAfterIndex: li$2,
  isNextLineEmpty: function(e20, t2, n2) {
    return li$2(e20, n2(t2));
  },
  isPreviousLineEmpty: function(e20, t2, n2) {
    let r2 = n2(t2) - 1;
    return r2 = ri$2(e20, r2, { backwards: true }), r2 = ai$2(e20, r2, { backwards: true }), r2 = ri$2(e20, r2, { backwards: true }), r2 !== ai$2(e20, r2, { backwards: true });
  },
  hasNewline: ci$2,
  hasNewlineInRange: function(e20, t2, n2) {
    for (let r2 = t2; r2 < n2; ++r2)
      if (e20.charAt(r2) === "\n")
        return true;
    return false;
  },
  hasSpaces: function(e20, t2, n2 = {}) {
    return ri$2(e20, n2.backwards ? t2 - 1 : t2, n2) !== t2;
  },
  getAlignmentSize: di$2,
  getIndentSize: function(e20, t2) {
    const n2 = e20.lastIndexOf("\n");
    return n2 === -1 ? 0 : di$2(e20.slice(n2 + 1).match(/^[\t ]*/)[0], t2);
  },
  getPreferredQuote: hi$2,
  printString: function(e20, t2) {
    return gi$2(e20.slice(1, -1), t2.parser === "json" || t2.parser === "json5" && t2.quoteProps === "preserve" && !t2.singleQuote ? '"' : t2.__isInHtmlAttribute ? "'" : hi$2(e20, t2.singleQuote ? "'" : '"'), !(t2.parser === "css" || t2.parser === "less" || t2.parser === "scss" || t2.__embeddedInHtml));
  },
  printNumber: function(e20) {
    return e20.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
  },
  makeString: gi$2,
  addLeadingComment: function(e20, t2) {
    t2.leading = true, t2.trailing = false, mi$2(e20, t2);
  },
  addDanglingComment: function(e20, t2, n2) {
    t2.leading = false, t2.trailing = false, n2 && (t2.marker = n2), mi$2(e20, t2);
  },
  addTrailingComment: function(e20, t2) {
    t2.leading = false, t2.trailing = true, mi$2(e20, t2);
  },
  isFrontMatterNode: function(e20) {
    return e20 && e20.type === "front-matter";
  },
  getShebang: function(e20) {
    if (!e20.startsWith("#!"))
      return "";
    const t2 = e20.indexOf("\n");
    return t2 === -1 ? e20 : e20.slice(0, t2);
  },
  isNonEmptyArray: function(e20) {
    return Array.isArray(e20) && e20.length > 0;
  },
  createGroupIdMapper: function(e20) {
    const t2 = new WeakMap();
    return function(n2) {
      return t2.has(n2) || t2.set(n2, Symbol(e20)), t2.get(n2);
    };
  }
};
var Di$2 = {
  guessEndOfLine: function(e20) {
    const t2 = e20.indexOf("\r");
    return t2 >= 0 ? e20.charAt(t2 + 1) === "\n" ? "crlf" : "cr" : "lf";
  },
  convertEndOfLineToChars: function(e20) {
    switch (e20) {
      case "cr":
        return "\r";
      case "crlf":
        return "\r\n";
      default:
        return "\n";
    }
  },
  countEndOfLineChars: function(e20, t2) {
    let n2;
    if (t2 === "\n")
      n2 = /\n/g;
    else if (t2 === "\r")
      n2 = /\r/g;
    else {
      if (t2 !== "\r\n")
        throw new Error(`Unexpected "eol" ${JSON.stringify(t2)}.`);
      n2 = /\r\n/g;
    }
    const r2 = e20.match(n2);
    return r2 ? r2.length : 0;
  },
  normalizeEndOfLine: function(e20) {
    return e20.replace(/\r\n?/g, "\n");
  }
};
const { literalline: Ei$2, join: Ci$2 } = xn$2, bi$2 = (e20) => Array.isArray(e20) || e20 && e20.type === "concat", Ai$2 = (e20) => {
  if (Array.isArray(e20))
    return e20;
  if (e20.type !== "concat" && e20.type !== "fill")
    throw new Error("Expect doc type to be `concat` or `fill`.");
  return e20.parts;
}, vi$2 = {};
function Fi$2(e20, t2, n2, r2) {
  const i2 = [e20];
  for (; i2.length > 0; ) {
    const e21 = i2.pop();
    if (e21 !== vi$2) {
      if (n2 && i2.push(e21, vi$2), !t2 || t2(e21) !== false)
        if (bi$2(e21) || e21.type === "fill") {
          const t3 = Ai$2(e21);
          for (let e22 = t3.length - 1; e22 >= 0; --e22)
            i2.push(t3[e22]);
        } else if (e21.type === "if-break")
          e21.flatContents && i2.push(e21.flatContents), e21.breakContents && i2.push(e21.breakContents);
        else if (e21.type === "group" && e21.expandedStates)
          if (r2)
            for (let t3 = e21.expandedStates.length - 1; t3 >= 0; --t3)
              i2.push(e21.expandedStates[t3]);
          else
            i2.push(e21.contents);
        else
          e21.contents && i2.push(e21.contents);
    } else
      n2(i2.pop());
  }
}
function Si$2(e20, t2) {
  const n2 = new Map();
  return r2(e20);
  function r2(e21) {
    if (n2.has(e21))
      return n2.get(e21);
    const i2 = function(e22) {
      if (Array.isArray(e22))
        return t2(e22.map(r2));
      if (e22.type === "concat" || e22.type === "fill") {
        const n3 = e22.parts.map(r2);
        return t2(Object.assign(Object.assign({}, e22), {}, { parts: n3 }));
      }
      if (e22.type === "if-break") {
        const n3 = e22.breakContents && r2(e22.breakContents), i3 = e22.flatContents && r2(e22.flatContents);
        return t2(Object.assign(Object.assign({}, e22), {}, { breakContents: n3, flatContents: i3 }));
      }
      if (e22.type === "group" && e22.expandedStates) {
        const n3 = e22.expandedStates.map(r2), i3 = n3[0];
        return t2(Object.assign(Object.assign({}, e22), {}, { contents: i3, expandedStates: n3 }));
      }
      if (e22.contents) {
        const n3 = r2(e22.contents);
        return t2(Object.assign(Object.assign({}, e22), {}, { contents: n3 }));
      }
      return t2(e22);
    }(e21);
    return n2.set(e21, i2), i2;
  }
}
function xi$2(e20, t2, n2) {
  let r2 = n2, i2 = false;
  return Fi$2(e20, function(e21) {
    const n3 = t2(e21);
    if (n3 !== void 0 && (i2 = true, r2 = n3), i2)
      return false;
  }), r2;
}
function wi$2(e20) {
  return !(e20.type !== "group" || !e20.break) || !(e20.type !== "line" || !e20.hard) || e20.type === "break-parent" || void 0;
}
function Ti$2(e20) {
  if (e20.length > 0) {
    const t2 = Ln$2(e20);
    t2.expandedStates || t2.break || (t2.break = "propagated");
  }
  return null;
}
function Bi$2(e20) {
  return e20.type !== "line" || e20.hard ? e20.type === "if-break" ? e20.flatContents || "" : e20 : e20.soft ? "" : " ";
}
const Ni$2 = (e20, t2) => e20 && e20.type === "line" && e20.hard && t2 && t2.type === "break-parent";
function ki$2(e20) {
  if (!e20)
    return e20;
  if (bi$2(e20) || e20.type === "fill") {
    const t2 = Ai$2(e20);
    for (; t2.length > 1 && Ni$2(...t2.slice(-2)); )
      t2.length -= 2;
    if (t2.length > 0) {
      const e21 = ki$2(Ln$2(t2));
      t2[t2.length - 1] = e21;
    }
    return Array.isArray(e20) ? t2 : Object.assign(Object.assign({}, e20), {}, { parts: t2 });
  }
  switch (e20.type) {
    case "align":
    case "indent":
    case "indent-if-break":
    case "group":
    case "line-suffix":
    case "label": {
      const t2 = ki$2(e20.contents);
      return Object.assign(Object.assign({}, e20), {}, { contents: t2 });
    }
    case "if-break": {
      const t2 = ki$2(e20.breakContents), n2 = ki$2(e20.flatContents);
      return Object.assign(Object.assign({}, e20), {}, { breakContents: t2, flatContents: n2 });
    }
  }
  return e20;
}
function Pi$2(e20) {
  return Si$2(e20, (e21) => function(e22) {
    switch (e22.type) {
      case "fill":
        if (e22.parts.length === 0 || e22.parts.every((e23) => e23 === ""))
          return "";
        break;
      case "group":
        if (!(e22.contents || e22.id || e22.break || e22.expandedStates))
          return "";
        if (e22.contents.type === "group" && e22.contents.id === e22.id && e22.contents.break === e22.break && e22.contents.expandedStates === e22.expandedStates)
          return e22.contents;
        break;
      case "align":
      case "indent":
      case "indent-if-break":
      case "line-suffix":
        if (!e22.contents)
          return "";
        break;
      case "if-break":
        if (!e22.flatContents && !e22.breakContents)
          return "";
    }
    if (!bi$2(e22))
      return e22;
    const t2 = [];
    for (const n2 of Ai$2(e22)) {
      if (!n2)
        continue;
      const [e23, ...r2] = bi$2(n2) ? Ai$2(n2) : [n2];
      typeof e23 == "string" && typeof Ln$2(t2) == "string" ? t2[t2.length - 1] += e23 : t2.push(e23), t2.push(...r2);
    }
    return t2.length === 0 ? "" : t2.length === 1 ? t2[0] : Array.isArray(e22) ? t2 : Object.assign(Object.assign({}, e22), {}, { parts: t2 });
  }(e21));
}
function Oi$2(e20) {
  const t2 = [], n2 = e20.filter(Boolean);
  for (; n2.length > 0; ) {
    const e21 = n2.shift();
    e21 && (bi$2(e21) ? n2.unshift(...Ai$2(e21)) : t2.length > 0 && typeof Ln$2(t2) == "string" && typeof e21 == "string" ? t2[t2.length - 1] += e21 : t2.push(e21));
  }
  return t2;
}
function Ii$2(e20, t2 = Ei$2) {
  return Ci$2(t2, e20.split("\n")).parts;
}
var Li$2 = {
  isConcat: bi$2,
  getDocParts: Ai$2,
  willBreak: function(e20) {
    return xi$2(e20, wi$2, false);
  },
  traverseDoc: Fi$2,
  findInDoc: xi$2,
  mapDoc: Si$2,
  propagateBreaks: function(e20) {
    const t2 = new Set(), n2 = [];
    Fi$2(e20, function(e21) {
      if (e21.type === "break-parent" && Ti$2(n2), e21.type === "group") {
        if (n2.push(e21), t2.has(e21))
          return false;
        t2.add(e21);
      }
    }, function(e21) {
      if (e21.type === "group") {
        n2.pop().break && Ti$2(n2);
      }
    }, true);
  },
  removeLines: function(e20) {
    return Si$2(e20, Bi$2);
  },
  stripTrailingHardline: function(e20) {
    return ki$2(Pi$2(e20));
  },
  normalizeParts: Oi$2,
  normalizeDoc: function(e20) {
    return Si$2(e20, (e21) => Array.isArray(e21) ? Oi$2(e21) : e21.parts ? Object.assign(Object.assign({}, e21), {}, { parts: Oi$2(e21.parts) }) : e21);
  },
  cleanDoc: Pi$2,
  replaceTextEndOfLine: Ii$2,
  replaceEndOfLine: function(e20) {
    return Si$2(e20, (e21) => typeof e21 == "string" && e21.includes("\n") ? Ii$2(e21) : e21);
  }
};
const { getStringWidth: ji$2, getLast: _i$2 } = yi$2, { convertEndOfLineToChars: Mi$2 } = Di$2, { fill: Ri$2, cursor: $i$2, indent: Vi$2 } = xn$2, { isConcat: Wi$2, getDocParts: qi$2 } = Li$2;
let Ui$2;
function zi$2(e20, t2) {
  return Hi$2(e20, { type: "indent" }, t2);
}
function Gi$2(e20, t2, n2) {
  if (t2 === Number.NEGATIVE_INFINITY)
    return e20.root || { value: "", length: 0, queue: [] };
  if (t2 < 0)
    return Hi$2(e20, { type: "dedent" }, n2);
  if (!t2)
    return e20;
  if (t2.type === "root")
    return Object.assign(Object.assign({}, e20), {}, { root: e20 });
  return Hi$2(e20, { type: typeof t2 == "string" ? "stringAlign" : "numberAlign", n: t2 }, n2);
}
function Hi$2(e20, t2, n2) {
  const r2 = t2.type === "dedent" ? e20.queue.slice(0, -1) : [...e20.queue, t2];
  let i2 = "", u2 = 0, o2 = 0, s2 = 0;
  for (const e21 of r2)
    switch (e21.type) {
      case "indent":
        l2(), n2.useTabs ? a2(1) : c2(n2.tabWidth);
        break;
      case "stringAlign":
        l2(), i2 += e21.n, u2 += e21.n.length;
        break;
      case "numberAlign":
        o2 += 1, s2 += e21.n;
        break;
      default:
        throw new Error(`Unexpected type '${e21.type}'`);
    }
  return p2(), Object.assign(Object.assign({}, e20), {}, { value: i2, length: u2, queue: r2 });
  function a2(e21) {
    i2 += "	".repeat(e21), u2 += n2.tabWidth * e21;
  }
  function c2(e21) {
    i2 += " ".repeat(e21), u2 += e21;
  }
  function l2() {
    n2.useTabs ? function() {
      o2 > 0 && a2(o2);
      f2();
    }() : p2();
  }
  function p2() {
    s2 > 0 && c2(s2), f2();
  }
  function f2() {
    o2 = 0, s2 = 0;
  }
}
function Ji$2(e20) {
  if (e20.length === 0)
    return 0;
  let t2 = 0;
  for (; e20.length > 0 && typeof _i$2(e20) == "string" && /^[\t ]*$/.test(_i$2(e20)); )
    t2 += e20.pop().length;
  if (e20.length > 0 && typeof _i$2(e20) == "string") {
    const n2 = _i$2(e20).replace(/[\t ]*$/, "");
    t2 += _i$2(e20).length - n2.length, e20[e20.length - 1] = n2;
  }
  return t2;
}
function Xi$2(e20, t2, n2, r2, i2, u2) {
  let o2 = t2.length;
  const s2 = [e20], a2 = [];
  for (; n2 >= 0; ) {
    if (s2.length === 0) {
      if (o2 === 0)
        return true;
      s2.push(t2[o2 - 1]), o2--;
      continue;
    }
    const [e21, c2, l2] = s2.pop();
    if (typeof l2 == "string")
      a2.push(l2), n2 -= ji$2(l2);
    else if (Wi$2(l2)) {
      const t3 = qi$2(l2);
      for (let n3 = t3.length - 1; n3 >= 0; n3--)
        s2.push([e21, c2, t3[n3]]);
    } else
      switch (l2.type) {
        case "indent":
          s2.push([zi$2(e21, r2), c2, l2.contents]);
          break;
        case "align":
          s2.push([Gi$2(e21, l2.n, r2), c2, l2.contents]);
          break;
        case "trim":
          n2 += Ji$2(a2);
          break;
        case "group": {
          if (u2 && l2.break)
            return false;
          const t3 = l2.break ? 1 : c2;
          s2.push([
            e21,
            t3,
            l2.expandedStates && t3 === 1 ? _i$2(l2.expandedStates) : l2.contents
          ]), l2.id && (Ui$2[l2.id] = t3);
          break;
        }
        case "fill":
          for (let t3 = l2.parts.length - 1; t3 >= 0; t3--)
            s2.push([e21, c2, l2.parts[t3]]);
          break;
        case "if-break":
        case "indent-if-break": {
          const t3 = l2.groupId ? Ui$2[l2.groupId] : c2;
          if (t3 === 1) {
            const t4 = l2.type === "if-break" ? l2.breakContents : l2.negate ? l2.contents : Vi$2(l2.contents);
            t4 && s2.push([e21, c2, t4]);
          }
          if (t3 === 2) {
            const t4 = l2.type === "if-break" ? l2.flatContents : l2.negate ? Vi$2(l2.contents) : l2.contents;
            t4 && s2.push([e21, c2, t4]);
          }
          break;
        }
        case "line":
          switch (c2) {
            case 2:
              if (!l2.hard) {
                l2.soft || (a2.push(" "), n2 -= 1);
                break;
              }
              return true;
            case 1:
              return true;
          }
          break;
        case "line-suffix":
          i2 = true;
          break;
        case "line-suffix-boundary":
          if (i2)
            return false;
          break;
        case "label":
          s2.push([e21, c2, l2.contents]);
      }
  }
  return false;
}
var Yi$2 = {
  printDocToString: function(e20, t2) {
    Ui$2 = {};
    const n2 = t2.printWidth, r2 = Mi$2(t2.endOfLine);
    let i2 = 0;
    const u2 = [[{ value: "", length: 0, queue: [] }, 1, e20]], o2 = [];
    let s2 = false, a2 = [];
    for (; u2.length > 0; ) {
      const [e21, c3, l2] = u2.pop();
      if (typeof l2 == "string") {
        const e22 = r2 !== "\n" ? l2.replace(/\n/g, r2) : l2;
        o2.push(e22), i2 += ji$2(e22);
      } else if (Wi$2(l2)) {
        const t3 = qi$2(l2);
        for (let n3 = t3.length - 1; n3 >= 0; n3--)
          u2.push([e21, c3, t3[n3]]);
      } else
        switch (l2.type) {
          case "cursor":
            o2.push($i$2.placeholder);
            break;
          case "indent":
            u2.push([zi$2(e21, t2), c3, l2.contents]);
            break;
          case "align":
            u2.push([Gi$2(e21, l2.n, t2), c3, l2.contents]);
            break;
          case "trim":
            i2 -= Ji$2(o2);
            break;
          case "group":
            switch (c3) {
              case 2:
                if (!s2) {
                  u2.push([e21, l2.break ? 1 : 2, l2.contents]);
                  break;
                }
              case 1: {
                s2 = false;
                const r3 = [e21, 2, l2.contents], o3 = n2 - i2, c4 = a2.length > 0;
                if (!l2.break && Xi$2(r3, u2, o3, t2, c4))
                  u2.push(r3);
                else if (l2.expandedStates) {
                  const n3 = _i$2(l2.expandedStates);
                  if (l2.break) {
                    u2.push([e21, 1, n3]);
                    break;
                  }
                  for (let r4 = 1; r4 < l2.expandedStates.length + 1; r4++) {
                    if (r4 >= l2.expandedStates.length) {
                      u2.push([e21, 1, n3]);
                      break;
                    }
                    {
                      const n4 = [
                        e21,
                        2,
                        l2.expandedStates[r4]
                      ];
                      if (Xi$2(n4, u2, o3, t2, c4)) {
                        u2.push(n4);
                        break;
                      }
                    }
                  }
                } else
                  u2.push([e21, 1, l2.contents]);
                break;
              }
            }
            l2.id && (Ui$2[l2.id] = _i$2(u2)[1]);
            break;
          case "fill": {
            const r3 = n2 - i2, { parts: o3 } = l2;
            if (o3.length === 0)
              break;
            const [s3, p2] = o3, f2 = [e21, 2, s3], d2 = [e21, 1, s3], h2 = Xi$2(f2, [], r3, t2, a2.length > 0, true);
            if (o3.length === 1) {
              h2 ? u2.push(f2) : u2.push(d2);
              break;
            }
            const g2 = [e21, 2, p2], m2 = [e21, 1, p2];
            if (o3.length === 2) {
              h2 ? u2.push(g2, f2) : u2.push(m2, d2);
              break;
            }
            o3.splice(0, 2);
            const y2 = [e21, c3, Ri$2(o3)];
            Xi$2([e21, 2, [s3, p2, o3[0]]], [], r3, t2, a2.length > 0, true) ? u2.push(y2, g2, f2) : h2 ? u2.push(y2, m2, f2) : u2.push(y2, m2, d2);
            break;
          }
          case "if-break":
          case "indent-if-break": {
            const t3 = l2.groupId ? Ui$2[l2.groupId] : c3;
            if (t3 === 1) {
              const t4 = l2.type === "if-break" ? l2.breakContents : l2.negate ? l2.contents : Vi$2(l2.contents);
              t4 && u2.push([e21, c3, t4]);
            }
            if (t3 === 2) {
              const t4 = l2.type === "if-break" ? l2.flatContents : l2.negate ? Vi$2(l2.contents) : l2.contents;
              t4 && u2.push([e21, c3, t4]);
            }
            break;
          }
          case "line-suffix":
            a2.push([e21, c3, l2.contents]);
            break;
          case "line-suffix-boundary":
            a2.length > 0 && u2.push([e21, c3, { type: "line", hard: true }]);
            break;
          case "line":
            switch (c3) {
              case 2:
                if (!l2.hard) {
                  l2.soft || (o2.push(" "), i2 += 1);
                  break;
                }
                s2 = true;
              case 1:
                if (a2.length > 0) {
                  u2.push([e21, c3, l2], ...a2.reverse()), a2 = [];
                  break;
                }
                l2.literal ? e21.root ? (o2.push(r2, e21.root.value), i2 = e21.root.length) : (o2.push(r2), i2 = 0) : (i2 -= Ji$2(o2), o2.push(r2 + e21.value), i2 = e21.length);
            }
            break;
          case "label":
            u2.push([e21, c3, l2.contents]);
        }
      u2.length === 0 && a2.length > 0 && (u2.push(...a2.reverse()), a2 = []);
    }
    const c2 = o2.indexOf($i$2.placeholder);
    if (c2 !== -1) {
      const e21 = o2.indexOf($i$2.placeholder, c2 + 1), t3 = o2.slice(0, c2).join(""), n3 = o2.slice(c2 + 1, e21).join("");
      return {
        formatted: t3 + n3 + o2.slice(e21 + 1).join(""),
        cursorNodeStart: t3.length,
        cursorNodeText: n3
      };
    }
    return { formatted: o2.join("") };
  }
};
const { isConcat: Ki$2, getDocParts: Qi$2 } = Li$2;
function Zi$2(e20) {
  if (!e20)
    return "";
  if (Ki$2(e20)) {
    const t2 = [];
    for (const n2 of Qi$2(e20))
      if (Ki$2(n2))
        t2.push(...Zi$2(n2).parts);
      else {
        const e21 = Zi$2(n2);
        e21 !== "" && t2.push(e21);
      }
    return { type: "concat", parts: t2 };
  }
  return e20.type === "if-break" ? Object.assign(Object.assign({}, e20), {}, {
    breakContents: Zi$2(e20.breakContents),
    flatContents: Zi$2(e20.flatContents)
  }) : e20.type === "group" ? Object.assign(Object.assign({}, e20), {}, {
    contents: Zi$2(e20.contents),
    expandedStates: e20.expandedStates && e20.expandedStates.map(Zi$2)
  }) : e20.type === "fill" ? { type: "fill", parts: e20.parts.map(Zi$2) } : e20.contents ? Object.assign(Object.assign({}, e20), {}, { contents: Zi$2(e20.contents) }) : e20;
}
var eu$1 = {
  builders: xn$2,
  printer: Yi$2,
  utils: Li$2,
  debug: {
    printDocToDebug: function(e20) {
      const t2 = Object.create(null), n2 = new Set();
      return function e21(t3, n3, i2) {
        if (typeof t3 == "string")
          return JSON.stringify(t3);
        if (Ki$2(t3)) {
          const n4 = Qi$2(t3).map(e21).filter(Boolean);
          return n4.length === 1 ? n4[0] : `[${n4.join(", ")}]`;
        }
        if (t3.type === "line") {
          const e22 = Array.isArray(i2) && i2[n3 + 1] && i2[n3 + 1].type === "break-parent";
          return t3.literal ? e22 ? "literalline" : "literallineWithoutBreakParent" : t3.hard ? e22 ? "hardline" : "hardlineWithoutBreakParent" : t3.soft ? "softline" : "line";
        }
        if (t3.type === "break-parent") {
          return Array.isArray(i2) && i2[n3 - 1] && i2[n3 - 1].type === "line" && i2[n3 - 1].hard ? void 0 : "breakParent";
        }
        if (t3.type === "trim")
          return "trim";
        if (t3.type === "indent")
          return "indent(" + e21(t3.contents) + ")";
        if (t3.type === "align")
          return t3.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + e21(t3.contents) + ")" : t3.n < 0 ? "dedent(" + e21(t3.contents) + ")" : t3.n.type === "root" ? "markAsRoot(" + e21(t3.contents) + ")" : "align(" + JSON.stringify(t3.n) + ", " + e21(t3.contents) + ")";
        if (t3.type === "if-break")
          return "ifBreak(" + e21(t3.breakContents) + (t3.flatContents ? ", " + e21(t3.flatContents) : "") + (t3.groupId ? (t3.flatContents ? "" : ', ""') + `, { groupId: ${r2(t3.groupId)} }` : "") + ")";
        if (t3.type === "indent-if-break") {
          const n4 = [];
          t3.negate && n4.push("negate: true"), t3.groupId && n4.push(`groupId: ${r2(t3.groupId)}`);
          const i3 = n4.length > 0 ? `, { ${n4.join(", ")} }` : "";
          return `indentIfBreak(${e21(t3.contents)}${i3})`;
        }
        if (t3.type === "group") {
          const n4 = [];
          t3.break && t3.break !== "propagated" && n4.push("shouldBreak: true"), t3.id && n4.push(`id: ${r2(t3.id)}`);
          const i3 = n4.length > 0 ? `, { ${n4.join(", ")} }` : "";
          return t3.expandedStates ? `conditionalGroup([${t3.expandedStates.map((t4) => e21(t4)).join(",")}]${i3})` : `group(${e21(t3.contents)}${i3})`;
        }
        if (t3.type === "fill")
          return `fill([${t3.parts.map((t4) => e21(t4)).join(", ")}])`;
        if (t3.type === "line-suffix")
          return "lineSuffix(" + e21(t3.contents) + ")";
        if (t3.type === "line-suffix-boundary")
          return "lineSuffixBoundary";
        if (t3.type === "label")
          return `label(${JSON.stringify(t3.label)}, ${e21(t3.contents)})`;
        throw new Error("Unknown doc type " + t3.type);
      }(Zi$2(e20));
      function r2(e21) {
        if (typeof e21 != "symbol")
          return JSON.stringify(String(e21));
        if (e21 in t2)
          return t2[e21];
        const r3 = String(e21).slice(7, -1) || "symbol";
        for (let i2 = 0; ; i2++) {
          const u2 = r3 + (i2 > 0 ? ` #${i2}` : "");
          if (!n2.has(u2))
            return n2.add(u2), t2[e21] = `Symbol.for(${JSON.stringify(u2)})`;
        }
      }
    }
  }
}, tu$1 = Object.freeze({ __proto__: null, default: {} });
function nu$1(e20, t2) {
  for (var n2 = 0, r2 = e20.length - 1; r2 >= 0; r2--) {
    var i2 = e20[r2];
    i2 === "." ? e20.splice(r2, 1) : i2 === ".." ? (e20.splice(r2, 1), n2++) : n2 && (e20.splice(r2, 1), n2--);
  }
  if (t2)
    for (; n2--; n2)
      e20.unshift("..");
  return e20;
}
var ru$1 = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, iu$1 = function(e20) {
  return ru$1.exec(e20).slice(1);
};
function uu$1() {
  for (var e20 = "", t2 = false, n2 = arguments.length - 1; n2 >= -1 && !t2; n2--) {
    var r2 = n2 >= 0 ? arguments[n2] : "/";
    if (typeof r2 != "string")
      throw new TypeError("Arguments to path.resolve must be strings");
    r2 && (e20 = r2 + "/" + e20, t2 = r2.charAt(0) === "/");
  }
  return (t2 ? "/" : "") + (e20 = nu$1(hu$1(e20.split("/"), function(e21) {
    return !!e21;
  }), !t2).join("/")) || ".";
}
function ou$1(e20) {
  var t2 = su$1(e20), n2 = gu$1(e20, -1) === "/";
  return (e20 = nu$1(hu$1(e20.split("/"), function(e21) {
    return !!e21;
  }), !t2).join("/")) || t2 || (e20 = "."), e20 && n2 && (e20 += "/"), (t2 ? "/" : "") + e20;
}
function su$1(e20) {
  return e20.charAt(0) === "/";
}
function au$1() {
  var e20 = Array.prototype.slice.call(arguments, 0);
  return ou$1(hu$1(e20, function(e21, t2) {
    if (typeof e21 != "string")
      throw new TypeError("Arguments to path.join must be strings");
    return e21;
  }).join("/"));
}
function cu$1(e20, t2) {
  function n2(e21) {
    for (var t3 = 0; t3 < e21.length && e21[t3] === ""; t3++)
      ;
    for (var n3 = e21.length - 1; n3 >= 0 && e21[n3] === ""; n3--)
      ;
    return t3 > n3 ? [] : e21.slice(t3, n3 - t3 + 1);
  }
  e20 = uu$1(e20).substr(1), t2 = uu$1(t2).substr(1);
  for (var r2 = n2(e20.split("/")), i2 = n2(t2.split("/")), u2 = Math.min(r2.length, i2.length), o2 = u2, s2 = 0; s2 < u2; s2++)
    if (r2[s2] !== i2[s2]) {
      o2 = s2;
      break;
    }
  var a2 = [];
  for (s2 = o2; s2 < r2.length; s2++)
    a2.push("..");
  return (a2 = a2.concat(i2.slice(o2))).join("/");
}
function lu$1(e20) {
  var t2 = iu$1(e20), n2 = t2[0], r2 = t2[1];
  return n2 || r2 ? (r2 && (r2 = r2.substr(0, r2.length - 1)), n2 + r2) : ".";
}
function pu$1(e20, t2) {
  var n2 = iu$1(e20)[2];
  return t2 && n2.substr(-1 * t2.length) === t2 && (n2 = n2.substr(0, n2.length - t2.length)), n2;
}
function fu$1(e20) {
  return iu$1(e20)[3];
}
var du$1 = {
  extname: fu$1,
  basename: pu$1,
  dirname: lu$1,
  sep: "/",
  delimiter: ":",
  relative: cu$1,
  join: au$1,
  isAbsolute: su$1,
  normalize: ou$1,
  resolve: uu$1
};
function hu$1(e20, t2) {
  if (e20.filter)
    return e20.filter(t2);
  for (var n2 = [], r2 = 0; r2 < e20.length; r2++)
    t2(e20[r2], r2, e20) && n2.push(e20[r2]);
  return n2;
}
var gu$1 = "ab".substr(-1) === "b" ? function(e20, t2, n2) {
  return e20.substr(t2, n2);
} : function(e20, t2, n2) {
  return t2 < 0 && (t2 = e20.length + t2), e20.substr(t2, n2);
}, mu$1 = Object.freeze({
  __proto__: null,
  resolve: uu$1,
  normalize: ou$1,
  isAbsolute: su$1,
  join: au$1,
  relative: cu$1,
  sep: "/",
  delimiter: ":",
  dirname: lu$1,
  basename: pu$1,
  extname: fu$1,
  default: du$1
}), yu$1 = [], Du$1 = [], Eu$1 = typeof Uint8Array != "undefined" ? Uint8Array : Array, Cu$1 = false;
function bu$1() {
  Cu$1 = true;
  for (var e20 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t2 = 0, n2 = e20.length; t2 < n2; ++t2)
    yu$1[t2] = e20[t2], Du$1[e20.charCodeAt(t2)] = t2;
  Du$1["-".charCodeAt(0)] = 62, Du$1["_".charCodeAt(0)] = 63;
}
function Au$1(e20, t2, n2) {
  for (var r2, i2, u2 = [], o2 = t2; o2 < n2; o2 += 3)
    r2 = (e20[o2] << 16) + (e20[o2 + 1] << 8) + e20[o2 + 2], u2.push(yu$1[(i2 = r2) >> 18 & 63] + yu$1[i2 >> 12 & 63] + yu$1[i2 >> 6 & 63] + yu$1[63 & i2]);
  return u2.join("");
}
function vu$1(e20) {
  var t2;
  Cu$1 || bu$1();
  for (var n2 = e20.length, r2 = n2 % 3, i2 = "", u2 = [], o2 = 16383, s2 = 0, a2 = n2 - r2; s2 < a2; s2 += o2)
    u2.push(Au$1(e20, s2, s2 + o2 > a2 ? a2 : s2 + o2));
  return r2 === 1 ? (t2 = e20[n2 - 1], i2 += yu$1[t2 >> 2], i2 += yu$1[t2 << 4 & 63], i2 += "==") : r2 === 2 && (t2 = (e20[n2 - 2] << 8) + e20[n2 - 1], i2 += yu$1[t2 >> 10], i2 += yu$1[t2 >> 4 & 63], i2 += yu$1[t2 << 2 & 63], i2 += "="), u2.push(i2), u2.join("");
}
function Fu$1(e20, t2, n2, r2, i2) {
  var u2, o2, s2 = 8 * i2 - r2 - 1, a2 = (1 << s2) - 1, c2 = a2 >> 1, l2 = -7, p2 = n2 ? i2 - 1 : 0, f2 = n2 ? -1 : 1, d2 = e20[t2 + p2];
  for (p2 += f2, u2 = d2 & (1 << -l2) - 1, d2 >>= -l2, l2 += s2; l2 > 0; u2 = 256 * u2 + e20[t2 + p2], p2 += f2, l2 -= 8)
    ;
  for (o2 = u2 & (1 << -l2) - 1, u2 >>= -l2, l2 += r2; l2 > 0; o2 = 256 * o2 + e20[t2 + p2], p2 += f2, l2 -= 8)
    ;
  if (u2 === 0)
    u2 = 1 - c2;
  else {
    if (u2 === a2)
      return o2 ? NaN : 1 / 0 * (d2 ? -1 : 1);
    o2 += Math.pow(2, r2), u2 -= c2;
  }
  return (d2 ? -1 : 1) * o2 * Math.pow(2, u2 - r2);
}
function Su$1(e20, t2, n2, r2, i2, u2) {
  var o2, s2, a2, c2 = 8 * u2 - i2 - 1, l2 = (1 << c2) - 1, p2 = l2 >> 1, f2 = i2 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d2 = r2 ? 0 : u2 - 1, h2 = r2 ? 1 : -1, g2 = t2 < 0 || t2 === 0 && 1 / t2 < 0 ? 1 : 0;
  for (t2 = Math.abs(t2), isNaN(t2) || t2 === 1 / 0 ? (s2 = isNaN(t2) ? 1 : 0, o2 = l2) : (o2 = Math.floor(Math.log(t2) / Math.LN2), t2 * (a2 = Math.pow(2, -o2)) < 1 && (o2--, a2 *= 2), (t2 += o2 + p2 >= 1 ? f2 / a2 : f2 * Math.pow(2, 1 - p2)) * a2 >= 2 && (o2++, a2 /= 2), o2 + p2 >= l2 ? (s2 = 0, o2 = l2) : o2 + p2 >= 1 ? (s2 = (t2 * a2 - 1) * Math.pow(2, i2), o2 += p2) : (s2 = t2 * Math.pow(2, p2 - 1) * Math.pow(2, i2), o2 = 0)); i2 >= 8; e20[n2 + d2] = 255 & s2, d2 += h2, s2 /= 256, i2 -= 8)
    ;
  for (o2 = o2 << i2 | s2, c2 += i2; c2 > 0; e20[n2 + d2] = 255 & o2, d2 += h2, o2 /= 256, c2 -= 8)
    ;
  e20[n2 + d2 - h2] |= 128 * g2;
}
var xu$1 = {}.toString, wu$1 = Array.isArray || function(e20) {
  return xu$1.call(e20) == "[object Array]";
};
function Tu$1() {
  return Nu$1.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function Bu$1(e20, t2) {
  if (Tu$1() < t2)
    throw new RangeError("Invalid typed array length");
  return Nu$1.TYPED_ARRAY_SUPPORT ? (e20 = new Uint8Array(t2)).__proto__ = Nu$1.prototype : (e20 === null && (e20 = new Nu$1(t2)), e20.length = t2), e20;
}
function Nu$1(e20, t2, n2) {
  if (!(Nu$1.TYPED_ARRAY_SUPPORT || this instanceof Nu$1))
    return new Nu$1(e20, t2, n2);
  if (typeof e20 == "number") {
    if (typeof t2 == "string")
      throw new Error("If encoding is specified then the first argument must be a string");
    return Ou$1(this, e20);
  }
  return ku$1(this, e20, t2, n2);
}
function ku$1(e20, t2, n2, r2) {
  if (typeof t2 == "number")
    throw new TypeError('"value" argument must not be a number');
  return typeof ArrayBuffer != "undefined" && t2 instanceof ArrayBuffer ? function(e21, t3, n3, r3) {
    if (t3.byteLength, n3 < 0 || t3.byteLength < n3)
      throw new RangeError("'offset' is out of bounds");
    if (t3.byteLength < n3 + (r3 || 0))
      throw new RangeError("'length' is out of bounds");
    t3 = n3 === void 0 && r3 === void 0 ? new Uint8Array(t3) : r3 === void 0 ? new Uint8Array(t3, n3) : new Uint8Array(t3, n3, r3);
    Nu$1.TYPED_ARRAY_SUPPORT ? (e21 = t3).__proto__ = Nu$1.prototype : e21 = Iu$1(e21, t3);
    return e21;
  }(e20, t2, n2, r2) : typeof t2 == "string" ? function(e21, t3, n3) {
    typeof n3 == "string" && n3 !== "" || (n3 = "utf8");
    if (!Nu$1.isEncoding(n3))
      throw new TypeError('"encoding" must be a valid string encoding');
    var r3 = 0 | _u$1(t3, n3), i2 = (e21 = Bu$1(e21, r3)).write(t3, n3);
    i2 !== r3 && (e21 = e21.slice(0, i2));
    return e21;
  }(e20, t2, n2) : function(e21, t3) {
    if (ju$1(t3)) {
      var n3 = 0 | Lu$1(t3.length);
      return (e21 = Bu$1(e21, n3)).length === 0 || t3.copy(e21, 0, 0, n3), e21;
    }
    if (t3) {
      if (typeof ArrayBuffer != "undefined" && t3.buffer instanceof ArrayBuffer || "length" in t3)
        return typeof t3.length != "number" || (r3 = t3.length) != r3 ? Bu$1(e21, 0) : Iu$1(e21, t3);
      if (t3.type === "Buffer" && wu$1(t3.data))
        return Iu$1(e21, t3.data);
    }
    var r3;
    throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
  }(e20, t2);
}
function Pu$1(e20) {
  if (typeof e20 != "number")
    throw new TypeError('"size" argument must be a number');
  if (e20 < 0)
    throw new RangeError('"size" argument must not be negative');
}
function Ou$1(e20, t2) {
  if (Pu$1(t2), e20 = Bu$1(e20, t2 < 0 ? 0 : 0 | Lu$1(t2)), !Nu$1.TYPED_ARRAY_SUPPORT)
    for (var n2 = 0; n2 < t2; ++n2)
      e20[n2] = 0;
  return e20;
}
function Iu$1(e20, t2) {
  var n2 = t2.length < 0 ? 0 : 0 | Lu$1(t2.length);
  e20 = Bu$1(e20, n2);
  for (var r2 = 0; r2 < n2; r2 += 1)
    e20[r2] = 255 & t2[r2];
  return e20;
}
function Lu$1(e20) {
  if (e20 >= Tu$1())
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Tu$1().toString(16) + " bytes");
  return 0 | e20;
}
function ju$1(e20) {
  return !(e20 == null || !e20._isBuffer);
}
function _u$1(e20, t2) {
  if (ju$1(e20))
    return e20.length;
  if (typeof ArrayBuffer != "undefined" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(e20) || e20 instanceof ArrayBuffer))
    return e20.byteLength;
  typeof e20 != "string" && (e20 = "" + e20);
  var n2 = e20.length;
  if (n2 === 0)
    return 0;
  for (var r2 = false; ; )
    switch (t2) {
      case "ascii":
      case "latin1":
      case "binary":
        return n2;
      case "utf8":
      case "utf-8":
      case void 0:
        return co$2(e20).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return 2 * n2;
      case "hex":
        return n2 >>> 1;
      case "base64":
        return lo$2(e20).length;
      default:
        if (r2)
          return co$2(e20).length;
        t2 = ("" + t2).toLowerCase(), r2 = true;
    }
}
function Mu$1(e20, t2, n2) {
  var r2 = false;
  if ((t2 === void 0 || t2 < 0) && (t2 = 0), t2 > this.length)
    return "";
  if ((n2 === void 0 || n2 > this.length) && (n2 = this.length), n2 <= 0)
    return "";
  if ((n2 >>>= 0) <= (t2 >>>= 0))
    return "";
  for (e20 || (e20 = "utf8"); ; )
    switch (e20) {
      case "hex":
        return Qu(this, t2, n2);
      case "utf8":
      case "utf-8":
        return Xu(this, t2, n2);
      case "ascii":
        return Yu(this, t2, n2);
      case "latin1":
      case "binary":
        return Ku(this, t2, n2);
      case "base64":
        return Ju(this, t2, n2);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return Zu(this, t2, n2);
      default:
        if (r2)
          throw new TypeError("Unknown encoding: " + e20);
        e20 = (e20 + "").toLowerCase(), r2 = true;
    }
}
function Ru$1(e20, t2, n2) {
  var r2 = e20[t2];
  e20[t2] = e20[n2], e20[n2] = r2;
}
function $u(e20, t2, n2, r2, i2) {
  if (e20.length === 0)
    return -1;
  if (typeof n2 == "string" ? (r2 = n2, n2 = 0) : n2 > 2147483647 ? n2 = 2147483647 : n2 < -2147483648 && (n2 = -2147483648), n2 = +n2, isNaN(n2) && (n2 = i2 ? 0 : e20.length - 1), n2 < 0 && (n2 = e20.length + n2), n2 >= e20.length) {
    if (i2)
      return -1;
    n2 = e20.length - 1;
  } else if (n2 < 0) {
    if (!i2)
      return -1;
    n2 = 0;
  }
  if (typeof t2 == "string" && (t2 = Nu$1.from(t2, r2)), ju$1(t2))
    return t2.length === 0 ? -1 : Vu(e20, t2, n2, r2, i2);
  if (typeof t2 == "number")
    return t2 &= 255, Nu$1.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? i2 ? Uint8Array.prototype.indexOf.call(e20, t2, n2) : Uint8Array.prototype.lastIndexOf.call(e20, t2, n2) : Vu(e20, [t2], n2, r2, i2);
  throw new TypeError("val must be string, number or Buffer");
}
function Vu(e20, t2, n2, r2, i2) {
  var u2, o2 = 1, s2 = e20.length, a2 = t2.length;
  if (r2 !== void 0 && ((r2 = String(r2).toLowerCase()) === "ucs2" || r2 === "ucs-2" || r2 === "utf16le" || r2 === "utf-16le")) {
    if (e20.length < 2 || t2.length < 2)
      return -1;
    o2 = 2, s2 /= 2, a2 /= 2, n2 /= 2;
  }
  function c2(e21, t3) {
    return o2 === 1 ? e21[t3] : e21.readUInt16BE(t3 * o2);
  }
  if (i2) {
    var l2 = -1;
    for (u2 = n2; u2 < s2; u2++)
      if (c2(e20, u2) === c2(t2, l2 === -1 ? 0 : u2 - l2)) {
        if (l2 === -1 && (l2 = u2), u2 - l2 + 1 === a2)
          return l2 * o2;
      } else
        l2 !== -1 && (u2 -= u2 - l2), l2 = -1;
  } else
    for (n2 + a2 > s2 && (n2 = s2 - a2), u2 = n2; u2 >= 0; u2--) {
      for (var p2 = true, f2 = 0; f2 < a2; f2++)
        if (c2(e20, u2 + f2) !== c2(t2, f2)) {
          p2 = false;
          break;
        }
      if (p2)
        return u2;
    }
  return -1;
}
function Wu(e20, t2, n2, r2) {
  n2 = Number(n2) || 0;
  var i2 = e20.length - n2;
  r2 ? (r2 = Number(r2)) > i2 && (r2 = i2) : r2 = i2;
  var u2 = t2.length;
  if (u2 % 2 != 0)
    throw new TypeError("Invalid hex string");
  r2 > u2 / 2 && (r2 = u2 / 2);
  for (var o2 = 0; o2 < r2; ++o2) {
    var s2 = parseInt(t2.substr(2 * o2, 2), 16);
    if (isNaN(s2))
      return o2;
    e20[n2 + o2] = s2;
  }
  return o2;
}
function qu(e20, t2, n2, r2) {
  return po$2(co$2(t2, e20.length - n2), e20, n2, r2);
}
function Uu$1(e20, t2, n2, r2) {
  return po$2(function(e21) {
    for (var t3 = [], n3 = 0; n3 < e21.length; ++n3)
      t3.push(255 & e21.charCodeAt(n3));
    return t3;
  }(t2), e20, n2, r2);
}
function zu(e20, t2, n2, r2) {
  return Uu$1(e20, t2, n2, r2);
}
function Gu(e20, t2, n2, r2) {
  return po$2(lo$2(t2), e20, n2, r2);
}
function Hu(e20, t2, n2, r2) {
  return po$2(function(e21, t3) {
    for (var n3, r3, i2, u2 = [], o2 = 0; o2 < e21.length && !((t3 -= 2) < 0); ++o2)
      r3 = (n3 = e21.charCodeAt(o2)) >> 8, i2 = n3 % 256, u2.push(i2), u2.push(r3);
    return u2;
  }(t2, e20.length - n2), e20, n2, r2);
}
function Ju(e20, t2, n2) {
  return t2 === 0 && n2 === e20.length ? vu$1(e20) : vu$1(e20.slice(t2, n2));
}
function Xu(e20, t2, n2) {
  n2 = Math.min(e20.length, n2);
  for (var r2 = [], i2 = t2; i2 < n2; ) {
    var u2, o2, s2, a2, c2 = e20[i2], l2 = null, p2 = c2 > 239 ? 4 : c2 > 223 ? 3 : c2 > 191 ? 2 : 1;
    if (i2 + p2 <= n2)
      switch (p2) {
        case 1:
          c2 < 128 && (l2 = c2);
          break;
        case 2:
          (192 & (u2 = e20[i2 + 1])) == 128 && (a2 = (31 & c2) << 6 | 63 & u2) > 127 && (l2 = a2);
          break;
        case 3:
          u2 = e20[i2 + 1], o2 = e20[i2 + 2], (192 & u2) == 128 && (192 & o2) == 128 && (a2 = (15 & c2) << 12 | (63 & u2) << 6 | 63 & o2) > 2047 && (a2 < 55296 || a2 > 57343) && (l2 = a2);
          break;
        case 4:
          u2 = e20[i2 + 1], o2 = e20[i2 + 2], s2 = e20[i2 + 3], (192 & u2) == 128 && (192 & o2) == 128 && (192 & s2) == 128 && (a2 = (15 & c2) << 18 | (63 & u2) << 12 | (63 & o2) << 6 | 63 & s2) > 65535 && a2 < 1114112 && (l2 = a2);
      }
    l2 === null ? (l2 = 65533, p2 = 1) : l2 > 65535 && (l2 -= 65536, r2.push(l2 >>> 10 & 1023 | 55296), l2 = 56320 | 1023 & l2), r2.push(l2), i2 += p2;
  }
  return function(e21) {
    var t3 = e21.length;
    if (t3 <= 4096)
      return String.fromCharCode.apply(String, e21);
    var n3 = "", r3 = 0;
    for (; r3 < t3; )
      n3 += String.fromCharCode.apply(String, e21.slice(r3, r3 += 4096));
    return n3;
  }(r2);
}
Nu$1.TYPED_ARRAY_SUPPORT = nr$2.TYPED_ARRAY_SUPPORT === void 0 || nr$2.TYPED_ARRAY_SUPPORT, Nu$1.poolSize = 8192, Nu$1._augment = function(e20) {
  return e20.__proto__ = Nu$1.prototype, e20;
}, Nu$1.from = function(e20, t2, n2) {
  return ku$1(null, e20, t2, n2);
}, Nu$1.TYPED_ARRAY_SUPPORT && (Nu$1.prototype.__proto__ = Uint8Array.prototype, Nu$1.__proto__ = Uint8Array), Nu$1.alloc = function(e20, t2, n2) {
  return function(e21, t3, n3, r2) {
    return Pu$1(t3), t3 <= 0 ? Bu$1(e21, t3) : n3 !== void 0 ? typeof r2 == "string" ? Bu$1(e21, t3).fill(n3, r2) : Bu$1(e21, t3).fill(n3) : Bu$1(e21, t3);
  }(null, e20, t2, n2);
}, Nu$1.allocUnsafe = function(e20) {
  return Ou$1(null, e20);
}, Nu$1.allocUnsafeSlow = function(e20) {
  return Ou$1(null, e20);
}, Nu$1.isBuffer = fo$2, Nu$1.compare = function(e20, t2) {
  if (!ju$1(e20) || !ju$1(t2))
    throw new TypeError("Arguments must be Buffers");
  if (e20 === t2)
    return 0;
  for (var n2 = e20.length, r2 = t2.length, i2 = 0, u2 = Math.min(n2, r2); i2 < u2; ++i2)
    if (e20[i2] !== t2[i2]) {
      n2 = e20[i2], r2 = t2[i2];
      break;
    }
  return n2 < r2 ? -1 : r2 < n2 ? 1 : 0;
}, Nu$1.isEncoding = function(e20) {
  switch (String(e20).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
}, Nu$1.concat = function(e20, t2) {
  if (!wu$1(e20))
    throw new TypeError('"list" argument must be an Array of Buffers');
  if (e20.length === 0)
    return Nu$1.alloc(0);
  var n2;
  if (t2 === void 0)
    for (t2 = 0, n2 = 0; n2 < e20.length; ++n2)
      t2 += e20[n2].length;
  var r2 = Nu$1.allocUnsafe(t2), i2 = 0;
  for (n2 = 0; n2 < e20.length; ++n2) {
    var u2 = e20[n2];
    if (!ju$1(u2))
      throw new TypeError('"list" argument must be an Array of Buffers');
    u2.copy(r2, i2), i2 += u2.length;
  }
  return r2;
}, Nu$1.byteLength = _u$1, Nu$1.prototype._isBuffer = true, Nu$1.prototype.swap16 = function() {
  var e20 = this.length;
  if (e20 % 2 != 0)
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  for (var t2 = 0; t2 < e20; t2 += 2)
    Ru$1(this, t2, t2 + 1);
  return this;
}, Nu$1.prototype.swap32 = function() {
  var e20 = this.length;
  if (e20 % 4 != 0)
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  for (var t2 = 0; t2 < e20; t2 += 4)
    Ru$1(this, t2, t2 + 3), Ru$1(this, t2 + 1, t2 + 2);
  return this;
}, Nu$1.prototype.swap64 = function() {
  var e20 = this.length;
  if (e20 % 8 != 0)
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  for (var t2 = 0; t2 < e20; t2 += 8)
    Ru$1(this, t2, t2 + 7), Ru$1(this, t2 + 1, t2 + 6), Ru$1(this, t2 + 2, t2 + 5), Ru$1(this, t2 + 3, t2 + 4);
  return this;
}, Nu$1.prototype.toString = function() {
  var e20 = 0 | this.length;
  return e20 === 0 ? "" : arguments.length === 0 ? Xu(this, 0, e20) : Mu$1.apply(this, arguments);
}, Nu$1.prototype.equals = function(e20) {
  if (!ju$1(e20))
    throw new TypeError("Argument must be a Buffer");
  return this === e20 || Nu$1.compare(this, e20) === 0;
}, Nu$1.prototype.inspect = function() {
  var e20 = "";
  return this.length > 0 && (e20 = this.toString("hex", 0, 50).match(/.{2}/g).join(" "), this.length > 50 && (e20 += " ... ")), "<Buffer " + e20 + ">";
}, Nu$1.prototype.compare = function(e20, t2, n2, r2, i2) {
  if (!ju$1(e20))
    throw new TypeError("Argument must be a Buffer");
  if (t2 === void 0 && (t2 = 0), n2 === void 0 && (n2 = e20 ? e20.length : 0), r2 === void 0 && (r2 = 0), i2 === void 0 && (i2 = this.length), t2 < 0 || n2 > e20.length || r2 < 0 || i2 > this.length)
    throw new RangeError("out of range index");
  if (r2 >= i2 && t2 >= n2)
    return 0;
  if (r2 >= i2)
    return -1;
  if (t2 >= n2)
    return 1;
  if (this === e20)
    return 0;
  for (var u2 = (i2 >>>= 0) - (r2 >>>= 0), o2 = (n2 >>>= 0) - (t2 >>>= 0), s2 = Math.min(u2, o2), a2 = this.slice(r2, i2), c2 = e20.slice(t2, n2), l2 = 0; l2 < s2; ++l2)
    if (a2[l2] !== c2[l2]) {
      u2 = a2[l2], o2 = c2[l2];
      break;
    }
  return u2 < o2 ? -1 : o2 < u2 ? 1 : 0;
}, Nu$1.prototype.includes = function(e20, t2, n2) {
  return this.indexOf(e20, t2, n2) !== -1;
}, Nu$1.prototype.indexOf = function(e20, t2, n2) {
  return $u(this, e20, t2, n2, true);
}, Nu$1.prototype.lastIndexOf = function(e20, t2, n2) {
  return $u(this, e20, t2, n2, false);
}, Nu$1.prototype.write = function(e20, t2, n2, r2) {
  if (t2 === void 0)
    r2 = "utf8", n2 = this.length, t2 = 0;
  else if (n2 === void 0 && typeof t2 == "string")
    r2 = t2, n2 = this.length, t2 = 0;
  else {
    if (!isFinite(t2))
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    t2 |= 0, isFinite(n2) ? (n2 |= 0, r2 === void 0 && (r2 = "utf8")) : (r2 = n2, n2 = void 0);
  }
  var i2 = this.length - t2;
  if ((n2 === void 0 || n2 > i2) && (n2 = i2), e20.length > 0 && (n2 < 0 || t2 < 0) || t2 > this.length)
    throw new RangeError("Attempt to write outside buffer bounds");
  r2 || (r2 = "utf8");
  for (var u2 = false; ; )
    switch (r2) {
      case "hex":
        return Wu(this, e20, t2, n2);
      case "utf8":
      case "utf-8":
        return qu(this, e20, t2, n2);
      case "ascii":
        return Uu$1(this, e20, t2, n2);
      case "latin1":
      case "binary":
        return zu(this, e20, t2, n2);
      case "base64":
        return Gu(this, e20, t2, n2);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return Hu(this, e20, t2, n2);
      default:
        if (u2)
          throw new TypeError("Unknown encoding: " + r2);
        r2 = ("" + r2).toLowerCase(), u2 = true;
    }
}, Nu$1.prototype.toJSON = function() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function Yu(e20, t2, n2) {
  var r2 = "";
  n2 = Math.min(e20.length, n2);
  for (var i2 = t2; i2 < n2; ++i2)
    r2 += String.fromCharCode(127 & e20[i2]);
  return r2;
}
function Ku(e20, t2, n2) {
  var r2 = "";
  n2 = Math.min(e20.length, n2);
  for (var i2 = t2; i2 < n2; ++i2)
    r2 += String.fromCharCode(e20[i2]);
  return r2;
}
function Qu(e20, t2, n2) {
  var r2 = e20.length;
  (!t2 || t2 < 0) && (t2 = 0), (!n2 || n2 < 0 || n2 > r2) && (n2 = r2);
  for (var i2 = "", u2 = t2; u2 < n2; ++u2)
    i2 += ao$2(e20[u2]);
  return i2;
}
function Zu(e20, t2, n2) {
  for (var r2 = e20.slice(t2, n2), i2 = "", u2 = 0; u2 < r2.length; u2 += 2)
    i2 += String.fromCharCode(r2[u2] + 256 * r2[u2 + 1]);
  return i2;
}
function eo$2(e20, t2, n2) {
  if (e20 % 1 != 0 || e20 < 0)
    throw new RangeError("offset is not uint");
  if (e20 + t2 > n2)
    throw new RangeError("Trying to access beyond buffer length");
}
function to$2(e20, t2, n2, r2, i2, u2) {
  if (!ju$1(e20))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (t2 > i2 || t2 < u2)
    throw new RangeError('"value" argument is out of bounds');
  if (n2 + r2 > e20.length)
    throw new RangeError("Index out of range");
}
function no$2(e20, t2, n2, r2) {
  t2 < 0 && (t2 = 65535 + t2 + 1);
  for (var i2 = 0, u2 = Math.min(e20.length - n2, 2); i2 < u2; ++i2)
    e20[n2 + i2] = (t2 & 255 << 8 * (r2 ? i2 : 1 - i2)) >>> 8 * (r2 ? i2 : 1 - i2);
}
function ro$2(e20, t2, n2, r2) {
  t2 < 0 && (t2 = 4294967295 + t2 + 1);
  for (var i2 = 0, u2 = Math.min(e20.length - n2, 4); i2 < u2; ++i2)
    e20[n2 + i2] = t2 >>> 8 * (r2 ? i2 : 3 - i2) & 255;
}
function io$2(e20, t2, n2, r2, i2, u2) {
  if (n2 + r2 > e20.length)
    throw new RangeError("Index out of range");
  if (n2 < 0)
    throw new RangeError("Index out of range");
}
function uo$2(e20, t2, n2, r2, i2) {
  return i2 || io$2(e20, 0, n2, 4), Su$1(e20, t2, n2, r2, 23, 4), n2 + 4;
}
function oo$2(e20, t2, n2, r2, i2) {
  return i2 || io$2(e20, 0, n2, 8), Su$1(e20, t2, n2, r2, 52, 8), n2 + 8;
}
Nu$1.prototype.slice = function(e20, t2) {
  var n2, r2 = this.length;
  if ((e20 = ~~e20) < 0 ? (e20 += r2) < 0 && (e20 = 0) : e20 > r2 && (e20 = r2), (t2 = t2 === void 0 ? r2 : ~~t2) < 0 ? (t2 += r2) < 0 && (t2 = 0) : t2 > r2 && (t2 = r2), t2 < e20 && (t2 = e20), Nu$1.TYPED_ARRAY_SUPPORT)
    (n2 = this.subarray(e20, t2)).__proto__ = Nu$1.prototype;
  else {
    var i2 = t2 - e20;
    n2 = new Nu$1(i2, void 0);
    for (var u2 = 0; u2 < i2; ++u2)
      n2[u2] = this[u2 + e20];
  }
  return n2;
}, Nu$1.prototype.readUIntLE = function(e20, t2, n2) {
  e20 |= 0, t2 |= 0, n2 || eo$2(e20, t2, this.length);
  for (var r2 = this[e20], i2 = 1, u2 = 0; ++u2 < t2 && (i2 *= 256); )
    r2 += this[e20 + u2] * i2;
  return r2;
}, Nu$1.prototype.readUIntBE = function(e20, t2, n2) {
  e20 |= 0, t2 |= 0, n2 || eo$2(e20, t2, this.length);
  for (var r2 = this[e20 + --t2], i2 = 1; t2 > 0 && (i2 *= 256); )
    r2 += this[e20 + --t2] * i2;
  return r2;
}, Nu$1.prototype.readUInt8 = function(e20, t2) {
  return t2 || eo$2(e20, 1, this.length), this[e20];
}, Nu$1.prototype.readUInt16LE = function(e20, t2) {
  return t2 || eo$2(e20, 2, this.length), this[e20] | this[e20 + 1] << 8;
}, Nu$1.prototype.readUInt16BE = function(e20, t2) {
  return t2 || eo$2(e20, 2, this.length), this[e20] << 8 | this[e20 + 1];
}, Nu$1.prototype.readUInt32LE = function(e20, t2) {
  return t2 || eo$2(e20, 4, this.length), (this[e20] | this[e20 + 1] << 8 | this[e20 + 2] << 16) + 16777216 * this[e20 + 3];
}, Nu$1.prototype.readUInt32BE = function(e20, t2) {
  return t2 || eo$2(e20, 4, this.length), 16777216 * this[e20] + (this[e20 + 1] << 16 | this[e20 + 2] << 8 | this[e20 + 3]);
}, Nu$1.prototype.readIntLE = function(e20, t2, n2) {
  e20 |= 0, t2 |= 0, n2 || eo$2(e20, t2, this.length);
  for (var r2 = this[e20], i2 = 1, u2 = 0; ++u2 < t2 && (i2 *= 256); )
    r2 += this[e20 + u2] * i2;
  return r2 >= (i2 *= 128) && (r2 -= Math.pow(2, 8 * t2)), r2;
}, Nu$1.prototype.readIntBE = function(e20, t2, n2) {
  e20 |= 0, t2 |= 0, n2 || eo$2(e20, t2, this.length);
  for (var r2 = t2, i2 = 1, u2 = this[e20 + --r2]; r2 > 0 && (i2 *= 256); )
    u2 += this[e20 + --r2] * i2;
  return u2 >= (i2 *= 128) && (u2 -= Math.pow(2, 8 * t2)), u2;
}, Nu$1.prototype.readInt8 = function(e20, t2) {
  return t2 || eo$2(e20, 1, this.length), 128 & this[e20] ? -1 * (255 - this[e20] + 1) : this[e20];
}, Nu$1.prototype.readInt16LE = function(e20, t2) {
  t2 || eo$2(e20, 2, this.length);
  var n2 = this[e20] | this[e20 + 1] << 8;
  return 32768 & n2 ? 4294901760 | n2 : n2;
}, Nu$1.prototype.readInt16BE = function(e20, t2) {
  t2 || eo$2(e20, 2, this.length);
  var n2 = this[e20 + 1] | this[e20] << 8;
  return 32768 & n2 ? 4294901760 | n2 : n2;
}, Nu$1.prototype.readInt32LE = function(e20, t2) {
  return t2 || eo$2(e20, 4, this.length), this[e20] | this[e20 + 1] << 8 | this[e20 + 2] << 16 | this[e20 + 3] << 24;
}, Nu$1.prototype.readInt32BE = function(e20, t2) {
  return t2 || eo$2(e20, 4, this.length), this[e20] << 24 | this[e20 + 1] << 16 | this[e20 + 2] << 8 | this[e20 + 3];
}, Nu$1.prototype.readFloatLE = function(e20, t2) {
  return t2 || eo$2(e20, 4, this.length), Fu$1(this, e20, true, 23, 4);
}, Nu$1.prototype.readFloatBE = function(e20, t2) {
  return t2 || eo$2(e20, 4, this.length), Fu$1(this, e20, false, 23, 4);
}, Nu$1.prototype.readDoubleLE = function(e20, t2) {
  return t2 || eo$2(e20, 8, this.length), Fu$1(this, e20, true, 52, 8);
}, Nu$1.prototype.readDoubleBE = function(e20, t2) {
  return t2 || eo$2(e20, 8, this.length), Fu$1(this, e20, false, 52, 8);
}, Nu$1.prototype.writeUIntLE = function(e20, t2, n2, r2) {
  (e20 = +e20, t2 |= 0, n2 |= 0, r2) || to$2(this, e20, t2, n2, Math.pow(2, 8 * n2) - 1, 0);
  var i2 = 1, u2 = 0;
  for (this[t2] = 255 & e20; ++u2 < n2 && (i2 *= 256); )
    this[t2 + u2] = e20 / i2 & 255;
  return t2 + n2;
}, Nu$1.prototype.writeUIntBE = function(e20, t2, n2, r2) {
  (e20 = +e20, t2 |= 0, n2 |= 0, r2) || to$2(this, e20, t2, n2, Math.pow(2, 8 * n2) - 1, 0);
  var i2 = n2 - 1, u2 = 1;
  for (this[t2 + i2] = 255 & e20; --i2 >= 0 && (u2 *= 256); )
    this[t2 + i2] = e20 / u2 & 255;
  return t2 + n2;
}, Nu$1.prototype.writeUInt8 = function(e20, t2, n2) {
  return e20 = +e20, t2 |= 0, n2 || to$2(this, e20, t2, 1, 255, 0), Nu$1.TYPED_ARRAY_SUPPORT || (e20 = Math.floor(e20)), this[t2] = 255 & e20, t2 + 1;
}, Nu$1.prototype.writeUInt16LE = function(e20, t2, n2) {
  return e20 = +e20, t2 |= 0, n2 || to$2(this, e20, t2, 2, 65535, 0), Nu$1.TYPED_ARRAY_SUPPORT ? (this[t2] = 255 & e20, this[t2 + 1] = e20 >>> 8) : no$2(this, e20, t2, true), t2 + 2;
}, Nu$1.prototype.writeUInt16BE = function(e20, t2, n2) {
  return e20 = +e20, t2 |= 0, n2 || to$2(this, e20, t2, 2, 65535, 0), Nu$1.TYPED_ARRAY_SUPPORT ? (this[t2] = e20 >>> 8, this[t2 + 1] = 255 & e20) : no$2(this, e20, t2, false), t2 + 2;
}, Nu$1.prototype.writeUInt32LE = function(e20, t2, n2) {
  return e20 = +e20, t2 |= 0, n2 || to$2(this, e20, t2, 4, 4294967295, 0), Nu$1.TYPED_ARRAY_SUPPORT ? (this[t2 + 3] = e20 >>> 24, this[t2 + 2] = e20 >>> 16, this[t2 + 1] = e20 >>> 8, this[t2] = 255 & e20) : ro$2(this, e20, t2, true), t2 + 4;
}, Nu$1.prototype.writeUInt32BE = function(e20, t2, n2) {
  return e20 = +e20, t2 |= 0, n2 || to$2(this, e20, t2, 4, 4294967295, 0), Nu$1.TYPED_ARRAY_SUPPORT ? (this[t2] = e20 >>> 24, this[t2 + 1] = e20 >>> 16, this[t2 + 2] = e20 >>> 8, this[t2 + 3] = 255 & e20) : ro$2(this, e20, t2, false), t2 + 4;
}, Nu$1.prototype.writeIntLE = function(e20, t2, n2, r2) {
  if (e20 = +e20, t2 |= 0, !r2) {
    var i2 = Math.pow(2, 8 * n2 - 1);
    to$2(this, e20, t2, n2, i2 - 1, -i2);
  }
  var u2 = 0, o2 = 1, s2 = 0;
  for (this[t2] = 255 & e20; ++u2 < n2 && (o2 *= 256); )
    e20 < 0 && s2 === 0 && this[t2 + u2 - 1] !== 0 && (s2 = 1), this[t2 + u2] = (e20 / o2 >> 0) - s2 & 255;
  return t2 + n2;
}, Nu$1.prototype.writeIntBE = function(e20, t2, n2, r2) {
  if (e20 = +e20, t2 |= 0, !r2) {
    var i2 = Math.pow(2, 8 * n2 - 1);
    to$2(this, e20, t2, n2, i2 - 1, -i2);
  }
  var u2 = n2 - 1, o2 = 1, s2 = 0;
  for (this[t2 + u2] = 255 & e20; --u2 >= 0 && (o2 *= 256); )
    e20 < 0 && s2 === 0 && this[t2 + u2 + 1] !== 0 && (s2 = 1), this[t2 + u2] = (e20 / o2 >> 0) - s2 & 255;
  return t2 + n2;
}, Nu$1.prototype.writeInt8 = function(e20, t2, n2) {
  return e20 = +e20, t2 |= 0, n2 || to$2(this, e20, t2, 1, 127, -128), Nu$1.TYPED_ARRAY_SUPPORT || (e20 = Math.floor(e20)), e20 < 0 && (e20 = 255 + e20 + 1), this[t2] = 255 & e20, t2 + 1;
}, Nu$1.prototype.writeInt16LE = function(e20, t2, n2) {
  return e20 = +e20, t2 |= 0, n2 || to$2(this, e20, t2, 2, 32767, -32768), Nu$1.TYPED_ARRAY_SUPPORT ? (this[t2] = 255 & e20, this[t2 + 1] = e20 >>> 8) : no$2(this, e20, t2, true), t2 + 2;
}, Nu$1.prototype.writeInt16BE = function(e20, t2, n2) {
  return e20 = +e20, t2 |= 0, n2 || to$2(this, e20, t2, 2, 32767, -32768), Nu$1.TYPED_ARRAY_SUPPORT ? (this[t2] = e20 >>> 8, this[t2 + 1] = 255 & e20) : no$2(this, e20, t2, false), t2 + 2;
}, Nu$1.prototype.writeInt32LE = function(e20, t2, n2) {
  return e20 = +e20, t2 |= 0, n2 || to$2(this, e20, t2, 4, 2147483647, -2147483648), Nu$1.TYPED_ARRAY_SUPPORT ? (this[t2] = 255 & e20, this[t2 + 1] = e20 >>> 8, this[t2 + 2] = e20 >>> 16, this[t2 + 3] = e20 >>> 24) : ro$2(this, e20, t2, true), t2 + 4;
}, Nu$1.prototype.writeInt32BE = function(e20, t2, n2) {
  return e20 = +e20, t2 |= 0, n2 || to$2(this, e20, t2, 4, 2147483647, -2147483648), e20 < 0 && (e20 = 4294967295 + e20 + 1), Nu$1.TYPED_ARRAY_SUPPORT ? (this[t2] = e20 >>> 24, this[t2 + 1] = e20 >>> 16, this[t2 + 2] = e20 >>> 8, this[t2 + 3] = 255 & e20) : ro$2(this, e20, t2, false), t2 + 4;
}, Nu$1.prototype.writeFloatLE = function(e20, t2, n2) {
  return uo$2(this, e20, t2, true, n2);
}, Nu$1.prototype.writeFloatBE = function(e20, t2, n2) {
  return uo$2(this, e20, t2, false, n2);
}, Nu$1.prototype.writeDoubleLE = function(e20, t2, n2) {
  return oo$2(this, e20, t2, true, n2);
}, Nu$1.prototype.writeDoubleBE = function(e20, t2, n2) {
  return oo$2(this, e20, t2, false, n2);
}, Nu$1.prototype.copy = function(e20, t2, n2, r2) {
  if (n2 || (n2 = 0), r2 || r2 === 0 || (r2 = this.length), t2 >= e20.length && (t2 = e20.length), t2 || (t2 = 0), r2 > 0 && r2 < n2 && (r2 = n2), r2 === n2)
    return 0;
  if (e20.length === 0 || this.length === 0)
    return 0;
  if (t2 < 0)
    throw new RangeError("targetStart out of bounds");
  if (n2 < 0 || n2 >= this.length)
    throw new RangeError("sourceStart out of bounds");
  if (r2 < 0)
    throw new RangeError("sourceEnd out of bounds");
  r2 > this.length && (r2 = this.length), e20.length - t2 < r2 - n2 && (r2 = e20.length - t2 + n2);
  var i2, u2 = r2 - n2;
  if (this === e20 && n2 < t2 && t2 < r2)
    for (i2 = u2 - 1; i2 >= 0; --i2)
      e20[i2 + t2] = this[i2 + n2];
  else if (u2 < 1e3 || !Nu$1.TYPED_ARRAY_SUPPORT)
    for (i2 = 0; i2 < u2; ++i2)
      e20[i2 + t2] = this[i2 + n2];
  else
    Uint8Array.prototype.set.call(e20, this.subarray(n2, n2 + u2), t2);
  return u2;
}, Nu$1.prototype.fill = function(e20, t2, n2, r2) {
  if (typeof e20 == "string") {
    if (typeof t2 == "string" ? (r2 = t2, t2 = 0, n2 = this.length) : typeof n2 == "string" && (r2 = n2, n2 = this.length), e20.length === 1) {
      var i2 = e20.charCodeAt(0);
      i2 < 256 && (e20 = i2);
    }
    if (r2 !== void 0 && typeof r2 != "string")
      throw new TypeError("encoding must be a string");
    if (typeof r2 == "string" && !Nu$1.isEncoding(r2))
      throw new TypeError("Unknown encoding: " + r2);
  } else
    typeof e20 == "number" && (e20 &= 255);
  if (t2 < 0 || this.length < t2 || this.length < n2)
    throw new RangeError("Out of range index");
  if (n2 <= t2)
    return this;
  var u2;
  if (t2 >>>= 0, n2 = n2 === void 0 ? this.length : n2 >>> 0, e20 || (e20 = 0), typeof e20 == "number")
    for (u2 = t2; u2 < n2; ++u2)
      this[u2] = e20;
  else {
    var o2 = ju$1(e20) ? e20 : co$2(new Nu$1(e20, r2).toString()), s2 = o2.length;
    for (u2 = 0; u2 < n2 - t2; ++u2)
      this[u2 + t2] = o2[u2 % s2];
  }
  return this;
};
var so$2 = /[^+\/0-9A-Za-z-_]/g;
function ao$2(e20) {
  return e20 < 16 ? "0" + e20.toString(16) : e20.toString(16);
}
function co$2(e20, t2) {
  var n2;
  t2 = t2 || 1 / 0;
  for (var r2 = e20.length, i2 = null, u2 = [], o2 = 0; o2 < r2; ++o2) {
    if ((n2 = e20.charCodeAt(o2)) > 55295 && n2 < 57344) {
      if (!i2) {
        if (n2 > 56319) {
          (t2 -= 3) > -1 && u2.push(239, 191, 189);
          continue;
        }
        if (o2 + 1 === r2) {
          (t2 -= 3) > -1 && u2.push(239, 191, 189);
          continue;
        }
        i2 = n2;
        continue;
      }
      if (n2 < 56320) {
        (t2 -= 3) > -1 && u2.push(239, 191, 189), i2 = n2;
        continue;
      }
      n2 = 65536 + (i2 - 55296 << 10 | n2 - 56320);
    } else
      i2 && (t2 -= 3) > -1 && u2.push(239, 191, 189);
    if (i2 = null, n2 < 128) {
      if ((t2 -= 1) < 0)
        break;
      u2.push(n2);
    } else if (n2 < 2048) {
      if ((t2 -= 2) < 0)
        break;
      u2.push(n2 >> 6 | 192, 63 & n2 | 128);
    } else if (n2 < 65536) {
      if ((t2 -= 3) < 0)
        break;
      u2.push(n2 >> 12 | 224, n2 >> 6 & 63 | 128, 63 & n2 | 128);
    } else {
      if (!(n2 < 1114112))
        throw new Error("Invalid code point");
      if ((t2 -= 4) < 0)
        break;
      u2.push(n2 >> 18 | 240, n2 >> 12 & 63 | 128, n2 >> 6 & 63 | 128, 63 & n2 | 128);
    }
  }
  return u2;
}
function lo$2(e20) {
  return function(e21) {
    var t2, n2, r2, i2, u2, o2;
    Cu$1 || bu$1();
    var s2 = e21.length;
    if (s2 % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    u2 = e21[s2 - 2] === "=" ? 2 : e21[s2 - 1] === "=" ? 1 : 0, o2 = new Eu$1(3 * s2 / 4 - u2), r2 = u2 > 0 ? s2 - 4 : s2;
    var a2 = 0;
    for (t2 = 0, n2 = 0; t2 < r2; t2 += 4, n2 += 3)
      i2 = Du$1[e21.charCodeAt(t2)] << 18 | Du$1[e21.charCodeAt(t2 + 1)] << 12 | Du$1[e21.charCodeAt(t2 + 2)] << 6 | Du$1[e21.charCodeAt(t2 + 3)], o2[a2++] = i2 >> 16 & 255, o2[a2++] = i2 >> 8 & 255, o2[a2++] = 255 & i2;
    return u2 === 2 ? (i2 = Du$1[e21.charCodeAt(t2)] << 2 | Du$1[e21.charCodeAt(t2 + 1)] >> 4, o2[a2++] = 255 & i2) : u2 === 1 && (i2 = Du$1[e21.charCodeAt(t2)] << 10 | Du$1[e21.charCodeAt(t2 + 1)] << 4 | Du$1[e21.charCodeAt(t2 + 2)] >> 2, o2[a2++] = i2 >> 8 & 255, o2[a2++] = 255 & i2), o2;
  }(function(e21) {
    if ((e21 = function(e22) {
      return e22.trim ? e22.trim() : e22.replace(/^\s+|\s+$/g, "");
    }(e21).replace(so$2, "")).length < 2)
      return "";
    for (; e21.length % 4 != 0; )
      e21 += "=";
    return e21;
  }(e20));
}
function po$2(e20, t2, n2, r2) {
  for (var i2 = 0; i2 < r2 && !(i2 + n2 >= t2.length || i2 >= e20.length); ++i2)
    t2[i2 + n2] = e20[i2];
  return i2;
}
function fo$2(e20) {
  return e20 != null && (!!e20._isBuffer || ho$2(e20) || function(e21) {
    return typeof e21.readFloatLE == "function" && typeof e21.slice == "function" && ho$2(e21.slice(0, 0));
  }(e20));
}
function ho$2(e20) {
  return !!e20.constructor && typeof e20.constructor.isBuffer == "function" && e20.constructor.isBuffer(e20);
}
var go$2 = n$3(tu$1);
var mo$2 = class {
  constructor(e20, t2) {
    (t2 = t2 || {}).readChunk || (t2.readChunk = 1024), t2.newLineCharacter ? t2.newLineCharacter = t2.newLineCharacter.charCodeAt(0) : t2.newLineCharacter = 10, this.fd = typeof e20 == "number" ? e20 : go$2.openSync(e20, "r"), this.options = t2, this.newLineCharacter = t2.newLineCharacter, this.reset();
  }
  _searchInBuffer(e20, t2) {
    let n2 = -1;
    for (let r2 = 0; r2 <= e20.length; r2++) {
      if (e20[r2] === t2) {
        n2 = r2;
        break;
      }
    }
    return n2;
  }
  reset() {
    this.eofReached = false, this.linesCache = [], this.fdPosition = 0;
  }
  close() {
    go$2.closeSync(this.fd), this.fd = null;
  }
  _extractLines(e20) {
    let t2;
    const n2 = [];
    let r2 = 0, i2 = 0;
    for (; ; ) {
      let u3 = e20[r2++];
      if (u3 === this.newLineCharacter)
        t2 = e20.slice(i2, r2), n2.push(t2), i2 = r2;
      else if (u3 === void 0)
        break;
    }
    let u2 = e20.slice(i2, r2);
    return u2.length && n2.push(u2), n2;
  }
  _readChunk(e20) {
    let t2, n2 = 0;
    const r2 = [];
    do {
      const e21 = new Nu$1(this.options.readChunk);
      t2 = go$2.readSync(this.fd, e21, 0, this.options.readChunk, this.fdPosition), n2 += t2, this.fdPosition = this.fdPosition + t2, r2.push(e21);
    } while (t2 && this._searchInBuffer(r2[r2.length - 1], this.options.newLineCharacter) === -1);
    let i2 = Nu$1.concat(r2);
    return t2 < this.options.readChunk && (this.eofReached = true, i2 = i2.slice(0, n2)), n2 && (this.linesCache = this._extractLines(i2), e20 && (this.linesCache[0] = Nu$1.concat([
      e20,
      this.linesCache[0]
    ]))), n2;
  }
  next() {
    if (!this.fd)
      return false;
    let e20, t2 = false;
    if (this.eofReached && this.linesCache.length === 0)
      return t2;
    if (this.linesCache.length || (e20 = this._readChunk()), this.linesCache.length) {
      t2 = this.linesCache.shift();
      t2[t2.length - 1] !== this.newLineCharacter && (e20 = this._readChunk(t2), e20 && (t2 = this.linesCache.shift()));
    }
    return this.eofReached && this.linesCache.length === 0 && this.close(), t2 && t2[t2.length - 1] === this.newLineCharacter && (t2 = t2.slice(0, t2.length - 1)), t2;
  }
};
class yo$2 extends Error {
}
class Do$2 extends Error {
}
class Eo$2 extends Error {
}
class Co$2 extends Error {
}
var bo$2 = {
  ConfigError: yo$2,
  DebugError: Do$2,
  UndefinedParserError: Eo$2,
  ArgExpansionBailout: Co$2
}, Ao$2 = function(e20, t2) {
  return (Ao$2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e21, t3) {
    e21.__proto__ = t3;
  } || function(e21, t3) {
    for (var n2 in t3)
      t3.hasOwnProperty(n2) && (e21[n2] = t3[n2]);
  })(e20, t2);
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var vo$2 = function() {
  return (vo$2 = Object.assign || function(e20) {
    for (var t2, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
      for (var i2 in t2 = arguments[n2])
        Object.prototype.hasOwnProperty.call(t2, i2) && (e20[i2] = t2[i2]);
    return e20;
  }).apply(this, arguments);
};
function Fo$2(e20) {
  var t2 = typeof Symbol == "function" && Symbol.iterator, n2 = t2 && e20[t2], r2 = 0;
  if (n2)
    return n2.call(e20);
  if (e20 && typeof e20.length == "number")
    return {
      next: function() {
        return e20 && r2 >= e20.length && (e20 = void 0), { value: e20 && e20[r2++], done: !e20 };
      }
    };
  throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function So$2(e20, t2) {
  var n2 = typeof Symbol == "function" && e20[Symbol.iterator];
  if (!n2)
    return e20;
  var r2, i2, u2 = n2.call(e20), o2 = [];
  try {
    for (; (t2 === void 0 || t2-- > 0) && !(r2 = u2.next()).done; )
      o2.push(r2.value);
  } catch (e21) {
    i2 = { error: e21 };
  } finally {
    try {
      r2 && !r2.done && (n2 = u2.return) && n2.call(u2);
    } finally {
      if (i2)
        throw i2.error;
    }
  }
  return o2;
}
function xo$2(e20) {
  return this instanceof xo$2 ? (this.v = e20, this) : new xo$2(e20);
}
var wo$2 = Object.freeze({
  __proto__: null,
  __extends: function(e20, t2) {
    function n2() {
      this.constructor = e20;
    }
    Ao$2(e20, t2), e20.prototype = t2 === null ? Object.create(t2) : (n2.prototype = t2.prototype, new n2());
  },
  get __assign() {
    return vo$2;
  },
  __rest: function(e20, t2) {
    var n2 = {};
    for (var r2 in e20)
      Object.prototype.hasOwnProperty.call(e20, r2) && t2.indexOf(r2) < 0 && (n2[r2] = e20[r2]);
    if (e20 != null && typeof Object.getOwnPropertySymbols == "function") {
      var i2 = 0;
      for (r2 = Object.getOwnPropertySymbols(e20); i2 < r2.length; i2++)
        t2.indexOf(r2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(e20, r2[i2]) && (n2[r2[i2]] = e20[r2[i2]]);
    }
    return n2;
  },
  __decorate: function(e20, t2, n2, r2) {
    var i2, u2 = arguments.length, o2 = u2 < 3 ? t2 : r2 === null ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o2 = Reflect.decorate(e20, t2, n2, r2);
    else
      for (var s2 = e20.length - 1; s2 >= 0; s2--)
        (i2 = e20[s2]) && (o2 = (u2 < 3 ? i2(o2) : u2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return u2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  },
  __param: function(e20, t2) {
    return function(n2, r2) {
      t2(n2, r2, e20);
    };
  },
  __metadata: function(e20, t2) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
      return Reflect.metadata(e20, t2);
  },
  __awaiter: function(e20, t2, n2, r2) {
    return new (n2 || (n2 = Promise))(function(i2, u2) {
      function o2(e21) {
        try {
          a2(r2.next(e21));
        } catch (e22) {
          u2(e22);
        }
      }
      function s2(e21) {
        try {
          a2(r2.throw(e21));
        } catch (e22) {
          u2(e22);
        }
      }
      function a2(e21) {
        var t3;
        e21.done ? i2(e21.value) : (t3 = e21.value, t3 instanceof n2 ? t3 : new n2(function(e22) {
          e22(t3);
        })).then(o2, s2);
      }
      a2((r2 = r2.apply(e20, t2 || [])).next());
    });
  },
  __generator: function(e20, t2) {
    var n2, r2, i2, u2, o2 = {
      label: 0,
      sent: function() {
        if (1 & i2[0])
          throw i2[1];
        return i2[1];
      },
      trys: [],
      ops: []
    };
    return u2 = { next: s2(0), throw: s2(1), return: s2(2) }, typeof Symbol == "function" && (u2[Symbol.iterator] = function() {
      return this;
    }), u2;
    function s2(u3) {
      return function(s3) {
        return function(u4) {
          if (n2)
            throw new TypeError("Generator is already executing.");
          for (; o2; )
            try {
              if (n2 = 1, r2 && (i2 = 2 & u4[0] ? r2.return : u4[0] ? r2.throw || ((i2 = r2.return) && i2.call(r2), 0) : r2.next) && !(i2 = i2.call(r2, u4[1])).done)
                return i2;
              switch (r2 = 0, i2 && (u4 = [2 & u4[0], i2.value]), u4[0]) {
                case 0:
                case 1:
                  i2 = u4;
                  break;
                case 4:
                  return o2.label++, { value: u4[1], done: false };
                case 5:
                  o2.label++, r2 = u4[1], u4 = [0];
                  continue;
                case 7:
                  u4 = o2.ops.pop(), o2.trys.pop();
                  continue;
                default:
                  if (!(i2 = o2.trys, (i2 = i2.length > 0 && i2[i2.length - 1]) || u4[0] !== 6 && u4[0] !== 2)) {
                    o2 = 0;
                    continue;
                  }
                  if (u4[0] === 3 && (!i2 || u4[1] > i2[0] && u4[1] < i2[3])) {
                    o2.label = u4[1];
                    break;
                  }
                  if (u4[0] === 6 && o2.label < i2[1]) {
                    o2.label = i2[1], i2 = u4;
                    break;
                  }
                  if (i2 && o2.label < i2[2]) {
                    o2.label = i2[2], o2.ops.push(u4);
                    break;
                  }
                  i2[2] && o2.ops.pop(), o2.trys.pop();
                  continue;
              }
              u4 = t2.call(e20, o2);
            } catch (e21) {
              u4 = [6, e21], r2 = 0;
            } finally {
              n2 = i2 = 0;
            }
          if (5 & u4[0])
            throw u4[1];
          return { value: u4[0] ? u4[1] : void 0, done: true };
        }([u3, s3]);
      };
    }
  },
  __createBinding: function(e20, t2, n2, r2) {
    r2 === void 0 && (r2 = n2), e20[r2] = t2[n2];
  },
  __exportStar: function(e20, t2) {
    for (var n2 in e20)
      n2 === "default" || t2.hasOwnProperty(n2) || (t2[n2] = e20[n2]);
  },
  __values: Fo$2,
  __read: So$2,
  __spread: function() {
    for (var e20 = [], t2 = 0; t2 < arguments.length; t2++)
      e20 = e20.concat(So$2(arguments[t2]));
    return e20;
  },
  __spreadArrays: function() {
    for (var e20 = 0, t2 = 0, n2 = arguments.length; t2 < n2; t2++)
      e20 += arguments[t2].length;
    var r2 = Array(e20), i2 = 0;
    for (t2 = 0; t2 < n2; t2++)
      for (var u2 = arguments[t2], o2 = 0, s2 = u2.length; o2 < s2; o2++, i2++)
        r2[i2] = u2[o2];
    return r2;
  },
  __await: xo$2,
  __asyncGenerator: function(e20, t2, n2) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var r2, i2 = n2.apply(e20, t2 || []), u2 = [];
    return r2 = {}, o2("next"), o2("throw"), o2("return"), r2[Symbol.asyncIterator] = function() {
      return this;
    }, r2;
    function o2(e21) {
      i2[e21] && (r2[e21] = function(t3) {
        return new Promise(function(n3, r3) {
          u2.push([e21, t3, n3, r3]) > 1 || s2(e21, t3);
        });
      });
    }
    function s2(e21, t3) {
      try {
        (n3 = i2[e21](t3)).value instanceof xo$2 ? Promise.resolve(n3.value.v).then(a2, c2) : l2(u2[0][2], n3);
      } catch (e22) {
        l2(u2[0][3], e22);
      }
      var n3;
    }
    function a2(e21) {
      s2("next", e21);
    }
    function c2(e21) {
      s2("throw", e21);
    }
    function l2(e21, t3) {
      e21(t3), u2.shift(), u2.length && s2(u2[0][0], u2[0][1]);
    }
  },
  __asyncDelegator: function(e20) {
    var t2, n2;
    return t2 = {}, r2("next"), r2("throw", function(e21) {
      throw e21;
    }), r2("return"), t2[Symbol.iterator] = function() {
      return this;
    }, t2;
    function r2(r3, i2) {
      t2[r3] = e20[r3] ? function(t3) {
        return (n2 = !n2) ? { value: xo$2(e20[r3](t3)), done: r3 === "return" } : i2 ? i2(t3) : t3;
      } : i2;
    }
  },
  __asyncValues: function(e20) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var t2, n2 = e20[Symbol.asyncIterator];
    return n2 ? n2.call(e20) : (e20 = Fo$2(e20), t2 = {}, r2("next"), r2("throw"), r2("return"), t2[Symbol.asyncIterator] = function() {
      return this;
    }, t2);
    function r2(n3) {
      t2[n3] = e20[n3] && function(t3) {
        return new Promise(function(r3, i2) {
          (function(e21, t4, n4, r4) {
            Promise.resolve(r4).then(function(t5) {
              e21({ value: t5, done: n4 });
            }, t4);
          })(r3, i2, (t3 = e20[n3](t3)).done, t3.value);
        });
      };
    }
  },
  __makeTemplateObject: function(e20, t2) {
    return Object.defineProperty ? Object.defineProperty(e20, "raw", { value: t2 }) : e20.raw = t2, e20;
  },
  __importStar: function(e20) {
    if (e20 && e20.__esModule)
      return e20;
    var t2 = {};
    if (e20 != null)
      for (var n2 in e20)
        Object.hasOwnProperty.call(e20, n2) && (t2[n2] = e20[n2]);
    return t2.default = e20, t2;
  },
  __importDefault: function(e20) {
    return e20 && e20.__esModule ? e20 : { default: e20 };
  },
  __classPrivateFieldGet: function(e20, t2) {
    if (!t2.has(e20))
      throw new TypeError("attempted to get private field on non-instance");
    return t2.get(e20);
  },
  __classPrivateFieldSet: function(e20, t2, n2) {
    if (!t2.has(e20))
      throw new TypeError("attempted to set private field on non-instance");
    return t2.set(e20, n2), n2;
  }
}), To$2 = r$3(function(e20, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.apiDescriptor = {
    key: (e21) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e21) ? e21 : JSON.stringify(e21),
    value(e21) {
      if (e21 === null || typeof e21 != "object")
        return JSON.stringify(e21);
      if (Array.isArray(e21))
        return `[${e21.map((e22) => t2.apiDescriptor.value(e22)).join(", ")}]`;
      const n2 = Object.keys(e21);
      return n2.length === 0 ? "{}" : `{ ${n2.map((n3) => `${t2.apiDescriptor.key(n3)}: ${t2.apiDescriptor.value(e21[n3])}`).join(", ")} }`;
    },
    pair: ({ key: e21, value: n2 }) => t2.apiDescriptor.value({ [e21]: n2 })
  };
}), Bo$2 = r$3(function(e20, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), wo$2.__exportStar(To$2, t2);
}), No$2 = /[|\\{}()[\]^$+*?.]/g, ko$2 = function(e20) {
  if (typeof e20 != "string")
    throw new TypeError("Expected a string");
  return e20.replace(No$2, "\\$&");
}, Po$2 = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
}, Oo$2 = r$3(function(e20) {
  var t2 = {};
  for (var n2 in Po$2)
    Po$2.hasOwnProperty(n2) && (t2[Po$2[n2]] = n2);
  var r2 = e20.exports = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  for (var i2 in r2)
    if (r2.hasOwnProperty(i2)) {
      if (!("channels" in r2[i2]))
        throw new Error("missing channels property: " + i2);
      if (!("labels" in r2[i2]))
        throw new Error("missing channel labels property: " + i2);
      if (r2[i2].labels.length !== r2[i2].channels)
        throw new Error("channel and label counts mismatch: " + i2);
      var u2 = r2[i2].channels, o2 = r2[i2].labels;
      delete r2[i2].channels, delete r2[i2].labels, Object.defineProperty(r2[i2], "channels", { value: u2 }), Object.defineProperty(r2[i2], "labels", { value: o2 });
    }
  r2.rgb.hsl = function(e21) {
    var t3, n3, r3 = e21[0] / 255, i3 = e21[1] / 255, u3 = e21[2] / 255, o3 = Math.min(r3, i3, u3), s2 = Math.max(r3, i3, u3), a2 = s2 - o3;
    return s2 === o3 ? t3 = 0 : r3 === s2 ? t3 = (i3 - u3) / a2 : i3 === s2 ? t3 = 2 + (u3 - r3) / a2 : u3 === s2 && (t3 = 4 + (r3 - i3) / a2), (t3 = Math.min(60 * t3, 360)) < 0 && (t3 += 360), n3 = (o3 + s2) / 2, [
      t3,
      100 * (s2 === o3 ? 0 : n3 <= 0.5 ? a2 / (s2 + o3) : a2 / (2 - s2 - o3)),
      100 * n3
    ];
  }, r2.rgb.hsv = function(e21) {
    var t3, n3, r3, i3, u3, o3 = e21[0] / 255, s2 = e21[1] / 255, a2 = e21[2] / 255, c2 = Math.max(o3, s2, a2), l2 = c2 - Math.min(o3, s2, a2), p2 = function(e22) {
      return (c2 - e22) / 6 / l2 + 0.5;
    };
    return l2 === 0 ? i3 = u3 = 0 : (u3 = l2 / c2, t3 = p2(o3), n3 = p2(s2), r3 = p2(a2), o3 === c2 ? i3 = r3 - n3 : s2 === c2 ? i3 = 1 / 3 + t3 - r3 : a2 === c2 && (i3 = 2 / 3 + n3 - t3), i3 < 0 ? i3 += 1 : i3 > 1 && (i3 -= 1)), [360 * i3, 100 * u3, 100 * c2];
  }, r2.rgb.hwb = function(e21) {
    var t3 = e21[0], n3 = e21[1], i3 = e21[2];
    return [
      r2.rgb.hsl(e21)[0],
      100 * (1 / 255 * Math.min(t3, Math.min(n3, i3))),
      100 * (i3 = 1 - 1 / 255 * Math.max(t3, Math.max(n3, i3)))
    ];
  }, r2.rgb.cmyk = function(e21) {
    var t3, n3 = e21[0] / 255, r3 = e21[1] / 255, i3 = e21[2] / 255;
    return [
      100 * ((1 - n3 - (t3 = Math.min(1 - n3, 1 - r3, 1 - i3))) / (1 - t3) || 0),
      100 * ((1 - r3 - t3) / (1 - t3) || 0),
      100 * ((1 - i3 - t3) / (1 - t3) || 0),
      100 * t3
    ];
  }, r2.rgb.keyword = function(e21) {
    var n3 = t2[e21];
    if (n3)
      return n3;
    var r3, i3, u3, o3 = 1 / 0;
    for (var s2 in Po$2)
      if (Po$2.hasOwnProperty(s2)) {
        var a2 = Po$2[s2], c2 = (i3 = e21, u3 = a2, Math.pow(i3[0] - u3[0], 2) + Math.pow(i3[1] - u3[1], 2) + Math.pow(i3[2] - u3[2], 2));
        c2 < o3 && (o3 = c2, r3 = s2);
      }
    return r3;
  }, r2.keyword.rgb = function(e21) {
    return Po$2[e21];
  }, r2.rgb.xyz = function(e21) {
    var t3 = e21[0] / 255, n3 = e21[1] / 255, r3 = e21[2] / 255;
    return [
      100 * (0.4124 * (t3 = t3 > 0.04045 ? Math.pow((t3 + 0.055) / 1.055, 2.4) : t3 / 12.92) + 0.3576 * (n3 = n3 > 0.04045 ? Math.pow((n3 + 0.055) / 1.055, 2.4) : n3 / 12.92) + 0.1805 * (r3 = r3 > 0.04045 ? Math.pow((r3 + 0.055) / 1.055, 2.4) : r3 / 12.92)),
      100 * (0.2126 * t3 + 0.7152 * n3 + 0.0722 * r3),
      100 * (0.0193 * t3 + 0.1192 * n3 + 0.9505 * r3)
    ];
  }, r2.rgb.lab = function(e21) {
    var t3 = r2.rgb.xyz(e21), n3 = t3[0], i3 = t3[1], u3 = t3[2];
    return i3 /= 100, u3 /= 108.883, n3 = (n3 /= 95.047) > 8856e-6 ? Math.pow(n3, 1 / 3) : 7.787 * n3 + 16 / 116, [
      116 * (i3 = i3 > 8856e-6 ? Math.pow(i3, 1 / 3) : 7.787 * i3 + 16 / 116) - 16,
      500 * (n3 - i3),
      200 * (i3 - (u3 = u3 > 8856e-6 ? Math.pow(u3, 1 / 3) : 7.787 * u3 + 16 / 116))
    ];
  }, r2.hsl.rgb = function(e21) {
    var t3, n3, r3, i3, u3, o3 = e21[0] / 360, s2 = e21[1] / 100, a2 = e21[2] / 100;
    if (s2 === 0)
      return [u3 = 255 * a2, u3, u3];
    t3 = 2 * a2 - (n3 = a2 < 0.5 ? a2 * (1 + s2) : a2 + s2 - a2 * s2), i3 = [0, 0, 0];
    for (var c2 = 0; c2 < 3; c2++)
      (r3 = o3 + 1 / 3 * -(c2 - 1)) < 0 && r3++, r3 > 1 && r3--, u3 = 6 * r3 < 1 ? t3 + 6 * (n3 - t3) * r3 : 2 * r3 < 1 ? n3 : 3 * r3 < 2 ? t3 + (n3 - t3) * (2 / 3 - r3) * 6 : t3, i3[c2] = 255 * u3;
    return i3;
  }, r2.hsl.hsv = function(e21) {
    var t3 = e21[0], n3 = e21[1] / 100, r3 = e21[2] / 100, i3 = n3, u3 = Math.max(r3, 0.01);
    return n3 *= (r3 *= 2) <= 1 ? r3 : 2 - r3, i3 *= u3 <= 1 ? u3 : 2 - u3, [
      t3,
      100 * (r3 === 0 ? 2 * i3 / (u3 + i3) : 2 * n3 / (r3 + n3)),
      100 * ((r3 + n3) / 2)
    ];
  }, r2.hsv.rgb = function(e21) {
    var t3 = e21[0] / 60, n3 = e21[1] / 100, r3 = e21[2] / 100, i3 = Math.floor(t3) % 6, u3 = t3 - Math.floor(t3), o3 = 255 * r3 * (1 - n3), s2 = 255 * r3 * (1 - n3 * u3), a2 = 255 * r3 * (1 - n3 * (1 - u3));
    switch (r3 *= 255, i3) {
      case 0:
        return [r3, a2, o3];
      case 1:
        return [s2, r3, o3];
      case 2:
        return [o3, r3, a2];
      case 3:
        return [o3, s2, r3];
      case 4:
        return [a2, o3, r3];
      case 5:
        return [r3, o3, s2];
    }
  }, r2.hsv.hsl = function(e21) {
    var t3, n3, r3, i3 = e21[0], u3 = e21[1] / 100, o3 = e21[2] / 100, s2 = Math.max(o3, 0.01);
    return r3 = (2 - u3) * o3, n3 = u3 * s2, [
      i3,
      100 * (n3 = (n3 /= (t3 = (2 - u3) * s2) <= 1 ? t3 : 2 - t3) || 0),
      100 * (r3 /= 2)
    ];
  }, r2.hwb.rgb = function(e21) {
    var t3, n3, r3, i3, u3, o3, s2, a2 = e21[0] / 360, c2 = e21[1] / 100, l2 = e21[2] / 100, p2 = c2 + l2;
    switch (p2 > 1 && (c2 /= p2, l2 /= p2), r3 = 6 * a2 - (t3 = Math.floor(6 * a2)), (1 & t3) != 0 && (r3 = 1 - r3), i3 = c2 + r3 * ((n3 = 1 - l2) - c2), t3) {
      default:
      case 6:
      case 0:
        u3 = n3, o3 = i3, s2 = c2;
        break;
      case 1:
        u3 = i3, o3 = n3, s2 = c2;
        break;
      case 2:
        u3 = c2, o3 = n3, s2 = i3;
        break;
      case 3:
        u3 = c2, o3 = i3, s2 = n3;
        break;
      case 4:
        u3 = i3, o3 = c2, s2 = n3;
        break;
      case 5:
        u3 = n3, o3 = c2, s2 = i3;
    }
    return [255 * u3, 255 * o3, 255 * s2];
  }, r2.cmyk.rgb = function(e21) {
    var t3 = e21[0] / 100, n3 = e21[1] / 100, r3 = e21[2] / 100, i3 = e21[3] / 100;
    return [
      255 * (1 - Math.min(1, t3 * (1 - i3) + i3)),
      255 * (1 - Math.min(1, n3 * (1 - i3) + i3)),
      255 * (1 - Math.min(1, r3 * (1 - i3) + i3))
    ];
  }, r2.xyz.rgb = function(e21) {
    var t3, n3, r3, i3 = e21[0] / 100, u3 = e21[1] / 100, o3 = e21[2] / 100;
    return n3 = -0.9689 * i3 + 1.8758 * u3 + 0.0415 * o3, r3 = 0.0557 * i3 + -0.204 * u3 + 1.057 * o3, t3 = (t3 = 3.2406 * i3 + -1.5372 * u3 + -0.4986 * o3) > 31308e-7 ? 1.055 * Math.pow(t3, 1 / 2.4) - 0.055 : 12.92 * t3, n3 = n3 > 31308e-7 ? 1.055 * Math.pow(n3, 1 / 2.4) - 0.055 : 12.92 * n3, r3 = r3 > 31308e-7 ? 1.055 * Math.pow(r3, 1 / 2.4) - 0.055 : 12.92 * r3, [
      255 * (t3 = Math.min(Math.max(0, t3), 1)),
      255 * (n3 = Math.min(Math.max(0, n3), 1)),
      255 * (r3 = Math.min(Math.max(0, r3), 1))
    ];
  }, r2.xyz.lab = function(e21) {
    var t3 = e21[0], n3 = e21[1], r3 = e21[2];
    return n3 /= 100, r3 /= 108.883, t3 = (t3 /= 95.047) > 8856e-6 ? Math.pow(t3, 1 / 3) : 7.787 * t3 + 16 / 116, [
      116 * (n3 = n3 > 8856e-6 ? Math.pow(n3, 1 / 3) : 7.787 * n3 + 16 / 116) - 16,
      500 * (t3 - n3),
      200 * (n3 - (r3 = r3 > 8856e-6 ? Math.pow(r3, 1 / 3) : 7.787 * r3 + 16 / 116))
    ];
  }, r2.lab.xyz = function(e21) {
    var t3, n3, r3, i3 = e21[0];
    t3 = e21[1] / 500 + (n3 = (i3 + 16) / 116), r3 = n3 - e21[2] / 200;
    var u3 = Math.pow(n3, 3), o3 = Math.pow(t3, 3), s2 = Math.pow(r3, 3);
    return n3 = u3 > 8856e-6 ? u3 : (n3 - 16 / 116) / 7.787, t3 = o3 > 8856e-6 ? o3 : (t3 - 16 / 116) / 7.787, r3 = s2 > 8856e-6 ? s2 : (r3 - 16 / 116) / 7.787, [t3 *= 95.047, n3 *= 100, r3 *= 108.883];
  }, r2.lab.lch = function(e21) {
    var t3, n3 = e21[0], r3 = e21[1], i3 = e21[2];
    return (t3 = 360 * Math.atan2(i3, r3) / 2 / Math.PI) < 0 && (t3 += 360), [n3, Math.sqrt(r3 * r3 + i3 * i3), t3];
  }, r2.lch.lab = function(e21) {
    var t3, n3 = e21[0], r3 = e21[1];
    return t3 = e21[2] / 360 * 2 * Math.PI, [n3, r3 * Math.cos(t3), r3 * Math.sin(t3)];
  }, r2.rgb.ansi16 = function(e21) {
    var t3 = e21[0], n3 = e21[1], i3 = e21[2], u3 = 1 in arguments ? arguments[1] : r2.rgb.hsv(e21)[2];
    if ((u3 = Math.round(u3 / 50)) === 0)
      return 30;
    var o3 = 30 + (Math.round(i3 / 255) << 2 | Math.round(n3 / 255) << 1 | Math.round(t3 / 255));
    return u3 === 2 && (o3 += 60), o3;
  }, r2.hsv.ansi16 = function(e21) {
    return r2.rgb.ansi16(r2.hsv.rgb(e21), e21[2]);
  }, r2.rgb.ansi256 = function(e21) {
    var t3 = e21[0], n3 = e21[1], r3 = e21[2];
    return t3 === n3 && n3 === r3 ? t3 < 8 ? 16 : t3 > 248 ? 231 : Math.round((t3 - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t3 / 255 * 5) + 6 * Math.round(n3 / 255 * 5) + Math.round(r3 / 255 * 5);
  }, r2.ansi16.rgb = function(e21) {
    var t3 = e21 % 10;
    if (t3 === 0 || t3 === 7)
      return e21 > 50 && (t3 += 3.5), [t3 = t3 / 10.5 * 255, t3, t3];
    var n3 = 0.5 * (1 + ~~(e21 > 50));
    return [
      (1 & t3) * n3 * 255,
      (t3 >> 1 & 1) * n3 * 255,
      (t3 >> 2 & 1) * n3 * 255
    ];
  }, r2.ansi256.rgb = function(e21) {
    if (e21 >= 232) {
      var t3 = 10 * (e21 - 232) + 8;
      return [t3, t3, t3];
    }
    var n3;
    return e21 -= 16, [
      Math.floor(e21 / 36) / 5 * 255,
      Math.floor((n3 = e21 % 36) / 6) / 5 * 255,
      n3 % 6 / 5 * 255
    ];
  }, r2.rgb.hex = function(e21) {
    var t3 = (((255 & Math.round(e21[0])) << 16) + ((255 & Math.round(e21[1])) << 8) + (255 & Math.round(e21[2]))).toString(16).toUpperCase();
    return "000000".substring(t3.length) + t3;
  }, r2.hex.rgb = function(e21) {
    var t3 = e21.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!t3)
      return [0, 0, 0];
    var n3 = t3[0];
    t3[0].length === 3 && (n3 = n3.split("").map(function(e22) {
      return e22 + e22;
    }).join(""));
    var r3 = parseInt(n3, 16);
    return [r3 >> 16 & 255, r3 >> 8 & 255, 255 & r3];
  }, r2.rgb.hcg = function(e21) {
    var t3, n3 = e21[0] / 255, r3 = e21[1] / 255, i3 = e21[2] / 255, u3 = Math.max(Math.max(n3, r3), i3), o3 = Math.min(Math.min(n3, r3), i3), s2 = u3 - o3;
    return t3 = s2 <= 0 ? 0 : u3 === n3 ? (r3 - i3) / s2 % 6 : u3 === r3 ? 2 + (i3 - n3) / s2 : 4 + (n3 - r3) / s2 + 4, t3 /= 6, [360 * (t3 %= 1), 100 * s2, 100 * (s2 < 1 ? o3 / (1 - s2) : 0)];
  }, r2.hsl.hcg = function(e21) {
    var t3 = e21[1] / 100, n3 = e21[2] / 100, r3 = 1, i3 = 0;
    return (r3 = n3 < 0.5 ? 2 * t3 * n3 : 2 * t3 * (1 - n3)) < 1 && (i3 = (n3 - 0.5 * r3) / (1 - r3)), [e21[0], 100 * r3, 100 * i3];
  }, r2.hsv.hcg = function(e21) {
    var t3 = e21[1] / 100, n3 = e21[2] / 100, r3 = t3 * n3, i3 = 0;
    return r3 < 1 && (i3 = (n3 - r3) / (1 - r3)), [e21[0], 100 * r3, 100 * i3];
  }, r2.hcg.rgb = function(e21) {
    var t3 = e21[0] / 360, n3 = e21[1] / 100, r3 = e21[2] / 100;
    if (n3 === 0)
      return [255 * r3, 255 * r3, 255 * r3];
    var i3, u3 = [0, 0, 0], o3 = t3 % 1 * 6, s2 = o3 % 1, a2 = 1 - s2;
    switch (Math.floor(o3)) {
      case 0:
        u3[0] = 1, u3[1] = s2, u3[2] = 0;
        break;
      case 1:
        u3[0] = a2, u3[1] = 1, u3[2] = 0;
        break;
      case 2:
        u3[0] = 0, u3[1] = 1, u3[2] = s2;
        break;
      case 3:
        u3[0] = 0, u3[1] = a2, u3[2] = 1;
        break;
      case 4:
        u3[0] = s2, u3[1] = 0, u3[2] = 1;
        break;
      default:
        u3[0] = 1, u3[1] = 0, u3[2] = a2;
    }
    return i3 = (1 - n3) * r3, [
      255 * (n3 * u3[0] + i3),
      255 * (n3 * u3[1] + i3),
      255 * (n3 * u3[2] + i3)
    ];
  }, r2.hcg.hsv = function(e21) {
    var t3 = e21[1] / 100, n3 = t3 + e21[2] / 100 * (1 - t3), r3 = 0;
    return n3 > 0 && (r3 = t3 / n3), [e21[0], 100 * r3, 100 * n3];
  }, r2.hcg.hsl = function(e21) {
    var t3 = e21[1] / 100, n3 = e21[2] / 100 * (1 - t3) + 0.5 * t3, r3 = 0;
    return n3 > 0 && n3 < 0.5 ? r3 = t3 / (2 * n3) : n3 >= 0.5 && n3 < 1 && (r3 = t3 / (2 * (1 - n3))), [e21[0], 100 * r3, 100 * n3];
  }, r2.hcg.hwb = function(e21) {
    var t3 = e21[1] / 100, n3 = t3 + e21[2] / 100 * (1 - t3);
    return [e21[0], 100 * (n3 - t3), 100 * (1 - n3)];
  }, r2.hwb.hcg = function(e21) {
    var t3 = e21[1] / 100, n3 = 1 - e21[2] / 100, r3 = n3 - t3, i3 = 0;
    return r3 < 1 && (i3 = (n3 - r3) / (1 - r3)), [e21[0], 100 * r3, 100 * i3];
  }, r2.apple.rgb = function(e21) {
    return [
      e21[0] / 65535 * 255,
      e21[1] / 65535 * 255,
      e21[2] / 65535 * 255
    ];
  }, r2.rgb.apple = function(e21) {
    return [
      e21[0] / 255 * 65535,
      e21[1] / 255 * 65535,
      e21[2] / 255 * 65535
    ];
  }, r2.gray.rgb = function(e21) {
    return [
      e21[0] / 100 * 255,
      e21[0] / 100 * 255,
      e21[0] / 100 * 255
    ];
  }, r2.gray.hsl = r2.gray.hsv = function(e21) {
    return [0, 0, e21[0]];
  }, r2.gray.hwb = function(e21) {
    return [0, 100, e21[0]];
  }, r2.gray.cmyk = function(e21) {
    return [0, 0, 0, e21[0]];
  }, r2.gray.lab = function(e21) {
    return [e21[0], 0, 0];
  }, r2.gray.hex = function(e21) {
    var t3 = 255 & Math.round(e21[0] / 100 * 255), n3 = ((t3 << 16) + (t3 << 8) + t3).toString(16).toUpperCase();
    return "000000".substring(n3.length) + n3;
  }, r2.rgb.gray = function(e21) {
    return [(e21[0] + e21[1] + e21[2]) / 3 / 255 * 100];
  };
});
function Io$2(e20) {
  var t2 = function() {
    for (var e21 = {}, t3 = Object.keys(Oo$2), n3 = t3.length, r3 = 0; r3 < n3; r3++)
      e21[t3[r3]] = { distance: -1, parent: null };
    return e21;
  }(), n2 = [e20];
  for (t2[e20].distance = 0; n2.length; )
    for (var r2 = n2.pop(), i2 = Object.keys(Oo$2[r2]), u2 = i2.length, o2 = 0; o2 < u2; o2++) {
      var s2 = i2[o2], a2 = t2[s2];
      a2.distance === -1 && (a2.distance = t2[r2].distance + 1, a2.parent = r2, n2.unshift(s2));
    }
  return t2;
}
function Lo$2(e20, t2) {
  return function(n2) {
    return t2(e20(n2));
  };
}
function jo$1(e20, t2) {
  for (var n2 = [t2[e20].parent, e20], r2 = Oo$2[t2[e20].parent][e20], i2 = t2[e20].parent; t2[i2].parent; )
    n2.unshift(t2[i2].parent), r2 = Lo$2(Oo$2[t2[i2].parent][i2], r2), i2 = t2[i2].parent;
  return r2.conversion = n2, r2;
}
var _o$2 = {};
Object.keys(Oo$2).forEach(function(e20) {
  _o$2[e20] = {}, Object.defineProperty(_o$2[e20], "channels", { value: Oo$2[e20].channels }), Object.defineProperty(_o$2[e20], "labels", { value: Oo$2[e20].labels });
  var t2 = function(e21) {
    for (var t3 = Io$2(e21), n2 = {}, r2 = Object.keys(t3), i2 = r2.length, u2 = 0; u2 < i2; u2++) {
      var o2 = r2[u2];
      t3[o2].parent !== null && (n2[o2] = jo$1(o2, t3));
    }
    return n2;
  }(e20);
  Object.keys(t2).forEach(function(n2) {
    var r2 = t2[n2];
    _o$2[e20][n2] = function(e21) {
      var t3 = function(t4) {
        if (t4 == null)
          return t4;
        arguments.length > 1 && (t4 = Array.prototype.slice.call(arguments));
        var n3 = e21(t4);
        if (typeof n3 == "object")
          for (var r3 = n3.length, i2 = 0; i2 < r3; i2++)
            n3[i2] = Math.round(n3[i2]);
        return n3;
      };
      return "conversion" in e21 && (t3.conversion = e21.conversion), t3;
    }(r2), _o$2[e20][n2].raw = function(e21) {
      var t3 = function(t4) {
        return t4 == null ? t4 : (arguments.length > 1 && (t4 = Array.prototype.slice.call(arguments)), e21(t4));
      };
      return "conversion" in e21 && (t3.conversion = e21.conversion), t3;
    }(r2);
  });
});
var Mo$1, Ro$2 = _o$2, $o$1 = r$3(function(e20) {
  const t2 = (e21, t3) => function() {
    const n3 = e21.apply(Ro$2, arguments);
    return `[${n3 + t3}m`;
  }, n2 = (e21, t3) => function() {
    const n3 = e21.apply(Ro$2, arguments);
    return `[${38 + t3};5;${n3}m`;
  }, r2 = (e21, t3) => function() {
    const n3 = e21.apply(Ro$2, arguments);
    return `[${38 + t3};2;${n3[0]};${n3[1]};${n3[2]}m`;
  };
  Object.defineProperty(e20, "exports", {
    enumerable: true,
    get: function() {
      const e21 = new Map(), i2 = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          gray: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      i2.color.grey = i2.color.gray;
      for (const t3 of Object.keys(i2)) {
        const n3 = i2[t3];
        for (const t4 of Object.keys(n3)) {
          const r3 = n3[t4];
          i2[t4] = {
            open: `[${r3[0]}m`,
            close: `[${r3[1]}m`
          }, n3[t4] = i2[t4], e21.set(r3[0], r3[1]);
        }
        Object.defineProperty(i2, t3, { value: n3, enumerable: false }), Object.defineProperty(i2, "codes", {
          value: e21,
          enumerable: false
        });
      }
      const u2 = (e22) => e22, o2 = (e22, t3, n3) => [e22, t3, n3];
      i2.color.close = "[39m", i2.bgColor.close = "[49m", i2.color.ansi = { ansi: t2(u2, 0) }, i2.color.ansi256 = { ansi256: n2(u2, 0) }, i2.color.ansi16m = { rgb: r2(o2, 0) }, i2.bgColor.ansi = { ansi: t2(u2, 10) }, i2.bgColor.ansi256 = { ansi256: n2(u2, 10) }, i2.bgColor.ansi16m = { rgb: r2(o2, 10) };
      for (let e22 of Object.keys(Ro$2)) {
        if (typeof Ro$2[e22] != "object")
          continue;
        const u3 = Ro$2[e22];
        e22 === "ansi16" && (e22 = "ansi"), "ansi16" in u3 && (i2.color.ansi[e22] = t2(u3.ansi16, 0), i2.bgColor.ansi[e22] = t2(u3.ansi16, 10)), "ansi256" in u3 && (i2.color.ansi256[e22] = n2(u3.ansi256, 0), i2.bgColor.ansi256[e22] = n2(u3.ansi256, 10)), "rgb" in u3 && (i2.color.ansi16m[e22] = r2(u3.rgb, 0), i2.bgColor.ansi16m[e22] = r2(u3.rgb, 10));
      }
      return i2;
    }
  });
});
function Vo$1() {
  if (Mo$1 === void 0) {
    var e20 = new ArrayBuffer(2), t2 = new Uint8Array(e20), n2 = new Uint16Array(e20);
    if (t2[0] = 1, t2[1] = 2, n2[0] === 258)
      Mo$1 = "BE";
    else {
      if (n2[0] !== 513)
        throw new Error("unable to figure out endianess");
      Mo$1 = "LE";
    }
  }
  return Mo$1;
}
function Wo$1() {
  return nr$2.location !== void 0 ? nr$2.location.hostname : "";
}
function qo$1() {
  return [];
}
function Uo$1() {
  return 0;
}
function zo$1() {
  return Number.MAX_VALUE;
}
function Go$1() {
  return Number.MAX_VALUE;
}
function Ho$1() {
  return [];
}
function Jo$1() {
  return "Browser";
}
function Xo$1() {
  return nr$2.navigator !== void 0 ? nr$2.navigator.appVersion : "";
}
function Yo$1() {
}
function Ko$1() {
}
function Qo$1() {
  return "javascript";
}
function Zo$1() {
  return "browser";
}
function es$2() {
  return "/tmp";
}
var ts$2 = es$2, ns$2 = {
  EOL: "\n",
  arch: Qo$1,
  platform: Zo$1,
  tmpdir: ts$2,
  tmpDir: es$2,
  networkInterfaces: Yo$1,
  getNetworkInterfaces: Ko$1,
  release: Xo$1,
  type: Jo$1,
  cpus: Ho$1,
  totalmem: Go$1,
  freemem: zo$1,
  uptime: Uo$1,
  loadavg: qo$1,
  hostname: Wo$1,
  endianness: Vo$1
}, rs$2 = (e20, t2) => {
  t2 = t2 || xr$2.argv;
  const n2 = e20.startsWith("-") ? "" : e20.length === 1 ? "-" : "--", r2 = t2.indexOf(n2 + e20), i2 = t2.indexOf("--");
  return r2 !== -1 && (i2 === -1 || r2 < i2);
}, is$2 = n$3(Object.freeze({
  __proto__: null,
  endianness: Vo$1,
  hostname: Wo$1,
  loadavg: qo$1,
  uptime: Uo$1,
  freemem: zo$1,
  totalmem: Go$1,
  cpus: Ho$1,
  type: Jo$1,
  release: Xo$1,
  networkInterfaces: Yo$1,
  getNetworkInterfaces: Ko$1,
  arch: Qo$1,
  platform: Zo$1,
  tmpDir: es$2,
  tmpdir: ts$2,
  EOL: "\n",
  default: ns$2
}));
const us$2 = xr$2.env;
let os$2;
function ss$2(e20) {
  return function(e21) {
    return e21 !== 0 && {
      level: e21,
      hasBasic: true,
      has256: e21 >= 2,
      has16m: e21 >= 3
    };
  }(function(e21) {
    if (os$2 === false)
      return 0;
    if (rs$2("color=16m") || rs$2("color=full") || rs$2("color=truecolor"))
      return 3;
    if (rs$2("color=256"))
      return 2;
    if (e21 && !e21.isTTY && os$2 !== true)
      return 0;
    const t2 = os$2 ? 1 : 0;
    if ("CI" in us$2)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((e22) => e22 in us$2) || us$2.CI_NAME === "codeship" ? 1 : t2;
    if ("TEAMCITY_VERSION" in us$2)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(us$2.TEAMCITY_VERSION) ? 1 : 0;
    if (us$2.COLORTERM === "truecolor")
      return 3;
    if ("TERM_PROGRAM" in us$2) {
      const e22 = parseInt((us$2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (us$2.TERM_PROGRAM) {
        case "iTerm.app":
          return e22 >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(us$2.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(us$2.TERM) || "COLORTERM" in us$2 ? 1 : (us$2.TERM, t2);
  }(e20));
}
rs$2("no-color") || rs$2("no-colors") || rs$2("color=false") ? os$2 = false : (rs$2("color") || rs$2("colors") || rs$2("color=true") || rs$2("color=always")) && (os$2 = true), "FORCE_COLOR" in us$2 && (os$2 = us$2.FORCE_COLOR.length === 0 || parseInt(us$2.FORCE_COLOR, 10) !== 0);
var as$2 = {
  supportsColor: ss$2,
  stdout: ss$2(xr$2.stdout),
  stderr: ss$2(xr$2.stderr)
};
const cs$2 = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, ls$2 = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, ps$2 = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, fs$2 = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, ds$2 = new Map([
  ["n", "\n"],
  ["r", "\r"],
  ["t", "	"],
  ["b", "\b"],
  ["f", "\f"],
  ["v", "\v"],
  ["0", "\0"],
  ["\\", "\\"],
  ["e", ""],
  ["a", "\x07"]
]);
function hs$2(e20) {
  return e20[0] === "u" && e20.length === 5 || e20[0] === "x" && e20.length === 3 ? String.fromCharCode(parseInt(e20.slice(1), 16)) : ds$2.get(e20) || e20;
}
function gs$2(e20, t2) {
  const n2 = [], r2 = t2.trim().split(/\s*,\s*/g);
  let i2;
  for (const t3 of r2)
    if (isNaN(t3)) {
      if (!(i2 = t3.match(ps$2)))
        throw new Error(`Invalid Chalk template style argument: ${t3} (in style '${e20}')`);
      n2.push(i2[2].replace(fs$2, (e21, t4, n3) => t4 ? hs$2(t4) : n3));
    } else
      n2.push(Number(t3));
  return n2;
}
function ms$2(e20) {
  ls$2.lastIndex = 0;
  const t2 = [];
  let n2;
  for (; (n2 = ls$2.exec(e20)) !== null; ) {
    const e21 = n2[1];
    if (n2[2]) {
      const r2 = gs$2(e21, n2[2]);
      t2.push([e21].concat(r2));
    } else
      t2.push([e21]);
  }
  return t2;
}
function ys$2(e20, t2) {
  const n2 = {};
  for (const e21 of t2)
    for (const t3 of e21.styles)
      n2[t3[0]] = e21.inverse ? null : t3.slice(1);
  let r2 = e20;
  for (const e21 of Object.keys(n2))
    if (Array.isArray(n2[e21])) {
      if (!(e21 in r2))
        throw new Error(`Unknown Chalk style: ${e21}`);
      r2 = n2[e21].length > 0 ? r2[e21].apply(r2, n2[e21]) : r2[e21];
    }
  return r2;
}
var Ds$2 = (e20, t2) => {
  const n2 = [], r2 = [];
  let i2 = [];
  if (t2.replace(cs$2, (t3, u2, o2, s2, a2, c2) => {
    if (u2)
      i2.push(hs$2(u2));
    else if (s2) {
      const t4 = i2.join("");
      i2 = [], r2.push(n2.length === 0 ? t4 : ys$2(e20, n2)(t4)), n2.push({ inverse: o2, styles: ms$2(s2) });
    } else if (a2) {
      if (n2.length === 0)
        throw new Error("Found extraneous } in Chalk template literal");
      r2.push(ys$2(e20, n2)(i2.join(""))), i2 = [], n2.pop();
    } else
      i2.push(c2);
  }), r2.push(i2.join("")), n2.length > 0) {
    const e21 = `Chalk template literal is missing ${n2.length} closing bracket${n2.length === 1 ? "" : "s"} (\`}\`)`;
    throw new Error(e21);
  }
  return r2.join("");
}, Es$2 = r$3(function(e20) {
  const t2 = as$2.stdout, r2 = ["ansi", "ansi", "ansi256", "ansi16m"], i2 = new Set(["gray"]), u2 = Object.create(null);
  function o2(e21, n2) {
    n2 = n2 || {};
    const r3 = t2 ? t2.level : 0;
    e21.level = n2.level === void 0 ? r3 : n2.level, e21.enabled = "enabled" in n2 ? n2.enabled : e21.level > 0;
  }
  function s2(e21) {
    if (!this || !(this instanceof s2) || this.template) {
      const t3 = {};
      return o2(t3, e21), t3.template = function() {
        const e22 = [].slice.call(arguments);
        return p2.apply(null, [t3.template].concat(e22));
      }, Object.setPrototypeOf(t3, s2.prototype), Object.setPrototypeOf(t3.template, t3), t3.template.constructor = s2, t3.template;
    }
    o2(this, e21);
  }
  for (const e21 of Object.keys($o$1))
    $o$1[e21].closeRe = new RegExp(ko$2($o$1[e21].close), "g"), u2[e21] = {
      get() {
        const t3 = $o$1[e21];
        return c2.call(this, this._styles ? this._styles.concat(t3) : [t3], this._empty, e21);
      }
    };
  u2.visible = {
    get() {
      return c2.call(this, this._styles || [], true, "visible");
    }
  }, $o$1.color.closeRe = new RegExp(ko$2($o$1.color.close), "g");
  for (const e21 of Object.keys($o$1.color.ansi))
    i2.has(e21) || (u2[e21] = {
      get() {
        const t3 = this.level;
        return function() {
          const n2 = $o$1.color[r2[t3]][e21].apply(null, arguments), i3 = {
            open: n2,
            close: $o$1.color.close,
            closeRe: $o$1.color.closeRe
          };
          return c2.call(this, this._styles ? this._styles.concat(i3) : [i3], this._empty, e21);
        };
      }
    });
  $o$1.bgColor.closeRe = new RegExp(ko$2($o$1.bgColor.close), "g");
  for (const e21 of Object.keys($o$1.bgColor.ansi)) {
    if (i2.has(e21))
      continue;
    u2["bg" + e21[0].toUpperCase() + e21.slice(1)] = {
      get() {
        const t3 = this.level;
        return function() {
          const n2 = $o$1.bgColor[r2[t3]][e21].apply(null, arguments), i3 = {
            open: n2,
            close: $o$1.bgColor.close,
            closeRe: $o$1.bgColor.closeRe
          };
          return c2.call(this, this._styles ? this._styles.concat(i3) : [i3], this._empty, e21);
        };
      }
    };
  }
  const a2 = Object.defineProperties(() => {
  }, u2);
  function c2(e21, t3, n2) {
    const r3 = function() {
      return l2.apply(r3, arguments);
    };
    r3._styles = e21, r3._empty = t3;
    const i3 = this;
    return Object.defineProperty(r3, "level", {
      enumerable: true,
      get: () => i3.level,
      set(e22) {
        i3.level = e22;
      }
    }), Object.defineProperty(r3, "enabled", {
      enumerable: true,
      get: () => i3.enabled,
      set(e22) {
        i3.enabled = e22;
      }
    }), r3.hasGrey = this.hasGrey || n2 === "gray" || n2 === "grey", r3.__proto__ = a2, r3;
  }
  function l2() {
    const e21 = arguments, t3 = e21.length;
    let r3 = String(arguments[0]);
    if (t3 === 0)
      return "";
    if (t3 > 1)
      for (let n2 = 1; n2 < t3; n2++)
        r3 += " " + e21[n2];
    if (!this.enabled || this.level <= 0 || !r3)
      return this._empty ? "" : r3;
    const i3 = $o$1.dim.open;
    for (const e22 of this._styles.slice().reverse())
      r3 = e22.open + r3.replace(e22.closeRe, e22.open) + e22.close, r3 = r3.replace(/\r?\n/g, `${e22.close}$&${e22.open}`);
    return $o$1.dim.open = i3, r3;
  }
  function p2(e21, t3) {
    if (!Array.isArray(t3))
      return [].slice.call(arguments, 1).join(" ");
    const n2 = [].slice.call(arguments, 2), r3 = [t3.raw[0]];
    for (let e22 = 1; e22 < t3.length; e22++)
      r3.push(String(n2[e22 - 1]).replace(/[{}\\]/g, "\\$&")), r3.push(String(t3.raw[e22]));
    return Ds$2(e21, r3.join(""));
  }
  Object.defineProperties(s2.prototype, u2), e20.exports = s2(), e20.exports.supportsColor = t2, e20.exports.default = e20.exports;
}), Cs$2 = Object.defineProperty({
  commonDeprecatedHandler: (e20, t2, { descriptor: n2 }) => {
    const r2 = [
      `${Es$2.default.yellow(typeof e20 == "string" ? n2.key(e20) : n2.pair(e20))} is deprecated`
    ];
    return t2 && r2.push(`we now treat it as ${Es$2.default.blue(typeof t2 == "string" ? n2.key(t2) : n2.pair(t2))}`), r2.join("; ") + ".";
  }
}, "__esModule", { value: true }), bs$2 = r$3(function(e20, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), wo$2.__exportStar(Cs$2, t2);
}), As$2 = Object.defineProperty({
  commonInvalidHandler: (e20, t2, n2) => [
    `Invalid ${Es$2.default.red(n2.descriptor.key(e20))} value.`,
    `Expected ${Es$2.default.blue(n2.schemas[e20].expected(n2))},`,
    `but received ${Es$2.default.red(n2.descriptor.value(t2))}.`
  ].join(" ")
}, "__esModule", { value: true }), vs$2 = r$3(function(e20, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), wo$2.__exportStar(As$2, t2);
}), Fs$2 = [], Ss$2 = [], xs$2 = Object.defineProperty({
  levenUnknownHandler: (e20, t2, { descriptor: n2, logger: r2, schemas: i2 }) => {
    const u2 = [
      `Ignored unknown option ${Es$2.default.yellow(n2.pair({ key: e20, value: t2 }))}.`
    ], o2 = Object.keys(i2).sort().find((t3) => function(e21, t4) {
      if (e21 === t4)
        return 0;
      var n3 = e21;
      e21.length > t4.length && (e21 = t4, t4 = n3);
      var r3 = e21.length, i3 = t4.length;
      if (r3 === 0)
        return i3;
      if (i3 === 0)
        return r3;
      for (; r3 > 0 && e21.charCodeAt(~-r3) === t4.charCodeAt(~-i3); )
        r3--, i3--;
      if (r3 === 0)
        return i3;
      for (var u3, o3, s2, a2, c2 = 0; c2 < r3 && e21.charCodeAt(c2) === t4.charCodeAt(c2); )
        c2++;
      if (i3 -= c2, (r3 -= c2) == 0)
        return i3;
      for (var l2 = 0, p2 = 0; l2 < r3; )
        Ss$2[c2 + l2] = e21.charCodeAt(c2 + l2), Fs$2[l2] = ++l2;
      for (; p2 < i3; )
        for (u3 = t4.charCodeAt(c2 + p2), s2 = p2++, o3 = p2, l2 = 0; l2 < r3; l2++)
          a2 = u3 === Ss$2[c2 + l2] ? s2 : s2 + 1, s2 = Fs$2[l2], o3 = Fs$2[l2] = s2 > o3 ? a2 > o3 ? o3 + 1 : a2 : a2 > s2 ? s2 + 1 : a2;
      return o3;
    }(e20, t3) < 3);
    o2 && u2.push(`Did you mean ${Es$2.default.blue(n2.key(o2))}?`), r2.warn(u2.join(" "));
  }
}, "__esModule", { value: true }), ws$2 = r$3(function(e20, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), wo$2.__exportStar(xs$2, t2);
}), Ts$2 = r$3(function(e20, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), wo$2.__exportStar(bs$2, t2), wo$2.__exportStar(vs$2, t2), wo$2.__exportStar(ws$2, t2);
});
const Bs$2 = [
  "default",
  "expected",
  "validate",
  "deprecated",
  "forward",
  "redirect",
  "overlap",
  "preprocess",
  "postprocess"
];
function Ns$2(e20, t2) {
  const n2 = new e20(t2), r2 = Object.create(n2);
  for (const e21 of Bs$2)
    e21 in t2 && (r2[e21] = Is$2(t2[e21], n2, Ps$2.prototype[e21].length));
  return r2;
}
var ks$2 = Ns$2;
class Ps$2 {
  constructor(e20) {
    this.name = e20.name;
  }
  static create(e20) {
    return Ns$2(this, e20);
  }
  default(e20) {
  }
  expected(e20) {
    return "nothing";
  }
  validate(e20, t2) {
    return false;
  }
  deprecated(e20, t2) {
    return false;
  }
  forward(e20, t2) {
  }
  redirect(e20, t2) {
  }
  overlap(e20, t2, n2) {
    return e20;
  }
  preprocess(e20, t2) {
    return e20;
  }
  postprocess(e20, t2) {
    return e20;
  }
}
var Os$2 = Ps$2;
function Is$2(e20, t2, n2) {
  return typeof e20 == "function" ? (...r2) => e20(...r2.slice(0, n2 - 1), t2, ...r2.slice(n2 - 1)) : () => e20;
}
var Ls$2 = Object.defineProperty({ createSchema: ks$2, Schema: Os$2 }, "__esModule", { value: true });
class js$2 extends Ls$2.Schema {
  constructor(e20) {
    super(e20), this._sourceName = e20.sourceName;
  }
  expected(e20) {
    return e20.schemas[this._sourceName].expected(e20);
  }
  validate(e20, t2) {
    return t2.schemas[this._sourceName].validate(e20, t2);
  }
  redirect(e20, t2) {
    return this._sourceName;
  }
}
var _s$2 = js$2, Ms$2 = Object.defineProperty({ AliasSchema: _s$2 }, "__esModule", {
  value: true
});
class Rs$2 extends Ls$2.Schema {
  expected() {
    return "anything";
  }
  validate() {
    return true;
  }
}
var $s$2 = Rs$2, Vs$2 = Object.defineProperty({ AnySchema: $s$2 }, "__esModule", {
  value: true
});
class Ws$2 extends Ls$2.Schema {
  constructor(e20) {
    var { valueSchema: t2, name: n2 = t2.name } = e20, r2 = wo$2.__rest(e20, ["valueSchema", "name"]);
    super(Object.assign({}, r2, { name: n2 })), this._valueSchema = t2;
  }
  expected(e20) {
    return `an array of ${this._valueSchema.expected(e20)}`;
  }
  validate(e20, t2) {
    if (!Array.isArray(e20))
      return false;
    const n2 = [];
    for (const r2 of e20) {
      const e21 = t2.normalizeValidateResult(this._valueSchema.validate(r2, t2), r2);
      e21 !== true && n2.push(e21.value);
    }
    return n2.length === 0 || { value: n2 };
  }
  deprecated(e20, t2) {
    const n2 = [];
    for (const r2 of e20) {
      const e21 = t2.normalizeDeprecatedResult(this._valueSchema.deprecated(r2, t2), r2);
      e21 !== false && n2.push(...e21.map(({ value: e22 }) => ({ value: [e22] })));
    }
    return n2;
  }
  forward(e20, t2) {
    const n2 = [];
    for (const r2 of e20) {
      const e21 = t2.normalizeForwardResult(this._valueSchema.forward(r2, t2), r2);
      n2.push(...e21.map(Us$2));
    }
    return n2;
  }
  redirect(e20, t2) {
    const n2 = [], r2 = [];
    for (const i2 of e20) {
      const e21 = t2.normalizeRedirectResult(this._valueSchema.redirect(i2, t2), i2);
      "remain" in e21 && n2.push(e21.remain), r2.push(...e21.redirect.map(Us$2));
    }
    return n2.length === 0 ? { redirect: r2 } : { redirect: r2, remain: n2 };
  }
  overlap(e20, t2) {
    return e20.concat(t2);
  }
}
var qs$2 = Ws$2;
function Us$2({ from: e20, to: t2 }) {
  return { from: [e20], to: t2 };
}
var zs$2 = Object.defineProperty({ ArraySchema: qs$2 }, "__esModule", {
  value: true
});
class Gs$2 extends Ls$2.Schema {
  expected() {
    return "true or false";
  }
  validate(e20) {
    return typeof e20 == "boolean";
  }
}
var Hs$2 = Gs$2, Js$2 = Object.defineProperty({ BooleanSchema: Hs$2 }, "__esModule", {
  value: true
});
var Xs$2 = function(e20, t2) {
  const n2 = Object.create(null);
  for (const r2 of e20) {
    const e21 = r2[t2];
    if (n2[e21])
      throw new Error(`Duplicate ${t2} ${JSON.stringify(e21)}`);
    n2[e21] = r2;
  }
  return n2;
};
var Ys$2 = function(e20, t2) {
  const n2 = new Map();
  for (const r2 of e20) {
    const e21 = r2[t2];
    if (n2.has(e21))
      throw new Error(`Duplicate ${t2} ${JSON.stringify(e21)}`);
    n2.set(e21, r2);
  }
  return n2;
};
var Ks$2 = function() {
  const e20 = Object.create(null);
  return (t2) => {
    const n2 = JSON.stringify(t2);
    return !!e20[n2] || (e20[n2] = true, false);
  };
};
var Qs$2 = function(e20, t2) {
  const n2 = [], r2 = [];
  for (const i2 of e20)
    t2(i2) ? n2.push(i2) : r2.push(i2);
  return [n2, r2];
};
var Zs$2 = function(e20) {
  return e20 === Math.floor(e20);
};
var ea$1 = function(e20, t2) {
  if (e20 === t2)
    return 0;
  const n2 = typeof e20, r2 = typeof t2, i2 = ["undefined", "object", "boolean", "number", "string"];
  return n2 !== r2 ? i2.indexOf(n2) - i2.indexOf(r2) : n2 !== "string" ? Number(e20) - Number(t2) : e20.localeCompare(t2);
};
var ta$1 = function(e20) {
  return e20 === void 0 ? {} : e20;
};
var na$1 = function(e20, t2) {
  return e20 === true || (e20 === false ? { value: t2 } : e20);
};
var ra$1 = function(e20, t2, n2 = false) {
  return e20 !== false && (e20 === true ? !!n2 || [{ value: t2 }] : "value" in e20 ? [e20] : e20.length !== 0 && e20);
};
function ia$1(e20, t2) {
  return typeof e20 == "string" || "key" in e20 ? { from: t2, to: e20 } : "from" in e20 ? { from: e20.from, to: e20.to } : { from: t2, to: e20.to };
}
var ua$1 = ia$1;
function oa$1(e20, t2) {
  return e20 === void 0 ? [] : Array.isArray(e20) ? e20.map((e21) => ia$1(e21, t2)) : [ia$1(e20, t2)];
}
var sa$1 = oa$1;
var aa$1 = function(e20, t2) {
  const n2 = oa$1(typeof e20 == "object" && "redirect" in e20 ? e20.redirect : e20, t2);
  return n2.length === 0 ? { remain: t2, redirect: n2 } : typeof e20 == "object" && "remain" in e20 ? { remain: e20.remain, redirect: n2 } : { redirect: n2 };
}, ca$1 = Object.defineProperty({
  recordFromArray: Xs$2,
  mapFromArray: Ys$2,
  createAutoChecklist: Ks$2,
  partition: Qs$2,
  isInt: Zs$2,
  comparePrimitive: ea$1,
  normalizeDefaultResult: ta$1,
  normalizeValidateResult: na$1,
  normalizeDeprecatedResult: ra$1,
  normalizeTransferResult: ua$1,
  normalizeForwardResult: sa$1,
  normalizeRedirectResult: aa$1
}, "__esModule", { value: true });
class la$1 extends Ls$2.Schema {
  constructor(e20) {
    super(e20), this._choices = ca$1.mapFromArray(e20.choices.map((e21) => e21 && typeof e21 == "object" ? e21 : { value: e21 }), "value");
  }
  expected({ descriptor: e20 }) {
    const t2 = Array.from(this._choices.keys()).map((e21) => this._choices.get(e21)).filter((e21) => !e21.deprecated).map((e21) => e21.value).sort(ca$1.comparePrimitive).map(e20.value), n2 = t2.slice(0, -2), r2 = t2.slice(-2);
    return n2.concat(r2.join(" or ")).join(", ");
  }
  validate(e20) {
    return this._choices.has(e20);
  }
  deprecated(e20) {
    const t2 = this._choices.get(e20);
    return !(!t2 || !t2.deprecated) && { value: e20 };
  }
  forward(e20) {
    const t2 = this._choices.get(e20);
    return t2 ? t2.forward : void 0;
  }
  redirect(e20) {
    const t2 = this._choices.get(e20);
    return t2 ? t2.redirect : void 0;
  }
}
var pa$1 = la$1, fa$1 = Object.defineProperty({ ChoiceSchema: pa$1 }, "__esModule", {
  value: true
});
class da$1 extends Ls$2.Schema {
  expected() {
    return "a number";
  }
  validate(e20, t2) {
    return typeof e20 == "number";
  }
}
var ha$1 = da$1, ga$1 = Object.defineProperty({ NumberSchema: ha$1 }, "__esModule", {
  value: true
});
class ma$1 extends ga$1.NumberSchema {
  expected() {
    return "an integer";
  }
  validate(e20, t2) {
    return t2.normalizeValidateResult(super.validate(e20, t2), e20) === true && ca$1.isInt(e20);
  }
}
var ya$1 = ma$1, Da$1 = Object.defineProperty({ IntegerSchema: ya$1 }, "__esModule", {
  value: true
});
class Ea$1 extends Ls$2.Schema {
  expected() {
    return "a string";
  }
  validate(e20) {
    return typeof e20 == "string";
  }
}
var Ca$1 = Ea$1, ba$1 = Object.defineProperty({ StringSchema: Ca$1 }, "__esModule", {
  value: true
}), Aa$1 = r$3(function(e20, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), wo$2.__exportStar(Ms$2, t2), wo$2.__exportStar(Vs$2, t2), wo$2.__exportStar(zs$2, t2), wo$2.__exportStar(Js$2, t2), wo$2.__exportStar(fa$1, t2), wo$2.__exportStar(Da$1, t2), wo$2.__exportStar(ga$1, t2), wo$2.__exportStar(ba$1, t2);
}), va$1 = To$2.apiDescriptor, Fa$1 = xs$2.levenUnknownHandler, Sa$1 = vs$2.commonInvalidHandler, xa$1 = Cs$2.commonDeprecatedHandler, wa$1 = Object.defineProperty({
  defaultDescriptor: va$1,
  defaultUnknownHandler: Fa$1,
  defaultInvalidHandler: Sa$1,
  defaultDeprecatedHandler: xa$1
}, "__esModule", { value: true });
class Ta$1 {
  constructor(e20, t2) {
    const {
      logger: n2 = console,
      descriptor: r2 = wa$1.defaultDescriptor,
      unknown: i2 = wa$1.defaultUnknownHandler,
      invalid: u2 = wa$1.defaultInvalidHandler,
      deprecated: o2 = wa$1.defaultDeprecatedHandler
    } = t2 || {};
    this._utils = {
      descriptor: r2,
      logger: n2 || { warn: () => {
      } },
      schemas: ca$1.recordFromArray(e20, "name"),
      normalizeDefaultResult: ca$1.normalizeDefaultResult,
      normalizeDeprecatedResult: ca$1.normalizeDeprecatedResult,
      normalizeForwardResult: ca$1.normalizeForwardResult,
      normalizeRedirectResult: ca$1.normalizeRedirectResult,
      normalizeValidateResult: ca$1.normalizeValidateResult
    }, this._unknownHandler = i2, this._invalidHandler = u2, this._deprecatedHandler = o2, this.cleanHistory();
  }
  cleanHistory() {
    this._hasDeprecationWarned = ca$1.createAutoChecklist();
  }
  normalize(e20) {
    const t2 = {}, n2 = [e20], r2 = () => {
      for (; n2.length !== 0; ) {
        const e21 = n2.shift(), r3 = this._applyNormalization(e21, t2);
        n2.push(...r3);
      }
    };
    r2();
    for (const e21 of Object.keys(this._utils.schemas)) {
      const r3 = this._utils.schemas[e21];
      if (!(e21 in t2)) {
        const t3 = ca$1.normalizeDefaultResult(r3.default(this._utils));
        "value" in t3 && n2.push({ [e21]: t3.value });
      }
    }
    r2();
    for (const e21 of Object.keys(this._utils.schemas)) {
      const n3 = this._utils.schemas[e21];
      e21 in t2 && (t2[e21] = n3.postprocess(t2[e21], this._utils));
    }
    return t2;
  }
  _applyNormalization(e20, t2) {
    const n2 = [], [r2, i2] = ca$1.partition(Object.keys(e20), (e21) => e21 in this._utils.schemas);
    for (const i3 of r2) {
      const r3 = this._utils.schemas[i3], u2 = r3.preprocess(e20[i3], this._utils), o2 = ca$1.normalizeValidateResult(r3.validate(u2, this._utils), u2);
      if (o2 !== true) {
        const { value: e21 } = o2, t3 = this._invalidHandler(i3, e21, this._utils);
        throw typeof t3 == "string" ? new Error(t3) : t3;
      }
      const s2 = ({ from: e21, to: t3 }) => {
        n2.push(typeof t3 == "string" ? { [t3]: e21 } : { [t3.key]: t3.value });
      }, a2 = ({ value: e21, redirectTo: t3 }) => {
        const n3 = ca$1.normalizeDeprecatedResult(r3.deprecated(e21, this._utils), u2, true);
        if (n3 !== false)
          if (n3 === true)
            this._hasDeprecationWarned(i3) || this._utils.logger.warn(this._deprecatedHandler(i3, t3, this._utils));
          else
            for (const { value: e22 } of n3) {
              const n4 = { key: i3, value: e22 };
              if (!this._hasDeprecationWarned(n4)) {
                const r4 = typeof t3 == "string" ? { key: t3, value: e22 } : t3;
                this._utils.logger.warn(this._deprecatedHandler(n4, r4, this._utils));
              }
            }
      };
      ca$1.normalizeForwardResult(r3.forward(u2, this._utils), u2).forEach(s2);
      const c2 = ca$1.normalizeRedirectResult(r3.redirect(u2, this._utils), u2);
      if (c2.redirect.forEach(s2), "remain" in c2) {
        const e21 = c2.remain;
        t2[i3] = i3 in t2 ? r3.overlap(t2[i3], e21, this._utils) : e21, a2({ value: e21 });
      }
      for (const { from: e21, to: t3 } of c2.redirect)
        a2({ value: e21, redirectTo: t3 });
    }
    for (const r3 of i2) {
      const i3 = e20[r3], u2 = this._unknownHandler(r3, i3, this._utils);
      if (u2)
        for (const e21 of Object.keys(u2)) {
          const r4 = { [e21]: u2[e21] };
          e21 in this._utils.schemas ? n2.push(r4) : Object.assign(t2, r4);
        }
    }
    return n2;
  }
}
var Ba$1 = Ta$1, Na$1 = Object.defineProperty({
  normalize: (e20, t2, n2) => new Ta$1(t2, n2).normalize(e20),
  Normalizer: Ba$1
}, "__esModule", { value: true }), ka$1 = r$3(function(e20, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), wo$2.__exportStar(Bo$2, t2), wo$2.__exportStar(Ts$2, t2), wo$2.__exportStar(Aa$1, t2), wo$2.__exportStar(Na$1, t2), wo$2.__exportStar(Ls$2, t2);
});
const Pa$1 = [], Oa$1 = [], Ia$1 = (e20, t2) => {
  if (e20 === t2)
    return 0;
  const n2 = e20;
  e20.length > t2.length && (e20 = t2, t2 = n2);
  let r2 = e20.length, i2 = t2.length;
  for (; r2 > 0 && e20.charCodeAt(~-r2) === t2.charCodeAt(~-i2); )
    r2--, i2--;
  let u2, o2, s2, a2, c2 = 0;
  for (; c2 < r2 && e20.charCodeAt(c2) === t2.charCodeAt(c2); )
    c2++;
  if (r2 -= c2, i2 -= c2, r2 === 0)
    return i2;
  let l2 = 0, p2 = 0;
  for (; l2 < r2; )
    Oa$1[l2] = e20.charCodeAt(c2 + l2), Pa$1[l2] = ++l2;
  for (; p2 < i2; )
    for (u2 = t2.charCodeAt(c2 + p2), s2 = p2++, o2 = p2, l2 = 0; l2 < r2; l2++)
      a2 = u2 === Oa$1[l2] ? s2 : s2 + 1, s2 = Pa$1[l2], o2 = Pa$1[l2] = s2 > o2 ? a2 > o2 ? o2 + 1 : a2 : a2 > s2 ? s2 + 1 : a2;
  return o2;
};
var La$1 = Ia$1, ja$1 = Ia$1;
La$1.default = ja$1;
var _a$1$1 = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};
const Ma$1 = {};
for (const e20 of Object.keys(_a$1$1))
  Ma$1[_a$1$1[e20]] = e20;
const Ra$1 = {
  rgb: { channels: 3, labels: "rgb" },
  hsl: { channels: 3, labels: "hsl" },
  hsv: { channels: 3, labels: "hsv" },
  hwb: { channels: 3, labels: "hwb" },
  cmyk: { channels: 4, labels: "cmyk" },
  xyz: { channels: 3, labels: "xyz" },
  lab: { channels: 3, labels: "lab" },
  lch: { channels: 3, labels: "lch" },
  hex: { channels: 1, labels: ["hex"] },
  keyword: { channels: 1, labels: ["keyword"] },
  ansi16: { channels: 1, labels: ["ansi16"] },
  ansi256: { channels: 1, labels: ["ansi256"] },
  hcg: { channels: 3, labels: ["h", "c", "g"] },
  apple: { channels: 3, labels: ["r16", "g16", "b16"] },
  gray: { channels: 1, labels: ["gray"] }
};
var $a$1 = Ra$1;
for (const e20 of Object.keys(Ra$1)) {
  if (!("channels" in Ra$1[e20]))
    throw new Error("missing channels property: " + e20);
  if (!("labels" in Ra$1[e20]))
    throw new Error("missing channel labels property: " + e20);
  if (Ra$1[e20].labels.length !== Ra$1[e20].channels)
    throw new Error("channel and label counts mismatch: " + e20);
  const { channels: t2, labels: n2 } = Ra$1[e20];
  delete Ra$1[e20].channels, delete Ra$1[e20].labels, Object.defineProperty(Ra$1[e20], "channels", { value: t2 }), Object.defineProperty(Ra$1[e20], "labels", { value: n2 });
}
function Va$1(e20) {
  const t2 = function() {
    const e21 = {}, t3 = Object.keys($a$1);
    for (let n3 = t3.length, r2 = 0; r2 < n3; r2++)
      e21[t3[r2]] = { distance: -1, parent: null };
    return e21;
  }(), n2 = [e20];
  for (t2[e20].distance = 0; n2.length; ) {
    const e21 = n2.pop(), r2 = Object.keys($a$1[e21]);
    for (let i2 = r2.length, u2 = 0; u2 < i2; u2++) {
      const i3 = r2[u2], o2 = t2[i3];
      o2.distance === -1 && (o2.distance = t2[e21].distance + 1, o2.parent = e21, n2.unshift(i3));
    }
  }
  return t2;
}
function Wa$1(e20, t2) {
  return function(n2) {
    return t2(e20(n2));
  };
}
function qa$1(e20, t2) {
  const n2 = [t2[e20].parent, e20];
  let r2 = $a$1[t2[e20].parent][e20], i2 = t2[e20].parent;
  for (; t2[i2].parent; )
    n2.unshift(t2[i2].parent), r2 = Wa$1($a$1[t2[i2].parent][i2], r2), i2 = t2[i2].parent;
  return r2.conversion = n2, r2;
}
Ra$1.rgb.hsl = function(e20) {
  const t2 = e20[0] / 255, n2 = e20[1] / 255, r2 = e20[2] / 255, i2 = Math.min(t2, n2, r2), u2 = Math.max(t2, n2, r2), o2 = u2 - i2;
  let s2, a2;
  u2 === i2 ? s2 = 0 : t2 === u2 ? s2 = (n2 - r2) / o2 : n2 === u2 ? s2 = 2 + (r2 - t2) / o2 : r2 === u2 && (s2 = 4 + (t2 - n2) / o2), s2 = Math.min(60 * s2, 360), s2 < 0 && (s2 += 360);
  const c2 = (i2 + u2) / 2;
  return a2 = u2 === i2 ? 0 : c2 <= 0.5 ? o2 / (u2 + i2) : o2 / (2 - u2 - i2), [s2, 100 * a2, 100 * c2];
}, Ra$1.rgb.hsv = function(e20) {
  let t2, n2, r2, i2, u2;
  const o2 = e20[0] / 255, s2 = e20[1] / 255, a2 = e20[2] / 255, c2 = Math.max(o2, s2, a2), l2 = c2 - Math.min(o2, s2, a2), p2 = function(e21) {
    return (c2 - e21) / 6 / l2 + 0.5;
  };
  return l2 === 0 ? (i2 = 0, u2 = 0) : (u2 = l2 / c2, t2 = p2(o2), n2 = p2(s2), r2 = p2(a2), o2 === c2 ? i2 = r2 - n2 : s2 === c2 ? i2 = 1 / 3 + t2 - r2 : a2 === c2 && (i2 = 2 / 3 + n2 - t2), i2 < 0 ? i2 += 1 : i2 > 1 && (i2 -= 1)), [360 * i2, 100 * u2, 100 * c2];
}, Ra$1.rgb.hwb = function(e20) {
  const t2 = e20[0], n2 = e20[1];
  let r2 = e20[2];
  const i2 = Ra$1.rgb.hsl(e20)[0], u2 = 1 / 255 * Math.min(t2, Math.min(n2, r2));
  return r2 = 1 - 1 / 255 * Math.max(t2, Math.max(n2, r2)), [i2, 100 * u2, 100 * r2];
}, Ra$1.rgb.cmyk = function(e20) {
  const t2 = e20[0] / 255, n2 = e20[1] / 255, r2 = e20[2] / 255, i2 = Math.min(1 - t2, 1 - n2, 1 - r2);
  return [
    100 * ((1 - t2 - i2) / (1 - i2) || 0),
    100 * ((1 - n2 - i2) / (1 - i2) || 0),
    100 * ((1 - r2 - i2) / (1 - i2) || 0),
    100 * i2
  ];
}, Ra$1.rgb.keyword = function(e20) {
  const t2 = Ma$1[e20];
  if (t2)
    return t2;
  let n2, r2 = 1 / 0;
  for (const t3 of Object.keys(_a$1$1)) {
    const o2 = (u2 = _a$1$1[t3], ((i2 = e20)[0] - u2[0]) ** 2 + (i2[1] - u2[1]) ** 2 + (i2[2] - u2[2]) ** 2);
    o2 < r2 && (r2 = o2, n2 = t3);
  }
  var i2, u2;
  return n2;
}, Ra$1.keyword.rgb = function(e20) {
  return _a$1$1[e20];
}, Ra$1.rgb.xyz = function(e20) {
  let t2 = e20[0] / 255, n2 = e20[1] / 255, r2 = e20[2] / 255;
  t2 = t2 > 0.04045 ? ((t2 + 0.055) / 1.055) ** 2.4 : t2 / 12.92, n2 = n2 > 0.04045 ? ((n2 + 0.055) / 1.055) ** 2.4 : n2 / 12.92, r2 = r2 > 0.04045 ? ((r2 + 0.055) / 1.055) ** 2.4 : r2 / 12.92;
  return [
    100 * (0.4124 * t2 + 0.3576 * n2 + 0.1805 * r2),
    100 * (0.2126 * t2 + 0.7152 * n2 + 0.0722 * r2),
    100 * (0.0193 * t2 + 0.1192 * n2 + 0.9505 * r2)
  ];
}, Ra$1.rgb.lab = function(e20) {
  const t2 = Ra$1.rgb.xyz(e20);
  let n2 = t2[0], r2 = t2[1], i2 = t2[2];
  n2 /= 95.047, r2 /= 100, i2 /= 108.883, n2 = n2 > 8856e-6 ? n2 ** (1 / 3) : 7.787 * n2 + 16 / 116, r2 = r2 > 8856e-6 ? r2 ** (1 / 3) : 7.787 * r2 + 16 / 116, i2 = i2 > 8856e-6 ? i2 ** (1 / 3) : 7.787 * i2 + 16 / 116;
  return [116 * r2 - 16, 500 * (n2 - r2), 200 * (r2 - i2)];
}, Ra$1.hsl.rgb = function(e20) {
  const t2 = e20[0] / 360, n2 = e20[1] / 100, r2 = e20[2] / 100;
  let i2, u2, o2;
  if (n2 === 0)
    return o2 = 255 * r2, [o2, o2, o2];
  i2 = r2 < 0.5 ? r2 * (1 + n2) : r2 + n2 - r2 * n2;
  const s2 = 2 * r2 - i2, a2 = [0, 0, 0];
  for (let e21 = 0; e21 < 3; e21++)
    u2 = t2 + 1 / 3 * -(e21 - 1), u2 < 0 && u2++, u2 > 1 && u2--, o2 = 6 * u2 < 1 ? s2 + 6 * (i2 - s2) * u2 : 2 * u2 < 1 ? i2 : 3 * u2 < 2 ? s2 + (i2 - s2) * (2 / 3 - u2) * 6 : s2, a2[e21] = 255 * o2;
  return a2;
}, Ra$1.hsl.hsv = function(e20) {
  const t2 = e20[0];
  let n2 = e20[1] / 100, r2 = e20[2] / 100, i2 = n2;
  const u2 = Math.max(r2, 0.01);
  r2 *= 2, n2 *= r2 <= 1 ? r2 : 2 - r2, i2 *= u2 <= 1 ? u2 : 2 - u2;
  return [
    t2,
    100 * (r2 === 0 ? 2 * i2 / (u2 + i2) : 2 * n2 / (r2 + n2)),
    100 * ((r2 + n2) / 2)
  ];
}, Ra$1.hsv.rgb = function(e20) {
  const t2 = e20[0] / 60, n2 = e20[1] / 100;
  let r2 = e20[2] / 100;
  const i2 = Math.floor(t2) % 6, u2 = t2 - Math.floor(t2), o2 = 255 * r2 * (1 - n2), s2 = 255 * r2 * (1 - n2 * u2), a2 = 255 * r2 * (1 - n2 * (1 - u2));
  switch (r2 *= 255, i2) {
    case 0:
      return [r2, a2, o2];
    case 1:
      return [s2, r2, o2];
    case 2:
      return [o2, r2, a2];
    case 3:
      return [o2, s2, r2];
    case 4:
      return [a2, o2, r2];
    case 5:
      return [r2, o2, s2];
  }
}, Ra$1.hsv.hsl = function(e20) {
  const t2 = e20[0], n2 = e20[1] / 100, r2 = e20[2] / 100, i2 = Math.max(r2, 0.01);
  let u2, o2;
  o2 = (2 - n2) * r2;
  const s2 = (2 - n2) * i2;
  return u2 = n2 * i2, u2 /= s2 <= 1 ? s2 : 2 - s2, u2 = u2 || 0, o2 /= 2, [t2, 100 * u2, 100 * o2];
}, Ra$1.hwb.rgb = function(e20) {
  const t2 = e20[0] / 360;
  let n2 = e20[1] / 100, r2 = e20[2] / 100;
  const i2 = n2 + r2;
  let u2;
  i2 > 1 && (n2 /= i2, r2 /= i2);
  const o2 = Math.floor(6 * t2), s2 = 1 - r2;
  u2 = 6 * t2 - o2, (1 & o2) != 0 && (u2 = 1 - u2);
  const a2 = n2 + u2 * (s2 - n2);
  let c2, l2, p2;
  switch (o2) {
    default:
    case 6:
    case 0:
      c2 = s2, l2 = a2, p2 = n2;
      break;
    case 1:
      c2 = a2, l2 = s2, p2 = n2;
      break;
    case 2:
      c2 = n2, l2 = s2, p2 = a2;
      break;
    case 3:
      c2 = n2, l2 = a2, p2 = s2;
      break;
    case 4:
      c2 = a2, l2 = n2, p2 = s2;
      break;
    case 5:
      c2 = s2, l2 = n2, p2 = a2;
  }
  return [255 * c2, 255 * l2, 255 * p2];
}, Ra$1.cmyk.rgb = function(e20) {
  const t2 = e20[0] / 100, n2 = e20[1] / 100, r2 = e20[2] / 100, i2 = e20[3] / 100;
  return [
    255 * (1 - Math.min(1, t2 * (1 - i2) + i2)),
    255 * (1 - Math.min(1, n2 * (1 - i2) + i2)),
    255 * (1 - Math.min(1, r2 * (1 - i2) + i2))
  ];
}, Ra$1.xyz.rgb = function(e20) {
  const t2 = e20[0] / 100, n2 = e20[1] / 100, r2 = e20[2] / 100;
  let i2, u2, o2;
  return i2 = 3.2406 * t2 + -1.5372 * n2 + -0.4986 * r2, u2 = -0.9689 * t2 + 1.8758 * n2 + 0.0415 * r2, o2 = 0.0557 * t2 + -0.204 * n2 + 1.057 * r2, i2 = i2 > 31308e-7 ? 1.055 * i2 ** (1 / 2.4) - 0.055 : 12.92 * i2, u2 = u2 > 31308e-7 ? 1.055 * u2 ** (1 / 2.4) - 0.055 : 12.92 * u2, o2 = o2 > 31308e-7 ? 1.055 * o2 ** (1 / 2.4) - 0.055 : 12.92 * o2, i2 = Math.min(Math.max(0, i2), 1), u2 = Math.min(Math.max(0, u2), 1), o2 = Math.min(Math.max(0, o2), 1), [255 * i2, 255 * u2, 255 * o2];
}, Ra$1.xyz.lab = function(e20) {
  let t2 = e20[0], n2 = e20[1], r2 = e20[2];
  t2 /= 95.047, n2 /= 100, r2 /= 108.883, t2 = t2 > 8856e-6 ? t2 ** (1 / 3) : 7.787 * t2 + 16 / 116, n2 = n2 > 8856e-6 ? n2 ** (1 / 3) : 7.787 * n2 + 16 / 116, r2 = r2 > 8856e-6 ? r2 ** (1 / 3) : 7.787 * r2 + 16 / 116;
  return [116 * n2 - 16, 500 * (t2 - n2), 200 * (n2 - r2)];
}, Ra$1.lab.xyz = function(e20) {
  let t2, n2, r2;
  n2 = (e20[0] + 16) / 116, t2 = e20[1] / 500 + n2, r2 = n2 - e20[2] / 200;
  const i2 = n2 ** 3, u2 = t2 ** 3, o2 = r2 ** 3;
  return n2 = i2 > 8856e-6 ? i2 : (n2 - 16 / 116) / 7.787, t2 = u2 > 8856e-6 ? u2 : (t2 - 16 / 116) / 7.787, r2 = o2 > 8856e-6 ? o2 : (r2 - 16 / 116) / 7.787, t2 *= 95.047, n2 *= 100, r2 *= 108.883, [t2, n2, r2];
}, Ra$1.lab.lch = function(e20) {
  const t2 = e20[0], n2 = e20[1], r2 = e20[2];
  let i2;
  i2 = 360 * Math.atan2(r2, n2) / 2 / Math.PI, i2 < 0 && (i2 += 360);
  return [t2, Math.sqrt(n2 * n2 + r2 * r2), i2];
}, Ra$1.lch.lab = function(e20) {
  const t2 = e20[0], n2 = e20[1], r2 = e20[2] / 360 * 2 * Math.PI;
  return [t2, n2 * Math.cos(r2), n2 * Math.sin(r2)];
}, Ra$1.rgb.ansi16 = function(e20, t2 = null) {
  const [n2, r2, i2] = e20;
  let u2 = t2 === null ? Ra$1.rgb.hsv(e20)[2] : t2;
  if (u2 = Math.round(u2 / 50), u2 === 0)
    return 30;
  let o2 = 30 + (Math.round(i2 / 255) << 2 | Math.round(r2 / 255) << 1 | Math.round(n2 / 255));
  return u2 === 2 && (o2 += 60), o2;
}, Ra$1.hsv.ansi16 = function(e20) {
  return Ra$1.rgb.ansi16(Ra$1.hsv.rgb(e20), e20[2]);
}, Ra$1.rgb.ansi256 = function(e20) {
  const t2 = e20[0], n2 = e20[1], r2 = e20[2];
  if (t2 === n2 && n2 === r2)
    return t2 < 8 ? 16 : t2 > 248 ? 231 : Math.round((t2 - 8) / 247 * 24) + 232;
  return 16 + 36 * Math.round(t2 / 255 * 5) + 6 * Math.round(n2 / 255 * 5) + Math.round(r2 / 255 * 5);
}, Ra$1.ansi16.rgb = function(e20) {
  let t2 = e20 % 10;
  if (t2 === 0 || t2 === 7)
    return e20 > 50 && (t2 += 3.5), t2 = t2 / 10.5 * 255, [t2, t2, t2];
  const n2 = 0.5 * (1 + ~~(e20 > 50));
  return [
    (1 & t2) * n2 * 255,
    (t2 >> 1 & 1) * n2 * 255,
    (t2 >> 2 & 1) * n2 * 255
  ];
}, Ra$1.ansi256.rgb = function(e20) {
  if (e20 >= 232) {
    const t3 = 10 * (e20 - 232) + 8;
    return [t3, t3, t3];
  }
  let t2;
  e20 -= 16;
  return [
    Math.floor(e20 / 36) / 5 * 255,
    Math.floor((t2 = e20 % 36) / 6) / 5 * 255,
    t2 % 6 / 5 * 255
  ];
}, Ra$1.rgb.hex = function(e20) {
  const t2 = (((255 & Math.round(e20[0])) << 16) + ((255 & Math.round(e20[1])) << 8) + (255 & Math.round(e20[2]))).toString(16).toUpperCase();
  return "000000".substring(t2.length) + t2;
}, Ra$1.hex.rgb = function(e20) {
  const t2 = e20.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
  if (!t2)
    return [0, 0, 0];
  let n2 = t2[0];
  t2[0].length === 3 && (n2 = n2.split("").map((e21) => e21 + e21).join(""));
  const r2 = parseInt(n2, 16);
  return [r2 >> 16 & 255, r2 >> 8 & 255, 255 & r2];
}, Ra$1.rgb.hcg = function(e20) {
  const t2 = e20[0] / 255, n2 = e20[1] / 255, r2 = e20[2] / 255, i2 = Math.max(Math.max(t2, n2), r2), u2 = Math.min(Math.min(t2, n2), r2), o2 = i2 - u2;
  let s2, a2;
  return s2 = o2 < 1 ? u2 / (1 - o2) : 0, a2 = o2 <= 0 ? 0 : i2 === t2 ? (n2 - r2) / o2 % 6 : i2 === n2 ? 2 + (r2 - t2) / o2 : 4 + (t2 - n2) / o2, a2 /= 6, a2 %= 1, [360 * a2, 100 * o2, 100 * s2];
}, Ra$1.hsl.hcg = function(e20) {
  const t2 = e20[1] / 100, n2 = e20[2] / 100, r2 = n2 < 0.5 ? 2 * t2 * n2 : 2 * t2 * (1 - n2);
  let i2 = 0;
  return r2 < 1 && (i2 = (n2 - 0.5 * r2) / (1 - r2)), [e20[0], 100 * r2, 100 * i2];
}, Ra$1.hsv.hcg = function(e20) {
  const t2 = e20[1] / 100, n2 = e20[2] / 100, r2 = t2 * n2;
  let i2 = 0;
  return r2 < 1 && (i2 = (n2 - r2) / (1 - r2)), [e20[0], 100 * r2, 100 * i2];
}, Ra$1.hcg.rgb = function(e20) {
  const t2 = e20[0] / 360, n2 = e20[1] / 100, r2 = e20[2] / 100;
  if (n2 === 0)
    return [255 * r2, 255 * r2, 255 * r2];
  const i2 = [0, 0, 0], u2 = t2 % 1 * 6, o2 = u2 % 1, s2 = 1 - o2;
  let a2 = 0;
  switch (Math.floor(u2)) {
    case 0:
      i2[0] = 1, i2[1] = o2, i2[2] = 0;
      break;
    case 1:
      i2[0] = s2, i2[1] = 1, i2[2] = 0;
      break;
    case 2:
      i2[0] = 0, i2[1] = 1, i2[2] = o2;
      break;
    case 3:
      i2[0] = 0, i2[1] = s2, i2[2] = 1;
      break;
    case 4:
      i2[0] = o2, i2[1] = 0, i2[2] = 1;
      break;
    default:
      i2[0] = 1, i2[1] = 0, i2[2] = s2;
  }
  return a2 = (1 - n2) * r2, [255 * (n2 * i2[0] + a2), 255 * (n2 * i2[1] + a2), 255 * (n2 * i2[2] + a2)];
}, Ra$1.hcg.hsv = function(e20) {
  const t2 = e20[1] / 100, n2 = t2 + e20[2] / 100 * (1 - t2);
  let r2 = 0;
  return n2 > 0 && (r2 = t2 / n2), [e20[0], 100 * r2, 100 * n2];
}, Ra$1.hcg.hsl = function(e20) {
  const t2 = e20[1] / 100, n2 = e20[2] / 100 * (1 - t2) + 0.5 * t2;
  let r2 = 0;
  return n2 > 0 && n2 < 0.5 ? r2 = t2 / (2 * n2) : n2 >= 0.5 && n2 < 1 && (r2 = t2 / (2 * (1 - n2))), [e20[0], 100 * r2, 100 * n2];
}, Ra$1.hcg.hwb = function(e20) {
  const t2 = e20[1] / 100, n2 = t2 + e20[2] / 100 * (1 - t2);
  return [e20[0], 100 * (n2 - t2), 100 * (1 - n2)];
}, Ra$1.hwb.hcg = function(e20) {
  const t2 = e20[1] / 100, n2 = 1 - e20[2] / 100, r2 = n2 - t2;
  let i2 = 0;
  return r2 < 1 && (i2 = (n2 - r2) / (1 - r2)), [e20[0], 100 * r2, 100 * i2];
}, Ra$1.apple.rgb = function(e20) {
  return [
    e20[0] / 65535 * 255,
    e20[1] / 65535 * 255,
    e20[2] / 65535 * 255
  ];
}, Ra$1.rgb.apple = function(e20) {
  return [
    e20[0] / 255 * 65535,
    e20[1] / 255 * 65535,
    e20[2] / 255 * 65535
  ];
}, Ra$1.gray.rgb = function(e20) {
  return [e20[0] / 100 * 255, e20[0] / 100 * 255, e20[0] / 100 * 255];
}, Ra$1.gray.hsl = function(e20) {
  return [0, 0, e20[0]];
}, Ra$1.gray.hsv = Ra$1.gray.hsl, Ra$1.gray.hwb = function(e20) {
  return [0, 100, e20[0]];
}, Ra$1.gray.cmyk = function(e20) {
  return [0, 0, 0, e20[0]];
}, Ra$1.gray.lab = function(e20) {
  return [e20[0], 0, 0];
}, Ra$1.gray.hex = function(e20) {
  const t2 = 255 & Math.round(e20[0] / 100 * 255), n2 = ((t2 << 16) + (t2 << 8) + t2).toString(16).toUpperCase();
  return "000000".substring(n2.length) + n2;
}, Ra$1.rgb.gray = function(e20) {
  return [(e20[0] + e20[1] + e20[2]) / 3 / 255 * 100];
};
const Ua$1 = {};
Object.keys($a$1).forEach((e20) => {
  Ua$1[e20] = {}, Object.defineProperty(Ua$1[e20], "channels", { value: $a$1[e20].channels }), Object.defineProperty(Ua$1[e20], "labels", { value: $a$1[e20].labels });
  const t2 = function(e21) {
    const t3 = Va$1(e21), n2 = {}, r2 = Object.keys(t3);
    for (let e22 = r2.length, i2 = 0; i2 < e22; i2++) {
      const e23 = r2[i2];
      t3[e23].parent !== null && (n2[e23] = qa$1(e23, t3));
    }
    return n2;
  }(e20);
  Object.keys(t2).forEach((n2) => {
    const r2 = t2[n2];
    Ua$1[e20][n2] = function(e21) {
      const t3 = function(...t4) {
        const n3 = t4[0];
        if (n3 == null)
          return n3;
        n3.length > 1 && (t4 = n3);
        const r3 = e21(t4);
        if (typeof r3 == "object")
          for (let e22 = r3.length, t5 = 0; t5 < e22; t5++)
            r3[t5] = Math.round(r3[t5]);
        return r3;
      };
      return "conversion" in e21 && (t3.conversion = e21.conversion), t3;
    }(r2), Ua$1[e20][n2].raw = function(e21) {
      const t3 = function(...t4) {
        const n3 = t4[0];
        return n3 == null ? n3 : (n3.length > 1 && (t4 = n3), e21(t4));
      };
      return "conversion" in e21 && (t3.conversion = e21.conversion), t3;
    }(r2);
  });
});
var za$1 = Ua$1, Ga$1 = r$3(function(e20) {
  const t2 = (e21, t3) => (...n3) => `[${e21(...n3) + t3}m`, n2 = (e21, t3) => (...n3) => {
    const r3 = e21(...n3);
    return `[${38 + t3};5;${r3}m`;
  }, r2 = (e21, t3) => (...n3) => {
    const r3 = e21(...n3);
    return `[${38 + t3};2;${r3[0]};${r3[1]};${r3[2]}m`;
  }, i2 = (e21) => e21, u2 = (e21, t3, n3) => [e21, t3, n3], o2 = (e21, t3, n3) => {
    Object.defineProperty(e21, t3, {
      get: () => {
        const r3 = n3();
        return Object.defineProperty(e21, t3, {
          value: r3,
          enumerable: true,
          configurable: true
        }), r3;
      },
      enumerable: true,
      configurable: true
    });
  };
  let s2;
  const a2 = (e21, t3, n3, r3) => {
    s2 === void 0 && (s2 = za$1);
    const i3 = r3 ? 10 : 0, u3 = {};
    for (const [r4, o3] of Object.entries(s2)) {
      const s3 = r4 === "ansi16" ? "ansi" : r4;
      r4 === t3 ? u3[s3] = e21(n3, i3) : typeof o3 == "object" && (u3[s3] = e21(o3[t3], i3));
    }
    return u3;
  };
  Object.defineProperty(e20, "exports", {
    enumerable: true,
    get: function() {
      const e21 = new Map(), s3 = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      s3.color.gray = s3.color.blackBright, s3.bgColor.bgGray = s3.bgColor.bgBlackBright, s3.color.grey = s3.color.blackBright, s3.bgColor.bgGrey = s3.bgColor.bgBlackBright;
      for (const [t3, n3] of Object.entries(s3)) {
        for (const [t4, r3] of Object.entries(n3))
          s3[t4] = {
            open: `[${r3[0]}m`,
            close: `[${r3[1]}m`
          }, n3[t4] = s3[t4], e21.set(r3[0], r3[1]);
        Object.defineProperty(s3, t3, { value: n3, enumerable: false });
      }
      return Object.defineProperty(s3, "codes", {
        value: e21,
        enumerable: false
      }), s3.color.close = "[39m", s3.bgColor.close = "[49m", o2(s3.color, "ansi", () => a2(t2, "ansi16", i2, false)), o2(s3.color, "ansi256", () => a2(n2, "ansi256", i2, false)), o2(s3.color, "ansi16m", () => a2(r2, "rgb", u2, false)), o2(s3.bgColor, "ansi", () => a2(t2, "ansi16", i2, true)), o2(s3.bgColor, "ansi256", () => a2(n2, "ansi256", i2, true)), o2(s3.bgColor, "ansi16m", () => a2(r2, "rgb", u2, true)), s3;
    }
  });
});
function Ha$1() {
  return false;
}
function Ja$1() {
  throw new Error("tty.ReadStream is not implemented");
}
function Xa$1() {
  throw new Error("tty.ReadStream is not implemented");
}
var Ya$1 = { isatty: Ha$1, ReadStream: Ja$1, WriteStream: Xa$1 }, Ka$1 = (e20, t2 = xr$2.argv) => {
  const n2 = e20.startsWith("-") ? "" : e20.length === 1 ? "-" : "--", r2 = t2.indexOf(n2 + e20), i2 = t2.indexOf("--");
  return r2 !== -1 && (i2 === -1 || r2 < i2);
}, Qa$1 = n$3(Object.freeze({
  __proto__: null,
  isatty: Ha$1,
  ReadStream: Ja$1,
  WriteStream: Xa$1,
  default: Ya$1
}));
const { env: Za$1 } = xr$2;
let ec;
function tc(e20) {
  return e20 !== 0 && { level: e20, hasBasic: true, has256: e20 >= 2, has16m: e20 >= 3 };
}
function nc(e20, t2) {
  if (ec === 0)
    return 0;
  if (Ka$1("color=16m") || Ka$1("color=full") || Ka$1("color=truecolor"))
    return 3;
  if (Ka$1("color=256"))
    return 2;
  if (e20 && !t2 && ec === void 0)
    return 0;
  const n2 = ec || 0;
  if (Za$1.TERM === "dumb")
    return n2;
  if ("CI" in Za$1)
    return [
      "TRAVIS",
      "CIRCLECI",
      "APPVEYOR",
      "GITLAB_CI",
      "GITHUB_ACTIONS",
      "BUILDKITE"
    ].some((e21) => e21 in Za$1) || Za$1.CI_NAME === "codeship" ? 1 : n2;
  if ("TEAMCITY_VERSION" in Za$1)
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Za$1.TEAMCITY_VERSION) ? 1 : 0;
  if (Za$1.COLORTERM === "truecolor")
    return 3;
  if ("TERM_PROGRAM" in Za$1) {
    const e21 = parseInt((Za$1.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (Za$1.TERM_PROGRAM) {
      case "iTerm.app":
        return e21 >= 3 ? 3 : 2;
      case "Apple_Terminal":
        return 2;
    }
  }
  return /-256(color)?$/i.test(Za$1.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Za$1.TERM) || "COLORTERM" in Za$1 ? 1 : n2;
}
Ka$1("no-color") || Ka$1("no-colors") || Ka$1("color=false") || Ka$1("color=never") ? ec = 0 : (Ka$1("color") || Ka$1("colors") || Ka$1("color=true") || Ka$1("color=always")) && (ec = 1), "FORCE_COLOR" in Za$1 && (ec = Za$1.FORCE_COLOR === "true" ? 1 : Za$1.FORCE_COLOR === "false" ? 0 : Za$1.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(Za$1.FORCE_COLOR, 10), 3));
var rc = {
  supportsColor: function(e20) {
    return tc(nc(e20, e20 && e20.isTTY));
  },
  stdout: tc(nc(true, Qa$1.isatty(1))),
  stderr: tc(nc(true, Qa$1.isatty(2)))
};
var ic = {
  stringReplaceAll: (e20, t2, n2) => {
    let r2 = e20.indexOf(t2);
    if (r2 === -1)
      return e20;
    const i2 = t2.length;
    let u2 = 0, o2 = "";
    do {
      o2 += e20.substr(u2, r2 - u2) + t2 + n2, u2 = r2 + i2, r2 = e20.indexOf(t2, u2);
    } while (r2 !== -1);
    return o2 += e20.substr(u2), o2;
  },
  stringEncaseCRLFWithFirstIndex: (e20, t2, n2, r2) => {
    let i2 = 0, u2 = "";
    do {
      const o2 = e20[r2 - 1] === "\r";
      u2 += e20.substr(i2, (o2 ? r2 - 1 : r2) - i2) + t2 + (o2 ? "\r\n" : "\n") + n2, i2 = r2 + 1, r2 = e20.indexOf("\n", i2);
    } while (r2 !== -1);
    return u2 += e20.substr(i2), u2;
  }
};
const uc = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, oc = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, sc = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, ac = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi, cc = new Map([
  ["n", "\n"],
  ["r", "\r"],
  ["t", "	"],
  ["b", "\b"],
  ["f", "\f"],
  ["v", "\v"],
  ["0", "\0"],
  ["\\", "\\"],
  ["e", ""],
  ["a", "\x07"]
]);
function lc(e20) {
  const t2 = e20[0] === "u", n2 = e20[1] === "{";
  return t2 && !n2 && e20.length === 5 || e20[0] === "x" && e20.length === 3 ? String.fromCharCode(parseInt(e20.slice(1), 16)) : t2 && n2 ? String.fromCodePoint(parseInt(e20.slice(2, -1), 16)) : cc.get(e20) || e20;
}
function pc(e20, t2) {
  const n2 = [], r2 = t2.trim().split(/\s*,\s*/g);
  let i2;
  for (const t3 of r2) {
    const r3 = Number(t3);
    if (Number.isNaN(r3)) {
      if (!(i2 = t3.match(sc)))
        throw new Error(`Invalid Chalk template style argument: ${t3} (in style '${e20}')`);
      n2.push(i2[2].replace(ac, (e21, t4, n3) => t4 ? lc(t4) : n3));
    } else
      n2.push(r3);
  }
  return n2;
}
function fc(e20) {
  oc.lastIndex = 0;
  const t2 = [];
  let n2;
  for (; (n2 = oc.exec(e20)) !== null; ) {
    const e21 = n2[1];
    if (n2[2]) {
      const r2 = pc(e21, n2[2]);
      t2.push([e21].concat(r2));
    } else
      t2.push([e21]);
  }
  return t2;
}
function dc(e20, t2) {
  const n2 = {};
  for (const e21 of t2)
    for (const t3 of e21.styles)
      n2[t3[0]] = e21.inverse ? null : t3.slice(1);
  let r2 = e20;
  for (const [e21, t3] of Object.entries(n2))
    if (Array.isArray(t3)) {
      if (!(e21 in r2))
        throw new Error(`Unknown Chalk style: ${e21}`);
      r2 = t3.length > 0 ? r2[e21](...t3) : r2[e21];
    }
  return r2;
}
var hc = (e20, t2) => {
  const n2 = [], r2 = [];
  let i2 = [];
  if (t2.replace(uc, (t3, u2, o2, s2, a2, c2) => {
    if (u2)
      i2.push(lc(u2));
    else if (s2) {
      const t4 = i2.join("");
      i2 = [], r2.push(n2.length === 0 ? t4 : dc(e20, n2)(t4)), n2.push({ inverse: o2, styles: fc(s2) });
    } else if (a2) {
      if (n2.length === 0)
        throw new Error("Found extraneous } in Chalk template literal");
      r2.push(dc(e20, n2)(i2.join(""))), i2 = [], n2.pop();
    } else
      i2.push(c2);
  }), r2.push(i2.join("")), n2.length > 0) {
    const e21 = `Chalk template literal is missing ${n2.length} closing bracket${n2.length === 1 ? "" : "s"} (\`}\`)`;
    throw new Error(e21);
  }
  return r2.join("");
};
const { stdout: gc, stderr: mc } = rc, { stringReplaceAll: yc, stringEncaseCRLFWithFirstIndex: Dc } = ic, { isArray: Ec } = Array, Cc = ["ansi", "ansi", "ansi256", "ansi16m"], bc = Object.create(null);
class Ac {
  constructor(e20) {
    return vc(e20);
  }
}
const vc = (e20) => {
  const t2 = {};
  return ((e21, t3 = {}) => {
    if (t3.level && !(Number.isInteger(t3.level) && t3.level >= 0 && t3.level <= 3))
      throw new Error("The `level` option should be an integer from 0 to 3");
    const n2 = gc ? gc.level : 0;
    e21.level = t3.level === void 0 ? n2 : t3.level;
  })(t2, e20), t2.template = (...e21) => kc(t2.template, ...e21), Object.setPrototypeOf(t2, Fc.prototype), Object.setPrototypeOf(t2.template, t2), t2.template.constructor = () => {
    throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
  }, t2.template.Instance = Ac, t2.template;
};
function Fc(e20) {
  return vc(e20);
}
for (const [e20, t2] of Object.entries(Ga$1))
  bc[e20] = {
    get() {
      const n2 = Tc(this, wc(t2.open, t2.close, this._styler), this._isEmpty);
      return Object.defineProperty(this, e20, { value: n2 }), n2;
    }
  };
bc.visible = {
  get() {
    const e20 = Tc(this, this._styler, true);
    return Object.defineProperty(this, "visible", { value: e20 }), e20;
  }
};
const Sc = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
for (const e20 of Sc)
  bc[e20] = {
    get() {
      const { level: t2 } = this;
      return function(...n2) {
        const r2 = wc(Ga$1.color[Cc[t2]][e20](...n2), Ga$1.color.close, this._styler);
        return Tc(this, r2, this._isEmpty);
      };
    }
  };
for (const e20 of Sc) {
  bc["bg" + e20[0].toUpperCase() + e20.slice(1)] = {
    get() {
      const { level: t2 } = this;
      return function(...n2) {
        const r2 = wc(Ga$1.bgColor[Cc[t2]][e20](...n2), Ga$1.bgColor.close, this._styler);
        return Tc(this, r2, this._isEmpty);
      };
    }
  };
}
const xc = Object.defineProperties(() => {
}, Object.assign(Object.assign({}, bc), {}, {
  level: {
    enumerable: true,
    get() {
      return this._generator.level;
    },
    set(e20) {
      this._generator.level = e20;
    }
  }
})), wc = (e20, t2, n2) => {
  let r2, i2;
  return n2 === void 0 ? (r2 = e20, i2 = t2) : (r2 = n2.openAll + e20, i2 = t2 + n2.closeAll), { open: e20, close: t2, openAll: r2, closeAll: i2, parent: n2 };
}, Tc = (e20, t2, n2) => {
  const r2 = (...e21) => Ec(e21[0]) && Ec(e21[0].raw) ? Bc(r2, kc(r2, ...e21)) : Bc(r2, e21.length === 1 ? "" + e21[0] : e21.join(" "));
  return Object.setPrototypeOf(r2, xc), r2._generator = e20, r2._styler = t2, r2._isEmpty = n2, r2;
}, Bc = (e20, t2) => {
  if (e20.level <= 0 || !t2)
    return e20._isEmpty ? "" : t2;
  let n2 = e20._styler;
  if (n2 === void 0)
    return t2;
  const { openAll: r2, closeAll: i2 } = n2;
  if (t2.indexOf("") !== -1)
    for (; n2 !== void 0; )
      t2 = yc(t2, n2.close, n2.open), n2 = n2.parent;
  const u2 = t2.indexOf("\n");
  return u2 !== -1 && (t2 = Dc(t2, i2, r2, u2)), r2 + t2 + i2;
};
let Nc;
const kc = (e20, ...t2) => {
  const [n2] = t2;
  if (!Ec(n2) || !Ec(n2.raw))
    return t2.join(" ");
  const r2 = t2.slice(1), i2 = [n2.raw[0]];
  for (let e21 = 1; e21 < n2.length; e21++)
    i2.push(String(r2[e21 - 1]).replace(/[{}\\]/g, "\\$&"), String(n2.raw[e21]));
  return Nc === void 0 && (Nc = hc), Nc(e20, i2.join(""));
};
Object.defineProperties(Fc.prototype, bc);
const Pc = Fc();
Pc.supportsColor = gc, Pc.stderr = Fc({ level: mc ? mc.level : 0 }), Pc.stderr.supportsColor = mc;
var Oc = Pc;
const Ic = ["_"], Lc = {
  key: (e20) => e20.length === 1 ? `-${e20}` : `--${e20}`,
  value: (e20) => ka$1.apiDescriptor.value(e20),
  pair: ({ key: e20, value: t2 }) => t2 === false ? `--no-${e20}` : t2 === true ? Lc.key(e20) : t2 === "" ? `${Lc.key(e20)} without an argument` : `${Lc.key(e20)}=${t2}`
};
class jc extends ka$1.ChoiceSchema {
  constructor({ name: e20, flags: t2 }) {
    super({ name: e20, choices: t2 }), this._flags = [...t2].sort();
  }
  preprocess(e20, t2) {
    if (typeof e20 == "string" && e20.length > 0 && !this._flags.includes(e20)) {
      const n2 = this._flags.find((t3) => La$1(t3, e20) < 3);
      if (n2)
        return t2.logger.warn([
          `Unknown flag ${Oc.yellow(t2.descriptor.value(e20))},`,
          `did you mean ${Oc.blue(t2.descriptor.value(n2))}?`
        ].join(" ")), n2;
    }
    return e20;
  }
  expected() {
    return "a flag";
  }
}
let _c$3;
function Mc(e20, t2, { logger: n2, isCLI: r2 = false, passThrough: i2 = false } = {}) {
  const u2 = i2 ? Array.isArray(i2) ? (e21, t3) => i2.includes(e21) ? { [e21]: t3 } : void 0 : (e21, t3) => ({ [e21]: t3 }) : (e21, t3, n3) => {
    const r3 = jn$2(n3.schemas, Ic);
    return ka$1.levenUnknownHandler(e21, t3, Object.assign(Object.assign({}, n3), {}, { schemas: r3 }));
  }, o2 = r2 ? Lc : ka$1.apiDescriptor, s2 = function(e21, { isCLI: t3 }) {
    const n3 = [];
    t3 && n3.push(ka$1.AnySchema.create({ name: "_" }));
    for (const r3 of e21)
      n3.push(Rc(r3, { isCLI: t3, optionInfos: e21 })), r3.alias && t3 && n3.push(ka$1.AliasSchema.create({
        name: r3.alias,
        sourceName: r3.name
      }));
    return n3;
  }(t2, { isCLI: r2 }), a2 = new ka$1.Normalizer(s2, { logger: n2, unknown: u2, descriptor: o2 }), c2 = n2 !== false;
  c2 && _c$3 && (a2._hasDeprecationWarned = _c$3);
  const l2 = a2.normalize(e20);
  return c2 && (_c$3 = a2._hasDeprecationWarned), l2;
}
function Rc(e20, { isCLI: t2, optionInfos: n2 }) {
  let r2;
  const i2 = { name: e20.name }, u2 = {};
  switch (e20.type) {
    case "int":
      r2 = ka$1.IntegerSchema, t2 && (i2.preprocess = (e21) => Number(e21));
      break;
    case "string":
      r2 = ka$1.StringSchema;
      break;
    case "choice":
      r2 = ka$1.ChoiceSchema, i2.choices = e20.choices.map((t3) => typeof t3 == "object" && t3.redirect ? Object.assign(Object.assign({}, t3), {}, {
        redirect: {
          to: { key: e20.name, value: t3.redirect }
        }
      }) : t3);
      break;
    case "boolean":
      r2 = ka$1.BooleanSchema;
      break;
    case "flag":
      r2 = jc, i2.flags = n2.flatMap((e21) => [
        e21.alias,
        e21.description && e21.name,
        e21.oppositeDescription && `no-${e21.name}`
      ].filter(Boolean));
      break;
    case "path":
      r2 = ka$1.StringSchema;
      break;
    default:
      throw new Error(`Unexpected type ${e20.type}`);
  }
  if (e20.exception ? i2.validate = (t3, n3, r3) => e20.exception(t3) || n3.validate(t3, r3) : i2.validate = (e21, t3, n3) => e21 === void 0 || t3.validate(e21, n3), e20.redirect && (u2.redirect = (t3) => t3 ? {
    to: {
      key: e20.redirect.option,
      value: e20.redirect.value
    }
  } : void 0), e20.deprecated && (u2.deprecated = true), t2 && !e20.array) {
    const e21 = i2.preprocess || ((e22) => e22);
    i2.preprocess = (t3, n3, r3) => n3.preprocess(e21(Array.isArray(t3) ? Ln$2(t3) : t3), r3);
  }
  return e20.array ? ka$1.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, t2 ? {
    preprocess: (e21) => Array.isArray(e21) ? e21 : [e21]
  } : {}), u2), {}, { valueSchema: r2.create(i2) })) : r2.create(Object.assign(Object.assign({}, i2), u2));
}
var $c = {
  normalizeApiOptions: function(e20, t2, n2) {
    return Mc(e20, t2, n2);
  },
  normalizeCliOptions: function(e20, t2, n2) {
    return Mc(e20, t2, Object.assign({ isCLI: true }, n2));
  }
};
const { isNonEmptyArray: Vc } = yi$2;
function Wc(e20, t2) {
  const { ignoreDecorators: n2 } = t2 || {};
  if (!n2) {
    const t3 = e20.declaration && e20.declaration.decorators || e20.decorators;
    if (Vc(t3))
      return Wc(t3[0]);
  }
  return e20.range ? e20.range[0] : e20.start;
}
function qc(e20) {
  return e20.range ? e20.range[1] : e20.end;
}
function Uc(e20, t2) {
  return Wc(e20) === Wc(t2);
}
var zc = {
  locStart: Wc,
  locEnd: qc,
  hasSameLocStart: Uc,
  hasSameLoc: function(e20, t2) {
    return Uc(e20, t2) && function(e21, t3) {
      return qc(e21) === qc(t3);
    }(e20, t2);
  }
}, Gc = Object.defineProperty({
  default: /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g,
  matchToToken: function(e20) {
    var t2 = { type: "invalid", value: e20[0], closed: void 0 };
    return e20[1] ? (t2.type = "string", t2.closed = !(!e20[3] && !e20[4])) : e20[5] ? t2.type = "comment" : e20[6] ? (t2.type = "comment", t2.closed = !!e20[7]) : e20[8] ? t2.type = "regex" : e20[9] ? t2.type = "number" : e20[10] ? t2.type = "name" : e20[11] ? t2.type = "punctuator" : e20[12] && (t2.type = "whitespace"), t2;
  }
}, "__esModule", { value: true }), Hc = rl, Jc = il, Xc = function(e20) {
  let t2 = true;
  for (let n2 = 0; n2 < e20.length; n2++) {
    let r2 = e20.charCodeAt(n2);
    if ((64512 & r2) == 55296 && n2 + 1 < e20.length) {
      const t3 = e20.charCodeAt(++n2);
      (64512 & t3) == 56320 && (r2 = 65536 + ((1023 & r2) << 10) + (1023 & t3));
    }
    if (t2) {
      if (t2 = false, !rl(r2))
        return false;
    } else if (!il(r2))
      return false;
  }
  return !t2;
};
let Yc = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", Kc = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
const Qc = new RegExp("[" + Yc + "]"), Zc = new RegExp("[" + Yc + Kc + "]");
Yc = Kc = null;
const el = [
  0,
  11,
  2,
  25,
  2,
  18,
  2,
  1,
  2,
  14,
  3,
  13,
  35,
  122,
  70,
  52,
  268,
  28,
  4,
  48,
  48,
  31,
  14,
  29,
  6,
  37,
  11,
  29,
  3,
  35,
  5,
  7,
  2,
  4,
  43,
  157,
  19,
  35,
  5,
  35,
  5,
  39,
  9,
  51,
  157,
  310,
  10,
  21,
  11,
  7,
  153,
  5,
  3,
  0,
  2,
  43,
  2,
  1,
  4,
  0,
  3,
  22,
  11,
  22,
  10,
  30,
  66,
  18,
  2,
  1,
  11,
  21,
  11,
  25,
  71,
  55,
  7,
  1,
  65,
  0,
  16,
  3,
  2,
  2,
  2,
  28,
  43,
  28,
  4,
  28,
  36,
  7,
  2,
  27,
  28,
  53,
  11,
  21,
  11,
  18,
  14,
  17,
  111,
  72,
  56,
  50,
  14,
  50,
  14,
  35,
  349,
  41,
  7,
  1,
  79,
  28,
  11,
  0,
  9,
  21,
  107,
  20,
  28,
  22,
  13,
  52,
  76,
  44,
  33,
  24,
  27,
  35,
  30,
  0,
  3,
  0,
  9,
  34,
  4,
  0,
  13,
  47,
  15,
  3,
  22,
  0,
  2,
  0,
  36,
  17,
  2,
  24,
  85,
  6,
  2,
  0,
  2,
  3,
  2,
  14,
  2,
  9,
  8,
  46,
  39,
  7,
  3,
  1,
  3,
  21,
  2,
  6,
  2,
  1,
  2,
  4,
  4,
  0,
  19,
  0,
  13,
  4,
  159,
  52,
  19,
  3,
  21,
  2,
  31,
  47,
  21,
  1,
  2,
  0,
  185,
  46,
  42,
  3,
  37,
  47,
  21,
  0,
  60,
  42,
  14,
  0,
  72,
  26,
  230,
  43,
  117,
  63,
  32,
  7,
  3,
  0,
  3,
  7,
  2,
  1,
  2,
  23,
  16,
  0,
  2,
  0,
  95,
  7,
  3,
  38,
  17,
  0,
  2,
  0,
  29,
  0,
  11,
  39,
  8,
  0,
  22,
  0,
  12,
  45,
  20,
  0,
  35,
  56,
  264,
  8,
  2,
  36,
  18,
  0,
  50,
  29,
  113,
  6,
  2,
  1,
  2,
  37,
  22,
  0,
  26,
  5,
  2,
  1,
  2,
  31,
  15,
  0,
  328,
  18,
  190,
  0,
  80,
  921,
  103,
  110,
  18,
  195,
  2749,
  1070,
  4050,
  582,
  8634,
  568,
  8,
  30,
  114,
  29,
  19,
  47,
  17,
  3,
  32,
  20,
  6,
  18,
  689,
  63,
  129,
  74,
  6,
  0,
  67,
  12,
  65,
  1,
  2,
  0,
  29,
  6135,
  9,
  1237,
  43,
  8,
  8952,
  286,
  50,
  2,
  18,
  3,
  9,
  395,
  2309,
  106,
  6,
  12,
  4,
  8,
  8,
  9,
  5991,
  84,
  2,
  70,
  2,
  1,
  3,
  0,
  3,
  1,
  3,
  3,
  2,
  11,
  2,
  0,
  2,
  6,
  2,
  64,
  2,
  3,
  3,
  7,
  2,
  6,
  2,
  27,
  2,
  3,
  2,
  4,
  2,
  0,
  4,
  6,
  2,
  339,
  3,
  24,
  2,
  24,
  2,
  30,
  2,
  24,
  2,
  30,
  2,
  24,
  2,
  30,
  2,
  24,
  2,
  30,
  2,
  24,
  2,
  7,
  2357,
  44,
  11,
  6,
  17,
  0,
  370,
  43,
  1301,
  196,
  60,
  67,
  8,
  0,
  1205,
  3,
  2,
  26,
  2,
  1,
  2,
  0,
  3,
  0,
  2,
  9,
  2,
  3,
  2,
  0,
  2,
  0,
  7,
  0,
  5,
  0,
  2,
  0,
  2,
  0,
  2,
  2,
  2,
  1,
  2,
  0,
  3,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  1,
  2,
  0,
  3,
  3,
  2,
  6,
  2,
  3,
  2,
  3,
  2,
  0,
  2,
  9,
  2,
  16,
  6,
  2,
  2,
  4,
  2,
  16,
  4421,
  42717,
  35,
  4148,
  12,
  221,
  3,
  5761,
  15,
  7472,
  3104,
  541,
  1507,
  4938
], tl = [
  509,
  0,
  227,
  0,
  150,
  4,
  294,
  9,
  1368,
  2,
  2,
  1,
  6,
  3,
  41,
  2,
  5,
  0,
  166,
  1,
  574,
  3,
  9,
  9,
  370,
  1,
  154,
  10,
  176,
  2,
  54,
  14,
  32,
  9,
  16,
  3,
  46,
  10,
  54,
  9,
  7,
  2,
  37,
  13,
  2,
  9,
  6,
  1,
  45,
  0,
  13,
  2,
  49,
  13,
  9,
  3,
  2,
  11,
  83,
  11,
  7,
  0,
  161,
  11,
  6,
  9,
  7,
  3,
  56,
  1,
  2,
  6,
  3,
  1,
  3,
  2,
  10,
  0,
  11,
  1,
  3,
  6,
  4,
  4,
  193,
  17,
  10,
  9,
  5,
  0,
  82,
  19,
  13,
  9,
  214,
  6,
  3,
  8,
  28,
  1,
  83,
  16,
  16,
  9,
  82,
  12,
  9,
  9,
  84,
  14,
  5,
  9,
  243,
  14,
  166,
  9,
  71,
  5,
  2,
  1,
  3,
  3,
  2,
  0,
  2,
  1,
  13,
  9,
  120,
  6,
  3,
  6,
  4,
  0,
  29,
  9,
  41,
  6,
  2,
  3,
  9,
  0,
  10,
  10,
  47,
  15,
  406,
  7,
  2,
  7,
  17,
  9,
  57,
  21,
  2,
  13,
  123,
  5,
  4,
  0,
  2,
  1,
  2,
  6,
  2,
  0,
  9,
  9,
  49,
  4,
  2,
  1,
  2,
  4,
  9,
  9,
  330,
  3,
  19306,
  9,
  135,
  4,
  60,
  6,
  26,
  9,
  1014,
  0,
  2,
  54,
  8,
  3,
  82,
  0,
  12,
  1,
  19628,
  1,
  5319,
  4,
  4,
  5,
  9,
  7,
  3,
  6,
  31,
  3,
  149,
  2,
  1418,
  49,
  513,
  54,
  5,
  49,
  9,
  0,
  15,
  0,
  23,
  4,
  2,
  14,
  1361,
  6,
  2,
  16,
  3,
  6,
  2,
  1,
  2,
  4,
  262,
  6,
  10,
  9,
  419,
  13,
  1495,
  6,
  110,
  6,
  6,
  9,
  4759,
  9,
  787719,
  239
];
function nl(e20, t2) {
  let n2 = 65536;
  for (let r2 = 0, i2 = t2.length; r2 < i2; r2 += 2) {
    if (n2 += t2[r2], n2 > e20)
      return false;
    if (n2 += t2[r2 + 1], n2 >= e20)
      return true;
  }
  return false;
}
function rl(e20) {
  return e20 < 65 ? e20 === 36 : e20 <= 90 || (e20 < 97 ? e20 === 95 : e20 <= 122 || (e20 <= 65535 ? e20 >= 170 && Qc.test(String.fromCharCode(e20)) : nl(e20, el)));
}
function il(e20) {
  return e20 < 48 ? e20 === 36 : e20 < 58 || !(e20 < 65) && (e20 <= 90 || (e20 < 97 ? e20 === 95 : e20 <= 122 || (e20 <= 65535 ? e20 >= 170 && Zc.test(String.fromCharCode(e20)) : nl(e20, el) || nl(e20, tl))));
}
var ul = Object.defineProperty({ isIdentifierStart: Hc, isIdentifierChar: Jc, isIdentifierName: Xc }, "__esModule", { value: true }), ol = ml, sl = yl, al = Dl, cl = function(e20, t2) {
  return yl(e20, t2) || Dl(e20);
}, ll = function(e20) {
  return dl.has(e20);
};
const pl = [
  "implements",
  "interface",
  "let",
  "package",
  "private",
  "protected",
  "public",
  "static",
  "yield"
], fl = ["eval", "arguments"], dl = new Set([
  "break",
  "case",
  "catch",
  "continue",
  "debugger",
  "default",
  "do",
  "else",
  "finally",
  "for",
  "function",
  "if",
  "return",
  "switch",
  "throw",
  "try",
  "var",
  "const",
  "while",
  "with",
  "new",
  "this",
  "super",
  "class",
  "extends",
  "export",
  "import",
  "null",
  "true",
  "false",
  "in",
  "instanceof",
  "typeof",
  "void",
  "delete"
]), hl = new Set(pl), gl = new Set(fl);
function ml(e20, t2) {
  return t2 && e20 === "await" || e20 === "enum";
}
function yl(e20, t2) {
  return ml(e20, t2) || hl.has(e20);
}
function Dl(e20) {
  return gl.has(e20);
}
var El = Object.defineProperty({
  isReservedWord: ol,
  isStrictReservedWord: sl,
  isStrictBindOnlyReservedWord: al,
  isStrictBindReservedWord: cl,
  isKeyword: ll
}, "__esModule", { value: true }), Cl = r$3(function(e20, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "isIdentifierName", {
    enumerable: true,
    get: function() {
      return ul.isIdentifierName;
    }
  }), Object.defineProperty(t2, "isIdentifierChar", {
    enumerable: true,
    get: function() {
      return ul.isIdentifierChar;
    }
  }), Object.defineProperty(t2, "isIdentifierStart", {
    enumerable: true,
    get: function() {
      return ul.isIdentifierStart;
    }
  }), Object.defineProperty(t2, "isReservedWord", {
    enumerable: true,
    get: function() {
      return El.isReservedWord;
    }
  }), Object.defineProperty(t2, "isStrictBindOnlyReservedWord", {
    enumerable: true,
    get: function() {
      return El.isStrictBindOnlyReservedWord;
    }
  }), Object.defineProperty(t2, "isStrictBindReservedWord", {
    enumerable: true,
    get: function() {
      return El.isStrictBindReservedWord;
    }
  }), Object.defineProperty(t2, "isStrictReservedWord", {
    enumerable: true,
    get: function() {
      return El.isStrictReservedWord;
    }
  }), Object.defineProperty(t2, "isKeyword", {
    enumerable: true,
    get: function() {
      return El.isKeyword;
    }
  });
}), bl = /[|\\{}()[\]^$+*?.]/g, Al = function(e20) {
  if (typeof e20 != "string")
    throw new TypeError("Expected a string");
  return e20.replace(bl, "\\$&");
}, vl = r$3(function(e20) {
  const t2 = (e21, t3) => function() {
    const n3 = e21.apply(Ro$2, arguments);
    return `[${n3 + t3}m`;
  }, n2 = (e21, t3) => function() {
    const n3 = e21.apply(Ro$2, arguments);
    return `[${38 + t3};5;${n3}m`;
  }, r2 = (e21, t3) => function() {
    const n3 = e21.apply(Ro$2, arguments);
    return `[${38 + t3};2;${n3[0]};${n3[1]};${n3[2]}m`;
  };
  Object.defineProperty(e20, "exports", {
    enumerable: true,
    get: function() {
      const e21 = new Map(), i2 = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          gray: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      i2.color.grey = i2.color.gray;
      for (const t3 of Object.keys(i2)) {
        const n3 = i2[t3];
        for (const t4 of Object.keys(n3)) {
          const r3 = n3[t4];
          i2[t4] = {
            open: `[${r3[0]}m`,
            close: `[${r3[1]}m`
          }, n3[t4] = i2[t4], e21.set(r3[0], r3[1]);
        }
        Object.defineProperty(i2, t3, { value: n3, enumerable: false }), Object.defineProperty(i2, "codes", {
          value: e21,
          enumerable: false
        });
      }
      const u2 = (e22) => e22, o2 = (e22, t3, n3) => [e22, t3, n3];
      i2.color.close = "[39m", i2.bgColor.close = "[49m", i2.color.ansi = { ansi: t2(u2, 0) }, i2.color.ansi256 = { ansi256: n2(u2, 0) }, i2.color.ansi16m = { rgb: r2(o2, 0) }, i2.bgColor.ansi = { ansi: t2(u2, 10) }, i2.bgColor.ansi256 = { ansi256: n2(u2, 10) }, i2.bgColor.ansi16m = { rgb: r2(o2, 10) };
      for (let e22 of Object.keys(Ro$2)) {
        if (typeof Ro$2[e22] != "object")
          continue;
        const u3 = Ro$2[e22];
        e22 === "ansi16" && (e22 = "ansi"), "ansi16" in u3 && (i2.color.ansi[e22] = t2(u3.ansi16, 0), i2.bgColor.ansi[e22] = t2(u3.ansi16, 10)), "ansi256" in u3 && (i2.color.ansi256[e22] = n2(u3.ansi256, 0), i2.bgColor.ansi256[e22] = n2(u3.ansi256, 10)), "rgb" in u3 && (i2.color.ansi16m[e22] = r2(u3.rgb, 0), i2.bgColor.ansi16m[e22] = r2(u3.rgb, 10));
      }
      return i2;
    }
  });
}), Fl = (e20, t2) => {
  t2 = t2 || xr$2.argv;
  const n2 = e20.startsWith("-") ? "" : e20.length === 1 ? "-" : "--", r2 = t2.indexOf(n2 + e20), i2 = t2.indexOf("--");
  return r2 !== -1 && (i2 === -1 || r2 < i2);
};
const Sl = xr$2.env;
let xl;
function wl(e20) {
  return function(e21) {
    return e21 !== 0 && {
      level: e21,
      hasBasic: true,
      has256: e21 >= 2,
      has16m: e21 >= 3
    };
  }(function(e21) {
    if (xl === false)
      return 0;
    if (Fl("color=16m") || Fl("color=full") || Fl("color=truecolor"))
      return 3;
    if (Fl("color=256"))
      return 2;
    if (e21 && !e21.isTTY && xl !== true)
      return 0;
    const t2 = xl ? 1 : 0;
    if ("CI" in Sl)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((e22) => e22 in Sl) || Sl.CI_NAME === "codeship" ? 1 : t2;
    if ("TEAMCITY_VERSION" in Sl)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Sl.TEAMCITY_VERSION) ? 1 : 0;
    if (Sl.COLORTERM === "truecolor")
      return 3;
    if ("TERM_PROGRAM" in Sl) {
      const e22 = parseInt((Sl.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (Sl.TERM_PROGRAM) {
        case "iTerm.app":
          return e22 >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(Sl.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Sl.TERM) || "COLORTERM" in Sl ? 1 : (Sl.TERM, t2);
  }(e20));
}
Fl("no-color") || Fl("no-colors") || Fl("color=false") ? xl = false : (Fl("color") || Fl("colors") || Fl("color=true") || Fl("color=always")) && (xl = true), "FORCE_COLOR" in Sl && (xl = Sl.FORCE_COLOR.length === 0 || parseInt(Sl.FORCE_COLOR, 10) !== 0);
var Tl = {
  supportsColor: wl,
  stdout: wl(xr$2.stdout),
  stderr: wl(xr$2.stderr)
};
const Bl = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, Nl = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, kl = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, Pl = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, Ol = new Map([
  ["n", "\n"],
  ["r", "\r"],
  ["t", "	"],
  ["b", "\b"],
  ["f", "\f"],
  ["v", "\v"],
  ["0", "\0"],
  ["\\", "\\"],
  ["e", ""],
  ["a", "\x07"]
]);
function Il(e20) {
  return e20[0] === "u" && e20.length === 5 || e20[0] === "x" && e20.length === 3 ? String.fromCharCode(parseInt(e20.slice(1), 16)) : Ol.get(e20) || e20;
}
function Ll(e20, t2) {
  const n2 = [], r2 = t2.trim().split(/\s*,\s*/g);
  let i2;
  for (const t3 of r2)
    if (isNaN(t3)) {
      if (!(i2 = t3.match(kl)))
        throw new Error(`Invalid Chalk template style argument: ${t3} (in style '${e20}')`);
      n2.push(i2[2].replace(Pl, (e21, t4, n3) => t4 ? Il(t4) : n3));
    } else
      n2.push(Number(t3));
  return n2;
}
function jl(e20) {
  Nl.lastIndex = 0;
  const t2 = [];
  let n2;
  for (; (n2 = Nl.exec(e20)) !== null; ) {
    const e21 = n2[1];
    if (n2[2]) {
      const r2 = Ll(e21, n2[2]);
      t2.push([e21].concat(r2));
    } else
      t2.push([e21]);
  }
  return t2;
}
function _l(e20, t2) {
  const n2 = {};
  for (const e21 of t2)
    for (const t3 of e21.styles)
      n2[t3[0]] = e21.inverse ? null : t3.slice(1);
  let r2 = e20;
  for (const e21 of Object.keys(n2))
    if (Array.isArray(n2[e21])) {
      if (!(e21 in r2))
        throw new Error(`Unknown Chalk style: ${e21}`);
      r2 = n2[e21].length > 0 ? r2[e21].apply(r2, n2[e21]) : r2[e21];
    }
  return r2;
}
var Ml = (e20, t2) => {
  const n2 = [], r2 = [];
  let i2 = [];
  if (t2.replace(Bl, (t3, u2, o2, s2, a2, c2) => {
    if (u2)
      i2.push(Il(u2));
    else if (s2) {
      const t4 = i2.join("");
      i2 = [], r2.push(n2.length === 0 ? t4 : _l(e20, n2)(t4)), n2.push({ inverse: o2, styles: jl(s2) });
    } else if (a2) {
      if (n2.length === 0)
        throw new Error("Found extraneous } in Chalk template literal");
      r2.push(_l(e20, n2)(i2.join(""))), i2 = [], n2.pop();
    } else
      i2.push(c2);
  }), r2.push(i2.join("")), n2.length > 0) {
    const e21 = `Chalk template literal is missing ${n2.length} closing bracket${n2.length === 1 ? "" : "s"} (\`}\`)`;
    throw new Error(e21);
  }
  return r2.join("");
}, Rl = r$3(function(e20) {
  const t2 = Tl.stdout, r2 = ["ansi", "ansi", "ansi256", "ansi16m"], i2 = new Set(["gray"]), u2 = Object.create(null);
  function o2(e21, n2) {
    n2 = n2 || {};
    const r3 = t2 ? t2.level : 0;
    e21.level = n2.level === void 0 ? r3 : n2.level, e21.enabled = "enabled" in n2 ? n2.enabled : e21.level > 0;
  }
  function s2(e21) {
    if (!this || !(this instanceof s2) || this.template) {
      const t3 = {};
      return o2(t3, e21), t3.template = function() {
        const e22 = [].slice.call(arguments);
        return p2.apply(null, [t3.template].concat(e22));
      }, Object.setPrototypeOf(t3, s2.prototype), Object.setPrototypeOf(t3.template, t3), t3.template.constructor = s2, t3.template;
    }
    o2(this, e21);
  }
  for (const e21 of Object.keys(vl))
    vl[e21].closeRe = new RegExp(Al(vl[e21].close), "g"), u2[e21] = {
      get() {
        const t3 = vl[e21];
        return c2.call(this, this._styles ? this._styles.concat(t3) : [t3], this._empty, e21);
      }
    };
  u2.visible = {
    get() {
      return c2.call(this, this._styles || [], true, "visible");
    }
  }, vl.color.closeRe = new RegExp(Al(vl.color.close), "g");
  for (const e21 of Object.keys(vl.color.ansi))
    i2.has(e21) || (u2[e21] = {
      get() {
        const t3 = this.level;
        return function() {
          const n2 = vl.color[r2[t3]][e21].apply(null, arguments), i3 = {
            open: n2,
            close: vl.color.close,
            closeRe: vl.color.closeRe
          };
          return c2.call(this, this._styles ? this._styles.concat(i3) : [i3], this._empty, e21);
        };
      }
    });
  vl.bgColor.closeRe = new RegExp(Al(vl.bgColor.close), "g");
  for (const e21 of Object.keys(vl.bgColor.ansi)) {
    if (i2.has(e21))
      continue;
    u2["bg" + e21[0].toUpperCase() + e21.slice(1)] = {
      get() {
        const t3 = this.level;
        return function() {
          const n2 = vl.bgColor[r2[t3]][e21].apply(null, arguments), i3 = {
            open: n2,
            close: vl.bgColor.close,
            closeRe: vl.bgColor.closeRe
          };
          return c2.call(this, this._styles ? this._styles.concat(i3) : [i3], this._empty, e21);
        };
      }
    };
  }
  const a2 = Object.defineProperties(() => {
  }, u2);
  function c2(e21, t3, n2) {
    const r3 = function() {
      return l2.apply(r3, arguments);
    };
    r3._styles = e21, r3._empty = t3;
    const i3 = this;
    return Object.defineProperty(r3, "level", {
      enumerable: true,
      get: () => i3.level,
      set(e22) {
        i3.level = e22;
      }
    }), Object.defineProperty(r3, "enabled", {
      enumerable: true,
      get: () => i3.enabled,
      set(e22) {
        i3.enabled = e22;
      }
    }), r3.hasGrey = this.hasGrey || n2 === "gray" || n2 === "grey", r3.__proto__ = a2, r3;
  }
  function l2() {
    const e21 = arguments, t3 = e21.length;
    let r3 = String(arguments[0]);
    if (t3 === 0)
      return "";
    if (t3 > 1)
      for (let n2 = 1; n2 < t3; n2++)
        r3 += " " + e21[n2];
    if (!this.enabled || this.level <= 0 || !r3)
      return this._empty ? "" : r3;
    const i3 = vl.dim.open;
    for (const e22 of this._styles.slice().reverse())
      r3 = e22.open + r3.replace(e22.closeRe, e22.open) + e22.close, r3 = r3.replace(/\r?\n/g, `${e22.close}$&${e22.open}`);
    return vl.dim.open = i3, r3;
  }
  function p2(e21, t3) {
    if (!Array.isArray(t3))
      return [].slice.call(arguments, 1).join(" ");
    const n2 = [].slice.call(arguments, 2), r3 = [t3.raw[0]];
    for (let e22 = 1; e22 < t3.length; e22++)
      r3.push(String(n2[e22 - 1]).replace(/[{}\\]/g, "\\$&")), r3.push(String(t3.raw[e22]));
    return Ml(e21, r3.join(""));
  }
  Object.defineProperties(s2.prototype, u2), e20.exports = s2(), e20.exports.supportsColor = t2, e20.exports.default = e20.exports;
}), $l = Hl, Vl = Jl, Wl = function(e20, t2 = {}) {
  if (Hl(t2)) {
    const n2 = Jl(t2);
    return function(e21, t3) {
      let n3 = "";
      for (const { type: r2, value: i2 } of Gl(t3)) {
        const t4 = e21[r2];
        n3 += t4 ? i2.split(Ul).map((e22) => t4(e22)).join("\n") : i2;
      }
      return n3;
    }(function(e21) {
      return {
        keyword: e21.cyan,
        capitalized: e21.yellow,
        jsxIdentifier: e21.yellow,
        punctuator: e21.yellow,
        number: e21.magenta,
        string: e21.green,
        regex: e21.magenta,
        comment: e21.grey,
        invalid: e21.white.bgRed.bold
      };
    }(n2), e20);
  }
  return e20;
};
const ql = new Set(["as", "async", "from", "get", "of", "set"]);
const Ul = /\r\n|[\n\r\u2028\u2029]/, zl = /^[()[\]{}]$/;
let Gl;
{
  const e20 = /^[a-z][\w-]*$/i, t2 = function(t3, n2, r2) {
    if (t3.type === "name") {
      if ((0, Cl.isKeyword)(t3.value) || (0, Cl.isStrictReservedWord)(t3.value, true) || ql.has(t3.value))
        return "keyword";
      if (e20.test(t3.value) && (r2[n2 - 1] === "<" || r2.substr(n2 - 2, 2) == "</"))
        return "jsxIdentifier";
      if (t3.value[0] !== t3.value[0].toLowerCase())
        return "capitalized";
    }
    return t3.type === "punctuator" && zl.test(t3.value) ? "bracket" : t3.type !== "invalid" || t3.value !== "@" && t3.value !== "#" ? t3.type : "punctuator";
  };
  Gl = function* (e21) {
    let n2;
    for (; n2 = Gc.default.exec(e21); ) {
      const r2 = Gc.matchToToken(n2);
      yield { type: t2(r2, n2.index, e21), value: r2.value };
    }
  };
}
function Hl(e20) {
  return !!Rl.supportsColor || e20.forceColor;
}
function Jl(e20) {
  return e20.forceColor ? new Rl.constructor({ enabled: true, level: 1 }) : Rl;
}
var Xl = Object.defineProperty({ shouldHighlight: $l, getChalk: Vl, default: Wl }, "__esModule", { value: true }), Yl = ep, Kl = function(e20, t2, n2, r2 = {}) {
  if (!Ql) {
    Ql = true;
    const e21 = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
    {
      new Error(e21).name = "DeprecationWarning", console.warn(new Error(e21));
    }
  }
  n2 = Math.max(n2, 0);
  return ep(e20, { start: { column: n2, line: t2 } }, r2);
};
let Ql = false;
const Zl = /\r\n|[\n\r\u2028\u2029]/;
function ep(e20, t2, n2 = {}) {
  const r2 = (n2.highlightCode || n2.forceColor) && (0, Xl.shouldHighlight)(n2), i2 = (0, Xl.getChalk)(n2), u2 = function(e21) {
    return { gutter: e21.grey, marker: e21.red.bold, message: e21.red.bold };
  }(i2), o2 = (e21, t3) => r2 ? e21(t3) : t3, s2 = e20.split(Zl), {
    start: a2,
    end: c2,
    markerLines: l2
  } = function(e21, t3, n3) {
    const r3 = Object.assign({ column: 0, line: -1 }, e21.start), i3 = Object.assign({}, r3, e21.end), { linesAbove: u3 = 2, linesBelow: o3 = 3 } = n3 || {}, s3 = r3.line, a3 = r3.column, c3 = i3.line, l3 = i3.column;
    let p3 = Math.max(s3 - (u3 + 1), 0), f3 = Math.min(t3.length, c3 + o3);
    s3 === -1 && (p3 = 0), c3 === -1 && (f3 = t3.length);
    const d3 = c3 - s3, h2 = {};
    if (d3)
      for (let e22 = 0; e22 <= d3; e22++) {
        const n4 = e22 + s3;
        if (a3)
          if (e22 === 0) {
            const e23 = t3[n4 - 1].length;
            h2[n4] = [a3, e23 - a3 + 1];
          } else if (e22 === d3)
            h2[n4] = [0, l3];
          else {
            const r4 = t3[n4 - e22].length;
            h2[n4] = [0, r4];
          }
        else
          h2[n4] = true;
      }
    else
      h2[s3] = a3 === l3 ? !a3 || [a3, 0] : [a3, l3 - a3];
    return { start: p3, end: f3, markerLines: h2 };
  }(t2, s2, n2), p2 = t2.start && typeof t2.start.column == "number", f2 = String(c2).length;
  let d2 = (r2 ? (0, Xl.default)(e20, n2) : e20).split(Zl).slice(a2, c2).map((e21, t3) => {
    const r3 = a2 + 1 + t3, i3 = ` ${` ${r3}`.slice(-f2)} |`, s3 = l2[r3], c3 = !l2[r3 + 1];
    if (s3) {
      let t4 = "";
      if (Array.isArray(s3)) {
        const r4 = e21.slice(0, Math.max(s3[0] - 1, 0)).replace(/[^\t]/g, " "), a3 = s3[1] || 1;
        t4 = [
          "\n ",
          o2(u2.gutter, i3.replace(/\d/g, " ")),
          " ",
          r4,
          o2(u2.marker, "^").repeat(a3)
        ].join(""), c3 && n2.message && (t4 += " " + o2(u2.message, n2.message));
      }
      return [
        o2(u2.marker, ">"),
        o2(u2.gutter, i3),
        e21.length > 0 ? ` ${e21}` : "",
        t4
      ].join("");
    }
    return ` ${o2(u2.gutter, i3)}${e21.length > 0 ? ` ${e21}` : ""}`;
  }).join("\n");
  return n2.message && !p2 && (d2 = `${" ".repeat(f2 + 1)}${n2.message}
${d2}`), r2 ? i2.reset(d2) : d2;
}
var tp = Object.defineProperty({ codeFrameColumns: Yl, default: Kl }, "__esModule", { value: true }), np = n$3(mu$1);
const { ConfigError: rp } = bo$2, { locStart: ip, locEnd: up } = zc, op = Object.getOwnPropertyNames, sp = Object.getOwnPropertyDescriptor;
function ap(e20) {
  const t2 = {};
  for (const n2 of e20.plugins)
    if (n2.parsers)
      for (const e21 of op(n2.parsers))
        Object.defineProperty(t2, e21, sp(n2.parsers, e21));
  return t2;
}
function cp(e20, t2 = ap(e20)) {
  if (typeof e20.parser == "function")
    return {
      parse: e20.parser,
      astFormat: "estree",
      locStart: ip,
      locEnd: up
    };
  if (typeof e20.parser == "string") {
    if (Object.prototype.hasOwnProperty.call(t2, e20.parser))
      return t2[e20.parser];
    throw new rp(`Couldn't resolve parser "${e20.parser}". Parsers must be explicitly added to the standalone bundle.`);
  }
}
var lp = {
  parse: function(e20, t2) {
    const n2 = ap(t2), r2 = Object.defineProperties({}, Object.fromEntries(Object.keys(n2).map((e21) => [
      e21,
      { enumerable: true, get: () => n2[e21].parse }
    ]))), i2 = cp(t2, n2);
    try {
      return i2.preprocess && (e20 = i2.preprocess(e20, t2)), { text: e20, ast: i2.parse(e20, r2, t2) };
    } catch (t3) {
      const { loc: n3 } = t3;
      if (n3) {
        const { codeFrameColumns: r3 } = tp;
        throw t3.codeFrame = r3(e20, n3, { highlightCode: true }), t3.message += "\n" + t3.codeFrame, t3;
      }
      throw t3.stack;
    }
  },
  resolveParser: cp
};
const { UndefinedParserError: pp } = bo$2, { getSupportInfo: fp } = Qr$2, { resolveParser: dp } = lp, hp = {
  astFormat: "estree",
  printer: {},
  originalText: void 0,
  locStart: null,
  locEnd: null
};
function gp(e20, t2) {
  const n2 = np.basename(e20).toLowerCase(), r2 = fp({ plugins: t2 }).languages.filter((e21) => e21.since !== null);
  let i2 = r2.find((e21) => e21.extensions && e21.extensions.some((e22) => n2.endsWith(e22)) || e21.filenames && e21.filenames.some((e22) => e22.toLowerCase() === n2));
  if (!i2 && !n2.includes(".")) {
    const t3 = function(e21) {
      if (typeof e21 != "string")
        return "";
      let t4;
      try {
        t4 = go$2.openSync(e21, "r");
      } catch {
        return "";
      }
      try {
        const e22 = new mo$2(t4).next().toString("utf8"), n3 = e22.match(/^#!\/(?:usr\/)?bin\/env\s+(\S+)/);
        if (n3)
          return n3[1];
        const r3 = e22.match(/^#!\/(?:usr\/(?:local\/)?)?bin\/(\S+)/);
        return r3 ? r3[1] : "";
      } catch {
        return "";
      } finally {
        try {
          go$2.closeSync(t4);
        } catch {
        }
      }
    }(e20);
    i2 = r2.find((e21) => e21.interpreters && e21.interpreters.includes(t3));
  }
  return i2 && i2.parsers[0];
}
var mp = {
  normalize: function(e20, t2 = {}) {
    const n2 = Object.assign({}, e20), r2 = fp({
      plugins: e20.plugins,
      showUnreleased: true,
      showDeprecated: true
    }).options, i2 = Object.assign(Object.assign({}, hp), Object.fromEntries(r2.filter((e21) => e21.default !== void 0).map((e21) => [e21.name, e21.default])));
    if (!n2.parser)
      if (n2.filepath) {
        if (n2.parser = gp(n2.filepath, n2.plugins), !n2.parser)
          throw new pp(`No parser could be inferred for file: ${n2.filepath}`);
      } else {
        (t2.logger || console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), n2.parser = "babel";
      }
    const u2 = dp($c.normalizeApiOptions(n2, [r2.find((e21) => e21.name === "parser")], {
      passThrough: true,
      logger: false
    }));
    n2.astFormat = u2.astFormat, n2.locEnd = u2.locEnd, n2.locStart = u2.locStart;
    const o2 = function(e21) {
      const { astFormat: t3 } = e21;
      if (!t3)
        throw new Error("getPlugin() requires astFormat to be set");
      const n3 = e21.plugins.find((e22) => e22.printers && e22.printers[t3]);
      if (!n3)
        throw new Error(`Couldn't find plugin for AST format "${t3}"`);
      return n3;
    }(n2);
    n2.printer = o2.printers[n2.astFormat];
    const s2 = Object.fromEntries(r2.filter((e21) => e21.pluginDefaults && e21.pluginDefaults[o2.name] !== void 0).map((e21) => [e21.name, e21.pluginDefaults[o2.name]])), a2 = Object.assign(Object.assign({}, i2), s2);
    for (const [e21, t3] of Object.entries(a2))
      n2[e21] !== null && n2[e21] !== void 0 || (n2[e21] = t3);
    return n2.parser === "json" && (n2.trailingComma = "none"), $c.normalizeApiOptions(n2, r2, Object.assign({ passThrough: Object.keys(hp) }, t2));
  },
  hiddenDefaults: hp,
  inferParser: gp
};
var yp = function e2(t2, n2, r2) {
  if (Array.isArray(t2))
    return t2.map((t3) => e2(t3, n2, r2)).filter(Boolean);
  if (!t2 || typeof t2 != "object")
    return t2;
  const i2 = n2.printer.massageAstNode;
  let u2;
  u2 = i2 && i2.ignoredProperties ? i2.ignoredProperties : new Set();
  const o2 = {};
  for (const [r3, i3] of Object.entries(t2))
    u2.has(r3) || typeof i3 == "function" || (o2[r3] = e2(i3, n2, t2));
  if (i2) {
    const e20 = i2(t2, o2, r2);
    if (e20 === null)
      return;
    if (e20)
      return e20;
  }
  return o2;
}, Dp = typeof Object.create == "function" ? function(e20, t2) {
  e20.super_ = t2, e20.prototype = Object.create(t2.prototype, {
    constructor: {
      value: e20,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
} : function(e20, t2) {
  e20.super_ = t2;
  var n2 = function() {
  };
  n2.prototype = t2.prototype, e20.prototype = new n2(), e20.prototype.constructor = e20;
};
function Ep(e20, t2) {
  var n2 = { seen: [], stylize: bp };
  return arguments.length >= 3 && (n2.depth = arguments[2]), arguments.length >= 4 && (n2.colors = arguments[3]), Sp(t2) ? n2.showHidden = t2 : t2 && jp(n2, t2), Tp(n2.showHidden) && (n2.showHidden = false), Tp(n2.depth) && (n2.depth = 2), Tp(n2.colors) && (n2.colors = false), Tp(n2.customInspect) && (n2.customInspect = true), n2.colors && (n2.stylize = Cp), Ap(n2, e20, n2.depth);
}
function Cp(e20, t2) {
  var n2 = Ep.styles[t2];
  return n2 ? "[" + Ep.colors[n2][0] + "m" + e20 + "[" + Ep.colors[n2][1] + "m" : e20;
}
function bp(e20, t2) {
  return e20;
}
function Ap(e20, t2, n2) {
  if (e20.customInspect && t2 && Op(t2.inspect) && t2.inspect !== Ep && (!t2.constructor || t2.constructor.prototype !== t2)) {
    var r2 = t2.inspect(n2, e20);
    return wp(r2) || (r2 = Ap(e20, r2, n2)), r2;
  }
  var i2 = function(e21, t3) {
    if (Tp(t3))
      return e21.stylize("undefined", "undefined");
    if (wp(t3)) {
      var n3 = "'" + JSON.stringify(t3).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return e21.stylize(n3, "string");
    }
    if (r3 = t3, typeof r3 == "number")
      return e21.stylize("" + t3, "number");
    var r3;
    if (Sp(t3))
      return e21.stylize("" + t3, "boolean");
    if (xp(t3))
      return e21.stylize("null", "null");
  }(e20, t2);
  if (i2)
    return i2;
  var u2 = Object.keys(t2), o2 = function(e21) {
    var t3 = {};
    return e21.forEach(function(e22, n3) {
      t3[e22] = true;
    }), t3;
  }(u2);
  if (e20.showHidden && (u2 = Object.getOwnPropertyNames(t2)), Pp(t2) && (u2.indexOf("message") >= 0 || u2.indexOf("description") >= 0))
    return vp(t2);
  if (u2.length === 0) {
    if (Op(t2)) {
      var s2 = t2.name ? ": " + t2.name : "";
      return e20.stylize("[Function" + s2 + "]", "special");
    }
    if (Bp(t2))
      return e20.stylize(RegExp.prototype.toString.call(t2), "regexp");
    if (kp(t2))
      return e20.stylize(Date.prototype.toString.call(t2), "date");
    if (Pp(t2))
      return vp(t2);
  }
  var a2, c2, l2 = "", p2 = false, f2 = ["{", "}"];
  (a2 = t2, Array.isArray(a2) && (p2 = true, f2 = ["[", "]"]), Op(t2)) && (l2 = " [Function" + (t2.name ? ": " + t2.name : "") + "]");
  return Bp(t2) && (l2 = " " + RegExp.prototype.toString.call(t2)), kp(t2) && (l2 = " " + Date.prototype.toUTCString.call(t2)), Pp(t2) && (l2 = " " + vp(t2)), u2.length !== 0 || p2 && t2.length != 0 ? n2 < 0 ? Bp(t2) ? e20.stylize(RegExp.prototype.toString.call(t2), "regexp") : e20.stylize("[Object]", "special") : (e20.seen.push(t2), c2 = p2 ? function(e21, t3, n3, r3, i3) {
    for (var u3 = [], o3 = 0, s3 = t3.length; o3 < s3; ++o3)
      _p(t3, String(o3)) ? u3.push(Fp(e21, t3, n3, r3, String(o3), true)) : u3.push("");
    return i3.forEach(function(i4) {
      i4.match(/^\d+$/) || u3.push(Fp(e21, t3, n3, r3, i4, true));
    }), u3;
  }(e20, t2, n2, o2, u2) : u2.map(function(r3) {
    return Fp(e20, t2, n2, o2, r3, p2);
  }), e20.seen.pop(), function(e21, t3, n3) {
    if (e21.reduce(function(e22, t4) {
      return t4.indexOf("\n"), e22 + t4.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0) > 60)
      return n3[0] + (t3 === "" ? "" : t3 + "\n ") + " " + e21.join(",\n  ") + " " + n3[1];
    return n3[0] + t3 + " " + e21.join(", ") + " " + n3[1];
  }(c2, l2, f2)) : f2[0] + l2 + f2[1];
}
function vp(e20) {
  return "[" + Error.prototype.toString.call(e20) + "]";
}
function Fp(e20, t2, n2, r2, i2, u2) {
  var o2, s2, a2;
  if ((a2 = Object.getOwnPropertyDescriptor(t2, i2) || { value: t2[i2] }).get ? s2 = a2.set ? e20.stylize("[Getter/Setter]", "special") : e20.stylize("[Getter]", "special") : a2.set && (s2 = e20.stylize("[Setter]", "special")), _p(r2, i2) || (o2 = "[" + i2 + "]"), s2 || (e20.seen.indexOf(a2.value) < 0 ? (s2 = xp(n2) ? Ap(e20, a2.value, null) : Ap(e20, a2.value, n2 - 1)).indexOf("\n") > -1 && (s2 = u2 ? s2.split("\n").map(function(e21) {
    return "  " + e21;
  }).join("\n").substr(2) : "\n" + s2.split("\n").map(function(e21) {
    return "   " + e21;
  }).join("\n")) : s2 = e20.stylize("[Circular]", "special")), Tp(o2)) {
    if (u2 && i2.match(/^\d+$/))
      return s2;
    (o2 = JSON.stringify("" + i2)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (o2 = o2.substr(1, o2.length - 2), o2 = e20.stylize(o2, "name")) : (o2 = o2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), o2 = e20.stylize(o2, "string"));
  }
  return o2 + ": " + s2;
}
function Sp(e20) {
  return typeof e20 == "boolean";
}
function xp(e20) {
  return e20 === null;
}
function wp(e20) {
  return typeof e20 == "string";
}
function Tp(e20) {
  return e20 === void 0;
}
function Bp(e20) {
  return Np(e20) && Lp(e20) === "[object RegExp]";
}
function Np(e20) {
  return typeof e20 == "object" && e20 !== null;
}
function kp(e20) {
  return Np(e20) && Lp(e20) === "[object Date]";
}
function Pp(e20) {
  return Np(e20) && (Lp(e20) === "[object Error]" || e20 instanceof Error);
}
function Op(e20) {
  return typeof e20 == "function";
}
function Ip(e20) {
  return e20 === null || typeof e20 == "boolean" || typeof e20 == "number" || typeof e20 == "string" || typeof e20 == "symbol" || e20 === void 0;
}
function Lp(e20) {
  return Object.prototype.toString.call(e20);
}
function jp(e20, t2) {
  if (!t2 || !Np(t2))
    return e20;
  for (var n2 = Object.keys(t2), r2 = n2.length; r2--; )
    e20[n2[r2]] = t2[n2[r2]];
  return e20;
}
function _p(e20, t2) {
  return Object.prototype.hasOwnProperty.call(e20, t2);
}
function Mp(e20, t2) {
  if (e20 === t2)
    return 0;
  for (var n2 = e20.length, r2 = t2.length, i2 = 0, u2 = Math.min(n2, r2); i2 < u2; ++i2)
    if (e20[i2] !== t2[i2]) {
      n2 = e20[i2], r2 = t2[i2];
      break;
    }
  return n2 < r2 ? -1 : r2 < n2 ? 1 : 0;
}
Ep.colors = {
  bold: [1, 22],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  white: [37, 39],
  grey: [90, 39],
  black: [30, 39],
  blue: [34, 39],
  cyan: [36, 39],
  green: [32, 39],
  magenta: [35, 39],
  red: [31, 39],
  yellow: [33, 39]
}, Ep.styles = {
  special: "cyan",
  number: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  date: "magenta",
  regexp: "red"
};
var Rp, $p = Object.prototype.hasOwnProperty, Vp = Object.keys || function(e20) {
  var t2 = [];
  for (var n2 in e20)
    $p.call(e20, n2) && t2.push(n2);
  return t2;
}, Wp = Array.prototype.slice;
function qp() {
  return Rp !== void 0 ? Rp : Rp = function() {
  }.name === "foo";
}
function Up(e20) {
  return Object.prototype.toString.call(e20);
}
function zp(e20) {
  return !fo$2(e20) && typeof nr$2.ArrayBuffer == "function" && (typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(e20) : !!e20 && (e20 instanceof DataView || !!(e20.buffer && e20.buffer instanceof ArrayBuffer)));
}
function Gp(e20, t2) {
  e20 || Qp(e20, true, t2, "==", Zp);
}
var Hp = /\s*function\s+([^\(\s]*)\s*/;
function Jp(e20) {
  if (Op(e20)) {
    if (qp())
      return e20.name;
    var t2 = e20.toString().match(Hp);
    return t2 && t2[1];
  }
}
function Xp(e20) {
  this.name = "AssertionError", this.actual = e20.actual, this.expected = e20.expected, this.operator = e20.operator, e20.message ? (this.message = e20.message, this.generatedMessage = false) : (this.message = function(e21) {
    return Yp(Kp(e21.actual), 128) + " " + e21.operator + " " + Yp(Kp(e21.expected), 128);
  }(this), this.generatedMessage = true);
  var t2 = e20.stackStartFunction || Qp;
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, t2);
  else {
    var n2 = new Error();
    if (n2.stack) {
      var r2 = n2.stack, i2 = Jp(t2), u2 = r2.indexOf("\n" + i2);
      if (u2 >= 0) {
        var o2 = r2.indexOf("\n", u2 + 1);
        r2 = r2.substring(o2 + 1);
      }
      this.stack = r2;
    }
  }
}
function Yp(e20, t2) {
  return typeof e20 == "string" ? e20.length < t2 ? e20 : e20.slice(0, t2) : e20;
}
function Kp(e20) {
  if (qp() || !Op(e20))
    return Ep(e20);
  var t2 = Jp(e20);
  return "[Function" + (t2 ? ": " + t2 : "") + "]";
}
function Qp(e20, t2, n2, r2, i2) {
  throw new Xp({
    message: n2,
    actual: e20,
    expected: t2,
    operator: r2,
    stackStartFunction: i2
  });
}
function Zp(e20, t2) {
  e20 || Qp(e20, true, t2, "==", Zp);
}
function ef(e20, t2, n2) {
  e20 != t2 && Qp(e20, t2, n2, "==", ef);
}
function tf(e20, t2, n2) {
  e20 == t2 && Qp(e20, t2, n2, "!=", tf);
}
function nf(e20, t2, n2) {
  uf(e20, t2, false) || Qp(e20, t2, n2, "deepEqual", nf);
}
function rf(e20, t2, n2) {
  uf(e20, t2, true) || Qp(e20, t2, n2, "deepStrictEqual", rf);
}
function uf(e20, t2, n2, r2) {
  if (e20 === t2)
    return true;
  if (fo$2(e20) && fo$2(t2))
    return Mp(e20, t2) === 0;
  if (kp(e20) && kp(t2))
    return e20.getTime() === t2.getTime();
  if (Bp(e20) && Bp(t2))
    return e20.source === t2.source && e20.global === t2.global && e20.multiline === t2.multiline && e20.lastIndex === t2.lastIndex && e20.ignoreCase === t2.ignoreCase;
  if (e20 !== null && typeof e20 == "object" || t2 !== null && typeof t2 == "object") {
    if (zp(e20) && zp(t2) && Up(e20) === Up(t2) && !(e20 instanceof Float32Array || e20 instanceof Float64Array))
      return Mp(new Uint8Array(e20.buffer), new Uint8Array(t2.buffer)) === 0;
    if (fo$2(e20) !== fo$2(t2))
      return false;
    var i2 = (r2 = r2 || { actual: [], expected: [] }).actual.indexOf(e20);
    return i2 !== -1 && i2 === r2.expected.indexOf(t2) || (r2.actual.push(e20), r2.expected.push(t2), function(e21, t3, n3, r3) {
      if (e21 == null || t3 == null)
        return false;
      if (Ip(e21) || Ip(t3))
        return e21 === t3;
      if (n3 && Object.getPrototypeOf(e21) !== Object.getPrototypeOf(t3))
        return false;
      var i3 = of(e21), u2 = of(t3);
      if (i3 && !u2 || !i3 && u2)
        return false;
      if (i3)
        return uf(e21 = Wp.call(e21), t3 = Wp.call(t3), n3);
      var o2, s2, a2 = Vp(e21), c2 = Vp(t3);
      if (a2.length !== c2.length)
        return false;
      for (a2.sort(), c2.sort(), s2 = a2.length - 1; s2 >= 0; s2--)
        if (a2[s2] !== c2[s2])
          return false;
      for (s2 = a2.length - 1; s2 >= 0; s2--)
        if (!uf(e21[o2 = a2[s2]], t3[o2], n3, r3))
          return false;
      return true;
    }(e20, t2, n2, r2));
  }
  return n2 ? e20 === t2 : e20 == t2;
}
function of(e20) {
  return Object.prototype.toString.call(e20) == "[object Arguments]";
}
function sf(e20, t2, n2) {
  uf(e20, t2, false) && Qp(e20, t2, n2, "notDeepEqual", sf);
}
function af(e20, t2, n2) {
  uf(e20, t2, true) && Qp(e20, t2, n2, "notDeepStrictEqual", af);
}
function cf(e20, t2, n2) {
  e20 !== t2 && Qp(e20, t2, n2, "===", cf);
}
function lf(e20, t2, n2) {
  e20 === t2 && Qp(e20, t2, n2, "!==", lf);
}
function pf(e20, t2) {
  if (!e20 || !t2)
    return false;
  if (Object.prototype.toString.call(t2) == "[object RegExp]")
    return t2.test(e20);
  try {
    if (e20 instanceof t2)
      return true;
  } catch (e21) {
  }
  return !Error.isPrototypeOf(t2) && t2.call({}, e20) === true;
}
function ff(e20, t2, n2, r2) {
  var i2;
  if (typeof t2 != "function")
    throw new TypeError('"block" argument must be a function');
  typeof n2 == "string" && (r2 = n2, n2 = null), i2 = function(e21) {
    var t3;
    try {
      e21();
    } catch (e22) {
      t3 = e22;
    }
    return t3;
  }(t2), r2 = (n2 && n2.name ? " (" + n2.name + ")." : ".") + (r2 ? " " + r2 : "."), e20 && !i2 && Qp(i2, n2, "Missing expected exception" + r2);
  var u2 = typeof r2 == "string", o2 = !e20 && i2 && !n2;
  if ((!e20 && Pp(i2) && u2 && pf(i2, n2) || o2) && Qp(i2, n2, "Got unwanted exception" + r2), e20 && i2 && n2 && !pf(i2, n2) || !e20 && i2)
    throw i2;
}
function df(e20, t2, n2) {
  ff(true, e20, t2, n2);
}
function hf(e20, t2, n2) {
  ff(false, e20, t2, n2);
}
function gf(e20) {
  if (e20)
    throw e20;
}
Gp.AssertionError = Xp, Dp(Xp, Error), Gp.fail = Qp, Gp.ok = Zp, Gp.equal = ef, Gp.notEqual = tf, Gp.deepEqual = nf, Gp.deepStrictEqual = rf, Gp.notDeepEqual = sf, Gp.notDeepStrictEqual = af, Gp.strictEqual = cf, Gp.notStrictEqual = lf, Gp.throws = df, Gp.doesNotThrow = hf, Gp.ifError = gf;
var mf = n$3(Object.freeze({
  __proto__: null,
  default: Gp,
  AssertionError: Xp,
  fail: Qp,
  ok: Zp,
  assert: Zp,
  equal: ef,
  notEqual: tf,
  deepEqual: nf,
  deepStrictEqual: rf,
  notDeepEqual: sf,
  notDeepStrictEqual: af,
  strictEqual: cf,
  notStrictEqual: lf,
  throws: df,
  doesNotThrow: hf,
  ifError: gf
}));
const {
  builders: {
    line: yf,
    hardline: Df,
    breakParent: Ef,
    indent: Cf,
    lineSuffix: bf,
    join: Af,
    cursor: vf
  }
} = eu$1, {
  hasNewline: Ff,
  skipNewline: Sf,
  skipSpaces: xf,
  isPreviousLineEmpty: wf,
  addLeadingComment: Tf,
  addDanglingComment: Bf,
  addTrailingComment: Nf
} = yi$2, kf = new WeakMap();
function Pf(e20, t2, n2) {
  if (!e20)
    return;
  const { printer: r2, locStart: i2, locEnd: u2 } = t2;
  if (n2) {
    if (r2.canAttachComment && r2.canAttachComment(e20)) {
      let t3;
      for (t3 = n2.length - 1; t3 >= 0 && !(i2(n2[t3]) <= i2(e20) && u2(n2[t3]) <= u2(e20)); --t3)
        ;
      return void n2.splice(t3 + 1, 0, e20);
    }
  } else if (kf.has(e20))
    return kf.get(e20);
  const o2 = r2.getCommentChildNodes && r2.getCommentChildNodes(e20, t2) || typeof e20 == "object" && Object.entries(e20).filter(([e21]) => e21 !== "enclosingNode" && e21 !== "precedingNode" && e21 !== "followingNode" && e21 !== "tokens" && e21 !== "comments").map(([, e21]) => e21);
  if (o2) {
    n2 || (n2 = [], kf.set(e20, n2));
    for (const e21 of o2)
      Pf(e21, t2, n2);
    return n2;
  }
}
function Of(e20, t2, n2, r2) {
  const { locStart: i2, locEnd: u2 } = n2, o2 = i2(t2), s2 = u2(t2), a2 = Pf(e20, n2);
  let c2, l2, p2 = 0, f2 = a2.length;
  for (; p2 < f2; ) {
    const e21 = p2 + f2 >> 1, r3 = a2[e21], d2 = i2(r3), h2 = u2(r3);
    if (d2 <= o2 && s2 <= h2)
      return Of(r3, t2, n2, r3);
    if (h2 <= o2)
      c2 = r3, p2 = e21 + 1;
    else {
      if (!(s2 <= d2))
        throw new Error("Comment location overlaps with node location");
      l2 = r3, f2 = e21;
    }
  }
  if (r2 && r2.type === "TemplateLiteral") {
    const { quasis: e21 } = r2, i3 = $f(e21, t2, n2);
    c2 && $f(e21, c2, n2) !== i3 && (c2 = null), l2 && $f(e21, l2, n2) !== i3 && (l2 = null);
  }
  return { enclosingNode: r2, precedingNode: c2, followingNode: l2 };
}
const If = () => false;
const Lf = (e20) => !/[\S\n\u2028\u2029]/.test(e20);
function jf(e20, t2, n2, r2) {
  const { comment: i2, precedingNode: u2 } = n2[r2], { locStart: o2, locEnd: s2 } = t2;
  let a2 = o2(i2);
  if (u2)
    for (let t3 = r2 - 1; t3 >= 0; t3--) {
      const { comment: r3, precedingNode: i3 } = n2[t3];
      if (i3 !== u2 || !Lf(e20.slice(s2(r3), a2)))
        break;
      a2 = o2(r3);
    }
  return Ff(e20, a2, { backwards: true });
}
function _f$1(e20, t2, n2, r2) {
  const { comment: i2, followingNode: u2 } = n2[r2], { locStart: o2, locEnd: s2 } = t2;
  let a2 = s2(i2);
  if (u2)
    for (let t3 = r2 + 1; t3 < n2.length; t3++) {
      const { comment: r3, followingNode: i3 } = n2[t3];
      if (i3 !== u2 || !Lf(e20.slice(a2, o2(r3))))
        break;
      a2 = s2(r3);
    }
  return Ff(e20, a2);
}
function Mf(e20, t2, n2) {
  const r2 = e20.length;
  if (r2 === 0)
    return;
  const { precedingNode: i2, followingNode: u2, enclosingNode: o2 } = e20[0], s2 = n2.printer.getGapRegex && n2.printer.getGapRegex(o2) || /^[\s(]*$/;
  let a2, c2 = n2.locStart(u2);
  for (a2 = r2; a2 > 0; --a2) {
    const { comment: r3, precedingNode: o3, followingNode: l2 } = e20[a2 - 1];
    mf.strictEqual(o3, i2), mf.strictEqual(l2, u2);
    const p2 = t2.slice(n2.locEnd(r3), c2);
    if (!s2.test(p2))
      break;
    c2 = n2.locStart(r3);
  }
  for (const [t3, { comment: n3 }] of e20.entries())
    t3 < a2 ? Nf(i2, n3) : Tf(u2, n3);
  for (const e21 of [i2, u2])
    e21.comments && e21.comments.length > 1 && e21.comments.sort((e22, t3) => n2.locStart(e22) - n2.locStart(t3));
  e20.length = 0;
}
function Rf(e20, t2) {
  return e20.getValue().printed = true, t2.printer.printComment(e20, t2);
}
function $f(e20, t2, n2) {
  const r2 = n2.locStart(t2) - 1;
  for (let t3 = 1; t3 < e20.length; ++t3)
    if (r2 < n2.locStart(e20[t3]))
      return t3 - 1;
  return 0;
}
function Vf(e20, t2, n2) {
  const r2 = e20.getValue();
  if (!r2)
    return {};
  let i2 = r2.comments || [];
  n2 && (i2 = i2.filter((e21) => !n2.has(e21)));
  const u2 = r2 === t2.cursorNode;
  if (i2.length === 0) {
    const e21 = u2 ? vf : "";
    return { leading: e21, trailing: e21 };
  }
  const o2 = [], s2 = [];
  return e20.each(() => {
    const r3 = e20.getValue();
    if (n2 && n2.has(r3))
      return;
    const { leading: i3, trailing: u3 } = r3;
    i3 ? o2.push(function(e21, t3) {
      const n3 = e21.getValue(), r4 = [Rf(e21, t3)], {
        printer: i4,
        originalText: u4,
        locStart: o3,
        locEnd: s3
      } = t3;
      if (i4.isBlockComment && i4.isBlockComment(n3)) {
        const e22 = Ff(u4, s3(n3)) ? Ff(u4, o3(n3), { backwards: true }) ? Df : yf : " ";
        r4.push(e22);
      } else
        r4.push(Df);
      const a2 = Sf(u4, xf(u4, s3(n3)));
      return a2 !== false && Ff(u4, a2) && r4.push(Df), r4;
    }(e20, t2)) : u3 && s2.push(function(e21, t3) {
      const n3 = e21.getValue(), r4 = Rf(e21, t3), { printer: i4, originalText: u4, locStart: o3 } = t3, s3 = i4.isBlockComment && i4.isBlockComment(n3);
      if (Ff(u4, o3(n3), { backwards: true })) {
        const e22 = wf(u4, n3, o3);
        return bf([Df, e22 ? Df : "", r4]);
      }
      let a2 = [" ", r4];
      return s3 || (a2 = [bf(a2), Ef]), a2;
    }(e20, t2));
  }, "comments"), u2 && (o2.unshift(vf), s2.push(vf)), { leading: o2, trailing: s2 };
}
var Wf = {
  attach: function(e20, t2, n2, r2) {
    if (!Array.isArray(e20))
      return;
    const i2 = [], {
      locStart: u2,
      locEnd: o2,
      printer: { handleComments: s2 = {} }
    } = r2, {
      avoidAstMutation: a2,
      ownLine: c2 = If,
      endOfLine: l2 = If,
      remaining: p2 = If
    } = s2, f2 = e20.map((i3, u3) => Object.assign(Object.assign({}, Of(t2, i3, r2)), {}, {
      comment: i3,
      text: n2,
      options: r2,
      ast: t2,
      isLastComment: e20.length - 1 === u3
    }));
    for (const [e21, t3] of f2.entries()) {
      const {
        comment: n3,
        precedingNode: r3,
        enclosingNode: s3,
        followingNode: d2,
        text: h2,
        options: g2,
        ast: m2,
        isLastComment: y2
      } = t3;
      if (g2.parser === "json" || g2.parser === "json5" || g2.parser === "__js_expression" || g2.parser === "__vue_expression") {
        if (u2(n3) - u2(m2) <= 0) {
          Tf(m2, n3);
          continue;
        }
        if (o2(n3) - o2(m2) >= 0) {
          Nf(m2, n3);
          continue;
        }
      }
      let D2;
      if (a2 ? D2 = [t3] : (n3.enclosingNode = s3, n3.precedingNode = r3, n3.followingNode = d2, D2 = [n3, h2, g2, m2, y2]), jf(h2, g2, f2, e21))
        n3.placement = "ownLine", c2(...D2) || (d2 ? Tf(d2, n3) : r3 ? Nf(r3, n3) : Bf(s3 || m2, n3));
      else if (_f$1(h2, g2, f2, e21))
        n3.placement = "endOfLine", l2(...D2) || (r3 ? Nf(r3, n3) : d2 ? Tf(d2, n3) : Bf(s3 || m2, n3));
      else if (n3.placement = "remaining", p2(...D2))
        ;
      else if (r3 && d2) {
        const e22 = i2.length;
        if (e22 > 0) {
          i2[e22 - 1].followingNode !== d2 && Mf(i2, h2, g2);
        }
        i2.push(t3);
      } else
        r3 ? Nf(r3, n3) : d2 ? Tf(d2, n3) : Bf(s3 || m2, n3);
    }
    if (Mf(i2, n2, r2), !a2)
      for (const t3 of e20)
        delete t3.precedingNode, delete t3.enclosingNode, delete t3.followingNode;
  },
  printComments: function(e20, t2, n2, r2) {
    const { leading: i2, trailing: u2 } = Vf(e20, n2, r2);
    return i2 || u2 ? [i2, t2, u2] : t2;
  },
  printCommentsSeparately: Vf,
  printDanglingComments: function(e20, t2, n2, r2) {
    const i2 = [], u2 = e20.getValue();
    return u2 && u2.comments ? (e20.each(() => {
      const n3 = e20.getValue();
      n3.leading || n3.trailing || r2 && !r2(n3) || i2.push(Rf(e20, t2));
    }, "comments"), i2.length === 0 ? "" : n2 ? Af(Df, i2) : Cf([Df, Af(Df, i2)])) : "";
  },
  getSortedChildNodes: Pf,
  ensureAllCommentsPrinted: function(e20) {
    if (e20)
      for (const t2 of e20) {
        if (!t2.printed)
          throw new Error('Comment "' + t2.value.trim() + '" was not printed. Please report this error!');
        delete t2.printed;
      }
  }
};
function qf(e20, t2) {
  const n2 = Uf(e20.stack, t2);
  return n2 === -1 ? null : e20.stack[n2];
}
function Uf(e20, t2) {
  for (let n2 = e20.length - 1; n2 >= 0; n2 -= 2) {
    const r2 = e20[n2];
    if (r2 && !Array.isArray(r2) && --t2 < 0)
      return n2;
  }
  return -1;
}
var zf = class {
  constructor(e20) {
    this.stack = [e20];
  }
  getName() {
    const { stack: e20 } = this, { length: t2 } = e20;
    return t2 > 1 ? e20[t2 - 2] : null;
  }
  getValue() {
    return Ln$2(this.stack);
  }
  getNode(e20 = 0) {
    return qf(this, e20);
  }
  getParentNode(e20 = 0) {
    return qf(this, e20 + 1);
  }
  call(e20, ...t2) {
    const { stack: n2 } = this, { length: r2 } = n2;
    let i2 = Ln$2(n2);
    for (const e21 of t2)
      i2 = i2[e21], n2.push(e21, i2);
    const u2 = e20(this);
    return n2.length = r2, u2;
  }
  callParent(e20, t2 = 0) {
    const n2 = Uf(this.stack, t2 + 1), r2 = this.stack.splice(n2 + 1), i2 = e20(this);
    return this.stack.push(...r2), i2;
  }
  each(e20, ...t2) {
    const { stack: n2 } = this, { length: r2 } = n2;
    let i2 = Ln$2(n2);
    for (const e21 of t2)
      i2 = i2[e21], n2.push(e21, i2);
    for (let t3 = 0; t3 < i2.length; ++t3)
      n2.push(t3, i2[t3]), e20(this, t3, i2), n2.length -= 2;
    n2.length = r2;
  }
  map(e20, ...t2) {
    const n2 = [];
    return this.each((t3, r2, i2) => {
      n2[r2] = e20(t3, r2, i2);
    }, ...t2), n2;
  }
  try(e20) {
    const { stack: t2 } = this, n2 = [...t2];
    try {
      return e20();
    } finally {
      t2.length = 0, t2.push(...n2);
    }
  }
  match(...e20) {
    let t2 = this.stack.length - 1, n2 = null, r2 = this.stack[t2--];
    for (const i2 of e20) {
      if (r2 === void 0)
        return false;
      let e21 = null;
      if (typeof n2 == "number" && (e21 = n2, n2 = this.stack[t2--], r2 = this.stack[t2--]), i2 && !i2(r2, n2, e21))
        return false;
      n2 = this.stack[t2--], r2 = this.stack[t2--];
    }
    return true;
  }
  findAncestor(e20) {
    let t2 = this.stack.length - 1, n2 = null, r2 = this.stack[t2--];
    for (; r2; ) {
      let i2 = null;
      if (typeof n2 == "number" && (i2 = n2, n2 = this.stack[t2--], r2 = this.stack[t2--]), n2 !== null && e20(r2, n2, i2))
        return r2;
      n2 = this.stack[t2--], r2 = this.stack[t2--];
    }
  }
};
const {
  utils: { stripTrailingHardline: Gf }
} = eu$1, { normalize: Hf } = mp;
var Jf = {
  printSubtree: function(e20, t2, n2, r2) {
    if (n2.printer.embed && n2.embeddedLanguageFormatting === "auto")
      return n2.printer.embed(e20, t2, (e21, t3, i2) => function(e22, t4, n3, r3, { stripTrailingHardline: i3 = false } = {}) {
        const u2 = Hf(Object.assign(Object.assign(Object.assign({}, n3), t4), {}, { parentParser: n3.parser, originalText: e22 }), { passThrough: true }), o2 = lp.parse(e22, u2), { ast: s2 } = o2;
        e22 = o2.text;
        const a2 = s2.comments;
        delete s2.comments, Wf.attach(a2, s2, e22, u2), u2[Symbol.for("comments")] = a2 || [], u2[Symbol.for("tokens")] = s2.tokens || [];
        const c2 = r3(s2, u2);
        if (Wf.ensureAllCommentsPrinted(a2), i3)
          return typeof c2 == "string" ? c2.replace(/(?:\r?\n)*$/, "") : Gf(c2);
        return c2;
      }(e21, t3, n2, r2, i2), n2);
  }
};
const {
  builders: { hardline: Xf, addAlignmentToDoc: Yf },
  utils: { propagateBreaks: Kf }
} = eu$1, { printComments: Qf } = Wf;
function Zf(e20, n2, r2 = 0) {
  const { printer: i2 } = n2;
  i2.preprocess && (e20 = i2.preprocess(e20, n2));
  const u2 = new Map(), o2 = new zf(e20);
  let s2 = a2();
  return r2 > 0 && (s2 = Yf([Xf, s2], r2, n2.tabWidth)), Kf(s2), s2;
  function a2(e21, t2) {
    return e21 === void 0 || e21 === o2 ? c2(t2) : Array.isArray(e21) ? o2.call(() => c2(t2), ...e21) : o2.call(() => c2(t2), e21);
  }
  function c2(e21) {
    const r3 = o2.getValue(), i3 = r3 && typeof r3 == "object" && e21 === void 0;
    if (i3 && u2.has(r3))
      return u2.get(r3);
    const s3 = function(e22, n3, r4, i4) {
      const u3 = e22.getValue(), { printer: o3 } = n3;
      let s4, a3;
      if (o3.hasPrettierIgnore && o3.hasPrettierIgnore(e22))
        ({ doc: s4, printedComments: a3 } = function(e23, t2) {
          const {
            originalText: n4,
            [Symbol.for("comments")]: r5,
            locStart: i5,
            locEnd: u4
          } = t2, o4 = i5(e23), s5 = u4(e23), a4 = new Set();
          for (const e24 of r5)
            i5(e24) >= o4 && u4(e24) <= s5 && (e24.printed = true, a4.add(e24));
          return { doc: n4.slice(o4, s5), printedComments: a4 };
        }(u3, n3));
      else {
        if (u3)
          try {
            s4 = Jf.printSubtree(e22, r4, n3, Zf);
          } catch (e23) {
            if (t$3.PRETTIER_DEBUG)
              throw e23;
          }
        s4 || (s4 = o3.print(e22, n3, r4, i4));
      }
      o3.willPrintOwnComments && o3.willPrintOwnComments(e22, n3) || (s4 = Qf(e22, s4, n3, a3));
      return s4;
    }(o2, n2, a2, e21);
    return i3 && u2.set(r3, s3), s3;
  }
}
var ed = Zf;
function td(e20) {
  let t2 = e20.length - 1;
  for (; ; ) {
    const n2 = e20[t2];
    if (!n2 || n2.type !== "Program" && n2.type !== "File")
      break;
    t2--;
  }
  return e20.slice(0, t2 + 1);
}
function nd(e20, t2, n2, r2, i2 = [], u2) {
  const { locStart: o2, locEnd: s2 } = n2, a2 = o2(e20), c2 = s2(e20);
  if (!(t2 > c2 || t2 < a2 || u2 === "rangeEnd" && t2 === a2 || u2 === "rangeStart" && t2 === c2)) {
    for (const o3 of Wf.getSortedChildNodes(e20, n2)) {
      const s3 = nd(o3, t2, n2, r2, [e20, ...i2], u2);
      if (s3)
        return s3;
    }
    return !r2 || r2(e20, i2[0]) ? { node: e20, parentNodes: i2 } : void 0;
  }
}
const rd = new Set([
  "ObjectExpression",
  "ArrayExpression",
  "StringLiteral",
  "NumericLiteral",
  "BooleanLiteral",
  "NullLiteral",
  "UnaryExpression",
  "TemplateLiteral"
]), id = new Set([
  "OperationDefinition",
  "FragmentDefinition",
  "VariableDefinition",
  "TypeExtensionDefinition",
  "ObjectTypeDefinition",
  "FieldDefinition",
  "DirectiveDefinition",
  "EnumTypeDefinition",
  "EnumValueDefinition",
  "InputValueDefinition",
  "InputObjectTypeDefinition",
  "SchemaDefinition",
  "OperationTypeDefinition",
  "InterfaceTypeDefinition",
  "UnionTypeDefinition",
  "ScalarTypeDefinition"
]);
function ud(e20, t2, n2) {
  if (!t2)
    return false;
  switch (e20.parser) {
    case "flow":
    case "babel":
    case "babel-flow":
    case "babel-ts":
    case "typescript":
    case "espree":
    case "meriyah":
    case "__babel_estree":
      return function(e21, t3) {
        return t3 !== "DeclareExportDeclaration" && e21 !== "TypeParameterDeclaration" && (e21 === "Directive" || e21 === "TypeAlias" || e21 === "TSExportAssignment" || e21.startsWith("Declare") || e21.startsWith("TSDeclare") || e21.endsWith("Statement") || e21.endsWith("Declaration"));
      }(t2.type, n2 && n2.type);
    case "json":
    case "json5":
    case "json-stringify":
      return rd.has(t2.type);
    case "graphql":
      return id.has(t2.kind);
    case "vue":
      return t2.tag !== "root";
  }
  return false;
}
var od = {
  calculateRange: function(e20, t2, n2) {
    let { rangeStart: r2, rangeEnd: i2, locStart: u2, locEnd: o2 } = t2;
    mf.ok(i2 > r2);
    const s2 = e20.slice(r2, i2).search(/\S/), a2 = s2 === -1;
    if (!a2)
      for (r2 += s2; i2 > r2 && !/\S/.test(e20[i2 - 1]); --i2)
        ;
    const c2 = nd(n2, r2, t2, (e21, n3) => ud(t2, e21, n3), [], "rangeStart"), l2 = a2 ? c2 : nd(n2, i2, t2, (e21) => ud(t2, e21), [], "rangeEnd");
    if (!c2 || !l2)
      return { rangeStart: 0, rangeEnd: 0 };
    let p2, f2;
    if ((({ parser: e21 }) => e21 === "json" || e21 === "json5" || e21 === "json-stringify")(t2)) {
      const e21 = function(e22, t3) {
        const n3 = [e22.node, ...e22.parentNodes], r3 = new Set([t3.node, ...t3.parentNodes]);
        return n3.find((e23) => rd.has(e23.type) && r3.has(e23));
      }(c2, l2);
      p2 = e21, f2 = e21;
    } else
      ({ startNode: p2, endNode: f2 } = function(e21, t3, { locStart: n3, locEnd: r3 }) {
        let i3 = e21.node, u3 = t3.node;
        if (i3 === u3)
          return { startNode: i3, endNode: u3 };
        const o3 = n3(e21.node);
        for (const e22 of td(t3.parentNodes)) {
          if (!(n3(e22) >= o3))
            break;
          u3 = e22;
        }
        const s3 = r3(t3.node);
        for (const t4 of td(e21.parentNodes)) {
          if (!(r3(t4) <= s3))
            break;
          i3 = t4;
        }
        return { startNode: i3, endNode: u3 };
      }(c2, l2, t2));
    return {
      rangeStart: Math.min(u2(p2), u2(f2)),
      rangeEnd: Math.max(o2(p2), o2(f2))
    };
  },
  findNodeAtOffset: nd
};
const {
  printer: { printDocToString: sd },
  debug: { printDocToDebug: ad }
} = eu$1, { getAlignmentSize: cd } = yi$2, {
  guessEndOfLine: ld,
  convertEndOfLineToChars: pd,
  countEndOfLineChars: fd,
  normalizeEndOfLine: dd
} = Di$2, hd = mp.normalize, gd = Symbol("cursor");
function md(e20, t2, n2) {
  const r2 = t2.comments;
  return r2 && (delete t2.comments, Wf.attach(r2, t2, e20, n2)), n2[Symbol.for("comments")] = r2 || [], n2[Symbol.for("tokens")] = t2.tokens || [], n2.originalText = e20, r2;
}
function yd(e20, t2, n2 = 0) {
  if (!e20 || e20.trim().length === 0)
    return { formatted: "", cursorOffset: -1, comments: [] };
  const { ast: r2, text: i2 } = lp.parse(e20, t2);
  if (t2.cursorOffset >= 0) {
    const e21 = od.findNodeAtOffset(r2, t2.cursorOffset, t2);
    e21 && e21.node && (t2.cursorNode = e21.node);
  }
  const u2 = md(i2, r2, t2), o2 = ed(r2, t2, n2), s2 = sd(o2, t2);
  if (Wf.ensureAllCommentsPrinted(u2), n2 > 0) {
    const e21 = s2.formatted.trim();
    s2.cursorNodeStart !== void 0 && (s2.cursorNodeStart -= s2.formatted.indexOf(e21)), s2.formatted = e21 + pd(t2.endOfLine);
  }
  if (t2.cursorOffset >= 0) {
    let e21, n3, r3, o3, a2;
    if (t2.cursorNode && s2.cursorNodeText ? (e21 = t2.locStart(t2.cursorNode), n3 = i2.slice(e21, t2.locEnd(t2.cursorNode)), r3 = t2.cursorOffset - e21, o3 = s2.cursorNodeStart, a2 = s2.cursorNodeText) : (e21 = 0, n3 = i2, r3 = t2.cursorOffset, o3 = 0, a2 = s2.formatted), n3 === a2)
      return { formatted: s2.formatted, cursorOffset: o3 + r3, comments: u2 };
    const c2 = [...n3];
    c2.splice(r3, 0, gd);
    const l2 = [...a2], p2 = mn$2.diffArrays(c2, l2);
    let f2 = o3;
    for (const e22 of p2)
      if (e22.removed) {
        if (e22.value.includes(gd))
          break;
      } else
        f2 += e22.count;
    return { formatted: s2.formatted, cursorOffset: f2, comments: u2 };
  }
  return { formatted: s2.formatted, cursorOffset: -1, comments: u2 };
}
function Dd(e20, t2, n2) {
  return typeof t2 != "number" || Number.isNaN(t2) || t2 < 0 || t2 > e20.length ? n2 : t2;
}
function Ed(e20, t2) {
  let { cursorOffset: n2, rangeStart: r2, rangeEnd: i2 } = t2;
  return n2 = Dd(e20, n2, -1), r2 = Dd(e20, r2, 0), i2 = Dd(e20, i2, e20.length), Object.assign(Object.assign({}, t2), {}, { cursorOffset: n2, rangeStart: r2, rangeEnd: i2 });
}
function Cd(e20, t2) {
  let {
    cursorOffset: n2,
    rangeStart: r2,
    rangeEnd: i2,
    endOfLine: u2
  } = Ed(e20, t2);
  const o2 = e20.charAt(0) === "\uFEFF";
  if (o2 && (e20 = e20.slice(1), n2--, r2--, i2--), u2 === "auto" && (u2 = ld(e20)), e20.includes("\r")) {
    const t3 = (t4) => fd(e20.slice(0, Math.max(t4, 0)), "\r\n");
    n2 -= t3(n2), r2 -= t3(r2), i2 -= t3(i2), e20 = dd(e20);
  }
  return {
    hasBOM: o2,
    text: e20,
    options: Ed(e20, Object.assign(Object.assign({}, t2), {}, { cursorOffset: n2, rangeStart: r2, rangeEnd: i2, endOfLine: u2 }))
  };
}
function bd(e20, t2) {
  const n2 = lp.resolveParser(t2);
  return !n2.hasPragma || n2.hasPragma(e20);
}
function Ad(e20, t2) {
  let n2, { hasBOM: r2, text: i2, options: u2 } = Cd(e20, hd(t2));
  return u2.rangeStart >= u2.rangeEnd && i2 !== "" || u2.requirePragma && !bd(i2, u2) ? { formatted: e20, cursorOffset: t2.cursorOffset, comments: [] } : (u2.rangeStart > 0 || u2.rangeEnd < i2.length ? n2 = function(e21, t3) {
    const { ast: n3, text: r3 } = lp.parse(e21, t3), { rangeStart: i3, rangeEnd: u3 } = od.calculateRange(r3, t3, n3), o2 = r3.slice(i3, u3), s2 = Math.min(i3, r3.lastIndexOf("\n", i3) + 1), a2 = r3.slice(s2, i3).match(/^\s*/)[0], c2 = cd(a2, t3.tabWidth), l2 = yd(o2, Object.assign(Object.assign({}, t3), {}, {
      rangeStart: 0,
      rangeEnd: Number.POSITIVE_INFINITY,
      cursorOffset: t3.cursorOffset > i3 && t3.cursorOffset <= u3 ? t3.cursorOffset - i3 : -1,
      endOfLine: "lf"
    }), c2), p2 = l2.formatted.trimEnd();
    let { cursorOffset: f2 } = t3;
    f2 > u3 ? f2 += p2.length - o2.length : l2.cursorOffset >= 0 && (f2 = l2.cursorOffset + i3);
    let d2 = r3.slice(0, i3) + p2 + r3.slice(u3);
    if (t3.endOfLine !== "lf") {
      const e22 = pd(t3.endOfLine);
      f2 >= 0 && e22 === "\r\n" && (f2 += fd(d2.slice(0, f2), "\n")), d2 = d2.replace(/\n/g, e22);
    }
    return {
      formatted: d2,
      cursorOffset: f2,
      comments: l2.comments
    };
  }(i2, u2) : (!u2.requirePragma && u2.insertPragma && u2.printer.insertPragma && !bd(i2, u2) && (i2 = u2.printer.insertPragma(i2)), n2 = yd(i2, u2)), r2 && (n2.formatted = "\uFEFF" + n2.formatted, n2.cursorOffset >= 0 && n2.cursorOffset++), n2);
}
var vd = {
  formatWithCursor: Ad,
  parse(e20, t2, n2) {
    const { text: r2, options: i2 } = Cd(e20, hd(t2)), u2 = lp.parse(r2, i2);
    return n2 && (u2.ast = yp(u2.ast, i2)), u2;
  },
  formatAST(e20, t2) {
    t2 = hd(t2);
    const n2 = ed(e20, t2);
    return sd(n2, t2);
  },
  formatDoc: (e20, t2) => Ad(ad(e20), Object.assign(Object.assign({}, t2), {}, { parser: "__js_expression" })).formatted,
  printToDoc(e20, t2) {
    t2 = hd(t2);
    const { ast: n2, text: r2 } = lp.parse(e20, t2);
    return md(r2, n2, t2), ed(n2, t2);
  },
  printDocToString: (e20, t2) => sd(e20, hd(t2))
};
const {
  getMaxContinuousCount: Fd,
  getStringWidth: Sd,
  getAlignmentSize: xd,
  getIndentSize: wd,
  skip: Td,
  skipWhitespace: Bd,
  skipSpaces: Nd,
  skipNewline: kd,
  skipToLineEnd: Pd,
  skipEverythingButNewLine: Od,
  skipInlineComment: Id,
  skipTrailingComment: Ld,
  hasNewline: jd,
  hasNewlineInRange: _d$2,
  hasSpaces: Md,
  isNextLineEmpty: Rd,
  isNextLineEmptyAfterIndex: $d,
  isPreviousLineEmpty: Vd,
  getNextNonSpaceNonCommentCharacterIndex: Wd,
  makeString: qd,
  addLeadingComment: Ud,
  addDanglingComment: zd,
  addTrailingComment: Gd
} = yi$2;
var Hd = {
  getMaxContinuousCount: Fd,
  getStringWidth: Sd,
  getAlignmentSize: xd,
  getIndentSize: wd,
  skip: Td,
  skipWhitespace: Bd,
  skipSpaces: Nd,
  skipNewline: kd,
  skipToLineEnd: Pd,
  skipEverythingButNewLine: Od,
  skipInlineComment: Id,
  skipTrailingComment: Ld,
  hasNewline: jd,
  hasNewlineInRange: _d$2,
  hasSpaces: Md,
  isNextLineEmpty: Rd,
  isNextLineEmptyAfterIndex: $d,
  isPreviousLineEmpty: Vd,
  getNextNonSpaceNonCommentCharacterIndex: Wd,
  makeString: qd,
  addLeadingComment: Ud,
  addDanglingComment: zd,
  addTrailingComment: Gd
};
const Jd = ["languageId"];
var Xd = function(e20, t2) {
  const { languageId: n2 } = e20, r2 = jn$2(e20, Jd);
  return Object.assign(Object.assign({ linguistLanguageId: n2 }, r2), t2(e20));
}, Yd = r$3(function(e20) {
  !function() {
    function t2(e21) {
      if (e21 == null)
        return false;
      switch (e21.type) {
        case "BlockStatement":
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "ForInStatement":
        case "ForStatement":
        case "IfStatement":
        case "LabeledStatement":
        case "ReturnStatement":
        case "SwitchStatement":
        case "ThrowStatement":
        case "TryStatement":
        case "VariableDeclaration":
        case "WhileStatement":
        case "WithStatement":
          return true;
      }
      return false;
    }
    function n2(e21) {
      switch (e21.type) {
        case "IfStatement":
          return e21.alternate != null ? e21.alternate : e21.consequent;
        case "LabeledStatement":
        case "ForStatement":
        case "ForInStatement":
        case "WhileStatement":
        case "WithStatement":
          return e21.body;
      }
      return null;
    }
    e20.exports = {
      isExpression: function(e21) {
        if (e21 == null)
          return false;
        switch (e21.type) {
          case "ArrayExpression":
          case "AssignmentExpression":
          case "BinaryExpression":
          case "CallExpression":
          case "ConditionalExpression":
          case "FunctionExpression":
          case "Identifier":
          case "Literal":
          case "LogicalExpression":
          case "MemberExpression":
          case "NewExpression":
          case "ObjectExpression":
          case "SequenceExpression":
          case "ThisExpression":
          case "UnaryExpression":
          case "UpdateExpression":
            return true;
        }
        return false;
      },
      isStatement: t2,
      isIterationStatement: function(e21) {
        if (e21 == null)
          return false;
        switch (e21.type) {
          case "DoWhileStatement":
          case "ForInStatement":
          case "ForStatement":
          case "WhileStatement":
            return true;
        }
        return false;
      },
      isSourceElement: function(e21) {
        return t2(e21) || e21 != null && e21.type === "FunctionDeclaration";
      },
      isProblematicIfStatement: function(e21) {
        var t3;
        if (e21.type !== "IfStatement")
          return false;
        if (e21.alternate == null)
          return false;
        t3 = e21.consequent;
        do {
          if (t3.type === "IfStatement" && t3.alternate == null)
            return true;
          t3 = n2(t3);
        } while (t3);
        return false;
      },
      trailingStatement: n2
    };
  }();
}), Kd = r$3(function(e20) {
  !function() {
    var t2, n2, r2, i2, u2, o2;
    function s2(e21) {
      return e21 <= 65535 ? String.fromCharCode(e21) : String.fromCharCode(Math.floor((e21 - 65536) / 1024) + 55296) + String.fromCharCode((e21 - 65536) % 1024 + 56320);
    }
    for (n2 = {
      NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
      NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
    }, t2 = {
      NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
      NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
    }, r2 = [
      5760,
      8192,
      8193,
      8194,
      8195,
      8196,
      8197,
      8198,
      8199,
      8200,
      8201,
      8202,
      8239,
      8287,
      12288,
      65279
    ], i2 = new Array(128), o2 = 0; o2 < 128; ++o2)
      i2[o2] = o2 >= 97 && o2 <= 122 || o2 >= 65 && o2 <= 90 || o2 === 36 || o2 === 95;
    for (u2 = new Array(128), o2 = 0; o2 < 128; ++o2)
      u2[o2] = o2 >= 97 && o2 <= 122 || o2 >= 65 && o2 <= 90 || o2 >= 48 && o2 <= 57 || o2 === 36 || o2 === 95;
    e20.exports = {
      isDecimalDigit: function(e21) {
        return 48 <= e21 && e21 <= 57;
      },
      isHexDigit: function(e21) {
        return 48 <= e21 && e21 <= 57 || 97 <= e21 && e21 <= 102 || 65 <= e21 && e21 <= 70;
      },
      isOctalDigit: function(e21) {
        return e21 >= 48 && e21 <= 55;
      },
      isWhiteSpace: function(e21) {
        return e21 === 32 || e21 === 9 || e21 === 11 || e21 === 12 || e21 === 160 || e21 >= 5760 && r2.indexOf(e21) >= 0;
      },
      isLineTerminator: function(e21) {
        return e21 === 10 || e21 === 13 || e21 === 8232 || e21 === 8233;
      },
      isIdentifierStartES5: function(e21) {
        return e21 < 128 ? i2[e21] : n2.NonAsciiIdentifierStart.test(s2(e21));
      },
      isIdentifierPartES5: function(e21) {
        return e21 < 128 ? u2[e21] : n2.NonAsciiIdentifierPart.test(s2(e21));
      },
      isIdentifierStartES6: function(e21) {
        return e21 < 128 ? i2[e21] : t2.NonAsciiIdentifierStart.test(s2(e21));
      },
      isIdentifierPartES6: function(e21) {
        return e21 < 128 ? u2[e21] : t2.NonAsciiIdentifierPart.test(s2(e21));
      }
    };
  }();
}), Qd = r$3(function(e20) {
  !function() {
    var t2 = Kd;
    function n2(e21, t3) {
      return !(!t3 && e21 === "yield") && r2(e21, t3);
    }
    function r2(e21, t3) {
      if (t3 && function(e22) {
        switch (e22) {
          case "implements":
          case "interface":
          case "package":
          case "private":
          case "protected":
          case "public":
          case "static":
          case "let":
            return true;
          default:
            return false;
        }
      }(e21))
        return true;
      switch (e21.length) {
        case 2:
          return e21 === "if" || e21 === "in" || e21 === "do";
        case 3:
          return e21 === "var" || e21 === "for" || e21 === "new" || e21 === "try";
        case 4:
          return e21 === "this" || e21 === "else" || e21 === "case" || e21 === "void" || e21 === "with" || e21 === "enum";
        case 5:
          return e21 === "while" || e21 === "break" || e21 === "catch" || e21 === "throw" || e21 === "const" || e21 === "yield" || e21 === "class" || e21 === "super";
        case 6:
          return e21 === "return" || e21 === "typeof" || e21 === "delete" || e21 === "switch" || e21 === "export" || e21 === "import";
        case 7:
          return e21 === "default" || e21 === "finally" || e21 === "extends";
        case 8:
          return e21 === "function" || e21 === "continue" || e21 === "debugger";
        case 10:
          return e21 === "instanceof";
        default:
          return false;
      }
    }
    function i2(e21, t3) {
      return e21 === "null" || e21 === "true" || e21 === "false" || n2(e21, t3);
    }
    function u2(e21, t3) {
      return e21 === "null" || e21 === "true" || e21 === "false" || r2(e21, t3);
    }
    function o2(e21) {
      var n3, r3, i3;
      if (e21.length === 0)
        return false;
      if (i3 = e21.charCodeAt(0), !t2.isIdentifierStartES5(i3))
        return false;
      for (n3 = 1, r3 = e21.length; n3 < r3; ++n3)
        if (i3 = e21.charCodeAt(n3), !t2.isIdentifierPartES5(i3))
          return false;
      return true;
    }
    function s2(e21) {
      var n3, r3, i3, u3, o3;
      if (e21.length === 0)
        return false;
      for (o3 = t2.isIdentifierStartES6, n3 = 0, r3 = e21.length; n3 < r3; ++n3) {
        if (55296 <= (i3 = e21.charCodeAt(n3)) && i3 <= 56319) {
          if (++n3 >= r3)
            return false;
          if (!(56320 <= (u3 = e21.charCodeAt(n3)) && u3 <= 57343))
            return false;
          i3 = 1024 * (i3 - 55296) + (u3 - 56320) + 65536;
        }
        if (!o3(i3))
          return false;
        o3 = t2.isIdentifierPartES6;
      }
      return true;
    }
    e20.exports = {
      isKeywordES5: n2,
      isKeywordES6: r2,
      isReservedWordES5: i2,
      isReservedWordES6: u2,
      isRestrictedWord: function(e21) {
        return e21 === "eval" || e21 === "arguments";
      },
      isIdentifierNameES5: o2,
      isIdentifierNameES6: s2,
      isIdentifierES5: function(e21, t3) {
        return o2(e21) && !i2(e21, t3);
      },
      isIdentifierES6: function(e21, t3) {
        return s2(e21) && !u2(e21, t3);
      }
    };
  }();
});
const Zd = r$3(function(e20, t2) {
  t2.ast = Yd, t2.code = Kd, t2.keyword = Qd;
}).keyword.isIdentifierNameES5, {
  getLast: eh,
  hasNewline: th,
  skipWhitespace: nh,
  isNonEmptyArray: rh,
  isNextLineEmptyAfterIndex: ih,
  getStringWidth: uh
} = yi$2, { locStart: oh, locEnd: sh, hasSameLocStart: ah } = zc, ch = new RegExp("^(?:(?=.)\\s)*:"), lh = new RegExp("^(?:(?=.)\\s)*::");
function ph(e20) {
  return e20.type === "Block" || e20.type === "CommentBlock" || e20.type === "MultiLine";
}
function fh(e20) {
  return e20.type === "Line" || e20.type === "CommentLine" || e20.type === "SingleLine" || e20.type === "HashbangComment" || e20.type === "HTMLOpen" || e20.type === "HTMLClose";
}
const dh = new Set([
  "ExportDefaultDeclaration",
  "ExportDefaultSpecifier",
  "DeclareExportDeclaration",
  "ExportNamedDeclaration",
  "ExportAllDeclaration"
]);
function hh(e20) {
  return e20 && dh.has(e20.type);
}
function gh(e20) {
  return e20.type === "NumericLiteral" || e20.type === "Literal" && typeof e20.value == "number";
}
function mh(e20) {
  return e20.type === "StringLiteral" || e20.type === "Literal" && typeof e20.value == "string";
}
function yh(e20) {
  return e20.type === "FunctionExpression" || e20.type === "ArrowFunctionExpression";
}
function Dh(e20) {
  return Sh(e20) && e20.callee.type === "Identifier" && (e20.callee.name === "async" || e20.callee.name === "inject" || e20.callee.name === "fakeAsync");
}
function Eh(e20) {
  return e20.type === "JSXElement" || e20.type === "JSXFragment";
}
function Ch(e20) {
  return e20.kind === "get" || e20.kind === "set";
}
function bh(e20) {
  return Ch(e20) || ah(e20, e20.value);
}
const Ah = new Set([
  "BinaryExpression",
  "LogicalExpression",
  "NGPipeExpression"
]);
const vh = new Set([
  "AnyTypeAnnotation",
  "TSAnyKeyword",
  "NullLiteralTypeAnnotation",
  "TSNullKeyword",
  "ThisTypeAnnotation",
  "TSThisType",
  "NumberTypeAnnotation",
  "TSNumberKeyword",
  "VoidTypeAnnotation",
  "TSVoidKeyword",
  "BooleanTypeAnnotation",
  "TSBooleanKeyword",
  "BigIntTypeAnnotation",
  "TSBigIntKeyword",
  "SymbolTypeAnnotation",
  "TSSymbolKeyword",
  "StringTypeAnnotation",
  "TSStringKeyword",
  "BooleanLiteralTypeAnnotation",
  "StringLiteralTypeAnnotation",
  "BigIntLiteralTypeAnnotation",
  "NumberLiteralTypeAnnotation",
  "TSLiteralType",
  "TSTemplateLiteralType",
  "EmptyTypeAnnotation",
  "MixedTypeAnnotation",
  "TSNeverKeyword",
  "TSObjectKeyword",
  "TSUndefinedKeyword",
  "TSUnknownKeyword"
]);
const Fh = /^(?:skip|[fx]?(?:it|describe|test))$/;
function Sh(e20) {
  return e20 && (e20.type === "CallExpression" || e20.type === "OptionalCallExpression");
}
function xh(e20) {
  return e20 && (e20.type === "MemberExpression" || e20.type === "OptionalMemberExpression");
}
function wh(e20) {
  return /^(?:\d+|\d+\.\d+)$/.test(e20);
}
function Th(e20) {
  return e20.quasis.some((e21) => e21.value.raw.includes("\n"));
}
function Bh(e20) {
  return e20.extra ? e20.extra.raw : e20.raw;
}
const Nh = { "==": true, "!=": true, "===": true, "!==": true }, kh = { "*": true, "/": true, "%": true }, Ph = { ">>": true, ">>>": true, "<<": true };
const Oh = {};
for (const [e20, t2] of [
  ["|>"],
  ["??"],
  ["||"],
  ["&&"],
  ["|"],
  ["^"],
  ["&"],
  ["==", "===", "!=", "!=="],
  ["<", ">", "<=", ">=", "in", "instanceof"],
  [">>", "<<", ">>>"],
  ["+", "-"],
  ["*", "/", "%"],
  ["**"]
].entries())
  for (const n2 of t2)
    Oh[n2] = e20;
function Ih(e20) {
  return Oh[e20];
}
const Lh = new WeakMap();
function jh(e20) {
  if (Lh.has(e20))
    return Lh.get(e20);
  const t2 = [];
  return e20.this && t2.push(e20.this), Array.isArray(e20.parameters) ? t2.push(...e20.parameters) : Array.isArray(e20.params) && t2.push(...e20.params), e20.rest && t2.push(e20.rest), Lh.set(e20, t2), t2;
}
const _h = new WeakMap();
function Mh(e20) {
  if (_h.has(e20))
    return _h.get(e20);
  let t2 = e20.arguments;
  return e20.type === "ImportExpression" && (t2 = [e20.source], e20.attributes && t2.push(e20.attributes)), _h.set(e20, t2), t2;
}
function Rh(e20) {
  return e20.value.trim() === "prettier-ignore" && !e20.unignore;
}
function $h(e20) {
  return e20 && (e20.prettierIgnore || qh(e20, Vh.PrettierIgnore));
}
const Vh = {
  Leading: 2,
  Trailing: 4,
  Dangling: 8,
  Block: 16,
  Line: 32,
  PrettierIgnore: 64,
  First: 128,
  Last: 256
}, Wh = (e20, t2) => {
  if (typeof e20 == "function" && (t2 = e20, e20 = 0), e20 || t2)
    return (n2, r2, i2) => !(e20 & Vh.Leading && !n2.leading || e20 & Vh.Trailing && !n2.trailing || e20 & Vh.Dangling && (n2.leading || n2.trailing) || e20 & Vh.Block && !ph(n2) || e20 & Vh.Line && !fh(n2) || e20 & Vh.First && r2 !== 0 || e20 & Vh.Last && r2 !== i2.length - 1 || e20 & Vh.PrettierIgnore && !Rh(n2) || t2 && !t2(n2));
};
function qh(e20, t2, n2) {
  if (!e20 || !rh(e20.comments))
    return false;
  const r2 = Wh(t2, n2);
  return !r2 || e20.comments.some(r2);
}
function Uh(e20, t2, n2) {
  if (!e20 || !Array.isArray(e20.comments))
    return [];
  const r2 = Wh(t2, n2);
  return r2 ? e20.comments.filter(r2) : e20.comments;
}
function zh(e20) {
  return Sh(e20) || e20.type === "NewExpression" || e20.type === "ImportExpression";
}
var Gh = {
  getFunctionParameters: jh,
  iterateFunctionParametersPath: function(e20, t2) {
    const n2 = e20.getValue();
    let r2 = 0;
    const i2 = (e21) => t2(e21, r2++);
    n2.this && e20.call(i2, "this"), Array.isArray(n2.parameters) ? e20.each(i2, "parameters") : Array.isArray(n2.params) && e20.each(i2, "params"), n2.rest && e20.call(i2, "rest");
  },
  getCallArguments: Mh,
  iterateCallArgumentsPath: function(e20, t2) {
    const n2 = e20.getValue();
    n2.type === "ImportExpression" ? (e20.call((e21) => t2(e21, 0), "source"), n2.attributes && e20.call((e21) => t2(e21, 1), "attributes")) : e20.each(t2, "arguments");
  },
  hasRestParameter: function(e20) {
    if (e20.rest)
      return true;
    const t2 = jh(e20);
    return t2.length > 0 && eh(t2).type === "RestElement";
  },
  getLeftSide: function(e20) {
    return e20.expressions ? e20.expressions[0] : e20.left || e20.test || e20.callee || e20.object || e20.tag || e20.argument || e20.expression;
  },
  getLeftSidePathName: function(e20, t2) {
    if (t2.expressions)
      return ["expressions", 0];
    if (t2.left)
      return ["left"];
    if (t2.test)
      return ["test"];
    if (t2.object)
      return ["object"];
    if (t2.callee)
      return ["callee"];
    if (t2.tag)
      return ["tag"];
    if (t2.argument)
      return ["argument"];
    if (t2.expression)
      return ["expression"];
    throw new Error("Unexpected node has no left side.");
  },
  getParentExportDeclaration: function(e20) {
    const t2 = e20.getParentNode();
    return e20.getName() === "declaration" && hh(t2) ? t2 : null;
  },
  getTypeScriptMappedTypeModifier: function(e20, t2) {
    return e20 === "+" ? "+" + t2 : e20 === "-" ? "-" + t2 : t2;
  },
  hasFlowAnnotationComment: function(e20) {
    return rh(e20) && ph(e20[0]) && lh.test(e20[0].value);
  },
  hasFlowShorthandAnnotationComment: function(e20) {
    return e20.extra && e20.extra.parenthesized && rh(e20.trailingComments) && ph(e20.trailingComments[0]) && ch.test(e20.trailingComments[0].value);
  },
  hasLeadingOwnLineComment: function(e20, t2) {
    return Eh(t2) ? $h(t2) : qh(t2, Vh.Leading, (t3) => th(e20, sh(t3)));
  },
  hasNakedLeftSide: function(e20) {
    return e20.type === "AssignmentExpression" || e20.type === "BinaryExpression" || e20.type === "LogicalExpression" || e20.type === "NGPipeExpression" || e20.type === "ConditionalExpression" || Sh(e20) || xh(e20) || e20.type === "SequenceExpression" || e20.type === "TaggedTemplateExpression" || e20.type === "BindExpression" || e20.type === "UpdateExpression" && !e20.prefix || e20.type === "TSAsExpression" || e20.type === "TSNonNullExpression";
  },
  hasNode: function e3(t2, n2) {
    if (!t2 || typeof t2 != "object")
      return false;
    if (Array.isArray(t2))
      return t2.some((t3) => e3(t3, n2));
    const r2 = n2(t2);
    return typeof r2 == "boolean" ? r2 : Object.values(t2).some((t3) => e3(t3, n2));
  },
  hasIgnoreComment: function(e20) {
    return $h(e20.getValue());
  },
  hasNodeIgnoreComment: $h,
  identity: function(e20) {
    return e20;
  },
  isBinaryish: function(e20) {
    return Ah.has(e20.type);
  },
  isBlockComment: ph,
  isCallLikeExpression: zh,
  isLineComment: fh,
  isPrettierIgnoreComment: Rh,
  isCallExpression: Sh,
  isMemberExpression: xh,
  isExportDeclaration: hh,
  isFlowAnnotationComment: function(e20, t2) {
    const n2 = oh(t2), r2 = nh(e20, sh(t2));
    return r2 !== false && e20.slice(n2, n2 + 2) === "/*" && e20.slice(r2, r2 + 2) === "*/";
  },
  isFunctionCompositionArgs: function(e20) {
    if (e20.length <= 1)
      return false;
    let t2 = 0;
    for (const n2 of e20)
      if (yh(n2)) {
        if (t2 += 1, t2 > 1)
          return true;
      } else if (Sh(n2)) {
        for (const e21 of n2.arguments)
          if (yh(e21))
            return true;
      }
    return false;
  },
  isFunctionNotation: bh,
  isFunctionOrArrowExpression: yh,
  isGetterOrSetter: Ch,
  isJestEachTemplateLiteral: function(e20, t2) {
    const n2 = /^[fx]?(?:describe|it|test)$/;
    return t2.type === "TaggedTemplateExpression" && t2.quasi === e20 && t2.tag.type === "MemberExpression" && t2.tag.property.type === "Identifier" && t2.tag.property.name === "each" && (t2.tag.object.type === "Identifier" && n2.test(t2.tag.object.name) || t2.tag.object.type === "MemberExpression" && t2.tag.object.property.type === "Identifier" && (t2.tag.object.property.name === "only" || t2.tag.object.property.name === "skip") && t2.tag.object.object.type === "Identifier" && n2.test(t2.tag.object.object.name));
  },
  isJsxNode: Eh,
  isLiteral: function(e20) {
    return e20.type === "BooleanLiteral" || e20.type === "DirectiveLiteral" || e20.type === "Literal" || e20.type === "NullLiteral" || e20.type === "NumericLiteral" || e20.type === "BigIntLiteral" || e20.type === "DecimalLiteral" || e20.type === "RegExpLiteral" || e20.type === "StringLiteral" || e20.type === "TemplateLiteral" || e20.type === "TSTypeLiteral" || e20.type === "JSXText";
  },
  isLongCurriedCallExpression: function(e20) {
    const t2 = e20.getValue(), n2 = e20.getParentNode();
    return Sh(t2) && Sh(n2) && n2.callee === t2 && t2.arguments.length > n2.arguments.length && n2.arguments.length > 0;
  },
  isSimpleCallArgument: function e4(t2, n2) {
    if (n2 >= 2)
      return false;
    const r2 = (t3) => e4(t3, n2 + 1), i2 = t2.type === "Literal" && "regex" in t2 && t2.regex.pattern || t2.type === "RegExpLiteral" && t2.pattern;
    return !(i2 && uh(i2) > 5) && (t2.type === "Literal" || t2.type === "BigIntLiteral" || t2.type === "DecimalLiteral" || t2.type === "BooleanLiteral" || t2.type === "NullLiteral" || t2.type === "NumericLiteral" || t2.type === "RegExpLiteral" || t2.type === "StringLiteral" || t2.type === "Identifier" || t2.type === "ThisExpression" || t2.type === "Super" || t2.type === "PrivateName" || t2.type === "PrivateIdentifier" || t2.type === "ArgumentPlaceholder" || t2.type === "Import" || (t2.type === "TemplateLiteral" ? t2.quasis.every((e20) => !e20.value.raw.includes("\n")) && t2.expressions.every(r2) : t2.type === "ObjectExpression" ? t2.properties.every((e20) => !e20.computed && (e20.shorthand || e20.value && r2(e20.value))) : t2.type === "ArrayExpression" ? t2.elements.every((e20) => e20 === null || r2(e20)) : zh(t2) ? (t2.type === "ImportExpression" || e4(t2.callee, n2)) && Mh(t2).every(r2) : xh(t2) ? e4(t2.object, n2) && e4(t2.property, n2) : t2.type !== "UnaryExpression" || t2.operator !== "!" && t2.operator !== "-" ? t2.type === "TSNonNullExpression" && e4(t2.expression, n2) : e4(t2.argument, n2)));
  },
  isMemberish: function(e20) {
    return xh(e20) || e20.type === "BindExpression" && Boolean(e20.object);
  },
  isNumericLiteral: gh,
  isSignedNumericLiteral: function(e20) {
    return e20.type === "UnaryExpression" && (e20.operator === "+" || e20.operator === "-") && gh(e20.argument);
  },
  isObjectProperty: function(e20) {
    return e20 && (e20.type === "ObjectProperty" || e20.type === "Property" && !e20.method && e20.kind === "init");
  },
  isObjectType: function(e20) {
    return e20.type === "ObjectTypeAnnotation" || e20.type === "TSTypeLiteral" || e20.type === "TSMappedType";
  },
  isObjectTypePropertyAFunction: function(e20) {
    return !(e20.type !== "ObjectTypeProperty" && e20.type !== "ObjectTypeInternalSlot" || e20.value.type !== "FunctionTypeAnnotation" || e20.static || bh(e20));
  },
  isSimpleType: function(e20) {
    return !!e20 && (!(e20.type !== "GenericTypeAnnotation" && e20.type !== "TSTypeReference" || e20.typeParameters) || !!vh.has(e20.type));
  },
  isSimpleNumber: wh,
  isSimpleTemplateLiteral: function(e20) {
    let t2 = "expressions";
    e20.type === "TSTemplateLiteralType" && (t2 = "types");
    const n2 = e20[t2];
    return n2.length !== 0 && n2.every((e21) => {
      if (qh(e21))
        return false;
      if (e21.type === "Identifier" || e21.type === "ThisExpression")
        return true;
      if (xh(e21)) {
        let t3 = e21;
        for (; xh(t3); ) {
          if (t3.property.type !== "Identifier" && t3.property.type !== "Literal" && t3.property.type !== "StringLiteral" && t3.property.type !== "NumericLiteral")
            return false;
          if (t3 = t3.object, qh(t3))
            return false;
        }
        return t3.type === "Identifier" || t3.type === "ThisExpression";
      }
      return false;
    });
  },
  isStringLiteral: mh,
  isStringPropSafeToUnquote: function(e20, t2) {
    return t2.parser !== "json" && mh(e20.key) && Bh(e20.key).slice(1, -1) === e20.key.value && (Zd(e20.key.value) && !((t2.parser === "typescript" || t2.parser === "babel-ts") && e20.type === "ClassProperty") || wh(e20.key.value) && String(Number(e20.key.value)) === e20.key.value && (t2.parser === "babel" || t2.parser === "espree" || t2.parser === "meriyah" || t2.parser === "__babel_estree"));
  },
  isTemplateOnItsOwnLine: function(e20, t2) {
    return (e20.type === "TemplateLiteral" && Th(e20) || e20.type === "TaggedTemplateExpression" && Th(e20.quasi)) && !th(t2, oh(e20), { backwards: true });
  },
  isTestCall: function e5(t2, n2) {
    if (t2.type !== "CallExpression")
      return false;
    if (t2.arguments.length === 1) {
      if (Dh(t2) && n2 && e5(n2))
        return yh(t2.arguments[0]);
      if (function(e20) {
        return e20.callee.type === "Identifier" && /^(?:before|after)(?:Each|All)$/.test(e20.callee.name) && e20.arguments.length === 1;
      }(t2))
        return Dh(t2.arguments[0]);
    } else if ((t2.arguments.length === 2 || t2.arguments.length === 3) && (t2.callee.type === "Identifier" && Fh.test(t2.callee.name) || function(e20) {
      return xh(e20.callee) && e20.callee.object.type === "Identifier" && e20.callee.property.type === "Identifier" && Fh.test(e20.callee.object.name) && (e20.callee.property.name === "only" || e20.callee.property.name === "skip");
    }(t2)) && (function(e20) {
      return e20.type === "TemplateLiteral";
    }(t2.arguments[0]) || mh(t2.arguments[0])))
      return !(t2.arguments[2] && !gh(t2.arguments[2])) && ((t2.arguments.length === 2 ? yh(t2.arguments[1]) : function(e20) {
        return e20.type === "FunctionExpression" || e20.type === "ArrowFunctionExpression" && e20.body.type === "BlockStatement";
      }(t2.arguments[1]) && jh(t2.arguments[1]).length <= 1) || Dh(t2.arguments[1]));
    return false;
  },
  isTheOnlyJsxElementInMarkdown: function(e20, t2) {
    if (e20.parentParser !== "markdown" && e20.parentParser !== "mdx")
      return false;
    const n2 = t2.getNode();
    if (!n2.expression || !Eh(n2.expression))
      return false;
    const r2 = t2.getParentNode();
    return r2.type === "Program" && r2.body.length === 1;
  },
  isTSXFile: function(e20) {
    return e20.filepath && /\.tsx$/i.test(e20.filepath);
  },
  isTypeAnnotationAFunction: function(e20) {
    return !(e20.type !== "TypeAnnotation" && e20.type !== "TSTypeAnnotation" || e20.typeAnnotation.type !== "FunctionTypeAnnotation" || e20.static || ah(e20, e20.typeAnnotation));
  },
  isNextLineEmpty: (e20, { originalText: t2 }) => ih(t2, sh(e20)),
  needsHardlineAfterDanglingComment: function(e20) {
    if (!qh(e20))
      return false;
    const t2 = eh(Uh(e20, Vh.Dangling));
    return t2 && !ph(t2);
  },
  rawText: Bh,
  shouldPrintComma: function(e20, t2 = "es5") {
    return e20.trailingComma === "es5" && t2 === "es5" || e20.trailingComma === "all" && (t2 === "all" || t2 === "es5");
  },
  isBitwiseOperator: function(e20) {
    return Boolean(Ph[e20]) || e20 === "|" || e20 === "^" || e20 === "&";
  },
  shouldFlatten: function(e20, t2) {
    return Ih(t2) === Ih(e20) && e20 !== "**" && (!Nh[e20] || !Nh[t2]) && !(t2 === "%" && kh[e20] || e20 === "%" && kh[t2]) && (t2 === e20 || !kh[t2] || !kh[e20]) && (!Ph[e20] || !Ph[t2]);
  },
  startsWithNoLookaheadToken: function e6(t2, n2) {
    switch ((t2 = function(e20) {
      for (; e20.left; )
        e20 = e20.left;
      return e20;
    }(t2)).type) {
      case "FunctionExpression":
      case "ClassExpression":
      case "DoExpression":
        return n2;
      case "ObjectExpression":
        return true;
      case "MemberExpression":
      case "OptionalMemberExpression":
        return e6(t2.object, n2);
      case "TaggedTemplateExpression":
        return t2.tag.type !== "FunctionExpression" && e6(t2.tag, n2);
      case "CallExpression":
      case "OptionalCallExpression":
        return t2.callee.type !== "FunctionExpression" && e6(t2.callee, n2);
      case "ConditionalExpression":
        return e6(t2.test, n2);
      case "UpdateExpression":
        return !t2.prefix && e6(t2.argument, n2);
      case "BindExpression":
        return t2.object && e6(t2.object, n2);
      case "SequenceExpression":
        return e6(t2.expressions[0], n2);
      case "TSAsExpression":
      case "TSNonNullExpression":
        return e6(t2.expression, n2);
      default:
        return false;
    }
  },
  getPrecedence: Ih,
  hasComment: qh,
  getComments: Uh,
  CommentCheckFlags: Vh
};
const { getStringWidth: Hh, getIndentSize: Jh } = yi$2, {
  builders: {
    join: Xh,
    hardline: Yh,
    softline: Kh,
    group: Qh,
    indent: Zh,
    align: eg,
    lineSuffixBoundary: tg,
    addAlignmentToDoc: ng
  },
  printer: { printDocToString: rg },
  utils: { mapDoc: ig }
} = eu$1, {
  isBinaryish: ug,
  isJestEachTemplateLiteral: og,
  isSimpleTemplateLiteral: sg,
  hasComment: ag,
  isMemberExpression: cg
} = Gh;
function lg(e20) {
  return e20.replace(/([\\`]|\${)/g, "\\$1");
}
var pg = {
  printTemplateLiteral: function(e20, t2, n2) {
    const r2 = e20.getValue();
    if (r2.type === "TemplateLiteral" && og(r2, e20.getParentNode())) {
      const r3 = function(e21, t3, n3) {
        const r4 = e21.getNode(), i3 = r4.quasis[0].value.raw.trim().split(/\s*\|\s*/);
        if (i3.length > 1 || i3.some((e22) => e22.length > 0)) {
          t3.__inJestEach = true;
          const u3 = e21.map(n3, "expressions");
          t3.__inJestEach = false;
          const o3 = [], s3 = u3.map((e22) => "${" + rg(e22, Object.assign(Object.assign({}, t3), {}, {
            printWidth: Number.POSITIVE_INFINITY,
            endOfLine: "lf"
          })).formatted + "}"), a2 = [{ hasLineBreak: false, cells: [] }];
          for (let e22 = 1; e22 < r4.quasis.length; e22++) {
            const t4 = Ln$2(a2), n4 = s3[e22 - 1];
            t4.cells.push(n4), n4.includes("\n") && (t4.hasLineBreak = true), r4.quasis[e22].value.raw.includes("\n") && a2.push({ hasLineBreak: false, cells: [] });
          }
          const c2 = Math.max(i3.length, ...a2.map((e22) => e22.cells.length)), l2 = Array.from({ length: c2 }).fill(0), p2 = [
            { cells: i3 },
            ...a2.filter((e22) => e22.cells.length > 0)
          ];
          for (const { cells: e22 } of p2.filter((e23) => !e23.hasLineBreak))
            for (const [t4, n4] of e22.entries())
              l2[t4] = Math.max(l2[t4], Hh(n4));
          return o3.push(tg, "`", Zh([
            Yh,
            Xh(Yh, p2.map((e22) => Xh(" | ", e22.cells.map((t4, n4) => e22.hasLineBreak ? t4 : t4 + " ".repeat(l2[n4] - Hh(t4))))))
          ]), Yh, "`"), o3;
        }
      }(e20, n2, t2);
      if (r3)
        return r3;
    }
    let i2 = "expressions";
    r2.type === "TSTemplateLiteralType" && (i2 = "types");
    const u2 = [];
    let o2 = e20.map(t2, i2);
    const s2 = sg(r2);
    return s2 && (o2 = o2.map((e21) => rg(e21, Object.assign(Object.assign({}, n2), {}, { printWidth: Number.POSITIVE_INFINITY })).formatted)), u2.push(tg, "`"), e20.each((e21) => {
      const a2 = e21.getName();
      if (u2.push(t2()), a2 < o2.length) {
        const { tabWidth: t3 } = n2, c2 = e21.getValue(), l2 = Jh(c2.value.raw, t3);
        let p2 = o2[a2];
        if (!s2) {
          const e22 = r2[i2][a2];
          (ag(e22) || cg(e22) || e22.type === "ConditionalExpression" || e22.type === "SequenceExpression" || e22.type === "TSAsExpression" || ug(e22)) && (p2 = [Zh([Kh, p2]), Kh]);
        }
        const f2 = l2 === 0 && c2.value.raw.endsWith("\n") ? eg(Number.NEGATIVE_INFINITY, p2) : ng(p2, l2, t3);
        u2.push(Qh(["${", f2, tg, "}"]));
      }
    }, "quasis"), u2.push("`"), u2;
  },
  printTemplateExpressions: function(e20, t2) {
    return e20.map((e21) => function(e22, t3) {
      const n2 = e22.getValue();
      let r2 = t3();
      return ag(n2) && (r2 = Qh([Zh([Kh, r2]), Kh])), ["${", r2, tg, "}"];
    }(e21, t2), "expressions");
  },
  escapeTemplateCharacters: function(e20, t2) {
    return ig(e20, (e21) => typeof e21 == "string" ? t2 ? e21.replace(/(\\*)`/g, "$1$1\\`") : lg(e21) : e21);
  },
  uncookTemplateElementValue: lg
};
const {
  builders: {
    indent: fg,
    softline: dg,
    literalline: hg,
    dedentToRoot: gg
  }
} = eu$1, { escapeTemplateCharacters: mg } = pg;
var yg = function(e20, t2, n2) {
  let r2 = e20.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, (e21, t3) => "\\".repeat(t3.length / 2) + "`");
  const i2 = function(e21) {
    const t3 = e21.match(/^([^\S\n]*)\S/m);
    return t3 === null ? "" : t3[1];
  }(r2), u2 = i2 !== "";
  u2 && (r2 = r2.replace(new RegExp(`^${i2}`, "gm"), ""));
  const o2 = mg(n2(r2, { parser: "markdown", __inJsTemplate: true }, { stripTrailingHardline: true }), true);
  return ["`", u2 ? fg([dg, o2]) : [hg, gg(o2)], dg, "`"];
};
const { isNonEmptyArray: Dg } = yi$2, {
  builders: { indent: Eg, hardline: Cg, softline: bg },
  utils: { mapDoc: Ag, replaceEndOfLine: vg, cleanDoc: Fg }
} = eu$1, { printTemplateExpressions: Sg } = pg;
var xg = function(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = r2.quasis.map((e21) => e21.value.raw);
  let u2 = 0;
  return function(e21, t3, n3) {
    if (t3.quasis.length === 1 && !t3.quasis[0].value.raw.trim())
      return "``";
    const r3 = function(e22, t4) {
      if (!Dg(t4))
        return e22;
      let n4 = 0;
      const r4 = Ag(Fg(e22), (e23) => typeof e23 == "string" && e23.includes("@prettier-placeholder") ? e23.split(/@prettier-placeholder-(\d+)-id/).map((e24, r5) => r5 % 2 == 0 ? vg(e24) : (n4++, t4[e24])) : e23);
      return t4.length === n4 ? r4 : null;
    }(e21, n3);
    if (!r3)
      throw new Error("Couldn't insert all the expressions");
    return ["`", Eg([Cg, r3]), bg, "`"];
  }(n2(i2.reduce((e21, t3, n3) => n3 === 0 ? t3 : e21 + "@prettier-placeholder-" + u2++ + "-id" + t3, ""), { parser: "scss" }, { stripTrailingHardline: true }), r2, Sg(e20, t2));
};
const {
  builders: { indent: wg, join: Tg, hardline: Bg }
} = eu$1, { escapeTemplateCharacters: Ng, printTemplateExpressions: kg } = pg;
function Pg(e20) {
  const t2 = [];
  let n2 = false;
  const r2 = e20.map((e21) => e21.trim());
  for (const [e21, i2] of r2.entries())
    i2 !== "" && (r2[e21 - 1] === "" && n2 ? t2.push([Bg, i2]) : t2.push(i2), n2 = true);
  return t2.length === 0 ? null : Tg(Bg, t2);
}
var Og = function(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = r2.quasis.length;
  if (i2 === 1 && r2.quasis[0].value.raw.trim() === "")
    return "``";
  const u2 = kg(e20, t2), o2 = [];
  for (let e21 = 0; e21 < i2; e21++) {
    const t3 = e21 === 0, s2 = e21 === i2 - 1, a2 = r2.quasis[e21].value.cooked, c2 = a2.split("\n"), l2 = c2.length, p2 = u2[e21], f2 = l2 > 2 && c2[0].trim() === "" && c2[1].trim() === "", d2 = l2 > 2 && c2[l2 - 1].trim() === "" && c2[l2 - 2].trim() === "", h2 = c2.every((e22) => /^\s*(?:#[^\n\r]*)?$/.test(e22));
    if (!s2 && /#[^\n\r]*$/.test(c2[l2 - 1]))
      return null;
    let g2 = null;
    g2 = h2 ? Pg(c2) : n2(a2, { parser: "graphql" }, { stripTrailingHardline: true }), g2 ? (g2 = Ng(g2, false), !t3 && f2 && o2.push(""), o2.push(g2), !s2 && d2 && o2.push("")) : t3 || s2 || !f2 || o2.push(""), p2 && o2.push(p2);
  }
  return ["`", wg([Bg, Tg(Bg, o2)]), Bg, "`"];
};
const {
  builders: { indent: Ig, line: Lg, hardline: jg, group: _g },
  utils: { mapDoc: Mg }
} = eu$1, { printTemplateExpressions: Rg, uncookTemplateElementValue: $g } = pg;
let Vg = 0;
var Wg = function(e20, t2, n2, r2, { parser: i2 }) {
  const u2 = e20.getValue(), o2 = Vg;
  Vg = Vg + 1 >>> 0;
  const s2 = (e21) => `PRETTIER_HTML_PLACEHOLDER_${e21}_${o2}_IN_JS`, a2 = u2.quasis.map((e21, t3, n3) => t3 === n3.length - 1 ? e21.value.cooked : e21.value.cooked + s2(t3)).join(""), c2 = Rg(e20, t2);
  if (c2.length === 0 && a2.trim().length === 0)
    return "``";
  const l2 = new RegExp(s2("(\\d+)"), "g");
  let p2 = 0;
  const f2 = n2(a2, {
    parser: i2,
    __onHtmlRoot(e21) {
      p2 = e21.children.length;
    }
  }, { stripTrailingHardline: true }), d2 = Mg(f2, (e21) => {
    if (typeof e21 != "string")
      return e21;
    const t3 = [], n3 = e21.split(l2);
    for (let e22 = 0; e22 < n3.length; e22++) {
      let i3 = n3[e22];
      if (e22 % 2 == 0) {
        i3 && (i3 = $g(i3), r2.__embeddedInHtml && (i3 = i3.replace(/<\/(script)\b/gi, "<\\/$1")), t3.push(i3));
        continue;
      }
      const u3 = Number(i3);
      t3.push(c2[u3]);
    }
    return t3;
  }), h2 = /^\s/.test(a2) ? " " : "", g2 = /\s$/.test(a2) ? " " : "", m2 = r2.htmlWhitespaceSensitivity === "ignore" ? jg : h2 && g2 ? Lg : null;
  return _g(m2 ? ["`", Ig([m2, _g(d2)]), m2, "`"] : ["`", h2, p2 > 1 ? Ig(_g(d2)) : _g(d2), g2, "`"]);
};
const { hasComment: qg, CommentCheckFlags: Ug, isObjectProperty: zg } = Gh;
function Gg(e20) {
  return function(e21) {
    const t2 = e21.getValue(), n2 = e21.getParentNode(), r2 = e21.getParentNode(1);
    return r2 && t2.quasis && n2.type === "JSXExpressionContainer" && r2.type === "JSXElement" && r2.openingElement.name.name === "style" && r2.openingElement.attributes.some((e22) => e22.name.name === "jsx") || n2 && n2.type === "TaggedTemplateExpression" && n2.tag.type === "Identifier" && n2.tag.name === "css" || n2 && n2.type === "TaggedTemplateExpression" && n2.tag.type === "MemberExpression" && n2.tag.object.name === "css" && (n2.tag.property.name === "global" || n2.tag.property.name === "resolve");
  }(e20) || function(e21) {
    const t2 = e21.getParentNode();
    if (!t2 || t2.type !== "TaggedTemplateExpression")
      return false;
    const n2 = t2.tag.type === "ParenthesizedExpression" ? t2.tag.expression : t2.tag;
    switch (n2.type) {
      case "MemberExpression":
        return Jg(n2.object) || Xg(n2);
      case "CallExpression":
        return Jg(n2.callee) || n2.callee.type === "MemberExpression" && (n2.callee.object.type === "MemberExpression" && (Jg(n2.callee.object.object) || Xg(n2.callee.object)) || n2.callee.object.type === "CallExpression" && Jg(n2.callee.object.callee));
      case "Identifier":
        return n2.name === "css";
      default:
        return false;
    }
  }(e20) || function(e21) {
    const t2 = e21.getParentNode(), n2 = e21.getParentNode(1);
    return n2 && t2.type === "JSXExpressionContainer" && n2.type === "JSXAttribute" && n2.name.type === "JSXIdentifier" && n2.name.name === "css";
  }(e20) || function(e21) {
    return e21.match((e22) => e22.type === "TemplateLiteral", (e22, t2) => e22.type === "ArrayExpression" && t2 === "elements", (e22, t2) => zg(e22) && e22.key.type === "Identifier" && e22.key.name === "styles" && t2 === "value", ...Hg);
  }(e20) ? "css" : function(e21) {
    const t2 = e21.getValue(), n2 = e21.getParentNode();
    return Yg(t2, "GraphQL") || n2 && (n2.type === "TaggedTemplateExpression" && (n2.tag.type === "MemberExpression" && n2.tag.object.name === "graphql" && n2.tag.property.name === "experimental" || n2.tag.type === "Identifier" && (n2.tag.name === "gql" || n2.tag.name === "graphql")) || n2.type === "CallExpression" && n2.callee.type === "Identifier" && n2.callee.name === "graphql");
  }(e20) ? "graphql" : function(e21) {
    return Yg(e21.getValue(), "HTML") || e21.match((e22) => e22.type === "TemplateLiteral", (e22, t2) => e22.type === "TaggedTemplateExpression" && e22.tag.type === "Identifier" && e22.tag.name === "html" && t2 === "quasi");
  }(e20) ? "html" : function(e21) {
    return e21.match((e22) => e22.type === "TemplateLiteral", (e22, t2) => zg(e22) && e22.key.type === "Identifier" && e22.key.name === "template" && t2 === "value", ...Hg);
  }(e20) ? "angular" : function(e21) {
    const t2 = e21.getValue(), n2 = e21.getParentNode();
    return n2 && n2.type === "TaggedTemplateExpression" && t2.quasis.length === 1 && n2.tag.type === "Identifier" && (n2.tag.name === "md" || n2.tag.name === "markdown");
  }(e20) ? "markdown" : void 0;
}
const Hg = [
  (e20, t2) => e20.type === "ObjectExpression" && t2 === "properties",
  (e20, t2) => e20.type === "CallExpression" && e20.callee.type === "Identifier" && e20.callee.name === "Component" && t2 === "arguments",
  (e20, t2) => e20.type === "Decorator" && t2 === "expression"
];
function Jg(e20) {
  return e20.type === "Identifier" && e20.name === "styled";
}
function Xg(e20) {
  return /^[A-Z]/.test(e20.object.name) && e20.property.name === "extend";
}
function Yg(e20, t2) {
  return qg(e20, Ug.Block | Ug.Leading, ({ value: e21 }) => e21 === ` ${t2} `);
}
var Kg = function(e20, t2, n2, r2) {
  const i2 = e20.getValue();
  if (i2.type !== "TemplateLiteral" || function({ quasis: e21 }) {
    return e21.some(({ value: { cooked: e22 } }) => e22 === null);
  }(i2))
    return;
  const u2 = Gg(e20);
  return u2 ? u2 === "markdown" ? yg(e20, t2, n2) : u2 === "css" ? xg(e20, t2, n2) : u2 === "graphql" ? Og(e20, t2, n2) : u2 === "html" || u2 === "angular" ? Wg(e20, t2, n2, r2, { parser: u2 }) : void 0 : void 0;
};
const { isBlockComment: Qg } = Gh, Zg = new Set([
  "range",
  "raw",
  "comments",
  "leadingComments",
  "trailingComments",
  "innerComments",
  "extra",
  "start",
  "end",
  "loc",
  "flags",
  "errors",
  "tokens"
]), em = (e20) => {
  for (const t2 of e20.quasis)
    delete t2.value;
};
function tm(e20, t2, n2) {
  if (e20.type === "Program" && delete t2.sourceType, e20.type !== "BigIntLiteral" && e20.type !== "BigIntLiteralTypeAnnotation" || t2.value && (t2.value = t2.value.toLowerCase()), e20.type !== "BigIntLiteral" && e20.type !== "Literal" || t2.bigint && (t2.bigint = t2.bigint.toLowerCase()), e20.type === "DecimalLiteral" && (t2.value = Number(t2.value)), e20.type === "Literal" && t2.decimal && (t2.decimal = Number(t2.decimal)), e20.type === "EmptyStatement")
    return null;
  if (e20.type === "JSXText")
    return null;
  if (e20.type === "JSXExpressionContainer" && (e20.expression.type === "Literal" || e20.expression.type === "StringLiteral") && e20.expression.value === " ")
    return null;
  if (e20.type !== "Property" && e20.type !== "ObjectProperty" && e20.type !== "MethodDefinition" && e20.type !== "ClassProperty" && e20.type !== "ClassMethod" && e20.type !== "PropertyDefinition" && e20.type !== "TSDeclareMethod" && e20.type !== "TSPropertySignature" && e20.type !== "ObjectTypeProperty" || typeof e20.key != "object" || !e20.key || e20.key.type !== "Literal" && e20.key.type !== "NumericLiteral" && e20.key.type !== "StringLiteral" && e20.key.type !== "Identifier" || delete t2.key, e20.type === "JSXElement" && e20.openingElement.name.name === "style" && e20.openingElement.attributes.some((e21) => e21.name.name === "jsx"))
    for (const { type: e21, expression: n3 } of t2.children)
      e21 === "JSXExpressionContainer" && n3.type === "TemplateLiteral" && em(n3);
  e20.type === "JSXAttribute" && e20.name.name === "css" && e20.value.type === "JSXExpressionContainer" && e20.value.expression.type === "TemplateLiteral" && em(t2.value.expression), e20.type === "JSXAttribute" && e20.value && e20.value.type === "Literal" && /["']|&quot;|&apos;/.test(e20.value.value) && (t2.value.value = t2.value.value.replace(/["']|&quot;|&apos;/g, '"'));
  const r2 = e20.expression || e20.callee;
  if (e20.type === "Decorator" && r2.type === "CallExpression" && r2.callee.name === "Component" && r2.arguments.length === 1) {
    const n3 = e20.expression.arguments[0].properties;
    for (const [e21, r3] of t2.expression.arguments[0].properties.entries())
      switch (n3[e21].key.name) {
        case "styles":
          r3.value.type === "ArrayExpression" && em(r3.value.elements[0]);
          break;
        case "template":
          r3.value.type === "TemplateLiteral" && em(r3.value);
      }
  }
  if (e20.type !== "TaggedTemplateExpression" || e20.tag.type !== "MemberExpression" && (e20.tag.type !== "Identifier" || e20.tag.name !== "gql" && e20.tag.name !== "graphql" && e20.tag.name !== "css" && e20.tag.name !== "md" && e20.tag.name !== "markdown" && e20.tag.name !== "html") && e20.tag.type !== "CallExpression" || em(t2.quasi), e20.type === "TemplateLiteral") {
    (e20.leadingComments && e20.leadingComments.some((e21) => Qg(e21) && ["GraphQL", "HTML"].some((t3) => e21.value === ` ${t3} `)) || n2.type === "CallExpression" && n2.callee.name === "graphql" || !e20.leadingComments) && em(t2);
  }
  return e20.type === "InterpreterDirective" && (t2.value = t2.value.trimEnd()), e20.type !== "TSIntersectionType" && e20.type !== "TSUnionType" || e20.types.length !== 1 ? void 0 : t2.types[0];
}
tm.ignoredProperties = Zg;
var nm = tm;
const rm = (e20) => {
  if (typeof e20 != "string")
    throw new TypeError("Expected a string");
  const t2 = e20.match(/(?:\r?\n)/g) || [];
  if (t2.length === 0)
    return;
  const n2 = t2.filter((e21) => e21 === "\r\n").length;
  return n2 > t2.length - n2 ? "\r\n" : "\n";
};
var im = rm;
im.graceful = (e20) => typeof e20 == "string" && rm(e20) || "\n";
var um = function(e20) {
  const t2 = e20.match(hm);
  return t2 ? t2[0].trimLeft() : "";
}, om = function(e20) {
  const t2 = e20.match(hm);
  return t2 && t2[0] ? e20.substring(t2[0].length) : e20;
}, sm = function(e20) {
  return bm(e20).pragmas;
}, am = bm, cm = function({ comments: e20 = "", pragmas: t2 = {} }) {
  const n2 = (0, pm().default)(e20) || lm().EOL, r2 = " *", i2 = Object.keys(t2), u2 = i2.map((e21) => Am(e21, t2[e21])).reduce((e21, t3) => e21.concat(t3), []).map((e21) => " * " + e21 + n2).join("");
  if (!e20) {
    if (i2.length === 0)
      return "";
    if (i2.length === 1 && !Array.isArray(t2[i2[0]])) {
      const e21 = t2[i2[0]];
      return `/** ${Am(i2[0], e21)[0]} */`;
    }
  }
  const o2 = e20.split(n2).map((e21) => ` * ${e21}`).join(n2) + n2;
  return "/**" + n2 + (e20 ? o2 : "") + (e20 && i2.length ? r2 + n2 : "") + u2 + " */";
};
function lm() {
  const e20 = is$2;
  return lm = function() {
    return e20;
  }, e20;
}
function pm() {
  const e20 = function(e21) {
    return e21 && e21.__esModule ? e21 : { default: e21 };
  }(im);
  return pm = function() {
    return e20;
  }, e20;
}
const fm = /\*\/$/, dm = /^\/\*\*/, hm = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, gm = /(^|\s+)\/\/([^\r\n]*)/g, mm = /^(\r?\n)+/, ym = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, Dm = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, Em = /(\r?\n|^) *\* ?/g, Cm = [];
function bm(e20) {
  const t2 = (0, pm().default)(e20) || lm().EOL;
  e20 = e20.replace(dm, "").replace(fm, "").replace(Em, "$1");
  let n2 = "";
  for (; n2 !== e20; )
    n2 = e20, e20 = e20.replace(ym, `${t2}$1 $2${t2}`);
  e20 = e20.replace(mm, "").trimRight();
  const r2 = Object.create(null), i2 = e20.replace(Dm, "").replace(mm, "").trimRight();
  let u2;
  for (; u2 = Dm.exec(e20); ) {
    const e21 = u2[2].replace(gm, "");
    typeof r2[u2[1]] == "string" || Array.isArray(r2[u2[1]]) ? r2[u2[1]] = Cm.concat(r2[u2[1]], e21) : r2[u2[1]] = e21;
  }
  return { comments: i2, pragmas: r2 };
}
function Am(e20, t2) {
  return Cm.concat(t2).map((t3) => `@${e20} ${t3}`.trim());
}
var vm = Object.defineProperty({ extract: um, strip: om, parse: sm, parseWithComments: am, print: cm }, "__esModule", { value: true });
const { parseWithComments: Fm, strip: Sm, extract: xm, print: wm } = vm, { getShebang: Tm } = yi$2, { normalizeEndOfLine: Bm } = Di$2;
function Nm(e20) {
  const t2 = Tm(e20);
  t2 && (e20 = e20.slice(t2.length + 1));
  const n2 = xm(e20), { pragmas: r2, comments: i2 } = Fm(n2);
  return { shebang: t2, text: e20, pragmas: r2, comments: i2 };
}
var km = {
  hasPragma: function(e20) {
    const t2 = Object.keys(Nm(e20).pragmas);
    return t2.includes("prettier") || t2.includes("format");
  },
  insertPragma: function(e20) {
    const { shebang: t2, text: n2, pragmas: r2, comments: i2 } = Nm(e20), u2 = Sm(n2), o2 = wm({
      pragmas: Object.assign({ format: "" }, r2),
      comments: i2.trimStart()
    });
    return (t2 ? `${t2}
` : "") + Bm(o2) + (u2.startsWith("\n") ? "\n" : "\n\n") + u2;
  }
};
const {
  getLast: Pm,
  hasNewline: Om,
  getNextNonSpaceNonCommentCharacterIndexWithStartIndex: Im,
  getNextNonSpaceNonCommentCharacter: Lm,
  hasNewlineInRange: jm,
  addLeadingComment: _m,
  addTrailingComment: Mm,
  addDanglingComment: Rm,
  getNextNonSpaceNonCommentCharacterIndex: $m,
  isNonEmptyArray: Vm
} = yi$2, {
  isBlockComment: Wm,
  getFunctionParameters: qm,
  isPrettierIgnoreComment: Um,
  isJsxNode: zm,
  hasFlowShorthandAnnotationComment: Gm,
  hasFlowAnnotationComment: Hm,
  hasIgnoreComment: Jm,
  isCallLikeExpression: Xm,
  getCallArguments: Ym,
  isCallExpression: Km,
  isMemberExpression: Qm,
  isObjectProperty: Zm,
  getComments: ey,
  CommentCheckFlags: ty
} = Gh, { locStart: ny, locEnd: ry } = zc;
function iy(e20, t2) {
  const n2 = (e20.body || e20.properties).find(({ type: e21 }) => e21 !== "EmptyStatement");
  n2 ? _m(n2, t2) : Rm(e20, t2);
}
function uy(e20, t2) {
  e20.type === "BlockStatement" ? iy(e20, t2) : _m(e20, t2);
}
function oy({ comment: e20, followingNode: t2 }) {
  return !(!t2 || !Ly(e20)) && (_m(t2, e20), true);
}
function sy({
  comment: e20,
  precedingNode: t2,
  enclosingNode: n2,
  followingNode: r2,
  text: i2
}) {
  if (!n2 || n2.type !== "IfStatement" || !r2)
    return false;
  return Lm(i2, e20, ry) === ")" ? (Mm(t2, e20), true) : t2 === n2.consequent && r2 === n2.alternate ? (t2.type === "BlockStatement" ? Mm(t2, e20) : Rm(n2, e20), true) : r2.type === "BlockStatement" ? (iy(r2, e20), true) : r2.type === "IfStatement" ? (uy(r2.consequent, e20), true) : n2.consequent === r2 && (_m(r2, e20), true);
}
function ay({
  comment: e20,
  precedingNode: t2,
  enclosingNode: n2,
  followingNode: r2,
  text: i2
}) {
  if (!n2 || n2.type !== "WhileStatement" || !r2)
    return false;
  return Lm(i2, e20, ry) === ")" ? (Mm(t2, e20), true) : r2.type === "BlockStatement" ? (iy(r2, e20), true) : n2.body === r2 && (_m(r2, e20), true);
}
function cy({
  comment: e20,
  precedingNode: t2,
  enclosingNode: n2,
  followingNode: r2
}) {
  return !(!n2 || n2.type !== "TryStatement" && n2.type !== "CatchClause" || !r2) && (n2.type === "CatchClause" && t2 ? (Mm(t2, e20), true) : r2.type === "BlockStatement" ? (iy(r2, e20), true) : r2.type === "TryStatement" ? (uy(r2.finalizer, e20), true) : r2.type === "CatchClause" && (uy(r2.body, e20), true));
}
function ly({ comment: e20, enclosingNode: t2, followingNode: n2 }) {
  return !(!Qm(t2) || !n2 || n2.type !== "Identifier") && (_m(t2, e20), true);
}
function py$1({
  comment: e20,
  precedingNode: t2,
  enclosingNode: n2,
  followingNode: r2,
  text: i2
}) {
  const u2 = t2 && !jm(i2, ry(t2), ny(e20));
  return !(t2 && u2 || !n2 || n2.type !== "ConditionalExpression" && n2.type !== "TSConditionalType" || !r2) && (_m(r2, e20), true);
}
function fy({ comment: e20, precedingNode: t2, enclosingNode: n2 }) {
  return !(!Zm(n2) || !n2.shorthand || n2.key !== t2 || n2.value.type !== "AssignmentPattern") && (Mm(n2.value.left, e20), true);
}
function dy({
  comment: e20,
  precedingNode: t2,
  enclosingNode: n2,
  followingNode: r2
}) {
  if (n2 && (n2.type === "ClassDeclaration" || n2.type === "ClassExpression" || n2.type === "DeclareClass" || n2.type === "DeclareInterface" || n2.type === "InterfaceDeclaration" || n2.type === "TSInterfaceDeclaration")) {
    if (Vm(n2.decorators) && (!r2 || r2.type !== "Decorator"))
      return Mm(Pm(n2.decorators), e20), true;
    if (n2.body && r2 === n2.body)
      return iy(n2.body, e20), true;
    if (r2) {
      for (const i2 of ["implements", "extends", "mixins"])
        if (n2[i2] && r2 === n2[i2][0])
          return !t2 || t2 !== n2.id && t2 !== n2.typeParameters && t2 !== n2.superClass ? Rm(n2, e20, i2) : Mm(t2, e20), true;
    }
  }
  return false;
}
function hy({ comment: e20, precedingNode: t2, enclosingNode: n2, text: r2 }) {
  return (n2 && t2 && (n2.type === "Property" || n2.type === "TSDeclareMethod" || n2.type === "TSAbstractMethodDefinition") && t2.type === "Identifier" && n2.key === t2 && Lm(r2, t2, ry) !== ":" || !(!t2 || !n2 || t2.type !== "Decorator" || n2.type !== "ClassMethod" && n2.type !== "ClassProperty" && n2.type !== "PropertyDefinition" && n2.type !== "TSAbstractClassProperty" && n2.type !== "TSAbstractMethodDefinition" && n2.type !== "TSDeclareMethod" && n2.type !== "MethodDefinition")) && (Mm(t2, e20), true);
}
function gy({ comment: e20, precedingNode: t2, enclosingNode: n2, text: r2 }) {
  return Lm(r2, e20, ry) === "(" && !(!t2 || !n2 || n2.type !== "FunctionDeclaration" && n2.type !== "FunctionExpression" && n2.type !== "ClassMethod" && n2.type !== "MethodDefinition" && n2.type !== "ObjectMethod") && (Mm(t2, e20), true);
}
function my({ comment: e20, enclosingNode: t2, text: n2 }) {
  if (!t2 || t2.type !== "ArrowFunctionExpression")
    return false;
  const r2 = $m(n2, e20, ry);
  return r2 !== false && n2.slice(r2, r2 + 2) === "=>" && (Rm(t2, e20), true);
}
function yy({ comment: e20, enclosingNode: t2, text: n2 }) {
  return Lm(n2, e20, ry) === ")" && (t2 && (Iy(t2) && qm(t2).length === 0 || Xm(t2) && Ym(t2).length === 0) ? (Rm(t2, e20), true) : !(!t2 || t2.type !== "MethodDefinition" && t2.type !== "TSAbstractMethodDefinition" || qm(t2.value).length !== 0) && (Rm(t2.value, e20), true));
}
function Dy({
  comment: e20,
  precedingNode: t2,
  enclosingNode: n2,
  followingNode: r2,
  text: i2
}) {
  if (t2 && t2.type === "FunctionTypeParam" && n2 && n2.type === "FunctionTypeAnnotation" && r2 && r2.type !== "FunctionTypeParam")
    return Mm(t2, e20), true;
  if (t2 && (t2.type === "Identifier" || t2.type === "AssignmentPattern") && n2 && Iy(n2) && Lm(i2, e20, ry) === ")")
    return Mm(t2, e20), true;
  if (n2 && n2.type === "FunctionDeclaration" && r2 && r2.type === "BlockStatement") {
    const t3 = (() => {
      const e21 = qm(n2);
      if (e21.length > 0)
        return Im(i2, ry(Pm(e21)));
      const t4 = Im(i2, ry(n2.id));
      return t4 !== false && Im(i2, t4 + 1);
    })();
    if (ny(e20) > t3)
      return iy(r2, e20), true;
  }
  return false;
}
function Ey({ comment: e20, enclosingNode: t2 }) {
  return !(!t2 || t2.type !== "ImportSpecifier") && (_m(t2, e20), true);
}
function Cy({ comment: e20, enclosingNode: t2 }) {
  return !(!t2 || t2.type !== "LabeledStatement") && (_m(t2, e20), true);
}
function by({ comment: e20, enclosingNode: t2 }) {
  return !(!t2 || t2.type !== "ContinueStatement" && t2.type !== "BreakStatement" || t2.label) && (Mm(t2, e20), true);
}
function Ay({ comment: e20, precedingNode: t2, enclosingNode: n2 }) {
  return !!(Km(n2) && t2 && n2.callee === t2 && n2.arguments.length > 0) && (_m(n2.arguments[0], e20), true);
}
function vy({
  comment: e20,
  precedingNode: t2,
  enclosingNode: n2,
  followingNode: r2
}) {
  return !n2 || n2.type !== "UnionTypeAnnotation" && n2.type !== "TSUnionType" ? (r2 && (r2.type === "UnionTypeAnnotation" || r2.type === "TSUnionType") && Um(e20) && (r2.types[0].prettierIgnore = true, e20.unignore = true), false) : (Um(e20) && (r2.prettierIgnore = true, e20.unignore = true), !!t2 && (Mm(t2, e20), true));
}
function Fy({ comment: e20, enclosingNode: t2 }) {
  return !!Zm(t2) && (_m(t2, e20), true);
}
function Sy({
  comment: e20,
  enclosingNode: t2,
  followingNode: n2,
  ast: r2,
  isLastComment: i2
}) {
  return r2 && r2.body && r2.body.length === 0 ? (i2 ? Rm(r2, e20) : _m(r2, e20), true) : t2 && t2.type === "Program" && t2.body.length === 0 && !Vm(t2.directives) ? (i2 ? Rm(t2, e20) : _m(t2, e20), true) : !(!n2 || n2.type !== "Program" || n2.body.length !== 0 || !t2 || t2.type !== "ModuleExpression") && (Rm(n2, e20), true);
}
function xy({ comment: e20, enclosingNode: t2 }) {
  return !(!t2 || t2.type !== "ForInStatement" && t2.type !== "ForOfStatement") && (_m(t2, e20), true);
}
function wy({ comment: e20, precedingNode: t2, enclosingNode: n2, text: r2 }) {
  return !!(t2 && t2.type === "ImportSpecifier" && n2 && n2.type === "ImportDeclaration" && Om(r2, ry(e20))) && (Mm(t2, e20), true);
}
function Ty({ comment: e20, enclosingNode: t2 }) {
  return !(!t2 || t2.type !== "AssignmentPattern") && (_m(t2, e20), true);
}
function By({ comment: e20, enclosingNode: t2 }) {
  return !(!t2 || t2.type !== "TypeAlias") && (_m(t2, e20), true);
}
function Ny({ comment: e20, enclosingNode: t2, followingNode: n2 }) {
  return !(!t2 || t2.type !== "VariableDeclarator" && t2.type !== "AssignmentExpression" || !n2 || n2.type !== "ObjectExpression" && n2.type !== "ArrayExpression" && n2.type !== "TemplateLiteral" && n2.type !== "TaggedTemplateExpression" && !Wm(e20)) && (_m(n2, e20), true);
}
function ky({ comment: e20, enclosingNode: t2, followingNode: n2, text: r2 }) {
  return !(n2 || !t2 || t2.type !== "TSMethodSignature" && t2.type !== "TSDeclareFunction" && t2.type !== "TSAbstractMethodDefinition" || Lm(r2, e20, ry) !== ";") && (Mm(t2, e20), true);
}
function Py({ comment: e20, enclosingNode: t2, followingNode: n2 }) {
  if (Um(e20) && t2 && t2.type === "TSMappedType" && n2 && n2.type === "TSTypeParameter" && n2.constraint)
    return t2.prettierIgnore = true, e20.unignore = true, true;
}
function Oy({
  comment: e20,
  precedingNode: t2,
  enclosingNode: n2,
  followingNode: r2
}) {
  return !(!n2 || n2.type !== "TSMappedType") && (r2 && r2.type === "TSTypeParameter" && r2.name ? (_m(r2.name, e20), true) : !(!t2 || t2.type !== "TSTypeParameter" || !t2.constraint) && (Mm(t2.constraint, e20), true));
}
function Iy(e20) {
  return e20.type === "ArrowFunctionExpression" || e20.type === "FunctionExpression" || e20.type === "FunctionDeclaration" || e20.type === "ObjectMethod" || e20.type === "ClassMethod" || e20.type === "TSDeclareFunction" || e20.type === "TSCallSignatureDeclaration" || e20.type === "TSConstructSignatureDeclaration" || e20.type === "TSMethodSignature" || e20.type === "TSConstructorType" || e20.type === "TSFunctionType" || e20.type === "TSDeclareMethod";
}
function Ly(e20) {
  return Wm(e20) && e20.value[0] === "*" && /@type\b/.test(e20.value);
}
var jy = {
  handleOwnLineComment: function(e20) {
    return [
      Py,
      Dy,
      ly,
      sy,
      ay,
      cy,
      dy,
      Ey,
      xy,
      vy,
      Sy,
      wy,
      Ty,
      hy,
      Cy
    ].some((t2) => t2(e20));
  },
  handleEndOfLineComment: function(e20) {
    return [oy, Dy, py$1, Ey, sy, ay, cy, dy, Cy, Ay, Fy, Sy, By, Ny].some((t2) => t2(e20));
  },
  handleRemainingComment: function(e20) {
    return [Py, sy, ay, fy, yy, hy, Sy, my, gy, Oy, by, ky].some((t2) => t2(e20));
  },
  isTypeCastComment: Ly,
  getCommentChildNodes: function(e20, t2) {
    if ((t2.parser === "typescript" || t2.parser === "flow" || t2.parser === "espree" || t2.parser === "meriyah" || t2.parser === "__babel_estree") && e20.type === "MethodDefinition" && e20.value && e20.value.type === "FunctionExpression" && qm(e20.value).length === 0 && !e20.value.returnType && !Vm(e20.value.typeParameters) && e20.value.body)
      return [...e20.decorators || [], e20.key, e20.value.body];
  },
  willPrintOwnComments: function(e20) {
    const t2 = e20.getValue(), n2 = e20.getParentNode();
    return (t2 && (zm(t2) || Gm(t2) || Km(n2) && ((e21) => Hm(ey(e21, ty.Leading)) || Hm(ey(e21, ty.Trailing)))(t2)) || n2 && (n2.type === "JSXSpreadAttribute" || n2.type === "JSXSpreadChild" || n2.type === "UnionTypeAnnotation" || n2.type === "TSUnionType" || (n2.type === "ClassDeclaration" || n2.type === "ClassExpression") && n2.superClass === t2)) && (!Jm(e20) || n2.type === "UnionTypeAnnotation" || n2.type === "TSUnionType");
  }
};
const {
  getFunctionParameters: _y$1,
  getLeftSidePathName: My,
  hasFlowShorthandAnnotationComment: Ry,
  hasNakedLeftSide: $y,
  hasNode: Vy,
  isBitwiseOperator: Wy,
  startsWithNoLookaheadToken: qy,
  shouldFlatten: Uy,
  getPrecedence: zy,
  isCallExpression: Gy,
  isMemberExpression: Hy,
  isObjectProperty: Jy
} = Gh;
function Xy(e20, t2) {
  const n2 = e20.getParentNode();
  if (!n2)
    return false;
  const r2 = e20.getName(), i2 = e20.getNode();
  if (t2.__isInHtmlInterpolation && !t2.bracketSpacing && function(e21) {
    switch (e21.type) {
      case "ObjectExpression":
        return true;
      default:
        return false;
    }
  }(i2) && Yy(e20))
    return true;
  if (function(e21) {
    return e21.type === "BlockStatement" || e21.type === "BreakStatement" || e21.type === "ClassBody" || e21.type === "ClassDeclaration" || e21.type === "ClassMethod" || e21.type === "ClassProperty" || e21.type === "PropertyDefinition" || e21.type === "ClassPrivateProperty" || e21.type === "ContinueStatement" || e21.type === "DebuggerStatement" || e21.type === "DeclareClass" || e21.type === "DeclareExportAllDeclaration" || e21.type === "DeclareExportDeclaration" || e21.type === "DeclareFunction" || e21.type === "DeclareInterface" || e21.type === "DeclareModule" || e21.type === "DeclareModuleExports" || e21.type === "DeclareVariable" || e21.type === "DoWhileStatement" || e21.type === "EnumDeclaration" || e21.type === "ExportAllDeclaration" || e21.type === "ExportDefaultDeclaration" || e21.type === "ExportNamedDeclaration" || e21.type === "ExpressionStatement" || e21.type === "ForInStatement" || e21.type === "ForOfStatement" || e21.type === "ForStatement" || e21.type === "FunctionDeclaration" || e21.type === "IfStatement" || e21.type === "ImportDeclaration" || e21.type === "InterfaceDeclaration" || e21.type === "LabeledStatement" || e21.type === "MethodDefinition" || e21.type === "ReturnStatement" || e21.type === "SwitchStatement" || e21.type === "ThrowStatement" || e21.type === "TryStatement" || e21.type === "TSDeclareFunction" || e21.type === "TSEnumDeclaration" || e21.type === "TSImportEqualsDeclaration" || e21.type === "TSInterfaceDeclaration" || e21.type === "TSModuleDeclaration" || e21.type === "TSNamespaceExportDeclaration" || e21.type === "TypeAlias" || e21.type === "VariableDeclaration" || e21.type === "WhileStatement" || e21.type === "WithStatement";
  }(i2))
    return false;
  if (t2.parser !== "flow" && Ry(e20.getValue()))
    return true;
  if (i2.type === "Identifier")
    return !!(i2.extra && i2.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(i2.name)) || r2 === "left" && i2.name === "async" && n2.type === "ForOfStatement" && !n2.await;
  switch (n2.type) {
    case "ParenthesizedExpression":
      return false;
    case "ClassDeclaration":
    case "ClassExpression":
      if (r2 === "superClass" && (i2.type === "ArrowFunctionExpression" || i2.type === "AssignmentExpression" || i2.type === "AwaitExpression" || i2.type === "BinaryExpression" || i2.type === "ConditionalExpression" || i2.type === "LogicalExpression" || i2.type === "NewExpression" || i2.type === "ObjectExpression" || i2.type === "ParenthesizedExpression" || i2.type === "SequenceExpression" || i2.type === "TaggedTemplateExpression" || i2.type === "UnaryExpression" || i2.type === "UpdateExpression" || i2.type === "YieldExpression" || i2.type === "TSNonNullExpression"))
        return true;
      break;
    case "ExportDefaultDeclaration":
      return Ky(e20, t2) || i2.type === "SequenceExpression";
    case "Decorator":
      if (r2 === "expression") {
        let e21 = false, t3 = false, n3 = i2;
        for (; n3; )
          switch (n3.type) {
            case "MemberExpression":
              t3 = true, n3 = n3.object;
              break;
            case "CallExpression":
              if (t3 || e21)
                return true;
              e21 = true, n3 = n3.callee;
              break;
            case "Identifier":
              return false;
            default:
              return true;
          }
        return true;
      }
      break;
    case "ExpressionStatement":
      if (qy(i2, true))
        return true;
      break;
    case "ArrowFunctionExpression":
      if (r2 === "body" && i2.type !== "SequenceExpression" && qy(i2, false))
        return true;
  }
  switch (i2.type) {
    case "UpdateExpression":
      if (n2.type === "UnaryExpression")
        return i2.prefix && (i2.operator === "++" && n2.operator === "+" || i2.operator === "--" && n2.operator === "-");
    case "UnaryExpression":
      switch (n2.type) {
        case "UnaryExpression":
          return i2.operator === n2.operator && (i2.operator === "+" || i2.operator === "-");
        case "BindExpression":
          return true;
        case "MemberExpression":
        case "OptionalMemberExpression":
          return r2 === "object";
        case "TaggedTemplateExpression":
          return true;
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return r2 === "callee";
        case "BinaryExpression":
          return r2 === "left" && n2.operator === "**";
        case "TSNonNullExpression":
          return true;
        default:
          return false;
      }
    case "BinaryExpression":
      if (n2.type === "UpdateExpression" || n2.type === "PipelineTopicExpression" && i2.operator === "|>")
        return true;
      if (i2.operator === "in" && function(e21) {
        let t3 = 0, n3 = e21.getValue();
        for (; n3; ) {
          const r3 = e21.getParentNode(t3++);
          if (r3 && r3.type === "ForStatement" && r3.init === n3)
            return true;
          n3 = r3;
        }
        return false;
      }(e20))
        return true;
      if (i2.operator === "|>" && i2.extra && i2.extra.parenthesized) {
        const t3 = e20.getParentNode(1);
        if (t3.type === "BinaryExpression" && t3.operator === "|>")
          return true;
      }
    case "TSTypeAssertion":
    case "TSAsExpression":
    case "LogicalExpression":
      switch (n2.type) {
        case "TSAsExpression":
          return i2.type !== "TSAsExpression";
        case "ConditionalExpression":
          return i2.type === "TSAsExpression";
        case "CallExpression":
        case "NewExpression":
        case "OptionalCallExpression":
          return r2 === "callee";
        case "ClassExpression":
        case "ClassDeclaration":
          return r2 === "superClass";
        case "TSTypeAssertion":
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "JSXSpreadAttribute":
        case "SpreadElement":
        case "SpreadProperty":
        case "BindExpression":
        case "AwaitExpression":
        case "TSNonNullExpression":
        case "UpdateExpression":
          return true;
        case "MemberExpression":
        case "OptionalMemberExpression":
          return r2 === "object";
        case "AssignmentExpression":
        case "AssignmentPattern":
          return r2 === "left" && (i2.type === "TSTypeAssertion" || i2.type === "TSAsExpression");
        case "LogicalExpression":
          if (i2.type === "LogicalExpression")
            return n2.operator !== i2.operator;
        case "BinaryExpression": {
          const { operator: e21, type: t3 } = i2;
          if (!e21 && t3 !== "TSTypeAssertion")
            return true;
          const u2 = zy(e21), o2 = n2.operator, s2 = zy(o2);
          return s2 > u2 || r2 === "right" && s2 === u2 || s2 === u2 && !Uy(o2, e21) || (s2 < u2 && e21 === "%" ? o2 === "+" || o2 === "-" : !!Wy(o2));
        }
        default:
          return false;
      }
    case "SequenceExpression":
      switch (n2.type) {
        case "ReturnStatement":
        case "ForStatement":
          return false;
        case "ExpressionStatement":
          return r2 !== "expression";
        case "ArrowFunctionExpression":
          return r2 !== "body";
        default:
          return true;
      }
    case "YieldExpression":
      if (n2.type === "UnaryExpression" || n2.type === "AwaitExpression" || n2.type === "TSAsExpression" || n2.type === "TSNonNullExpression")
        return true;
      if (r2 === "expression" && i2.argument && i2.argument.type === "PipelinePrimaryTopicReference" && n2.type === "PipelineTopicExpression")
        return true;
    case "AwaitExpression":
      switch (n2.type) {
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "LogicalExpression":
        case "SpreadElement":
        case "SpreadProperty":
        case "TSAsExpression":
        case "TSNonNullExpression":
        case "BindExpression":
          return true;
        case "MemberExpression":
        case "OptionalMemberExpression":
          return r2 === "object";
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return r2 === "callee";
        case "ConditionalExpression":
          return r2 === "test";
        case "BinaryExpression":
          return !(!i2.argument && n2.operator === "|>");
        default:
          return false;
      }
    case "TSConditionalType":
      if (r2 === "extendsType" && n2.type === "TSConditionalType")
        return true;
    case "TSFunctionType":
    case "TSConstructorType":
      if (r2 === "checkType" && n2.type === "TSConditionalType")
        return true;
    case "TSUnionType":
    case "TSIntersectionType":
      if ((n2.type === "TSUnionType" || n2.type === "TSIntersectionType") && n2.types.length > 1 && (!i2.types || i2.types.length > 1))
        return true;
    case "TSInferType":
      if (i2.type === "TSInferType" && n2.type === "TSRestType")
        return false;
    case "TSTypeOperator":
      return n2.type === "TSArrayType" || n2.type === "TSOptionalType" || n2.type === "TSRestType" || r2 === "objectType" && n2.type === "TSIndexedAccessType" || n2.type === "TSTypeOperator" || n2.type === "TSTypeAnnotation" && /^TSJSDoc/.test(e20.getParentNode(1).type);
    case "ArrayTypeAnnotation":
      return n2.type === "NullableTypeAnnotation";
    case "IntersectionTypeAnnotation":
    case "UnionTypeAnnotation":
      return n2.type === "ArrayTypeAnnotation" || n2.type === "NullableTypeAnnotation" || n2.type === "IntersectionTypeAnnotation" || n2.type === "UnionTypeAnnotation" || r2 === "objectType" && (n2.type === "IndexedAccessType" || n2.type === "OptionalIndexedAccessType");
    case "NullableTypeAnnotation":
      return n2.type === "ArrayTypeAnnotation" || r2 === "objectType" && (n2.type === "IndexedAccessType" || n2.type === "OptionalIndexedAccessType");
    case "FunctionTypeAnnotation": {
      const t3 = n2.type === "NullableTypeAnnotation" ? e20.getParentNode(1) : n2;
      return t3.type === "UnionTypeAnnotation" || t3.type === "IntersectionTypeAnnotation" || t3.type === "ArrayTypeAnnotation" || r2 === "objectType" && (t3.type === "IndexedAccessType" || t3.type === "OptionalIndexedAccessType") || t3.type === "NullableTypeAnnotation" || n2.type === "FunctionTypeParam" && n2.name === null && _y$1(i2).some((e21) => e21.typeAnnotation && e21.typeAnnotation.type === "NullableTypeAnnotation");
    }
    case "OptionalIndexedAccessType":
      return r2 === "objectType" && n2.type === "IndexedAccessType";
    case "TypeofTypeAnnotation":
      return r2 === "objectType" && (n2.type === "IndexedAccessType" || n2.type === "OptionalIndexedAccessType");
    case "StringLiteral":
    case "NumericLiteral":
    case "Literal":
      if (typeof i2.value == "string" && n2.type === "ExpressionStatement" && !n2.directive) {
        const t3 = e20.getParentNode(1);
        return t3.type === "Program" || t3.type === "BlockStatement";
      }
      return r2 === "object" && n2.type === "MemberExpression" && typeof i2.value == "number";
    case "AssignmentExpression": {
      const t3 = e20.getParentNode(1);
      return r2 === "body" && n2.type === "ArrowFunctionExpression" || (r2 !== "key" || n2.type !== "ClassProperty" && n2.type !== "PropertyDefinition" || !n2.computed) && (r2 !== "init" && r2 !== "update" || n2.type !== "ForStatement") && (n2.type === "ExpressionStatement" ? i2.left.type === "ObjectPattern" : (r2 !== "key" || n2.type !== "TSPropertySignature") && n2.type !== "AssignmentExpression" && (n2.type !== "SequenceExpression" || !t3 || t3.type !== "ForStatement" || t3.init !== n2 && t3.update !== n2) && (r2 !== "value" || n2.type !== "Property" || !t3 || t3.type !== "ObjectPattern" || !t3.properties.includes(n2)) && n2.type !== "NGChainedExpression");
    }
    case "ConditionalExpression":
      switch (n2.type) {
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "SpreadElement":
        case "SpreadProperty":
        case "BinaryExpression":
        case "LogicalExpression":
        case "NGPipeExpression":
        case "ExportDefaultDeclaration":
        case "AwaitExpression":
        case "JSXSpreadAttribute":
        case "TSTypeAssertion":
        case "TypeCastExpression":
        case "TSAsExpression":
        case "TSNonNullExpression":
          return true;
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return r2 === "callee";
        case "ConditionalExpression":
          return r2 === "test";
        case "MemberExpression":
        case "OptionalMemberExpression":
          return r2 === "object";
        default:
          return false;
      }
    case "FunctionExpression":
      switch (n2.type) {
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return r2 === "callee";
        case "TaggedTemplateExpression":
          return true;
        default:
          return false;
      }
    case "ArrowFunctionExpression":
      switch (n2.type) {
        case "PipelineTopicExpression":
          return Boolean(i2.extra && i2.extra.parenthesized);
        case "BinaryExpression":
          return n2.operator !== "|>" || i2.extra && i2.extra.parenthesized;
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return r2 === "callee";
        case "MemberExpression":
        case "OptionalMemberExpression":
          return r2 === "object";
        case "TSAsExpression":
        case "TSNonNullExpression":
        case "BindExpression":
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "LogicalExpression":
        case "AwaitExpression":
        case "TSTypeAssertion":
          return true;
        case "ConditionalExpression":
          return r2 === "test";
        default:
          return false;
      }
    case "ClassExpression":
      switch (n2.type) {
        case "NewExpression":
          return r2 === "callee";
        default:
          return false;
      }
    case "OptionalMemberExpression":
    case "OptionalCallExpression": {
      const t3 = e20.getParentNode(1);
      if (r2 === "object" && n2.type === "MemberExpression" || r2 === "callee" && (n2.type === "CallExpression" || n2.type === "NewExpression") || n2.type === "TSNonNullExpression" && t3.type === "MemberExpression" && t3.object === n2)
        return true;
    }
    case "CallExpression":
    case "MemberExpression":
    case "TaggedTemplateExpression":
    case "TSNonNullExpression":
      if (r2 === "callee" && (n2.type === "BindExpression" || n2.type === "NewExpression")) {
        let e21 = i2;
        for (; e21; )
          switch (e21.type) {
            case "CallExpression":
            case "OptionalCallExpression":
              return true;
            case "MemberExpression":
            case "OptionalMemberExpression":
            case "BindExpression":
              e21 = e21.object;
              break;
            case "TaggedTemplateExpression":
              e21 = e21.tag;
              break;
            case "TSNonNullExpression":
              e21 = e21.expression;
              break;
            default:
              return false;
          }
      }
      return false;
    case "BindExpression":
      return r2 === "callee" && (n2.type === "BindExpression" || n2.type === "NewExpression") || r2 === "object" && Hy(n2);
    case "NGPipeExpression":
      return !(n2.type === "NGRoot" || n2.type === "NGMicrosyntaxExpression" || n2.type === "ObjectProperty" && (!i2.extra || !i2.extra.parenthesized) || n2.type === "ArrayExpression" || Gy(n2) && n2.arguments[r2] === i2 || r2 === "right" && n2.type === "NGPipeExpression" || r2 === "property" && n2.type === "MemberExpression" || n2.type === "AssignmentExpression");
    case "JSXFragment":
    case "JSXElement":
      return r2 === "callee" || r2 === "left" && n2.type === "BinaryExpression" && n2.operator === "<" || n2.type !== "ArrayExpression" && n2.type !== "ArrowFunctionExpression" && n2.type !== "AssignmentExpression" && n2.type !== "AssignmentPattern" && n2.type !== "BinaryExpression" && n2.type !== "NewExpression" && n2.type !== "ConditionalExpression" && n2.type !== "ExpressionStatement" && n2.type !== "JsExpressionRoot" && n2.type !== "JSXAttribute" && n2.type !== "JSXElement" && n2.type !== "JSXExpressionContainer" && n2.type !== "JSXFragment" && n2.type !== "LogicalExpression" && !Gy(n2) && !Jy(n2) && n2.type !== "ReturnStatement" && n2.type !== "ThrowStatement" && n2.type !== "TypeCastExpression" && n2.type !== "VariableDeclarator" && n2.type !== "YieldExpression";
    case "TypeAnnotation":
      return r2 === "returnType" && n2.type === "ArrowFunctionExpression" && function(e21) {
        return Vy(e21, (e22) => e22.type === "ObjectTypeAnnotation" && Vy(e22, (e23) => e23.type === "FunctionTypeAnnotation" || void 0) || void 0);
      }(i2);
  }
  return false;
}
function Yy(e20) {
  const t2 = e20.getValue(), n2 = e20.getParentNode(), r2 = e20.getName();
  switch (n2.type) {
    case "NGPipeExpression":
      if (typeof r2 == "number" && n2.arguments[r2] === t2 && n2.arguments.length - 1 === r2)
        return e20.callParent(Yy);
      break;
    case "ObjectProperty":
      if (r2 === "value") {
        const t3 = e20.getParentNode(1);
        return Ln$2(t3.properties) === n2;
      }
      break;
    case "BinaryExpression":
    case "LogicalExpression":
      if (r2 === "right")
        return e20.callParent(Yy);
      break;
    case "ConditionalExpression":
      if (r2 === "alternate")
        return e20.callParent(Yy);
      break;
    case "UnaryExpression":
      if (n2.prefix)
        return e20.callParent(Yy);
  }
  return false;
}
function Ky(e20, t2) {
  const n2 = e20.getValue(), r2 = e20.getParentNode();
  return n2.type === "FunctionExpression" || n2.type === "ClassExpression" ? r2.type === "ExportDefaultDeclaration" || !Xy(e20, t2) : !(!$y(n2) || r2.type !== "ExportDefaultDeclaration" && Xy(e20, t2)) && e20.call((e21) => Ky(e21, t2), ...My(e20, n2));
}
var Qy = Xy;
var Zy = function(e20, t2) {
  switch (t2.parser) {
    case "json":
    case "json5":
    case "json-stringify":
    case "__js_expression":
    case "__vue_expression":
      return Object.assign(Object.assign({}, e20), {}, {
        type: t2.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot",
        node: e20,
        comments: [],
        rootMarker: t2.rootMarker
      });
    default:
      return e20;
  }
};
const {
  builders: { join: eD, line: tD, group: nD, softline: rD, indent: iD }
} = eu$1;
var uD = {
  isVueEventBindingExpression: function e7(t2) {
    switch (t2.type) {
      case "MemberExpression":
        switch (t2.property.type) {
          case "Identifier":
          case "NumericLiteral":
          case "StringLiteral":
            return e7(t2.object);
        }
        return false;
      case "Identifier":
        return true;
      default:
        return false;
    }
  },
  printHtmlBinding: function(e20, t2, n2) {
    const r2 = e20.getValue();
    if (t2.__onHtmlBindingRoot && e20.getName() === null && t2.__onHtmlBindingRoot(r2, t2), r2.type === "File")
      return t2.__isVueForBindingLeft ? e20.call((e21) => {
        const t3 = eD([",", tD], e21.map(n2, "params")), { params: r3 } = e21.getValue();
        return r3.length === 1 ? t3 : ["(", iD([rD, nD(t3)]), rD, ")"];
      }, "program", "body", 0) : t2.__isVueBindings ? e20.call((e21) => eD([",", tD], e21.map(n2, "params")), "program", "body", 0) : void 0;
  }
};
const { printComments: oD } = Wf, { getLast: sD } = yi$2, {
  builders: {
    join: aD,
    line: cD,
    softline: lD,
    group: pD,
    indent: fD,
    align: dD,
    ifBreak: hD,
    indentIfBreak: gD
  },
  utils: { cleanDoc: mD, getDocParts: yD, isConcat: DD }
} = eu$1, {
  hasLeadingOwnLineComment: ED,
  isBinaryish: CD,
  isJsxNode: bD,
  shouldFlatten: AD,
  hasComment: vD,
  CommentCheckFlags: FD,
  isCallExpression: SD,
  isMemberExpression: xD,
  isObjectProperty: wD
} = Gh;
let TD = 0;
function BD(e20, t2, n2, r2, i2) {
  let u2 = [];
  const o2 = e20.getValue();
  if (CD(o2)) {
    AD(o2.operator, o2.left.operator) ? u2 = [...u2, ...e20.call((e21) => BD(e21, t2, n2, true, i2), "left")] : u2.push(pD(t2("left")));
    const s2 = ND(o2), a2 = (o2.operator === "|>" || o2.type === "NGPipeExpression" || o2.operator === "|" && n2.parser === "__vue_expression") && !ED(n2.originalText, o2.right), c2 = o2.type === "NGPipeExpression" ? "|" : o2.operator, l2 = o2.type === "NGPipeExpression" && o2.arguments.length > 0 ? pD(fD([
      lD,
      ": ",
      aD([lD, ":", hD(" ")], e20.map(t2, "arguments").map((e21) => dD(2, pD(e21))))
    ])) : "", p2 = s2 ? [c2, " ", t2("right"), l2] : [a2 ? cD : "", c2, a2 ? " " : cD, t2("right"), l2], f2 = e20.getParentNode(), d2 = vD(o2.left, FD.Trailing | FD.Line), h2 = d2 || !(i2 && o2.type === "LogicalExpression") && f2.type !== o2.type && o2.left.type !== o2.type && o2.right.type !== o2.type;
    if (u2.push(a2 ? "" : " ", h2 ? pD(p2, { shouldBreak: d2 }) : p2), r2 && vD(o2)) {
      const t3 = mD(oD(e20, u2, n2));
      u2 = DD(t3) || t3.type === "fill" ? yD(t3) : [t3];
    }
  } else
    u2.push(pD(t2()));
  return u2;
}
function ND(e20) {
  return e20.type === "LogicalExpression" && (e20.right.type === "ObjectExpression" && e20.right.properties.length > 0 || e20.right.type === "ArrayExpression" && e20.right.elements.length > 0 || !!bD(e20.right));
}
var kD = {
  printBinaryishExpression: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = e20.getParentNode(), u2 = e20.getParentNode(1), o2 = r2 !== i2.body && (i2.type === "IfStatement" || i2.type === "WhileStatement" || i2.type === "SwitchStatement" || i2.type === "DoWhileStatement"), s2 = BD(e20, n2, t2, false, o2);
    if (o2)
      return s2;
    if (SD(i2) && i2.callee === r2 || i2.type === "UnaryExpression" || xD(i2) && !i2.computed)
      return pD([fD([lD, ...s2]), lD]);
    const a2 = i2.type === "ReturnStatement" || i2.type === "ThrowStatement" || i2.type === "JSXExpressionContainer" && u2.type === "JSXAttribute" || r2.operator !== "|" && i2.type === "JsExpressionRoot" || r2.type !== "NGPipeExpression" && (i2.type === "NGRoot" && t2.parser === "__ng_binding" || i2.type === "NGMicrosyntaxExpression" && u2.type === "NGMicrosyntax" && u2.body.length === 1) || r2 === i2.body && i2.type === "ArrowFunctionExpression" || r2 !== i2.body && i2.type === "ForStatement" || i2.type === "ConditionalExpression" && u2.type !== "ReturnStatement" && u2.type !== "ThrowStatement" && !SD(u2) || i2.type === "TemplateLiteral", c2 = i2.type === "AssignmentExpression" || i2.type === "VariableDeclarator" || i2.type === "ClassProperty" || i2.type === "PropertyDefinition" || i2.type === "TSAbstractClassProperty" || i2.type === "ClassPrivateProperty" || wD(i2), l2 = CD(r2.left) && AD(r2.operator, r2.left.operator);
    if (a2 || ND(r2) && !l2 || !ND(r2) && c2)
      return pD(s2);
    if (s2.length === 0)
      return "";
    const p2 = bD(r2.right), f2 = s2.findIndex((e21) => typeof e21 != "string" && !Array.isArray(e21) && e21.type === "group"), d2 = s2.slice(0, f2 === -1 ? 1 : f2 + 1), h2 = s2.slice(d2.length, p2 ? -1 : void 0), g2 = Symbol("logicalChain-" + ++TD), m2 = pD([...d2, fD(h2)], { id: g2 });
    if (!p2)
      return m2;
    const y2 = sD(s2);
    return pD([m2, gD(y2, { groupId: g2 })]);
  },
  shouldInlineLogicalExpression: ND
};
const {
  builders: { join: PD, line: OD, group: ID }
} = eu$1, { hasNode: LD, hasComment: jD, getComments: _D } = Gh, { printBinaryishExpression: MD } = kD;
function RD(e20, t2, n2) {
  return e20.type === "NGMicrosyntaxKeyedExpression" && e20.key.name === "of" && t2 === 1 && n2.body[0].type === "NGMicrosyntaxLet" && n2.body[0].value === null;
}
var $D = {
  printAngular: function(e20, t2, n2) {
    const r2 = e20.getValue();
    if (r2.type.startsWith("NG"))
      switch (r2.type) {
        case "NGRoot":
          return [
            n2("node"),
            jD(r2.node) ? " //" + _D(r2.node)[0].value.trimEnd() : ""
          ];
        case "NGPipeExpression":
          return MD(e20, t2, n2);
        case "NGChainedExpression":
          return ID(PD([";", OD], e20.map((e21) => function(e22) {
            return LD(e22.getValue(), (e23) => {
              switch (e23.type) {
                case void 0:
                  return false;
                case "CallExpression":
                case "OptionalCallExpression":
                case "AssignmentExpression":
                  return true;
              }
            });
          }(e21) ? n2() : ["(", n2(), ")"], "expressions")));
        case "NGEmptyExpression":
          return "";
        case "NGQuotedExpression":
          return [r2.prefix, ": ", r2.value.trim()];
        case "NGMicrosyntax":
          return e20.map((e21, t3) => [
            t3 === 0 ? "" : RD(e21.getValue(), t3, r2) ? " " : [";", OD],
            n2()
          ], "body");
        case "NGMicrosyntaxKey":
          return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(r2.name) ? r2.name : JSON.stringify(r2.name);
        case "NGMicrosyntaxExpression":
          return [
            n2("expression"),
            r2.alias === null ? "" : [" as ", n2("alias")]
          ];
        case "NGMicrosyntaxKeyedExpression": {
          const t3 = e20.getName(), i2 = e20.getParentNode(), u2 = RD(r2, t3, i2) || (t3 === 1 && (r2.key.name === "then" || r2.key.name === "else") || t3 === 2 && r2.key.name === "else" && i2.body[t3 - 1].type === "NGMicrosyntaxKeyedExpression" && i2.body[t3 - 1].key.name === "then") && i2.body[0].type === "NGMicrosyntaxExpression";
          return [n2("key"), u2 ? " " : ": ", n2("expression")];
        }
        case "NGMicrosyntaxLet":
          return [
            "let ",
            n2("key"),
            r2.value === null ? "" : [" = ", n2("value")]
          ];
        case "NGMicrosyntaxAs":
          return [n2("key"), " as ", n2("alias")];
        default:
          throw new Error(`Unknown Angular node type: ${JSON.stringify(r2.type)}.`);
      }
  }
};
const { printComments: VD, printDanglingComments: WD } = Wf, {
  builders: {
    line: qD,
    hardline: UD,
    softline: zD,
    group: GD,
    indent: HD,
    conditionalGroup: JD,
    fill: XD,
    ifBreak: YD,
    lineSuffixBoundary: KD,
    join: QD
  },
  utils: { willBreak: ZD }
} = eu$1, { getLast: eE, getPreferredQuote: tE } = yi$2, {
  isJsxNode: nE,
  rawText: rE,
  isLiteral: iE,
  isCallExpression: uE,
  isStringLiteral: oE,
  isBinaryish: sE,
  hasComment: aE,
  CommentCheckFlags: cE,
  hasNodeIgnoreComment: lE
} = Gh, { willPrintOwnComments: pE } = jy, fE = (e20) => e20 === "" || e20 === qD || e20 === UD || e20 === zD;
function dE(e20, t2, n2) {
  const r2 = e20.getValue();
  if (r2.type === "JSXElement" && function(e21) {
    if (e21.children.length === 0)
      return true;
    if (e21.children.length > 1)
      return false;
    const t3 = e21.children[0];
    return iE(t3) && !bE(t3);
  }(r2))
    return [n2("openingElement"), n2("closingElement")];
  const i2 = r2.type === "JSXElement" ? n2("openingElement") : n2("openingFragment"), u2 = r2.type === "JSXElement" ? n2("closingElement") : n2("closingFragment");
  if (r2.children.length === 1 && r2.children[0].type === "JSXExpressionContainer" && (r2.children[0].expression.type === "TemplateLiteral" || r2.children[0].expression.type === "TaggedTemplateExpression"))
    return [i2, ...e20.map(n2, "children"), u2];
  r2.children = r2.children.map((e21) => function(e22) {
    return e22.type === "JSXExpressionContainer" && iE(e22.expression) && e22.expression.value === " " && !aE(e22.expression);
  }(e21) ? { type: "JSXText", value: " ", raw: " " } : e21);
  const o2 = r2.children.filter(nE).length > 0, s2 = r2.children.filter((e21) => e21.type === "JSXExpressionContainer").length > 1, a2 = r2.type === "JSXElement" && r2.openingElement.attributes.length > 1;
  let c2 = ZD(i2) || o2 || a2 || s2;
  const l2 = e20.getParentNode().rootMarker === "mdx", p2 = t2.singleQuote ? "{' '}" : '{" "}', f2 = l2 ? " " : YD([p2, zD], " "), d2 = function(e21, t3, n3, r3, i3) {
    const u3 = [];
    return e21.each((e22, t4, o3) => {
      const s3 = e22.getValue();
      if (iE(s3)) {
        const e23 = rE(s3);
        if (bE(s3)) {
          const n4 = e23.split(DE);
          if (n4[0] === "") {
            if (u3.push(""), n4.shift(), /\n/.test(n4[0])) {
              const e24 = o3[t4 + 1];
              u3.push(gE(i3, n4[1], s3, e24));
            } else
              u3.push(r3);
            n4.shift();
          }
          let a3;
          if (eE(n4) === "" && (n4.pop(), a3 = n4.pop()), n4.length === 0)
            return;
          for (const [e24, t5] of n4.entries())
            e24 % 2 == 1 ? u3.push(qD) : u3.push(t5);
          if (a3 !== void 0)
            if (/\n/.test(a3)) {
              const e24 = o3[t4 + 1];
              u3.push(gE(i3, eE(u3), s3, e24));
            } else
              u3.push(r3);
          else {
            const e24 = o3[t4 + 1];
            u3.push(hE(i3, eE(u3), s3, e24));
          }
        } else
          /\n/.test(e23) ? e23.match(/\n/g).length > 1 && u3.push("", UD) : u3.push("", r3);
      } else {
        const e23 = n3();
        u3.push(e23);
        const r4 = o3[t4 + 1];
        if (r4 && bE(r4)) {
          const e24 = CE(rE(r4)).split(DE)[0];
          u3.push(hE(i3, e24, s3, r4));
        } else
          u3.push(UD);
      }
    }, "children"), u3;
  }(e20, 0, n2, f2, r2.openingElement && r2.openingElement.name && r2.openingElement.name.name === "fbt"), h2 = r2.children.some((e21) => bE(e21));
  for (let e21 = d2.length - 2; e21 >= 0; e21--) {
    const t3 = d2[e21] === "" && d2[e21 + 1] === "", n3 = d2[e21] === UD && d2[e21 + 1] === "" && d2[e21 + 2] === UD, r3 = (d2[e21] === zD || d2[e21] === UD) && d2[e21 + 1] === "" && d2[e21 + 2] === f2, i3 = d2[e21] === f2 && d2[e21 + 1] === "" && (d2[e21 + 2] === zD || d2[e21 + 2] === UD), u3 = d2[e21] === f2 && d2[e21 + 1] === "" && d2[e21 + 2] === f2, o3 = d2[e21] === zD && d2[e21 + 1] === "" && d2[e21 + 2] === UD || d2[e21] === UD && d2[e21 + 1] === "" && d2[e21 + 2] === zD;
    n3 && h2 || t3 || r3 || u3 || o3 ? d2.splice(e21, 2) : i3 && d2.splice(e21 + 1, 2);
  }
  for (; d2.length > 0 && fE(eE(d2)); )
    d2.pop();
  for (; d2.length > 1 && fE(d2[0]) && fE(d2[1]); )
    d2.shift(), d2.shift();
  const g2 = [];
  for (const [e21, t3] of d2.entries()) {
    if (t3 === f2) {
      if (e21 === 1 && d2[e21 - 1] === "") {
        if (d2.length === 2) {
          g2.push(p2);
          continue;
        }
        g2.push([p2, UD]);
        continue;
      }
      if (e21 === d2.length - 1) {
        g2.push(p2);
        continue;
      }
      if (d2[e21 - 1] === "" && d2[e21 - 2] === UD) {
        g2.push(p2);
        continue;
      }
    }
    g2.push(t3), ZD(t3) && (c2 = true);
  }
  const m2 = h2 ? XD(g2) : GD(g2, { shouldBreak: true });
  if (l2)
    return m2;
  const y2 = GD([i2, HD([UD, m2]), UD, u2]);
  return c2 ? y2 : JD([GD([i2, ...d2, u2]), y2]);
}
function hE(e20, t2, n2, r2) {
  return e20 ? "" : n2.type === "JSXElement" && !n2.closingElement || r2 && r2.type === "JSXElement" && !r2.closingElement ? t2.length === 1 ? zD : UD : zD;
}
function gE(e20, t2, n2, r2) {
  return e20 ? UD : t2.length === 1 ? n2.type === "JSXElement" && !n2.closingElement || r2 && r2.type === "JSXElement" && !r2.closingElement ? UD : zD : UD;
}
function mE(e20, t2, n2) {
  return function(e21, t3, n3) {
    const r2 = e21.getParentNode();
    if (!r2)
      return t3;
    if ({
      ArrayExpression: true,
      JSXAttribute: true,
      JSXElement: true,
      JSXExpressionContainer: true,
      JSXFragment: true,
      ExpressionStatement: true,
      CallExpression: true,
      OptionalCallExpression: true,
      ConditionalExpression: true,
      JsExpressionRoot: true
    }[r2.type])
      return t3;
    const i2 = e21.match(void 0, (e22) => e22.type === "ArrowFunctionExpression", uE, (e22) => e22.type === "JSXExpressionContainer"), u2 = Qy(e21, n3);
    return GD([u2 ? "" : YD("("), HD([zD, t3]), zD, u2 ? "" : YD(")")], {
      shouldBreak: i2
    });
  }(e20, VD(e20, dE(e20, t2, n2), t2), t2);
}
function yE(e20, t2, n2) {
  const r2 = e20.getValue();
  return [
    "{",
    e20.call((e21) => {
      const r3 = ["...", n2()], i2 = e21.getValue();
      return aE(i2) && pE(e21) ? [HD([zD, VD(e21, r3, t2)]), zD] : r3;
    }, r2.type === "JSXSpreadAttribute" ? "argument" : "expression"),
    "}"
  ];
}
const DE = new RegExp("([ \n\r	]+)"), EE = new RegExp("[^ \n\r	]"), CE = (e20) => e20.replace(new RegExp("(?:^" + DE.source + "|" + DE.source + "$)"), "");
function bE(e20) {
  return iE(e20) && (EE.test(rE(e20)) || !/\n/.test(rE(e20)));
}
var AE = {
  hasJsxIgnoreComment: function(e20) {
    const t2 = e20.getValue(), n2 = e20.getParentNode();
    if (!(n2 && t2 && nE(t2) && nE(n2)))
      return false;
    let r2 = null;
    for (let e21 = n2.children.indexOf(t2); e21 > 0; e21--) {
      const t3 = n2.children[e21 - 1];
      if (t3.type !== "JSXText" || bE(t3)) {
        r2 = t3;
        break;
      }
    }
    return r2 && r2.type === "JSXExpressionContainer" && r2.expression.type === "JSXEmptyExpression" && lE(r2.expression);
  },
  printJsx: function(e20, t2, n2) {
    const r2 = e20.getValue();
    if (r2.type.startsWith("JSX"))
      switch (r2.type) {
        case "JSXAttribute":
          return function(e21, t3, n3) {
            const r3 = e21.getValue(), i2 = [];
            if (i2.push(n3("name")), r3.value) {
              let e22;
              if (oE(r3.value)) {
                let n4 = rE(r3.value).replace(/&apos;/g, "'").replace(/&quot;/g, '"');
                const i3 = tE(n4, t3.jsxSingleQuote ? "'" : '"'), u2 = i3 === "'" ? "&apos;" : "&quot;";
                n4 = n4.slice(1, -1).replace(new RegExp(i3, "g"), u2), e22 = [i3, n4, i3];
              } else
                e22 = n3("value");
              i2.push("=", e22);
            }
            return i2;
          }(e20, t2, n2);
        case "JSXIdentifier":
          return String(r2.name);
        case "JSXNamespacedName":
          return QD(":", [n2("namespace"), n2("name")]);
        case "JSXMemberExpression":
          return QD(".", [n2("object"), n2("property")]);
        case "JSXSpreadAttribute":
          return yE(e20, t2, n2);
        case "JSXSpreadChild":
          return yE(e20, t2, n2);
        case "JSXExpressionContainer":
          return function(e21, t3, n3) {
            const r3 = e21.getValue(), i2 = e21.getParentNode(0), u2 = r3.expression.type === "JSXEmptyExpression" || !aE(r3.expression) && (r3.expression.type === "ArrayExpression" || r3.expression.type === "ObjectExpression" || r3.expression.type === "ArrowFunctionExpression" || uE(r3.expression) || r3.expression.type === "FunctionExpression" || r3.expression.type === "TemplateLiteral" || r3.expression.type === "TaggedTemplateExpression" || r3.expression.type === "DoExpression" || nE(i2) && (r3.expression.type === "ConditionalExpression" || sE(r3.expression)));
            return GD(u2 ? ["{", n3("expression"), KD, "}"] : ["{", HD([zD, n3("expression")]), zD, KD, "}"]);
          }(e20, 0, n2);
        case "JSXFragment":
        case "JSXElement":
          return mE(e20, t2, n2);
        case "JSXOpeningElement":
          return function(e21, t3, n3) {
            const r3 = e21.getValue(), i2 = r3.name && aE(r3.name) || r3.typeParameters && aE(r3.typeParameters);
            if (r3.selfClosing && r3.attributes.length === 0 && !i2)
              return ["<", n3("name"), n3("typeParameters"), " />"];
            if (r3.attributes && r3.attributes.length === 1 && r3.attributes[0].value && oE(r3.attributes[0].value) && !r3.attributes[0].value.value.includes("\n") && !i2 && !aE(r3.attributes[0]))
              return GD([
                "<",
                n3("name"),
                n3("typeParameters"),
                " ",
                ...e21.map(n3, "attributes"),
                r3.selfClosing ? " />" : ">"
              ]);
            const u2 = r3.attributes.length > 0 && aE(eE(r3.attributes), cE.Trailing), o2 = r3.attributes.length === 0 && !i2 || (t3.bracketSameLine || t3.jsxBracketSameLine) && (!i2 || r3.attributes.length > 0) && !u2, s2 = r3.attributes && r3.attributes.some((e22) => e22.value && oE(e22.value) && e22.value.value.includes("\n"));
            return GD([
              "<",
              n3("name"),
              n3("typeParameters"),
              HD(e21.map(() => [qD, n3()], "attributes")),
              r3.selfClosing ? qD : o2 ? ">" : zD,
              r3.selfClosing ? "/>" : o2 ? "" : ">"
            ], { shouldBreak: s2 });
          }(e20, t2, n2);
        case "JSXClosingElement":
          return function(e21, t3, n3) {
            const r3 = e21.getValue(), i2 = [];
            i2.push("</");
            const u2 = n3("name");
            return aE(r3.name, cE.Leading | cE.Line) ? i2.push(HD([UD, u2]), UD) : aE(r3.name, cE.Leading | cE.Block) ? i2.push(" ", u2) : i2.push(u2), i2.push(">"), i2;
          }(e20, 0, n2);
        case "JSXOpeningFragment":
        case "JSXClosingFragment":
          return function(e21, t3) {
            const n3 = e21.getValue(), r3 = aE(n3), i2 = aE(n3, cE.Line), u2 = n3.type === "JSXOpeningFragment";
            return [
              u2 ? "<" : "</",
              HD([i2 ? UD : r3 && !u2 ? " " : "", WD(e21, t3, true)]),
              i2 ? UD : "",
              ">"
            ];
          }(e20, t2);
        case "JSXEmptyExpression":
          return function(e21, t3) {
            const n3 = e21.getValue(), r3 = aE(n3, cE.Line);
            return [WD(e21, t3, !r3), r3 ? UD : ""];
          }(e20, t2);
        case "JSXText":
          throw new Error("JSXTest should be handled by JSXElement");
        default:
          throw new Error(`Unknown JSX node type: ${JSON.stringify(r2.type)}.`);
      }
  }
};
Ze$3({ target: "Array", proto: true }, {
  flat: function() {
    var e20 = arguments.length ? arguments[0] : void 0, t2 = q$3(this), n2 = Le$3(t2.length), r2 = Wn$2(t2, 0);
    return r2.length = $n$2(r2, t2, t2, n2, 0, e20 === void 0 ? 1 : Oe$3(e20)), r2;
  }
});
const { isNonEmptyArray: vE } = yi$2, {
  builders: { indent: FE, join: SE, line: xE }
} = eu$1, { isFlowAnnotationComment: wE } = Gh;
function TE(e20, t2, n2) {
  const r2 = e20.getValue();
  if (!r2.typeAnnotation)
    return "";
  const i2 = e20.getParentNode(), u2 = r2.definite || i2 && i2.type === "VariableDeclarator" && i2.definite, o2 = i2.type === "DeclareFunction" && i2.id === r2;
  return wE(t2.originalText, r2.typeAnnotation) ? [" /*: ", n2("typeAnnotation"), " */"] : [o2 ? "" : u2 ? "!: " : ": ", n2("typeAnnotation")];
}
var BE = {
  printOptionalToken: function(e20) {
    const t2 = e20.getValue();
    return !t2.optional || t2.type === "Identifier" && t2 === e20.getParentNode().key ? "" : t2.type === "OptionalCallExpression" || t2.type === "OptionalMemberExpression" && t2.computed ? "?." : "?";
  },
  printFunctionTypeParameters: function(e20, t2, n2) {
    const r2 = e20.getValue();
    return r2.typeArguments ? n2("typeArguments") : r2.typeParameters ? n2("typeParameters") : "";
  },
  printBindExpressionCallee: function(e20, t2, n2) {
    return ["::", n2("callee")];
  },
  printTypeScriptModifiers: function(e20, t2, n2) {
    const r2 = e20.getValue();
    return vE(r2.modifiers) ? [SE(" ", e20.map(n2, "modifiers")), " "] : "";
  },
  printTypeAnnotation: TE,
  printRestSpread: function(e20, t2, n2) {
    return ["...", n2("argument"), TE(e20, t2, n2)];
  },
  adjustClause: function(e20, t2, n2) {
    return e20.type === "EmptyStatement" ? ";" : e20.type === "BlockStatement" || n2 ? [" ", t2] : FE([xE, t2]);
  }
};
const { printDanglingComments: NE } = Wf, {
  builders: {
    line: kE,
    softline: PE,
    hardline: OE,
    group: IE,
    indent: LE,
    ifBreak: jE,
    fill: _E
  }
} = eu$1, { getLast: ME, hasNewline: RE } = yi$2, {
  shouldPrintComma: $E,
  hasComment: VE,
  CommentCheckFlags: WE,
  isNextLineEmpty: qE,
  isNumericLiteral: UE,
  isSignedNumericLiteral: zE
} = Gh, { locStart: GE } = zc, { printOptionalToken: HE, printTypeAnnotation: JE } = BE;
function XE(e20, t2) {
  return e20.elements.length > 1 && e20.elements.every((e21) => e21 && (UE(e21) || zE(e21) && !VE(e21.argument)) && !VE(e21, WE.Trailing | WE.Line, (e22) => !RE(t2.originalText, GE(e22), { backwards: true })));
}
function YE(e20, t2, n2, r2) {
  const i2 = [];
  let u2 = [];
  return e20.each((e21) => {
    i2.push(u2, IE(r2())), u2 = [",", kE], e21.getValue() && qE(e21.getValue(), t2) && u2.push(PE);
  }, n2), i2;
}
function KE(e20, t2, n2, r2) {
  const i2 = [];
  return e20.each((e21, u2, o2) => {
    const s2 = u2 === o2.length - 1;
    i2.push([n2(), s2 ? r2 : ","]), s2 || i2.push(qE(e21.getValue(), t2) ? [OE, OE] : VE(o2[u2 + 1], WE.Leading | WE.Line) ? OE : kE);
  }, "elements"), _E(i2);
}
var QE = {
  printArray: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = [], u2 = r2.type === "TupleExpression" ? "#[" : "[";
    if (r2.elements.length === 0)
      VE(r2, WE.Dangling) ? i2.push(IE([u2, NE(e20, t2), PE, "]"])) : i2.push(u2, "]");
    else {
      const o2 = ME(r2.elements), s2 = !(o2 && o2.type === "RestElement"), a2 = o2 === null, c2 = Symbol("array"), l2 = !t2.__inJestEach && r2.elements.length > 1 && r2.elements.every((e21, t3, n3) => {
        const r3 = e21 && e21.type;
        if (r3 !== "ArrayExpression" && r3 !== "ObjectExpression")
          return false;
        const i3 = n3[t3 + 1];
        if (i3 && r3 !== i3.type)
          return false;
        const u3 = r3 === "ArrayExpression" ? "elements" : "properties";
        return e21[u3] && e21[u3].length > 1;
      }), p2 = XE(r2, t2), f2 = s2 ? a2 ? "," : $E(t2) ? p2 ? jE(",", "", { groupId: c2 }) : jE(",") : "" : "";
      i2.push(IE([
        u2,
        LE([
          PE,
          p2 ? KE(e20, t2, n2, f2) : [YE(e20, t2, "elements", n2), f2],
          NE(e20, t2, true)
        ]),
        PE,
        "]"
      ], { shouldBreak: l2, id: c2 }));
    }
    return i2.push(HE(e20), JE(e20, t2, n2)), i2;
  },
  printArrayItems: YE,
  isConciselyPrintedArray: XE
};
const { printDanglingComments: ZE } = Wf, { getLast: eC, getPenultimate: tC } = yi$2, {
  getFunctionParameters: nC,
  hasComment: rC,
  CommentCheckFlags: iC,
  isFunctionCompositionArgs: uC,
  isJsxNode: oC,
  isLongCurriedCallExpression: sC,
  shouldPrintComma: aC,
  getCallArguments: cC,
  iterateCallArgumentsPath: lC,
  isNextLineEmpty: pC,
  isCallExpression: fC,
  isStringLiteral: dC,
  isObjectProperty: hC
} = Gh, {
  builders: {
    line: gC,
    hardline: mC,
    softline: yC,
    group: DC,
    indent: EC,
    conditionalGroup: CC,
    ifBreak: bC,
    breakParent: AC
  },
  utils: { willBreak: vC }
} = eu$1, { ArgExpansionBailout: FC } = bo$2, { isConciselyPrintedArray: SC } = QE;
function xC(e20, t2 = false) {
  return e20.type === "ObjectExpression" && (e20.properties.length > 0 || rC(e20)) || e20.type === "ArrayExpression" && (e20.elements.length > 0 || rC(e20)) || e20.type === "TSTypeAssertion" && xC(e20.expression) || e20.type === "TSAsExpression" && xC(e20.expression) || e20.type === "FunctionExpression" || e20.type === "ArrowFunctionExpression" && (!e20.returnType || !e20.returnType.typeAnnotation || e20.returnType.typeAnnotation.type !== "TSTypeReference" || (n2 = e20.body).type === "BlockStatement" && (n2.body.some((e21) => e21.type !== "EmptyStatement") || rC(n2, iC.Dangling))) && (e20.body.type === "BlockStatement" || e20.body.type === "ArrowFunctionExpression" && xC(e20.body, true) || e20.body.type === "ObjectExpression" || e20.body.type === "ArrayExpression" || !t2 && (fC(e20.body) || e20.body.type === "ConditionalExpression") || oC(e20.body)) || e20.type === "DoExpression" || e20.type === "ModuleExpression";
  var n2;
}
var wC = function(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = r2.type === "ImportExpression", u2 = cC(r2);
  if (u2.length === 0)
    return ["(", ZE(e20, t2, true), ")"];
  if (function(e21) {
    return e21.length === 2 && e21[0].type === "ArrowFunctionExpression" && nC(e21[0]).length === 0 && e21[0].body.type === "BlockStatement" && e21[1].type === "ArrayExpression" && !e21.some((e22) => rC(e22));
  }(u2))
    return ["(", n2(["arguments", 0]), ", ", n2(["arguments", 1]), ")"];
  let o2 = false, s2 = false;
  const a2 = u2.length - 1, c2 = [];
  lC(e20, (e21, r3) => {
    const i3 = e21.getNode(), u3 = [n2()];
    r3 === a2 || (pC(i3, t2) ? (r3 === 0 && (s2 = true), o2 = true, u3.push(",", mC, mC)) : u3.push(",", gC)), c2.push(u3);
  });
  const l2 = i2 || r2.callee && r2.callee.type === "Import" || !aC(t2, "all") ? "" : ",";
  function p2() {
    return DC(["(", EC([gC, ...c2]), l2, gC, ")"], { shouldBreak: true });
  }
  if (o2 || e20.getParentNode().type !== "Decorator" && uC(u2))
    return p2();
  const f2 = function(e21) {
    if (e21.length !== 2)
      return false;
    const [t3, n3] = e21;
    if (t3.type === "ModuleExpression" && function(e22) {
      return e22.type === "ObjectExpression" && e22.properties.length === 1 && hC(e22.properties[0]) && e22.properties[0].key.type === "Identifier" && e22.properties[0].key.name === "type" && dC(e22.properties[0].value) && e22.properties[0].value.value === "module";
    }(n3))
      return true;
    return !rC(t3) && (t3.type === "FunctionExpression" || t3.type === "ArrowFunctionExpression" && t3.body.type === "BlockStatement") && n3.type !== "FunctionExpression" && n3.type !== "ArrowFunctionExpression" && n3.type !== "ConditionalExpression" && !xC(n3);
  }(u2), d2 = function(e21, t3) {
    const n3 = eC(e21), r3 = tC(e21);
    return !rC(n3, iC.Leading) && !rC(n3, iC.Trailing) && xC(n3) && (!r3 || r3.type !== n3.type) && (e21.length !== 2 || r3.type !== "ArrowFunctionExpression" || n3.type !== "ArrayExpression") && !(e21.length > 1 && n3.type === "ArrayExpression" && SC(n3, t3));
  }(u2, t2);
  if (f2 || d2) {
    if (f2 ? c2.slice(1).some(vC) : c2.slice(0, -1).some(vC))
      return p2();
    let t3 = [];
    try {
      e20.try(() => {
        lC(e20, (e21, r3) => {
          f2 && r3 === 0 && (t3 = [
            [
              n2([], { expandFirstArg: true }),
              c2.length > 1 ? "," : "",
              s2 ? mC : gC,
              s2 ? mC : ""
            ],
            ...c2.slice(1)
          ]), d2 && r3 === a2 && (t3 = [
            ...c2.slice(0, -1),
            n2([], { expandLastArg: true })
          ]);
        });
      });
    } catch (e21) {
      if (e21 instanceof FC)
        return p2();
      throw e21;
    }
    return [
      c2.some(vC) ? AC : "",
      CC([
        ["(", ...t3, ")"],
        f2 ? ["(", DC(t3[0], { shouldBreak: true }), ...t3.slice(1), ")"] : [
          "(",
          ...c2.slice(0, -1),
          DC(eC(t3), { shouldBreak: true }),
          ")"
        ],
        p2()
      ])
    ];
  }
  const h2 = ["(", EC([yC, ...c2]), bC(l2), yC, ")"];
  return sC(e20) ? h2 : DC(h2, { shouldBreak: c2.some(vC) || o2 });
};
const {
  builders: { softline: TC, group: BC, indent: NC, label: kC }
} = eu$1, { isNumericLiteral: PC, isMemberExpression: OC, isCallExpression: IC } = Gh, { printOptionalToken: LC } = BE;
function jC(e20, t2, n2) {
  const r2 = n2("property"), i2 = e20.getValue(), u2 = LC(e20);
  return i2.computed ? !i2.property || PC(i2.property) ? [u2, "[", r2, "]"] : BC([u2, "[", NC([TC, r2]), TC, "]"]) : [u2, ".", r2];
}
var _C = {
  printMemberExpression: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = e20.getParentNode();
    let u2, o2 = 0;
    do {
      u2 = e20.getParentNode(o2), o2++;
    } while (u2 && (OC(u2) || u2.type === "TSNonNullExpression"));
    const s2 = n2("object"), a2 = jC(e20, t2, n2), c2 = u2 && (u2.type === "NewExpression" || u2.type === "BindExpression" || u2.type === "AssignmentExpression" && u2.left.type !== "Identifier") || r2.computed || r2.object.type === "Identifier" && r2.property.type === "Identifier" && !OC(i2) || (i2.type === "AssignmentExpression" || i2.type === "VariableDeclarator") && (IC(r2.object) && r2.object.arguments.length > 0 || r2.object.type === "TSNonNullExpression" && IC(r2.object.expression) && r2.object.expression.arguments.length > 0 || s2.label === "member-chain");
    return kC(s2.label === "member-chain" ? "member-chain" : "member", [
      s2,
      c2 ? a2 : BC(NC([TC, a2]))
    ]);
  },
  printMemberLookup: jC
};
const { printComments: MC } = Wf, {
  getLast: RC,
  isNextLineEmptyAfterIndex: $C,
  getNextNonSpaceNonCommentCharacterIndex: VC
} = yi$2, {
  isCallExpression: WC,
  isMemberExpression: qC,
  isFunctionOrArrowExpression: UC,
  isLongCurriedCallExpression: zC,
  isMemberish: GC,
  isNumericLiteral: HC,
  isSimpleCallArgument: JC,
  hasComment: XC,
  CommentCheckFlags: YC,
  isNextLineEmpty: KC
} = Gh, { locEnd: QC } = zc, {
  builders: {
    join: ZC,
    hardline: eb,
    group: tb,
    indent: nb,
    conditionalGroup: rb,
    breakParent: ib,
    label: ub
  },
  utils: { willBreak: ob }
} = eu$1, { printMemberLookup: sb } = _C, {
  printOptionalToken: ab,
  printFunctionTypeParameters: cb,
  printBindExpressionCallee: lb
} = BE;
var pb = function(e20, t2, n2) {
  const r2 = e20.getParentNode(), i2 = !r2 || r2.type === "ExpressionStatement", u2 = [];
  function o2(e21) {
    const { originalText: n3 } = t2, r3 = VC(n3, e21, QC);
    return n3.charAt(r3) === ")" ? r3 !== false && $C(n3, r3 + 1) : KC(e21, t2);
  }
  function s2(e21) {
    const r3 = e21.getValue();
    WC(r3) && (GC(r3.callee) || WC(r3.callee)) ? (u2.unshift({
      node: r3,
      printed: [
        MC(e21, [ab(e21), cb(e21, t2, n2), wC(e21, t2, n2)], t2),
        o2(r3) ? eb : ""
      ]
    }), e21.call((e22) => s2(e22), "callee")) : GC(r3) ? (u2.unshift({
      node: r3,
      needsParens: Qy(e21, t2),
      printed: MC(e21, qC(r3) ? sb(e21, t2, n2) : lb(e21, t2, n2), t2)
    }), e21.call((e22) => s2(e22), "object")) : r3.type === "TSNonNullExpression" ? (u2.unshift({ node: r3, printed: MC(e21, "!", t2) }), e21.call((e22) => s2(e22), "expression")) : u2.unshift({ node: r3, printed: n2() });
  }
  const a2 = e20.getValue();
  u2.unshift({ node: a2, printed: [ab(e20), cb(e20, t2, n2), wC(e20, t2, n2)] }), a2.callee && e20.call((e21) => s2(e21), "callee");
  const c2 = [];
  let l2 = [u2[0]], p2 = 1;
  for (; p2 < u2.length && (u2[p2].node.type === "TSNonNullExpression" || WC(u2[p2].node) || qC(u2[p2].node) && u2[p2].node.computed && HC(u2[p2].node.property)); ++p2)
    l2.push(u2[p2]);
  if (!WC(u2[0].node))
    for (; p2 + 1 < u2.length && GC(u2[p2].node) && GC(u2[p2 + 1].node); ++p2)
      l2.push(u2[p2]);
  c2.push(l2), l2 = [];
  let f2 = false;
  for (; p2 < u2.length; ++p2) {
    if (f2 && GC(u2[p2].node)) {
      if (u2[p2].node.computed && HC(u2[p2].node.property)) {
        l2.push(u2[p2]);
        continue;
      }
      c2.push(l2), l2 = [], f2 = false;
    }
    (WC(u2[p2].node) || u2[p2].node.type === "ImportExpression") && (f2 = true), l2.push(u2[p2]), XC(u2[p2].node, YC.Trailing) && (c2.push(l2), l2 = [], f2 = false);
  }
  function d2(e21) {
    return /^[A-Z]|^[$_]+$/.test(e21);
  }
  l2.length > 0 && c2.push(l2);
  const h2 = c2.length >= 2 && !XC(c2[1][0].node) && function(e21) {
    const n3 = e21[1].length > 0 && e21[1][0].node.computed;
    if (e21[0].length === 1) {
      const r4 = e21[0][0].node;
      return r4.type === "ThisExpression" || r4.type === "Identifier" && (d2(r4.name) || i2 && function(e22) {
        return e22.length <= t2.tabWidth;
      }(r4.name) || n3);
    }
    const r3 = RC(e21[0]).node;
    return qC(r3) && r3.property.type === "Identifier" && (d2(r3.property.name) || n3);
  }(c2);
  function g2(e21) {
    const t3 = e21.map((e22) => e22.printed);
    return e21.length > 0 && RC(e21).needsParens ? ["(", ...t3, ")"] : t3;
  }
  const m2 = c2.map(g2), y2 = m2, D2 = h2 ? 3 : 2, E2 = c2.flat(), C2 = E2.slice(1, -1).some((e21) => XC(e21.node, YC.Leading)) || E2.slice(0, -1).some((e21) => XC(e21.node, YC.Trailing)) || c2[D2] && XC(c2[D2][0].node, YC.Leading);
  if (c2.length <= D2 && !C2)
    return zC(e20) ? y2 : tb(y2);
  const b2 = RC(c2[h2 ? 1 : 0]).node, A2 = !WC(b2) && o2(b2), v2 = [
    g2(c2[0]),
    h2 ? c2.slice(1, 2).map(g2) : "",
    A2 ? eb : "",
    function(e21) {
      return e21.length === 0 ? "" : nb(tb([eb, ZC(eb, e21.map(g2))]));
    }(c2.slice(h2 ? 2 : 1))
  ], F2 = u2.map(({ node: e21 }) => e21).filter(WC);
  let S2;
  return S2 = C2 || F2.length > 2 && F2.some((e21) => !e21.arguments.every((e22) => JC(e22, 0))) || m2.slice(0, -1).some(ob) || function() {
    const e21 = RC(RC(c2)).node, t3 = RC(m2);
    return WC(e21) && ob(t3) && F2.slice(0, -1).some((e22) => e22.arguments.some(UC));
  }() ? tb(v2) : [ob(y2) || A2 ? ib : "", rb([y2, v2])], ub("member-chain", S2);
};
const {
  builders: { join: fb, group: db }
} = eu$1, {
  getCallArguments: hb,
  hasFlowAnnotationComment: gb,
  isCallExpression: mb,
  isMemberish: yb,
  isStringLiteral: Db,
  isTemplateOnItsOwnLine: Eb,
  isTestCall: Cb,
  iterateCallArgumentsPath: bb
} = Gh, { printOptionalToken: Ab, printFunctionTypeParameters: vb } = BE;
var Fb = {
  printCallExpression: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = e20.getParentNode(), u2 = r2.type === "NewExpression", o2 = r2.type === "ImportExpression", s2 = Ab(e20), a2 = hb(r2);
    if (a2.length > 0 && (!o2 && !u2 && function(e21, t3) {
      if (e21.callee.type !== "Identifier")
        return false;
      if (e21.callee.name === "require")
        return true;
      if (e21.callee.name === "define") {
        const n3 = hb(e21);
        return t3.type === "ExpressionStatement" && (n3.length === 1 || n3.length === 2 && n3[0].type === "ArrayExpression" || n3.length === 3 && Db(n3[0]) && n3[1].type === "ArrayExpression");
      }
      return false;
    }(r2, i2) || a2.length === 1 && Eb(a2[0], t2.originalText) || !u2 && Cb(r2, i2))) {
      const r3 = [];
      return bb(e20, () => {
        r3.push(n2());
      }), [
        u2 ? "new " : "",
        n2("callee"),
        s2,
        vb(e20, t2, n2),
        "(",
        fb(", ", r3),
        ")"
      ];
    }
    const c2 = (t2.parser === "babel" || t2.parser === "babel-flow") && r2.callee && r2.callee.type === "Identifier" && gb(r2.callee.trailingComments);
    if (c2 && (r2.callee.trailingComments[0].printed = true), !o2 && !u2 && yb(r2.callee) && !e20.call((e21) => Qy(e21, t2), "callee"))
      return pb(e20, t2, n2);
    const l2 = [
      u2 ? "new " : "",
      o2 ? "import" : n2("callee"),
      s2,
      c2 ? `/*:: ${r2.callee.trailingComments[0].value.slice(2).trim()} */` : "",
      vb(e20, t2, n2),
      wC(e20, t2, n2)
    ];
    return o2 || mb(r2.callee) ? db(l2) : l2;
  }
};
const { isNonEmptyArray: Sb, getStringWidth: xb } = yi$2, {
  builders: { line: wb, group: Tb, indent: Bb, indentIfBreak: Nb },
  utils: { cleanDoc: kb, willBreak: Pb }
} = eu$1, {
  hasLeadingOwnLineComment: Ob,
  isBinaryish: Ib,
  isStringLiteral: Lb,
  isLiteral: jb,
  isNumericLiteral: _b$3,
  isCallExpression: Mb,
  isMemberExpression: Rb,
  getCallArguments: $b,
  rawText: Vb,
  hasComment: Wb,
  isSignedNumericLiteral: qb,
  isObjectProperty: Ub
} = Gh, { shouldInlineLogicalExpression: zb } = kD, { printCallExpression: Gb } = Fb;
function Hb(e20, t2, n2, r2, i2, u2) {
  const o2 = function(e21, t3, n3, r3, i3) {
    const u3 = e21.getValue(), o3 = u3[i3];
    if (!o3)
      return "only-left";
    const s3 = !Jb(o3);
    if (e21.match(Jb, Xb, (e22) => !s3 || e22.type !== "ExpressionStatement" && e22.type !== "VariableDeclaration"))
      return s3 ? o3.type === "ArrowFunctionExpression" && o3.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
    if (!s3 && Jb(o3.right) || Ob(t3.originalText, o3))
      return "break-after-operator";
    if (o3.type === "CallExpression" && o3.callee.name === "require" || t3.parser === "json5" || t3.parser === "json")
      return "never-break-after-operator";
    if (function(e22) {
      if (Xb(e22)) {
        const t4 = e22.left || e22.id;
        return t4.type === "ObjectPattern" && t4.properties.length > 2 && t4.properties.some((e23) => Ub(e23) && (!e23.shorthand || e23.value && e23.value.type === "AssignmentPattern"));
      }
      return false;
    }(u3) || function(e22) {
      const t4 = function(e23) {
        if (function(e24) {
          return e24.type === "TSTypeAliasDeclaration" || e24.type === "TypeAlias";
        }(e23) && e23.typeParameters && e23.typeParameters.params)
          return e23.typeParameters.params;
        return null;
      }(e22);
      if (Sb(t4)) {
        const n4 = e22.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
        if (t4.length > 1 && t4.some((e23) => e23[n4] || e23.default))
          return true;
      }
      return false;
    }(u3) || function(e22) {
      if (e22.type !== "VariableDeclarator")
        return false;
      const { typeAnnotation: t4 } = e22.id;
      if (!t4 || !t4.typeAnnotation)
        return false;
      const n4 = Yb(t4.typeAnnotation);
      return Sb(n4) && n4.length > 1 && n4.some((e23) => Sb(Yb(e23)) || e23.type === "TSConditionalType");
    }(u3))
      return "break-lhs";
    const a2 = function(e22, t4, n4) {
      if (!Ub(e22))
        return false;
      t4 = kb(t4);
      const r4 = 3;
      return typeof t4 == "string" && xb(t4) < n4.tabWidth + r4;
    }(u3, r3, t3);
    if (e21.call(() => function(e22, t4, n4, r4) {
      const i4 = e22.getValue();
      if (Ib(i4) && !zb(i4))
        return true;
      switch (i4.type) {
        case "StringLiteralTypeAnnotation":
        case "SequenceExpression":
          return true;
        case "ConditionalExpression": {
          const { test: e23 } = i4;
          return Ib(e23) && !zb(e23);
        }
        case "ClassExpression":
          return Sb(i4.decorators);
      }
      if (r4)
        return false;
      let u4 = i4;
      const o4 = [];
      for (; ; )
        if (u4.type === "UnaryExpression")
          u4 = u4.argument, o4.push("argument");
        else {
          if (u4.type !== "TSNonNullExpression")
            break;
          u4 = u4.expression, o4.push("expression");
        }
      if (Lb(u4) || e22.call(() => Kb(e22, t4, n4), ...o4))
        return true;
      return false;
    }(e21, t3, n3, a2), i3))
      return "break-after-operator";
    if (a2 || o3.type === "TemplateLiteral" || o3.type === "TaggedTemplateExpression" || o3.type === "BooleanLiteral" || _b$3(o3) || o3.type === "ClassExpression")
      return "never-break-after-operator";
    return "fluid";
  }(e20, t2, n2, r2, u2), s2 = n2(u2, { assignmentLayout: o2 });
  switch (o2) {
    case "break-after-operator":
      return Tb([Tb(r2), i2, Tb(Bb([wb, s2]))]);
    case "never-break-after-operator":
      return Tb([Tb(r2), i2, " ", s2]);
    case "fluid": {
      const e21 = Symbol("assignment");
      return Tb([Tb(r2), i2, Tb(Bb(wb), { id: e21 }), Nb(s2, { groupId: e21 })]);
    }
    case "break-lhs":
      return Tb([r2, i2, " ", Tb(s2)]);
    case "chain":
      return [Tb(r2), i2, wb, s2];
    case "chain-tail":
      return [Tb(r2), i2, Bb([wb, s2])];
    case "chain-tail-arrow-chain":
      return [Tb(r2), i2, s2];
    case "only-left":
      return r2;
  }
}
function Jb(e20) {
  return e20.type === "AssignmentExpression";
}
function Xb(e20) {
  return Jb(e20) || e20.type === "VariableDeclarator";
}
function Yb(e20) {
  return function(e21) {
    return e21.type === "TSTypeReference" || e21.type === "GenericTypeAnnotation";
  }(e20) && e20.typeParameters && e20.typeParameters.params ? e20.typeParameters.params : null;
}
function Kb(e20, t2, n2, r2 = false) {
  const i2 = e20.getValue(), u2 = () => Kb(e20, t2, n2, true);
  if (i2.type === "TSNonNullExpression")
    return e20.call(u2, "expression");
  if (Mb(i2)) {
    if (Gb(e20, t2, n2).label === "member-chain")
      return false;
    const r3 = $b(i2);
    return !!(r3.length === 0 || r3.length === 1 && function(e21, { printWidth: t3 }) {
      if (Wb(e21))
        return false;
      const n3 = 0.25 * t3;
      if (e21.type === "ThisExpression" || e21.type === "Identifier" && e21.name.length <= n3 || qb(e21) && !Wb(e21.argument))
        return true;
      const r4 = e21.type === "Literal" && "regex" in e21 && e21.regex.pattern || e21.type === "RegExpLiteral" && e21.pattern;
      if (r4)
        return r4.length <= n3;
      if (Lb(e21))
        return Vb(e21).length <= n3;
      if (e21.type === "TemplateLiteral")
        return e21.expressions.length === 0 && e21.quasis[0].value.raw.length <= n3 && !e21.quasis[0].value.raw.includes("\n");
      return jb(e21);
    }(r3[0], t2)) && !function(e21, t3) {
      const n3 = function(e22) {
        return e22.typeParameters && e22.typeParameters.params || e22.typeArguments && e22.typeArguments.params;
      }(e21);
      if (Sb(n3)) {
        if (n3.length > 1)
          return true;
        if (n3.length === 1) {
          const e22 = n3[0];
          if (e22.type === "TSUnionType" || e22.type === "UnionTypeAnnotation" || e22.type === "TSIntersectionType" || e22.type === "IntersectionTypeAnnotation")
            return true;
        }
        const r4 = e21.typeParameters ? "typeParameters" : "typeArguments";
        if (Pb(t3(r4)))
          return true;
      }
      return false;
    }(i2, n2) && e20.call(u2, "callee");
  }
  return Rb(i2) ? e20.call(u2, "object") : r2 && (i2.type === "Identifier" || i2.type === "ThisExpression");
}
var Qb = {
  printVariableDeclarator: function(e20, t2, n2) {
    return Hb(e20, t2, n2, n2("id"), " =", "init");
  },
  printAssignmentExpression: function(e20, t2, n2) {
    const r2 = e20.getValue();
    return Hb(e20, t2, n2, n2("left"), [" ", r2.operator], "right");
  },
  printAssignment: Hb
};
const { getNextNonSpaceNonCommentCharacter: Zb } = yi$2, { printDanglingComments: eA } = Wf, {
  builders: {
    line: tA,
    hardline: nA,
    softline: rA,
    group: iA,
    indent: uA,
    ifBreak: oA
  },
  utils: { removeLines: sA, willBreak: aA }
} = eu$1, {
  getFunctionParameters: cA,
  iterateFunctionParametersPath: lA,
  isSimpleType: pA,
  isTestCall: fA,
  isTypeAnnotationAFunction: dA,
  isObjectType: hA,
  isObjectTypePropertyAFunction: gA,
  hasRestParameter: mA,
  shouldPrintComma: yA,
  hasComment: DA,
  isNextLineEmpty: EA
} = Gh, { locEnd: CA } = zc, { ArgExpansionBailout: bA } = bo$2, { printFunctionTypeParameters: AA } = BE;
function vA(e20) {
  if (!e20)
    return false;
  const t2 = cA(e20);
  if (t2.length !== 1)
    return false;
  const [n2] = t2;
  return !DA(n2) && (n2.type === "ObjectPattern" || n2.type === "ArrayPattern" || n2.type === "Identifier" && n2.typeAnnotation && (n2.typeAnnotation.type === "TypeAnnotation" || n2.typeAnnotation.type === "TSTypeAnnotation") && hA(n2.typeAnnotation.typeAnnotation) || n2.type === "FunctionTypeParam" && hA(n2.typeAnnotation) || n2.type === "AssignmentPattern" && (n2.left.type === "ObjectPattern" || n2.left.type === "ArrayPattern") && (n2.right.type === "Identifier" || n2.right.type === "ObjectExpression" && n2.right.properties.length === 0 || n2.right.type === "ArrayExpression" && n2.right.elements.length === 0));
}
var FA = {
  printFunctionParameters: function(e20, t2, n2, r2, i2) {
    const u2 = e20.getValue(), o2 = cA(u2), s2 = i2 ? AA(e20, n2, t2) : "";
    if (o2.length === 0)
      return [
        s2,
        "(",
        eA(e20, n2, true, (e21) => Zb(n2.originalText, e21, CA) === ")"),
        ")"
      ];
    const a2 = e20.getParentNode(), c2 = fA(a2), l2 = vA(u2), p2 = [];
    if (lA(e20, (e21, r3) => {
      const i3 = r3 === o2.length - 1;
      i3 && u2.rest && p2.push("..."), p2.push(t2()), i3 || (p2.push(","), c2 || l2 ? p2.push(" ") : EA(o2[r3], n2) ? p2.push(nA, nA) : p2.push(tA));
    }), r2) {
      if (aA(s2) || aA(p2))
        throw new bA();
      return iA([sA(s2), "(", sA(p2), ")"]);
    }
    const f2 = o2.every((e21) => !e21.decorators);
    return l2 && f2 || c2 ? [s2, "(", ...p2, ")"] : (gA(a2) || dA(a2) || a2.type === "TypeAlias" || a2.type === "UnionTypeAnnotation" || a2.type === "TSUnionType" || a2.type === "IntersectionTypeAnnotation" || a2.type === "FunctionTypeAnnotation" && a2.returnType === u2) && o2.length === 1 && o2[0].name === null && u2.this !== o2[0] && o2[0].typeAnnotation && u2.typeParameters === null && pA(o2[0].typeAnnotation) && !u2.rest ? n2.arrowParens === "always" ? ["(", ...p2, ")"] : p2 : [
      s2,
      "(",
      uA([rA, ...p2]),
      oA(!mA(u2) && yA(n2, "all") ? "," : ""),
      rA,
      ")"
    ];
  },
  shouldHugFunctionParameters: vA,
  shouldGroupFunctionParameters: function(e20, t2) {
    const n2 = function(e21) {
      let t3;
      return e21.returnType ? (t3 = e21.returnType, t3.typeAnnotation && (t3 = t3.typeAnnotation)) : e21.typeAnnotation && (t3 = e21.typeAnnotation), t3;
    }(e20);
    if (!n2)
      return false;
    const r2 = e20.typeParameters && e20.typeParameters.params;
    if (r2) {
      if (r2.length > 1)
        return false;
      if (r2.length === 1) {
        const e21 = r2[0];
        if (e21.constraint || e21.default)
          return false;
      }
    }
    return cA(e20).length === 1 && (hA(n2) || aA(t2));
  }
};
const { printComments: SA, printDanglingComments: xA } = Wf, { getLast: wA } = yi$2, {
  builders: {
    group: TA,
    join: BA,
    line: NA,
    softline: kA,
    indent: PA,
    align: OA,
    ifBreak: IA
  }
} = eu$1, { locStart: LA } = zc, {
  isSimpleType: jA,
  isObjectType: _A,
  hasLeadingOwnLineComment: MA,
  isObjectTypePropertyAFunction: RA,
  shouldPrintComma: $A
} = Gh, { printAssignment: VA } = Qb, { printFunctionParameters: WA, shouldGroupFunctionParameters: qA } = FA, { printArrayItems: UA } = QE;
function zA(e20) {
  if (jA(e20) || _A(e20))
    return true;
  if (e20.type === "UnionTypeAnnotation" || e20.type === "TSUnionType") {
    const t2 = e20.types.filter((e21) => e21.type === "VoidTypeAnnotation" || e21.type === "TSVoidKeyword" || e21.type === "NullLiteralTypeAnnotation" || e21.type === "TSNullKeyword").length, n2 = e20.types.some((e21) => e21.type === "ObjectTypeAnnotation" || e21.type === "TSTypeLiteral" || e21.type === "GenericTypeAnnotation" || e21.type === "TSTypeReference");
    if (e20.types.length - 1 === t2 && n2)
      return true;
  }
  return false;
}
var GA = {
  printOpaqueType: function(e20, t2, n2) {
    const r2 = t2.semi ? ";" : "", i2 = e20.getValue(), u2 = [];
    return u2.push("opaque type ", n2("id"), n2("typeParameters")), i2.supertype && u2.push(": ", n2("supertype")), i2.impltype && u2.push(" = ", n2("impltype")), u2.push(r2), u2;
  },
  printTypeAlias: function(e20, t2, n2) {
    const r2 = t2.semi ? ";" : "", i2 = e20.getValue(), u2 = [];
    i2.declare && u2.push("declare "), u2.push("type ", n2("id"), n2("typeParameters"));
    const o2 = i2.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
    return [VA(e20, t2, n2, u2, " =", o2), r2];
  },
  printIntersectionType: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = e20.map(n2, "types"), u2 = [];
    let o2 = false;
    for (let e21 = 0; e21 < i2.length; ++e21)
      e21 === 0 ? u2.push(i2[e21]) : _A(r2.types[e21 - 1]) && _A(r2.types[e21]) ? u2.push([" & ", o2 ? PA(i2[e21]) : i2[e21]]) : _A(r2.types[e21 - 1]) || _A(r2.types[e21]) ? (e21 > 1 && (o2 = true), u2.push(" & ", e21 > 1 ? PA(i2[e21]) : i2[e21])) : u2.push(PA([" &", NA, i2[e21]]));
    return TA(u2);
  },
  printUnionType: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = e20.getParentNode(), u2 = !(i2.type === "TypeParameterInstantiation" || i2.type === "TSTypeParameterInstantiation" || i2.type === "GenericTypeAnnotation" || i2.type === "TSTypeReference" || i2.type === "TSTypeAssertion" || i2.type === "TupleTypeAnnotation" || i2.type === "TSTupleType" || i2.type === "FunctionTypeParam" && !i2.name && e20.getParentNode(1).this !== i2 || (i2.type === "TypeAlias" || i2.type === "VariableDeclarator" || i2.type === "TSTypeAliasDeclaration") && MA(t2.originalText, r2)), o2 = zA(r2), s2 = e20.map((e21) => {
      let r3 = n2();
      return o2 || (r3 = OA(2, r3)), SA(e21, r3, t2);
    }, "types");
    if (o2)
      return BA(" | ", s2);
    const a2 = u2 && !MA(t2.originalText, r2), c2 = [IA([a2 ? NA : "", "| "]), BA([NA, "| "], s2)];
    return Qy(e20, t2) ? TA([PA(c2), kA]) : i2.type === "TupleTypeAnnotation" && i2.types.length > 1 || i2.type === "TSTupleType" && i2.elementTypes.length > 1 ? TA([PA([IA(["(", kA]), c2]), kA, IA(")")]) : TA(u2 ? PA(c2) : c2);
  },
  printFunctionType: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = [], u2 = e20.getParentNode(0), o2 = e20.getParentNode(1), s2 = e20.getParentNode(2);
    let a2 = r2.type === "TSFunctionType" || !((u2.type === "ObjectTypeProperty" || u2.type === "ObjectTypeInternalSlot") && !u2.variance && !u2.optional && LA(u2) === LA(r2) || u2.type === "ObjectTypeCallProperty" || s2 && s2.type === "DeclareFunction"), c2 = a2 && (u2.type === "TypeAnnotation" || u2.type === "TSTypeAnnotation");
    const l2 = c2 && a2 && (u2.type === "TypeAnnotation" || u2.type === "TSTypeAnnotation") && o2.type === "ArrowFunctionExpression";
    RA(u2) && (a2 = true, c2 = true), l2 && i2.push("(");
    const p2 = WA(e20, n2, t2, false, true), f2 = r2.returnType || r2.predicate || r2.typeAnnotation ? [
      a2 ? " => " : ": ",
      n2("returnType"),
      n2("predicate"),
      n2("typeAnnotation")
    ] : "", d2 = qA(r2, f2);
    return i2.push(d2 ? TA(p2) : p2), f2 && i2.push(f2), l2 && i2.push(")"), TA(i2);
  },
  printTupleType: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = r2.type === "TSTupleType" ? "elementTypes" : "types", u2 = r2[i2].length > 0 && wA(r2[i2]).type === "TSRestType";
    return TA([
      "[",
      PA([kA, UA(e20, t2, i2, n2)]),
      IA($A(t2, "all") && !u2 ? "," : ""),
      xA(e20, t2, true),
      kA,
      "]"
    ]);
  },
  printIndexedAccessType: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = r2.type === "OptionalIndexedAccessType" && r2.optional ? "?.[" : "[";
    return [n2("objectType"), i2, n2("indexType"), "]"];
  },
  shouldHugType: zA
};
const { printDanglingComments: HA } = Wf, {
  builders: {
    join: JA,
    line: XA,
    hardline: YA,
    softline: KA,
    group: QA,
    indent: ZA,
    ifBreak: ev
  }
} = eu$1, {
  isTestCall: tv,
  hasComment: nv,
  CommentCheckFlags: rv,
  isTSXFile: iv,
  shouldPrintComma: uv,
  getFunctionParameters: ov
} = Gh, { createGroupIdMapper: sv } = yi$2, { shouldHugType: av } = GA, cv = sv("typeParameters");
function lv(e20, t2) {
  const n2 = e20.getValue();
  if (!nv(n2, rv.Dangling))
    return "";
  const r2 = !nv(n2, rv.Line), i2 = HA(e20, t2, r2);
  return r2 ? i2 : [i2, YA];
}
var pv = {
  printTypeParameter: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = [], u2 = e20.getParentNode();
    return u2.type === "TSMappedType" ? (i2.push("[", n2("name")), r2.constraint && i2.push(" in ", n2("constraint")), u2.nameType && i2.push(" as ", e20.callParent(() => n2("nameType"))), i2.push("]"), i2) : (r2.variance && i2.push(n2("variance")), i2.push(n2("name")), r2.bound && i2.push(": ", n2("bound")), r2.constraint && i2.push(" extends ", n2("constraint")), r2.default && i2.push(" = ", n2("default")), i2);
  },
  printTypeParameters: function(e20, t2, n2, r2) {
    const i2 = e20.getValue();
    if (!i2[r2])
      return "";
    if (!Array.isArray(i2[r2]))
      return n2(r2);
    const u2 = e20.getNode(2);
    if (u2 && tv(u2) || i2[r2].length === 0 || i2[r2].length === 1 && (av(i2[r2][0]) || i2[r2][0].type === "NullableTypeAnnotation"))
      return ["<", JA(", ", e20.map(n2, r2)), lv(e20, t2), ">"];
    const o2 = i2.type === "TSTypeParameterInstantiation" ? "" : ov(i2).length === 1 && iv(t2) && !i2[r2][0].constraint && e20.getParentNode().type === "ArrowFunctionExpression" ? "," : uv(t2, "all") ? ev(",") : "";
    return QA(["<", ZA([KA, JA([",", XA], e20.map(n2, r2))]), o2, KA, ">"], {
      id: cv(i2)
    });
  },
  getTypeParametersGroupId: cv
};
const { printComments: fv } = Wf, { printString: dv, printNumber: hv } = yi$2, {
  isNumericLiteral: gv,
  isSimpleNumber: mv,
  isStringLiteral: yv,
  isStringPropSafeToUnquote: Dv,
  rawText: Ev
} = Gh, { printAssignment: Cv } = Qb, bv = new WeakMap();
function Av(e20, t2, n2) {
  const r2 = e20.getNode();
  if (r2.computed)
    return ["[", n2("key"), "]"];
  const i2 = e20.getParentNode(), { key: u2 } = r2;
  if (r2.type === "ClassPrivateProperty" && u2.type === "Identifier")
    return ["#", n2("key")];
  if (t2.quoteProps === "consistent" && !bv.has(i2)) {
    const e21 = (i2.properties || i2.body || i2.members).some((e22) => !e22.computed && e22.key && yv(e22.key) && !Dv(e22, t2));
    bv.set(i2, e21);
  }
  if ((u2.type === "Identifier" || gv(u2) && mv(hv(Ev(u2))) && String(u2.value) === hv(Ev(u2)) && t2.parser !== "typescript" && t2.parser !== "babel-ts") && (t2.parser === "json" || t2.quoteProps === "consistent" && bv.get(i2))) {
    const n3 = dv(JSON.stringify(u2.type === "Identifier" ? u2.name : u2.value.toString()), t2);
    return e20.call((e21) => fv(e21, n3, t2), "key");
  }
  return Dv(r2, t2) && (t2.quoteProps === "as-needed" || t2.quoteProps === "consistent" && !bv.get(i2)) ? e20.call((e21) => fv(e21, /^\d/.test(u2.value) ? hv(u2.value) : u2.value, t2), "key") : n2("key");
}
var vv = {
  printProperty: function(e20, t2, n2) {
    return e20.getValue().shorthand ? n2("value") : Cv(e20, t2, n2, Av(e20, t2, n2), ":", "value");
  },
  printPropertyKey: Av
};
const { printDanglingComments: Fv, printCommentsSeparately: Sv } = Wf, { getNextNonSpaceNonCommentCharacterIndex: xv } = yi$2, {
  builders: {
    line: wv,
    softline: Tv,
    group: Bv,
    indent: Nv,
    ifBreak: kv,
    hardline: Pv,
    join: Ov,
    indentIfBreak: Iv
  },
  utils: { removeLines: Lv, willBreak: jv }
} = eu$1, { ArgExpansionBailout: _v } = bo$2, {
  getFunctionParameters: Mv,
  hasLeadingOwnLineComment: Rv,
  isFlowAnnotationComment: $v,
  isJsxNode: Vv,
  isTemplateOnItsOwnLine: Wv,
  shouldPrintComma: qv,
  startsWithNoLookaheadToken: Uv,
  isBinaryish: zv,
  isLineComment: Gv,
  hasComment: Hv,
  getComments: Jv,
  CommentCheckFlags: Xv,
  isCallLikeExpression: Yv,
  isCallExpression: Kv,
  getCallArguments: Qv,
  hasNakedLeftSide: Zv,
  getLeftSide: eF
} = Gh, { locEnd: tF } = zc, { printFunctionParameters: nF, shouldGroupFunctionParameters: rF } = FA, { printPropertyKey: iF } = vv, { printFunctionTypeParameters: uF } = BE;
function oF(e20, t2, n2) {
  const r2 = e20.getNode(), i2 = nF(e20, n2, t2), u2 = aF(e20, n2, t2), o2 = rF(r2, u2), s2 = [uF(e20, t2, n2), Bv([o2 ? Bv(i2) : i2, u2])];
  return r2.body ? s2.push(" ", n2("body")) : s2.push(t2.semi ? ";" : ""), s2;
}
function sF(e20, t2) {
  if (t2.arrowParens === "always")
    return false;
  if (t2.arrowParens === "avoid") {
    return function(e21) {
      const t3 = Mv(e21);
      return !(t3.length !== 1 || e21.typeParameters || Hv(e21, Xv.Dangling) || t3[0].type !== "Identifier" || t3[0].typeAnnotation || Hv(t3[0]) || t3[0].optional || e21.predicate || e21.returnType);
    }(e20.getValue());
  }
  return false;
}
function aF(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = t2("returnType");
  if (r2.returnType && $v(n2.originalText, r2.returnType))
    return [" /*: ", i2, " */"];
  const u2 = [i2];
  return r2.returnType && r2.returnType.typeAnnotation && u2.unshift(": "), r2.predicate && u2.push(r2.returnType ? " " : ": ", t2("predicate")), u2;
}
function cF(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = t2.semi ? ";" : "", u2 = [];
  r2.argument && (!function(e21, t3) {
    if (Rv(e21.originalText, t3))
      return true;
    if (Zv(t3)) {
      let n3, r3 = t3;
      for (; n3 = eF(r3); )
        if (r3 = n3, Rv(e21.originalText, r3))
          return true;
    }
    return false;
  }(t2, r2.argument) ? zv(r2.argument) || r2.argument.type === "SequenceExpression" ? u2.push(Bv([kv(" (", " "), Nv([Tv, n2("argument")]), Tv, kv(")")])) : u2.push(" ", n2("argument")) : u2.push([" (", Nv([Pv, n2("argument")]), Pv, ")"]));
  const o2 = Jv(r2), s2 = Ln$2(o2), a2 = s2 && Gv(s2);
  return a2 && u2.push(i2), Hv(r2, Xv.Dangling) && u2.push(" ", Fv(e20, t2, true)), a2 || u2.push(i2), u2;
}
var lF = {
  printFunction: function(e20, t2, n2, r2) {
    const i2 = e20.getValue();
    let u2 = false;
    if ((i2.type === "FunctionDeclaration" || i2.type === "FunctionExpression") && r2 && r2.expandLastArg) {
      const t3 = e20.getParentNode();
      Kv(t3) && Qv(t3).length > 1 && (u2 = true);
    }
    const o2 = [];
    i2.type === "TSDeclareFunction" && i2.declare && o2.push("declare "), i2.async && o2.push("async "), i2.generator ? o2.push("function* ") : o2.push("function "), i2.id && o2.push(t2("id"));
    const s2 = nF(e20, t2, n2, u2), a2 = aF(e20, t2, n2), c2 = rF(i2, a2);
    return o2.push(uF(e20, n2, t2), Bv([c2 ? Bv(s2) : s2, a2]), i2.body ? " " : "", t2("body")), !n2.semi || !i2.declare && i2.body || o2.push(";"), o2;
  },
  printArrowFunction: function(e20, t2, n2, r2) {
    let i2 = e20.getValue();
    const u2 = [], o2 = [];
    let s2 = false;
    if (function a3() {
      const c3 = function(e21, t3, n3, r3) {
        const i3 = [];
        if (e21.getValue().async && i3.push("async "), sF(e21, t3))
          i3.push(n3(["params", 0]));
        else {
          const u4 = r3 && (r3.expandLastArg || r3.expandFirstArg);
          let o3 = aF(e21, n3, t3);
          if (u4) {
            if (jv(o3))
              throw new _v();
            o3 = Bv(Lv(o3));
          }
          i3.push(Bv([nF(e21, n3, t3, u4, true), o3]));
        }
        const u3 = Fv(e21, t3, true, (e22) => {
          const n4 = xv(t3.originalText, e22, tF);
          return n4 !== false && t3.originalText.slice(n4, n4 + 2) === "=>";
        });
        return u3 && i3.push(" ", u3), i3;
      }(e20, t2, n2, r2);
      if (u2.length === 0)
        u2.push(c3);
      else {
        const { leading: n3, trailing: r3 } = Sv(e20, t2);
        u2.push([n3, c3]), o2.unshift(r3);
      }
      s2 = s2 || i2.returnType && Mv(i2).length > 0 || i2.typeParameters || Mv(i2).some((e21) => e21.type !== "Identifier"), i2.body.type !== "ArrowFunctionExpression" || r2 && r2.expandLastArg ? o2.unshift(n2("body", r2)) : (i2 = i2.body, e20.call(a3, "body"));
    }(), u2.length > 1)
      return function(e21, t3, n3, r3, i3, u3) {
        const o3 = e21.getName(), s3 = e21.getParentNode(), a3 = Yv(s3) && o3 === "callee", c3 = Boolean(t3 && t3.assignmentLayout), l3 = u3.body.type !== "BlockStatement" && u3.body.type !== "ObjectExpression", p3 = a3 && l3 || t3 && t3.assignmentLayout === "chain-tail-arrow-chain", f2 = Symbol("arrow-chain");
        return Bv([
          Bv(Nv([
            a3 || c3 ? Tv : "",
            Bv(Ov([" =>", wv], n3), { shouldBreak: r3 })
          ]), { id: f2, shouldBreak: p3 }),
          " =>",
          Iv(l3 ? Nv([wv, i3]) : [" ", i3], { groupId: f2 }),
          a3 ? kv(Tv, "", { groupId: f2 }) : ""
        ]);
      }(e20, r2, u2, s2, o2, i2);
    const a2 = u2;
    if (a2.push(" =>"), !Rv(t2.originalText, i2.body) && (i2.body.type === "ArrayExpression" || i2.body.type === "ObjectExpression" || i2.body.type === "BlockStatement" || Vv(i2.body) || Wv(i2.body, t2.originalText) || i2.body.type === "ArrowFunctionExpression" || i2.body.type === "DoExpression"))
      return Bv([...a2, " ", o2]);
    if (i2.body.type === "SequenceExpression")
      return Bv([...a2, Bv([" (", Nv([Tv, o2]), Tv, ")"])]);
    const c2 = (r2 && r2.expandLastArg || e20.getParentNode().type === "JSXExpressionContainer") && !Hv(i2), l2 = r2 && r2.expandLastArg && qv(t2, "all"), p2 = i2.body.type === "ConditionalExpression" && !Uv(i2.body, false);
    return Bv([
      ...a2,
      Bv([
        Nv([wv, p2 ? kv("", "(") : "", o2, p2 ? kv("", ")") : ""]),
        c2 ? [kv(l2 ? "," : ""), Tv] : ""
      ])
    ]);
  },
  printMethod: function(e20, t2, n2) {
    const r2 = e20.getNode(), { kind: i2 } = r2, u2 = r2.value || r2, o2 = [];
    return i2 && i2 !== "init" && i2 !== "method" && i2 !== "constructor" ? (mf.ok(i2 === "get" || i2 === "set"), o2.push(i2, " ")) : u2.async && o2.push("async "), u2.generator && o2.push("*"), o2.push(iF(e20, t2, n2), r2.optional || r2.key.optional ? "?" : ""), r2 === u2 ? o2.push(oF(e20, t2, n2)) : u2.type === "FunctionExpression" ? o2.push(e20.call((e21) => oF(e21, t2, n2), "value")) : o2.push(n2("value")), o2;
  },
  printReturnStatement: function(e20, t2, n2) {
    return ["return", cF(e20, t2, n2)];
  },
  printThrowStatement: function(e20, t2, n2) {
    return ["throw", cF(e20, t2, n2)];
  },
  printMethodInternal: oF,
  shouldPrintParamsWithoutParens: sF
};
const { isNonEmptyArray: pF, hasNewline: fF } = yi$2, {
  builders: {
    line: dF,
    hardline: hF,
    join: gF,
    breakParent: mF,
    group: yF
  }
} = eu$1, { locStart: DF, locEnd: EF } = zc, { getParentExportDeclaration: CF } = Gh;
function bF(e20, t2) {
  return e20.decorators.some((e21) => fF(t2.originalText, EF(e21)));
}
function AF(e20) {
  if (e20.type !== "ExportDefaultDeclaration" && e20.type !== "ExportNamedDeclaration" && e20.type !== "DeclareExportDeclaration")
    return false;
  const t2 = e20.declaration && e20.declaration.decorators;
  return pF(t2) && DF(e20, { ignoreDecorators: true }) > DF(t2[0]);
}
var vF = {
  printDecorators: function(e20, t2, n2) {
    const r2 = e20.getValue(), { decorators: i2 } = r2;
    if (!pF(i2) || AF(e20.getParentNode()))
      return;
    const u2 = r2.type === "ClassExpression" || r2.type === "ClassDeclaration" || bF(r2, t2);
    return [CF(e20) ? hF : u2 ? mF : "", gF(dF, e20.map(n2, "decorators")), dF];
  },
  printClassMemberDecorators: function(e20, t2, n2) {
    const r2 = e20.getValue();
    return yF([gF(dF, e20.map(n2, "decorators")), bF(r2, t2) ? hF : dF]);
  },
  printDecoratorsBeforeExport: function(e20, t2, n2) {
    return [gF(hF, e20.map(n2, "declaration", "decorators")), hF];
  },
  hasDecoratorsBeforeExport: AF
};
const { isNonEmptyArray: FF, createGroupIdMapper: SF } = yi$2, { printComments: xF, printDanglingComments: wF } = Wf, {
  builders: {
    join: TF,
    line: BF,
    hardline: NF,
    softline: kF,
    group: PF,
    indent: OF,
    ifBreak: IF
  }
} = eu$1, { hasComment: LF, CommentCheckFlags: jF } = Gh, { getTypeParametersGroupId: _F } = pv, { printMethod: MF } = lF, { printOptionalToken: RF, printTypeAnnotation: $F } = BE, { printPropertyKey: VF } = vv, { printAssignment: WF } = Qb, { printClassMemberDecorators: qF } = vF;
const UF = SF("heritageGroup");
function zF(e20) {
  return e20.typeParameters && !LF(e20.typeParameters, jF.Trailing | jF.Line) && !function(e21) {
    return ["superClass", "extends", "mixins", "implements"].filter((t2) => Boolean(e21[t2])).length > 1;
  }(e20);
}
function GF(e20, t2, n2, r2) {
  const i2 = e20.getValue();
  if (!FF(i2[r2]))
    return "";
  const u2 = wF(e20, t2, true, ({ marker: e21 }) => e21 === r2);
  return [
    zF(i2) ? IF(" ", BF, { groupId: _F(i2.typeParameters) }) : BF,
    u2,
    u2 && NF,
    r2,
    PF(OF([BF, TF([",", BF], e20.map(n2, r2))]))
  ];
}
function HF(e20, t2, n2) {
  const r2 = n2("superClass");
  return e20.getParentNode().type === "AssignmentExpression" ? PF(IF(["(", OF([kF, r2]), kF, ")"], r2)) : r2;
}
var JF = {
  printClass: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = [];
    r2.declare && i2.push("declare "), r2.abstract && i2.push("abstract "), i2.push("class");
    const u2 = r2.id && LF(r2.id, jF.Trailing) || r2.superClass && LF(r2.superClass) || FF(r2.extends) || FF(r2.mixins) || FF(r2.implements), o2 = [], s2 = [];
    if (r2.id && o2.push(" ", n2("id")), o2.push(n2("typeParameters")), r2.superClass) {
      const r3 = ["extends ", HF(e20, t2, n2), n2("superTypeParameters")], i3 = e20.call((e21) => xF(e21, r3, t2), "superClass");
      u2 ? s2.push(BF, PF(i3)) : s2.push(" ", i3);
    } else
      s2.push(GF(e20, t2, n2, "extends"));
    if (s2.push(GF(e20, t2, n2, "mixins"), GF(e20, t2, n2, "implements")), u2) {
      let e21;
      e21 = zF(r2) ? [...o2, OF(s2)] : OF([...o2, s2]), i2.push(PF(e21, { id: UF(r2) }));
    } else
      i2.push(...o2, ...s2);
    return i2.push(" ", n2("body")), i2;
  },
  printClassMethod: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = [];
    return FF(r2.decorators) && i2.push(qF(e20, t2, n2)), r2.accessibility && i2.push(r2.accessibility + " "), r2.readonly && i2.push("readonly "), r2.declare && i2.push("declare "), r2.static && i2.push("static "), (r2.type === "TSAbstractMethodDefinition" || r2.abstract) && i2.push("abstract "), r2.override && i2.push("override "), i2.push(MF(e20, t2, n2)), i2;
  },
  printClassProperty: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = [], u2 = t2.semi ? ";" : "";
    return FF(r2.decorators) && i2.push(qF(e20, t2, n2)), r2.accessibility && i2.push(r2.accessibility + " "), r2.declare && i2.push("declare "), r2.static && i2.push("static "), (r2.type === "TSAbstractClassProperty" || r2.abstract) && i2.push("abstract "), r2.override && i2.push("override "), r2.readonly && i2.push("readonly "), r2.variance && i2.push(n2("variance")), i2.push(VF(e20, t2, n2), RF(e20), $F(e20, t2, n2)), [WF(e20, t2, n2, i2, " =", "value"), u2];
  },
  printHardlineAfterHeritage: function(e20) {
    return IF(NF, "", { groupId: UF(e20) });
  }
};
const { isNonEmptyArray: XF } = yi$2, {
  builders: { join: YF, line: KF, group: QF, indent: ZF, ifBreak: eS }
} = eu$1, { hasComment: tS, identity: nS, CommentCheckFlags: rS } = Gh, { getTypeParametersGroupId: iS } = pv, { printTypeScriptModifiers: uS } = BE;
var oS = {
  printInterface: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = [];
    r2.declare && i2.push("declare "), r2.type === "TSInterfaceDeclaration" && i2.push(r2.abstract ? "abstract " : "", uS(e20, t2, n2)), i2.push("interface");
    const u2 = [], o2 = [];
    r2.type !== "InterfaceTypeAnnotation" && u2.push(" ", n2("id"), n2("typeParameters"));
    const s2 = r2.typeParameters && !tS(r2.typeParameters, rS.Trailing | rS.Line);
    return XF(r2.extends) && o2.push(s2 ? eS(" ", KF, { groupId: iS(r2.typeParameters) }) : KF, "extends ", (r2.extends.length === 1 ? nS : ZF)(YF([",", KF], e20.map(n2, "extends")))), r2.id && tS(r2.id, rS.Trailing) || XF(r2.extends) ? s2 ? i2.push(QF([...u2, ZF(o2)])) : i2.push(QF(ZF([...u2, ...o2]))) : i2.push(...u2, ...o2), i2.push(" ", n2("body")), QF(i2);
  }
};
const { isNonEmptyArray: sS } = yi$2, {
  builders: {
    softline: aS,
    group: cS,
    indent: lS,
    join: pS,
    line: fS,
    ifBreak: dS,
    hardline: hS
  }
} = eu$1, { printDanglingComments: gS } = Wf, {
  hasComment: mS,
  CommentCheckFlags: yS,
  shouldPrintComma: DS,
  needsHardlineAfterDanglingComment: ES
} = Gh, { locStart: CS, hasSameLoc: bS } = zc, { hasDecoratorsBeforeExport: AS, printDecoratorsBeforeExport: vS } = vF;
function FS(e20, t2, n2) {
  const r2 = e20.getValue();
  if (!r2.source)
    return "";
  const i2 = [];
  return xS(r2, t2) || i2.push(" from"), i2.push(" ", n2("source")), i2;
}
function SS(e20, t2, n2) {
  const r2 = e20.getValue();
  if (xS(r2, t2))
    return "";
  const i2 = [" "];
  if (sS(r2.specifiers)) {
    const u2 = [], o2 = [];
    if (e20.each(() => {
      const t3 = e20.getValue().type;
      if (t3 === "ExportNamespaceSpecifier" || t3 === "ExportDefaultSpecifier" || t3 === "ImportNamespaceSpecifier" || t3 === "ImportDefaultSpecifier")
        u2.push(n2());
      else {
        if (t3 !== "ExportSpecifier" && t3 !== "ImportSpecifier")
          throw new Error(`Unknown specifier type ${JSON.stringify(t3)}`);
        o2.push(n2());
      }
    }, "specifiers"), i2.push(pS(", ", u2)), o2.length > 0) {
      u2.length > 0 && i2.push(", ");
      o2.length > 1 || u2.length > 0 || r2.specifiers.some((e21) => mS(e21)) ? i2.push(cS([
        "{",
        lS([t2.bracketSpacing ? fS : aS, pS([",", fS], o2)]),
        dS(DS(t2) ? "," : ""),
        t2.bracketSpacing ? fS : aS,
        "}"
      ])) : i2.push([
        "{",
        t2.bracketSpacing ? " " : "",
        ...o2,
        t2.bracketSpacing ? " " : "",
        "}"
      ]);
    }
  } else
    i2.push("{}");
  return i2;
}
function xS(e20, t2) {
  const { type: n2, importKind: r2, source: i2, specifiers: u2 } = e20;
  return n2 === "ImportDeclaration" && !sS(u2) && r2 !== "type" && !/{\s*}/.test(t2.originalText.slice(CS(e20), CS(i2)));
}
function wS(e20, t2, n2) {
  const r2 = e20.getNode();
  return sS(r2.assertions) ? [
    " assert {",
    t2.bracketSpacing ? " " : "",
    pS(", ", e20.map(n2, "assertions")),
    t2.bracketSpacing ? " " : "",
    "}"
  ] : "";
}
var TS = {
  printImportDeclaration: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = t2.semi ? ";" : "", u2 = [], { importKind: o2 } = r2;
    return u2.push("import"), o2 && o2 !== "value" && u2.push(" ", o2), u2.push(SS(e20, t2, n2), FS(e20, t2, n2), wS(e20, t2, n2), i2), u2;
  },
  printExportDeclaration: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = [];
    AS(r2) && i2.push(vS(e20, t2, n2));
    const { type: u2, exportKind: o2, declaration: s2 } = r2;
    return i2.push("export"), (r2.default || u2 === "ExportDefaultDeclaration") && i2.push(" default"), mS(r2, yS.Dangling) && (i2.push(" ", gS(e20, t2, true)), ES(r2) && i2.push(hS)), s2 ? i2.push(" ", n2("declaration")) : i2.push(o2 === "type" ? " type" : "", SS(e20, t2, n2), FS(e20, t2, n2), wS(e20, t2, n2)), function(e21, t3) {
      if (!t3.semi)
        return false;
      const { type: n3, declaration: r3 } = e21, i3 = e21.default || n3 === "ExportDefaultDeclaration";
      if (!r3)
        return true;
      const { type: u3 } = r3;
      if (i3 && u3 !== "ClassDeclaration" && u3 !== "FunctionDeclaration" && u3 !== "TSInterfaceDeclaration" && u3 !== "DeclareClass" && u3 !== "DeclareFunction" && u3 !== "TSDeclareFunction" && u3 !== "EnumDeclaration")
        return true;
      return false;
    }(r2, t2) && i2.push(";"), i2;
  },
  printExportAllDeclaration: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = t2.semi ? ";" : "", u2 = [], { exportKind: o2, exported: s2 } = r2;
    return u2.push("export"), o2 === "type" && u2.push(" type"), u2.push(" *"), s2 && u2.push(" as ", n2("exported")), u2.push(FS(e20, t2, n2), wS(e20, t2, n2), i2), u2;
  },
  printModuleSpecifier: function(e20, t2, n2) {
    const r2 = e20.getNode(), { type: i2, importKind: u2 } = r2, o2 = [];
    i2 === "ImportSpecifier" && u2 && o2.push(u2, " ");
    const s2 = i2.startsWith("Import"), a2 = s2 ? "imported" : "local", c2 = s2 ? "local" : "exported";
    let l2 = "", p2 = "";
    return i2 === "ExportNamespaceSpecifier" || i2 === "ImportNamespaceSpecifier" ? l2 = "*" : r2[a2] && (l2 = n2(a2)), !r2[c2] || r2[a2] && bS(r2[a2], r2[c2]) || (p2 = n2(c2)), o2.push(l2, l2 && p2 ? " as " : "", p2), o2;
  }
};
const { printDanglingComments: BS } = Wf, {
  builders: {
    line: NS,
    softline: kS,
    group: PS,
    indent: OS,
    ifBreak: IS,
    hardline: LS
  }
} = eu$1, {
  getLast: jS,
  hasNewlineInRange: _S,
  hasNewline: MS,
  isNonEmptyArray: RS
} = yi$2, {
  shouldPrintComma: $S,
  hasComment: VS,
  getComments: WS,
  CommentCheckFlags: qS,
  isNextLineEmpty: US
} = Gh, { locStart: zS, locEnd: GS } = zc, { printOptionalToken: HS, printTypeAnnotation: JS } = BE, { shouldHugFunctionParameters: XS } = FA, { shouldHugType: YS } = GA, { printHardlineAfterHeritage: KS } = JF;
var QS = {
  printObject: function(e20, t2, n2) {
    const r2 = t2.semi ? ";" : "", i2 = e20.getValue();
    let u2;
    u2 = i2.type === "TSTypeLiteral" ? "members" : i2.type === "TSInterfaceBody" ? "body" : "properties";
    const o2 = i2.type === "ObjectTypeAnnotation", s2 = [u2];
    o2 && s2.push("indexers", "callProperties", "internalSlots");
    const a2 = s2.map((e21) => i2[e21][0]).sort((e21, t3) => zS(e21) - zS(t3))[0], c2 = e20.getParentNode(0), l2 = o2 && c2 && (c2.type === "InterfaceDeclaration" || c2.type === "DeclareInterface" || c2.type === "DeclareClass") && e20.getName() === "body", p2 = i2.type === "TSInterfaceBody" || l2 || i2.type === "ObjectPattern" && c2.type !== "FunctionDeclaration" && c2.type !== "FunctionExpression" && c2.type !== "ArrowFunctionExpression" && c2.type !== "ObjectMethod" && c2.type !== "ClassMethod" && c2.type !== "ClassPrivateMethod" && c2.type !== "AssignmentPattern" && c2.type !== "CatchClause" && i2.properties.some((e21) => e21.value && (e21.value.type === "ObjectPattern" || e21.value.type === "ArrayPattern")) || i2.type !== "ObjectPattern" && a2 && _S(t2.originalText, zS(i2), zS(a2)), f2 = l2 ? ";" : i2.type === "TSInterfaceBody" || i2.type === "TSTypeLiteral" ? IS(r2, ";") : ",", d2 = i2.type === "RecordExpression" ? "#{" : i2.exact ? "{|" : "{", h2 = i2.exact ? "|}" : "}", g2 = [];
    for (const t3 of s2)
      e20.each((e21) => {
        const t4 = e21.getValue();
        g2.push({ node: t4, printed: n2(), loc: zS(t4) });
      }, t3);
    s2.length > 1 && g2.sort((e21, t3) => e21.loc - t3.loc);
    let m2 = [];
    const y2 = g2.map((e21) => {
      const n3 = [...m2, PS(e21.printed)];
      return m2 = [f2, NS], e21.node.type !== "TSPropertySignature" && e21.node.type !== "TSMethodSignature" && e21.node.type !== "TSConstructSignatureDeclaration" || !VS(e21.node, qS.PrettierIgnore) || m2.shift(), US(e21.node, t2) && m2.push(LS), n3;
    });
    if (i2.inexact) {
      let n3;
      if (VS(i2, qS.Dangling)) {
        const r3 = VS(i2, qS.Line);
        n3 = [
          BS(e20, t2, true),
          r3 || MS(t2.originalText, GS(jS(WS(i2)))) ? LS : NS,
          "..."
        ];
      } else
        n3 = ["..."];
      y2.push([...m2, ...n3]);
    }
    const D2 = jS(i2[u2]), E2 = !(i2.inexact || D2 && D2.type === "RestElement" || D2 && (D2.type === "TSPropertySignature" || D2.type === "TSCallSignatureDeclaration" || D2.type === "TSMethodSignature" || D2.type === "TSConstructSignatureDeclaration") && VS(D2, qS.PrettierIgnore));
    let C2;
    if (y2.length === 0) {
      if (!VS(i2, qS.Dangling))
        return [d2, h2, JS(e20, t2, n2)];
      C2 = PS([d2, BS(e20, t2), kS, h2, HS(e20), JS(e20, t2, n2)]);
    } else
      C2 = [
        l2 && RS(i2.properties) ? KS(c2) : "",
        d2,
        OS([t2.bracketSpacing ? NS : kS, ...y2]),
        IS(E2 && (f2 !== "," || $S(t2)) ? f2 : ""),
        t2.bracketSpacing ? NS : kS,
        h2,
        HS(e20),
        JS(e20, t2, n2)
      ];
    return e20.match((e21) => e21.type === "ObjectPattern" && !e21.decorators, (e21, t3, n3) => XS(e21) && (t3 === "params" || t3 === "parameters" || t3 === "this" || t3 === "rest") && n3 === 0) || e20.match(YS, (e21, t3) => t3 === "typeAnnotation", (e21, t3) => t3 === "typeAnnotation", (e21, t3, n3) => XS(e21) && (t3 === "params" || t3 === "parameters" || t3 === "this" || t3 === "rest") && n3 === 0) || !p2 && e20.match((e21) => e21.type === "ObjectPattern", (e21) => e21.type === "AssignmentExpression" || e21.type === "VariableDeclarator") ? C2 : PS(C2, { shouldBreak: p2 });
  }
};
const { printDanglingComments: ZS } = Wf, { printString: ex, printNumber: tx } = yi$2, {
  builders: { hardline: nx, softline: rx, group: ix, indent: ux }
} = eu$1, {
  getParentExportDeclaration: ox,
  isFunctionNotation: sx,
  isGetterOrSetter: ax,
  rawText: cx,
  shouldPrintComma: lx
} = Gh, { locStart: px$1, locEnd: fx } = zc, { printClass: dx } = JF, {
  printOpaqueType: hx,
  printTypeAlias: gx,
  printIntersectionType: mx,
  printUnionType: yx,
  printFunctionType: Dx,
  printTupleType: Ex,
  printIndexedAccessType: Cx
} = GA, { printInterface: bx } = oS, { printTypeParameter: Ax, printTypeParameters: vx } = pv, { printExportDeclaration: Fx, printExportAllDeclaration: Sx } = TS, { printArrayItems: xx } = QE, { printObject: wx } = QS, { printPropertyKey: Tx } = vv, {
  printOptionalToken: Bx,
  printTypeAnnotation: Nx,
  printRestSpread: kx
} = BE;
function Px(e20, t2) {
  const n2 = ox(e20);
  return n2 ? (mf.strictEqual(n2.type, "DeclareExportDeclaration"), t2) : ["declare ", t2];
}
var Ox = {
  printFlow: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = t2.semi ? ";" : "", u2 = [];
    switch (r2.type) {
      case "DeclareClass":
        return Px(e20, dx(e20, t2, n2));
      case "DeclareFunction":
        return Px(e20, [
          "function ",
          n2("id"),
          r2.predicate ? " " : "",
          n2("predicate"),
          i2
        ]);
      case "DeclareModule":
        return Px(e20, ["module ", n2("id"), " ", n2("body")]);
      case "DeclareModuleExports":
        return Px(e20, ["module.exports", ": ", n2("typeAnnotation"), i2]);
      case "DeclareVariable":
        return Px(e20, ["var ", n2("id"), i2]);
      case "DeclareOpaqueType":
        return Px(e20, hx(e20, t2, n2));
      case "DeclareInterface":
        return Px(e20, bx(e20, t2, n2));
      case "DeclareTypeAlias":
        return Px(e20, gx(e20, t2, n2));
      case "DeclareExportDeclaration":
        return Px(e20, Fx(e20, t2, n2));
      case "DeclareExportAllDeclaration":
        return Px(e20, Sx(e20, t2, n2));
      case "OpaqueType":
        return hx(e20, t2, n2);
      case "TypeAlias":
        return gx(e20, t2, n2);
      case "IntersectionTypeAnnotation":
        return mx(e20, t2, n2);
      case "UnionTypeAnnotation":
        return yx(e20, t2, n2);
      case "FunctionTypeAnnotation":
        return Dx(e20, t2, n2);
      case "TupleTypeAnnotation":
        return Ex(e20, t2, n2);
      case "GenericTypeAnnotation":
        return [n2("id"), vx(e20, t2, n2, "typeParameters")];
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        return Cx(e20, t2, n2);
      case "TypeAnnotation":
        return n2("typeAnnotation");
      case "TypeParameter":
        return Ax(e20, t2, n2);
      case "TypeofTypeAnnotation":
        return ["typeof ", n2("argument")];
      case "ExistsTypeAnnotation":
        return "*";
      case "EmptyTypeAnnotation":
        return "empty";
      case "MixedTypeAnnotation":
        return "mixed";
      case "ArrayTypeAnnotation":
        return [n2("elementType"), "[]"];
      case "BooleanLiteralTypeAnnotation":
        return String(r2.value);
      case "EnumDeclaration":
        return ["enum ", n2("id"), " ", n2("body")];
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
        if (r2.type === "EnumSymbolBody" || r2.explicitType) {
          let e21 = null;
          switch (r2.type) {
            case "EnumBooleanBody":
              e21 = "boolean";
              break;
            case "EnumNumberBody":
              e21 = "number";
              break;
            case "EnumStringBody":
              e21 = "string";
              break;
            case "EnumSymbolBody":
              e21 = "symbol";
          }
          u2.push("of ", e21, " ");
        }
        if (r2.members.length !== 0 || r2.hasUnknownMembers) {
          const i3 = r2.members.length > 0 ? [
            nx,
            xx(e20, t2, "members", n2),
            r2.hasUnknownMembers || lx(t2) ? "," : ""
          ] : [];
          u2.push(ix([
            "{",
            ux([
              ...i3,
              ...r2.hasUnknownMembers ? [nx, "..."] : []
            ]),
            ZS(e20, t2, true),
            nx,
            "}"
          ]));
        } else
          u2.push(ix(["{", ZS(e20, t2), rx, "}"]));
        return u2;
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
        return [
          n2("id"),
          " = ",
          typeof r2.init == "object" ? n2("init") : String(r2.init)
        ];
      case "EnumDefaultedMember":
        return n2("id");
      case "FunctionTypeParam": {
        const t3 = r2.name ? n2("name") : e20.getParentNode().this === r2 ? "this" : "";
        return [t3, Bx(e20), t3 ? ": " : "", n2("typeAnnotation")];
      }
      case "InterfaceDeclaration":
      case "InterfaceTypeAnnotation":
        return bx(e20, t2, n2);
      case "ClassImplements":
      case "InterfaceExtends":
        return [n2("id"), n2("typeParameters")];
      case "NullableTypeAnnotation":
        return ["?", n2("typeAnnotation")];
      case "Variance": {
        const { kind: e21 } = r2;
        return mf.ok(e21 === "plus" || e21 === "minus"), e21 === "plus" ? "+" : "-";
      }
      case "ObjectTypeCallProperty":
        return r2.static && u2.push("static "), u2.push(n2("value")), u2;
      case "ObjectTypeIndexer":
        return [
          r2.variance ? n2("variance") : "",
          "[",
          n2("id"),
          r2.id ? ": " : "",
          n2("key"),
          "]: ",
          n2("value")
        ];
      case "ObjectTypeProperty": {
        let i3 = "";
        return r2.proto ? i3 = "proto " : r2.static && (i3 = "static "), [
          i3,
          ax(r2) ? r2.kind + " " : "",
          r2.variance ? n2("variance") : "",
          Tx(e20, t2, n2),
          Bx(e20),
          sx(r2) ? "" : ": ",
          n2("value")
        ];
      }
      case "ObjectTypeAnnotation":
        return wx(e20, t2, n2);
      case "ObjectTypeInternalSlot":
        return [
          r2.static ? "static " : "",
          "[[",
          n2("id"),
          "]]",
          Bx(e20),
          r2.method ? "" : ": ",
          n2("value")
        ];
      case "ObjectTypeSpreadProperty":
        return kx(e20, t2, n2);
      case "QualifiedTypeIdentifier":
        return [n2("qualification"), ".", n2("id")];
      case "StringLiteralTypeAnnotation":
        return ex(cx(r2), t2);
      case "NumberLiteralTypeAnnotation":
        mf.strictEqual(typeof r2.value, "number");
      case "BigIntLiteralTypeAnnotation":
        return r2.extra ? tx(r2.extra.raw) : tx(r2.raw);
      case "TypeCastExpression":
        return ["(", n2("expression"), Nx(e20, t2, n2), ")"];
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation": {
        const i3 = vx(e20, t2, n2, "params");
        if (t2.parser === "flow") {
          const e21 = px$1(r2), n3 = fx(r2), u3 = t2.originalText.lastIndexOf("/*", e21), o2 = t2.originalText.indexOf("*/", n3);
          if (u3 !== -1 && o2 !== -1) {
            const e22 = t2.originalText.slice(u3 + 2, o2).trim();
            if (e22.startsWith("::") && !e22.includes("/*") && !e22.includes("*/"))
              return ["/*:: ", i3, " */"];
          }
        }
        return i3;
      }
      case "InferredPredicate":
        return "%checks";
      case "DeclaredPredicate":
        return ["%checks(", n2("value"), ")"];
      case "AnyTypeAnnotation":
        return "any";
      case "BooleanTypeAnnotation":
        return "boolean";
      case "BigIntTypeAnnotation":
        return "bigint";
      case "NullLiteralTypeAnnotation":
        return "null";
      case "NumberTypeAnnotation":
        return "number";
      case "SymbolTypeAnnotation":
        return "symbol";
      case "StringTypeAnnotation":
        return "string";
      case "VoidTypeAnnotation":
        return "void";
      case "ThisTypeAnnotation":
        return "this";
      case "Node":
      case "Printable":
      case "SourceLocation":
      case "Position":
      case "Statement":
      case "Function":
      case "Pattern":
      case "Expression":
      case "Declaration":
      case "Specifier":
      case "NamedSpecifier":
      case "Comment":
      case "MemberTypeAnnotation":
      case "Type":
        throw new Error("unprintable type: " + JSON.stringify(r2.type));
    }
  }
};
const { hasNewlineInRange: Ix } = yi$2, {
  isJsxNode: Lx,
  isBlockComment: jx,
  getComments: _x$1,
  isCallExpression: Mx,
  isMemberExpression: Rx
} = Gh, { locStart: $x, locEnd: Vx } = zc, {
  builders: {
    line: Wx,
    softline: qx,
    group: Ux,
    indent: zx,
    align: Gx,
    ifBreak: Hx,
    dedent: Jx,
    breakParent: Xx
  }
} = eu$1;
function Yx(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = r2.type === "ConditionalExpression", u2 = i2 ? "alternate" : "falseType", o2 = e20.getParentNode(), s2 = i2 ? n2("test") : [n2("checkType"), " ", "extends", " ", n2("extendsType")];
  return o2.type === r2.type && o2[u2] === r2 ? Gx(2, s2) : s2;
}
const Kx = new Map([
  ["AssignmentExpression", "right"],
  ["VariableDeclarator", "init"],
  ["ReturnStatement", "argument"],
  ["ThrowStatement", "argument"],
  ["UnaryExpression", "argument"],
  ["YieldExpression", "argument"]
]);
var Qx = {
  printTernary: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = r2.type === "ConditionalExpression", u2 = i2 ? "consequent" : "trueType", o2 = i2 ? "alternate" : "falseType", s2 = i2 ? ["test"] : ["checkType", "extendsType"], a2 = r2[u2], c2 = r2[o2], l2 = [];
    let p2 = false;
    const f2 = e20.getParentNode(), d2 = f2.type === r2.type && s2.some((e21) => f2[e21] === r2);
    let h2, g2, m2 = f2.type === r2.type && !d2, y2 = 0;
    do {
      g2 = h2 || r2, h2 = e20.getParentNode(y2), y2++;
    } while (h2 && h2.type === r2.type && s2.every((e21) => h2[e21] !== g2));
    const D2 = h2 || f2, E2 = g2;
    if (i2 && (Lx(r2[s2[0]]) || Lx(a2) || Lx(c2) || function(e21) {
      const t3 = [e21];
      for (let e22 = 0; e22 < t3.length; e22++) {
        const n3 = t3[e22];
        for (const e23 of ["test", "consequent", "alternate"]) {
          const r3 = n3[e23];
          if (Lx(r3))
            return true;
          r3.type === "ConditionalExpression" && t3.push(r3);
        }
      }
      return false;
    }(E2))) {
      p2 = true, m2 = true;
      const e21 = (e22) => [Hx("("), zx([qx, e22]), qx, Hx(")")], t3 = (e22) => e22.type === "NullLiteral" || e22.type === "Literal" && e22.value === null || e22.type === "Identifier" && e22.name === "undefined";
      l2.push(" ? ", t3(a2) ? n2(u2) : e21(n2(u2)), " : ", c2.type === r2.type || t3(c2) ? n2(o2) : e21(n2(o2)));
    } else {
      const e21 = [
        Wx,
        "? ",
        a2.type === r2.type ? Hx("", "(") : "",
        Gx(2, n2(u2)),
        a2.type === r2.type ? Hx("", ")") : "",
        Wx,
        ": ",
        c2.type === r2.type ? n2(o2) : Gx(2, n2(o2))
      ];
      l2.push(f2.type !== r2.type || f2[o2] === r2 || d2 ? e21 : t2.useTabs ? Jx(zx(e21)) : Gx(Math.max(0, t2.tabWidth - 2), e21));
    }
    const C2 = [...s2.map((e21) => _x$1(r2[e21])), _x$1(a2), _x$1(c2)].flat().some((e21) => jx(e21) && Ix(t2.originalText, $x(e21), Vx(e21))), b2 = !p2 && (Rx(f2) || f2.type === "NGPipeExpression" && f2.left === r2) && !f2.computed, A2 = function(e21) {
      const t3 = e21.getValue();
      if (t3.type !== "ConditionalExpression")
        return false;
      let n3, r3 = t3;
      for (let t4 = 0; !n3; t4++) {
        const i3 = e21.getParentNode(t4);
        Mx(i3) && i3.callee === r3 || Rx(i3) && i3.object === r3 || i3.type === "TSNonNullExpression" && i3.expression === r3 ? r3 = i3 : i3.type === "NewExpression" && i3.callee === r3 || i3.type === "TSAsExpression" && i3.expression === r3 ? (n3 = e21.getParentNode(t4 + 1), r3 = i3) : n3 = i3;
      }
      return r3 !== t3 && n3[Kx.get(n3.type)] === r3;
    }(e20), v2 = (F2 = [Yx(e20, 0, n2), m2 ? l2 : zx(l2), i2 && b2 && !A2 ? qx : ""], f2 === D2 ? Ux(F2, { shouldBreak: C2 }) : C2 ? [F2, Xx] : F2);
    var F2;
    return d2 || A2 ? Ux([zx([qx, v2]), qx]) : v2;
  }
};
const {
  builders: { hardline: Zx }
} = eu$1, {
  getLeftSidePathName: ew,
  hasNakedLeftSide: tw,
  isJsxNode: nw,
  isTheOnlyJsxElementInMarkdown: rw,
  hasComment: iw,
  CommentCheckFlags: uw,
  isNextLineEmpty: ow
} = Gh, { shouldPrintParamsWithoutParens: sw } = lF;
function aw(e20, t2, n2, r2) {
  const i2 = e20.getValue(), u2 = [], o2 = i2.type === "ClassBody", s2 = function(e21) {
    for (let t3 = e21.length - 1; t3 >= 0; t3--) {
      const n3 = e21[t3];
      if (n3.type !== "EmptyStatement")
        return n3;
    }
  }(i2[r2]);
  return e20.each((e21, r3, i3) => {
    const a2 = e21.getValue();
    if (a2.type === "EmptyStatement")
      return;
    const c2 = n2();
    t2.semi || o2 || rw(t2, e21) || !function(e22, t3) {
      if (e22.getNode().type !== "ExpressionStatement")
        return false;
      return e22.call((e23) => cw(e23, t3), "expression");
    }(e21, t2) ? u2.push(c2) : iw(a2, uw.Leading) ? u2.push(n2([], { needsSemi: true })) : u2.push(";", c2), !t2.semi && o2 && lw(a2) && function(e22, t3) {
      const n3 = e22.key && e22.key.name;
      if (!(n3 !== "static" && n3 !== "get" && n3 !== "set" || e22.value || e22.typeAnnotation))
        return true;
      if (!t3)
        return false;
      if (t3.static || t3.accessibility)
        return false;
      if (!t3.computed) {
        const e23 = t3.key && t3.key.name;
        if (e23 === "in" || e23 === "instanceof")
          return true;
      }
      if (lw(t3) && t3.variance && !t3.static && !t3.declare)
        return true;
      switch (t3.type) {
        case "ClassProperty":
        case "PropertyDefinition":
        case "TSAbstractClassProperty":
          return t3.computed;
        case "MethodDefinition":
        case "TSAbstractMethodDefinition":
        case "ClassMethod":
        case "ClassPrivateMethod": {
          if ((t3.value ? t3.value.async : t3.async) || t3.kind === "get" || t3.kind === "set")
            return false;
          const e23 = t3.value ? t3.value.generator : t3.generator;
          return !(!t3.computed && !e23);
        }
        case "TSIndexSignature":
          return true;
      }
      return false;
    }(a2, i3[r3 + 1]) && u2.push(";"), a2 !== s2 && (u2.push(Zx), ow(a2, t2) && u2.push(Zx));
  }, r2), u2;
}
function cw(e20, t2) {
  const n2 = e20.getValue();
  switch (n2.type) {
    case "ParenthesizedExpression":
    case "TypeCastExpression":
    case "ArrayExpression":
    case "ArrayPattern":
    case "TemplateLiteral":
    case "TemplateElement":
    case "RegExpLiteral":
      return true;
    case "ArrowFunctionExpression":
      if (!sw(e20, t2))
        return true;
      break;
    case "UnaryExpression": {
      const { prefix: e21, operator: t3 } = n2;
      if (e21 && (t3 === "+" || t3 === "-"))
        return true;
      break;
    }
    case "BindExpression":
      if (!n2.object)
        return true;
      break;
    case "Literal":
      if (n2.regex)
        return true;
      break;
    default:
      if (nw(n2))
        return true;
  }
  return !!Qy(e20, t2) || !!tw(n2) && e20.call((e21) => cw(e21, t2), ...ew(e20, n2));
}
const lw = ({ type: e20 }) => e20 === "ClassProperty" || e20 === "PropertyDefinition" || e20 === "ClassPrivateProperty";
var pw = {
  printBody: function(e20, t2, n2) {
    return aw(e20, t2, n2, "body");
  },
  printSwitchCaseConsequent: function(e20, t2, n2) {
    return aw(e20, t2, n2, "consequent");
  }
};
const { printDanglingComments: fw } = Wf, { isNonEmptyArray: dw } = yi$2, {
  builders: { hardline: hw, indent: gw }
} = eu$1, { hasComment: mw, CommentCheckFlags: yw, isNextLineEmpty: Dw } = Gh, { printHardlineAfterHeritage: Ew } = JF, { printBody: Cw } = pw;
function bw(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = dw(r2.directives), u2 = r2.body.some((e21) => e21.type !== "EmptyStatement"), o2 = mw(r2, yw.Dangling);
  if (!i2 && !u2 && !o2)
    return "";
  const s2 = [];
  if (i2 && e20.each((e21, r3, i3) => {
    s2.push(n2()), (r3 < i3.length - 1 || u2 || o2) && (s2.push(hw), Dw(e21.getValue(), t2) && s2.push(hw));
  }, "directives"), u2 && s2.push(Cw(e20, t2, n2)), o2 && s2.push(fw(e20, t2, true)), r2.type === "Program") {
    const t3 = e20.getParentNode();
    t3 && t3.type === "ModuleExpression" || s2.push(hw);
  }
  return s2;
}
var Aw = {
  printBlock: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = [];
    if (r2.type === "StaticBlock" && i2.push("static "), r2.type === "ClassBody" && dw(r2.body)) {
      const t3 = e20.getParentNode();
      i2.push(Ew(t3));
    }
    i2.push("{");
    const u2 = bw(e20, t2, n2);
    if (u2)
      i2.push(gw([hw, u2]), hw);
    else {
      const t3 = e20.getParentNode(), n3 = e20.getParentNode(1);
      t3.type === "ArrowFunctionExpression" || t3.type === "FunctionExpression" || t3.type === "FunctionDeclaration" || t3.type === "ObjectMethod" || t3.type === "ClassMethod" || t3.type === "ClassPrivateMethod" || t3.type === "ForStatement" || t3.type === "WhileStatement" || t3.type === "DoWhileStatement" || t3.type === "DoExpression" || t3.type === "CatchClause" && !n3.finalizer || t3.type === "TSModuleDeclaration" || t3.type === "TSDeclareFunction" || r2.type === "StaticBlock" || r2.type === "ClassBody" || i2.push(hw);
    }
    return i2.push("}"), i2;
  },
  printBlockBody: bw
};
const { printDanglingComments: vw } = Wf, { hasNewlineInRange: Fw } = yi$2, {
  builders: {
    join: Sw,
    line: xw,
    hardline: ww,
    softline: Tw,
    group: Bw,
    indent: Nw,
    conditionalGroup: kw,
    ifBreak: Pw
  }
} = eu$1, {
  isLiteral: Ow,
  getTypeScriptMappedTypeModifier: Iw,
  shouldPrintComma: Lw,
  isCallExpression: jw,
  isMemberExpression: _w
} = Gh, { locStart: Mw, locEnd: Rw } = zc, { printOptionalToken: $w, printTypeScriptModifiers: Vw } = BE, { printTernary: Ww } = Qx, { printFunctionParameters: qw, shouldGroupFunctionParameters: Uw } = FA, { printTemplateLiteral: zw } = pg, { printArrayItems: Gw } = QE, { printObject: Hw } = QS, { printClassProperty: Jw, printClassMethod: Xw } = JF, { printTypeParameter: Yw, printTypeParameters: Kw } = pv, { printPropertyKey: Qw } = vv, { printFunction: Zw, printMethodInternal: eT } = lF, { printInterface: tT } = oS, { printBlock: nT } = Aw, {
  printTypeAlias: rT,
  printIntersectionType: iT,
  printUnionType: uT,
  printFunctionType: oT,
  printTupleType: sT,
  printIndexedAccessType: aT
} = GA;
var cT = {
  printTypescript: function(e20, t2, n2) {
    const r2 = e20.getValue();
    if (!r2.type.startsWith("TS"))
      return;
    if (r2.type.endsWith("Keyword"))
      return r2.type.slice(2, -7).toLowerCase();
    const i2 = t2.semi ? ";" : "", u2 = [];
    switch (r2.type) {
      case "TSThisType":
        return "this";
      case "TSTypeAssertion": {
        const e21 = !(r2.expression.type === "ArrayExpression" || r2.expression.type === "ObjectExpression"), t3 = Bw(["<", Nw([Tw, n2("typeAnnotation")]), Tw, ">"]), i3 = [Pw("("), Nw([Tw, n2("expression")]), Tw, Pw(")")];
        return e21 ? kw([
          [t3, n2("expression")],
          [t3, Bw(i3, { shouldBreak: true })],
          [t3, n2("expression")]
        ]) : Bw([t3, n2("expression")]);
      }
      case "TSDeclareFunction":
        return Zw(e20, n2, t2);
      case "TSExportAssignment":
        return ["export = ", n2("expression"), i2];
      case "TSModuleBlock":
        return nT(e20, t2, n2);
      case "TSInterfaceBody":
      case "TSTypeLiteral":
        return Hw(e20, t2, n2);
      case "TSTypeAliasDeclaration":
        return rT(e20, t2, n2);
      case "TSQualifiedName":
        return Sw(".", [n2("left"), n2("right")]);
      case "TSAbstractMethodDefinition":
      case "TSDeclareMethod":
        return Xw(e20, t2, n2);
      case "TSAbstractClassProperty":
        return Jw(e20, t2, n2);
      case "TSInterfaceHeritage":
      case "TSExpressionWithTypeArguments":
        return u2.push(n2("expression")), r2.typeParameters && u2.push(n2("typeParameters")), u2;
      case "TSTemplateLiteralType":
        return zw(e20, n2, t2);
      case "TSNamedTupleMember":
        return [
          n2("label"),
          r2.optional ? "?" : "",
          ": ",
          n2("elementType")
        ];
      case "TSRestType":
        return ["...", n2("typeAnnotation")];
      case "TSOptionalType":
        return [n2("typeAnnotation"), "?"];
      case "TSInterfaceDeclaration":
        return tT(e20, t2, n2);
      case "TSClassImplements":
        return [n2("expression"), n2("typeParameters")];
      case "TSTypeParameterDeclaration":
      case "TSTypeParameterInstantiation":
        return Kw(e20, t2, n2, "params");
      case "TSTypeParameter":
        return Yw(e20, t2, n2);
      case "TSAsExpression": {
        u2.push(n2("expression"), " as ", n2("typeAnnotation"));
        const t3 = e20.getParentNode();
        return jw(t3) && t3.callee === r2 || _w(t3) && t3.object === r2 ? Bw([Nw([Tw, ...u2]), Tw]) : u2;
      }
      case "TSArrayType":
        return [n2("elementType"), "[]"];
      case "TSPropertySignature":
        return r2.readonly && u2.push("readonly "), u2.push(Qw(e20, t2, n2), $w(e20)), r2.typeAnnotation && u2.push(": ", n2("typeAnnotation")), r2.initializer && u2.push(" = ", n2("initializer")), u2;
      case "TSParameterProperty":
        return r2.accessibility && u2.push(r2.accessibility + " "), r2.export && u2.push("export "), r2.static && u2.push("static "), r2.override && u2.push("override "), r2.readonly && u2.push("readonly "), u2.push(n2("parameter")), u2;
      case "TSTypeQuery":
        return ["typeof ", n2("exprName")];
      case "TSIndexSignature": {
        const u3 = e20.getParentNode(), o2 = r2.parameters.length > 1 ? Pw(Lw(t2) ? "," : "") : "", s2 = Bw([
          Nw([Tw, Sw([", ", Tw], e20.map(n2, "parameters"))]),
          o2,
          Tw
        ]);
        return [
          r2.export ? "export " : "",
          r2.accessibility ? [r2.accessibility, " "] : "",
          r2.static ? "static " : "",
          r2.readonly ? "readonly " : "",
          r2.declare ? "declare " : "",
          "[",
          r2.parameters ? s2 : "",
          r2.typeAnnotation ? "]: " : "]",
          r2.typeAnnotation ? n2("typeAnnotation") : "",
          u3.type === "ClassBody" ? i2 : ""
        ];
      }
      case "TSTypePredicate":
        return [
          r2.asserts ? "asserts " : "",
          n2("parameterName"),
          r2.typeAnnotation ? [" is ", n2("typeAnnotation")] : ""
        ];
      case "TSNonNullExpression":
        return [n2("expression"), "!"];
      case "TSImportType":
        return [
          r2.isTypeOf ? "typeof " : "",
          "import(",
          n2(r2.parameter ? "parameter" : "argument"),
          ")",
          r2.qualifier ? [".", n2("qualifier")] : "",
          Kw(e20, t2, n2, "typeParameters")
        ];
      case "TSLiteralType":
        return n2("literal");
      case "TSIndexedAccessType":
        return aT(e20, t2, n2);
      case "TSConstructSignatureDeclaration":
      case "TSCallSignatureDeclaration":
      case "TSConstructorType":
        if (r2.type === "TSConstructorType" && r2.abstract && u2.push("abstract "), r2.type !== "TSCallSignatureDeclaration" && u2.push("new "), u2.push(Bw(qw(e20, n2, t2, false, true))), r2.returnType || r2.typeAnnotation) {
          const e21 = r2.type === "TSConstructorType";
          u2.push(e21 ? " => " : ": ", n2("returnType"), n2("typeAnnotation"));
        }
        return u2;
      case "TSTypeOperator":
        return [r2.operator, " ", n2("typeAnnotation")];
      case "TSMappedType": {
        const u3 = Fw(t2.originalText, Mw(r2), Rw(r2));
        return Bw([
          "{",
          Nw([
            t2.bracketSpacing ? xw : Tw,
            r2.readonly ? [Iw(r2.readonly, "readonly"), " "] : "",
            Vw(e20, t2, n2),
            n2("typeParameter"),
            r2.optional ? Iw(r2.optional, "?") : "",
            r2.typeAnnotation ? ": " : "",
            n2("typeAnnotation"),
            Pw(i2)
          ]),
          vw(e20, t2, true),
          t2.bracketSpacing ? xw : Tw,
          "}"
        ], { shouldBreak: u3 });
      }
      case "TSMethodSignature": {
        const i3 = r2.kind && r2.kind !== "method" ? `${r2.kind} ` : "";
        u2.push(r2.accessibility ? [r2.accessibility, " "] : "", i3, r2.export ? "export " : "", r2.static ? "static " : "", r2.readonly ? "readonly " : "", r2.abstract ? "abstract " : "", r2.declare ? "declare " : "", r2.computed ? "[" : "", n2("key"), r2.computed ? "]" : "", $w(e20));
        const o2 = qw(e20, n2, t2, false, true), s2 = r2.returnType ? "returnType" : "typeAnnotation", a2 = r2[s2], c2 = a2 ? n2(s2) : "", l2 = Uw(r2, c2);
        return u2.push(l2 ? Bw(o2) : o2), a2 && u2.push(": ", Bw(c2)), Bw(u2);
      }
      case "TSNamespaceExportDeclaration":
        return u2.push("export as namespace ", n2("id")), t2.semi && u2.push(";"), Bw(u2);
      case "TSEnumDeclaration":
        return r2.declare && u2.push("declare "), r2.modifiers && u2.push(Vw(e20, t2, n2)), r2.const && u2.push("const "), u2.push("enum ", n2("id"), " "), r2.members.length === 0 ? u2.push(Bw(["{", vw(e20, t2), Tw, "}"])) : u2.push(Bw([
          "{",
          Nw([
            ww,
            Gw(e20, t2, "members", n2),
            Lw(t2, "es5") ? "," : ""
          ]),
          vw(e20, t2, true),
          ww,
          "}"
        ])), u2;
      case "TSEnumMember":
        return u2.push(n2("id")), r2.initializer && u2.push(" = ", n2("initializer")), u2;
      case "TSImportEqualsDeclaration":
        return r2.isExport && u2.push("export "), u2.push("import "), r2.importKind && r2.importKind !== "value" && u2.push(r2.importKind, " "), u2.push(n2("id"), " = ", n2("moduleReference")), t2.semi && u2.push(";"), Bw(u2);
      case "TSExternalModuleReference":
        return ["require(", n2("expression"), ")"];
      case "TSModuleDeclaration": {
        const o2 = e20.getParentNode(), s2 = Ow(r2.id), a2 = o2.type === "TSModuleDeclaration", c2 = r2.body && r2.body.type === "TSModuleDeclaration";
        if (a2)
          u2.push(".");
        else {
          r2.declare && u2.push("declare "), u2.push(Vw(e20, t2, n2));
          const i3 = t2.originalText.slice(Mw(r2), Mw(r2.id));
          r2.id.type === "Identifier" && r2.id.name === "global" && !/namespace|module/.test(i3) || u2.push(s2 || /(?:^|\s)module(?:\s|$)/.test(i3) ? "module " : "namespace ");
        }
        return u2.push(n2("id")), c2 ? u2.push(n2("body")) : r2.body ? u2.push(" ", Bw(n2("body"))) : u2.push(i2), u2;
      }
      case "TSPrivateIdentifier":
        return r2.escapedText;
      case "TSConditionalType":
        return Ww(e20, t2, n2);
      case "TSInferType":
        return ["infer", " ", n2("typeParameter")];
      case "TSIntersectionType":
        return iT(e20, t2, n2);
      case "TSUnionType":
        return uT(e20, t2, n2);
      case "TSFunctionType":
        return oT(e20, t2, n2);
      case "TSTupleType":
        return sT(e20, t2, n2);
      case "TSTypeReference":
        return [n2("typeName"), Kw(e20, t2, n2, "typeParameters")];
      case "TSTypeAnnotation":
        return n2("typeAnnotation");
      case "TSEmptyBodyFunctionExpression":
        return eT(e20, t2, n2);
      case "TSJSDocAllType":
        return "*";
      case "TSJSDocUnknownType":
        return "?";
      case "TSJSDocNullableType":
        return ["?", n2("typeAnnotation")];
      case "TSJSDocNonNullableType":
        return ["!", n2("typeAnnotation")];
      default:
        throw new Error(`Unknown TypeScript node type: ${JSON.stringify(r2.type)}.`);
    }
  }
};
const { hasNewline: lT } = yi$2, {
  builders: { join: pT, hardline: fT },
  utils: { replaceTextEndOfLine: dT }
} = eu$1, { isLineComment: hT, isBlockComment: gT } = Gh, { locStart: mT, locEnd: yT } = zc;
var DT = {
  printComment: function(e20, t2) {
    const n2 = e20.getValue();
    if (hT(n2))
      return t2.originalText.slice(mT(n2), yT(n2)).trimEnd();
    if (gT(n2)) {
      if (function(e22) {
        const t3 = `*${e22.value}*`.split("\n");
        return t3.length > 1 && t3.every((e23) => e23.trim()[0] === "*");
      }(n2)) {
        const e22 = function(e23) {
          const t3 = e23.value.split("\n");
          return [
            "/*",
            pT(fT, t3.map((e24, n3) => n3 === 0 ? e24.trimEnd() : " " + (n3 < t3.length - 1 ? e24.trim() : e24.trimStart()))),
            "*/"
          ];
        }(n2);
        return n2.trailing && !lT(t2.originalText, mT(n2), { backwards: true }) ? [fT, e22] : e22;
      }
      const e21 = yT(n2), r2 = t2.originalText.slice(e21 - 3, e21) === "*-/";
      return ["/*", dT(n2.value), r2 ? "*-/" : "*/"];
    }
    throw new Error("Not a comment: " + JSON.stringify(n2));
  }
};
const { printString: ET, printNumber: CT } = yi$2;
function bT(e20) {
  return e20.toLowerCase();
}
function AT({ pattern: e20, flags: t2 }) {
  return `/${e20}/${t2 = [...t2].sort().join("")}`;
}
var vT = {
  printLiteral: function(e20, t2) {
    const n2 = e20.getNode();
    switch (n2.type) {
      case "RegExpLiteral":
        return AT(n2);
      case "BigIntLiteral":
        return bT(n2.bigint || n2.extra.raw);
      case "NumericLiteral":
        return CT(n2.extra.raw);
      case "StringLiteral":
        return ET(n2.extra.raw, t2);
      case "NullLiteral":
        return "null";
      case "BooleanLiteral":
        return String(n2.value);
      case "DecimalLiteral":
        return CT(n2.value) + "m";
      case "Literal": {
        if (n2.regex)
          return AT(n2.regex);
        if (n2.bigint)
          return bT(n2.raw);
        if (n2.decimal)
          return CT(n2.decimal) + "m";
        const { value: e21 } = n2;
        return typeof e21 == "number" ? CT(n2.raw) : typeof e21 == "string" ? ET(n2.raw, t2) : String(e21);
      }
    }
  }
};
const { printDanglingComments: FT } = Wf, { hasNewline: ST } = yi$2, {
  builders: {
    join: xT,
    line: wT,
    hardline: TT,
    softline: BT,
    group: NT,
    indent: kT
  },
  utils: { replaceTextEndOfLine: PT }
} = eu$1, { insertPragma: OT } = km, {
  hasFlowShorthandAnnotationComment: IT,
  hasComment: LT,
  CommentCheckFlags: jT,
  isTheOnlyJsxElementInMarkdown: _T,
  isBlockComment: MT,
  isLineComment: RT,
  isNextLineEmpty: $T,
  needsHardlineAfterDanglingComment: VT,
  rawText: WT,
  hasIgnoreComment: qT,
  isCallExpression: UT,
  isMemberExpression: zT
} = Gh, { locStart: GT, locEnd: HT } = zc, { printHtmlBinding: JT, isVueEventBindingExpression: XT } = uD, { printAngular: YT } = $D, { printJsx: KT, hasJsxIgnoreComment: QT } = AE, { printFlow: ZT } = Ox, { printTypescript: eB } = cT, {
  printOptionalToken: tB,
  printBindExpressionCallee: nB,
  printTypeAnnotation: rB,
  adjustClause: iB,
  printRestSpread: uB
} = BE, {
  printImportDeclaration: oB,
  printExportDeclaration: sB,
  printExportAllDeclaration: aB,
  printModuleSpecifier: cB
} = TS, { printTernary: lB } = Qx, { printTemplateLiteral: pB } = pg, { printArray: fB } = QE, { printObject: dB } = QS, { printClass: hB, printClassMethod: gB, printClassProperty: mB } = JF, { printProperty: yB } = vv, {
  printFunction: DB,
  printArrowFunction: EB,
  printMethod: CB,
  printReturnStatement: bB,
  printThrowStatement: AB
} = lF, { printCallExpression: vB } = Fb, { printVariableDeclarator: FB, printAssignmentExpression: SB } = Qb, { printBinaryishExpression: xB } = kD, { printSwitchCaseConsequent: wB } = pw, { printMemberExpression: TB } = _C, { printBlock: BB, printBlockBody: NB } = Aw, { printComment: kB } = DT, { printLiteral: PB } = vT, { printDecorators: OB } = vF;
function IB(e20, t2) {
  const n2 = WT(e20), r2 = n2.slice(1, -1);
  if (r2.includes('"') || r2.includes("'"))
    return n2;
  const i2 = t2.singleQuote ? "'" : '"';
  return i2 + r2 + i2;
}
var LB = {
  preprocess: Zy,
  print: function(e20, t2, n2, r2) {
    const i2 = function(e21, t3, n3, r3) {
      const i3 = e21.getValue(), u3 = t3.semi ? ";" : "";
      if (!i3)
        return "";
      if (typeof i3 == "string")
        return i3;
      for (const r4 of [PB, JT, YT, KT, ZT, eB]) {
        const i4 = r4(e21, t3, n3);
        if (i4 !== void 0)
          return i4;
      }
      let o3 = [];
      switch (i3.type) {
        case "JsExpressionRoot":
          return n3("node");
        case "JsonRoot":
          return [n3("node"), TT];
        case "File":
          return i3.program && i3.program.interpreter && o3.push(n3(["program", "interpreter"])), o3.push(n3("program")), o3;
        case "Program":
          return NB(e21, t3, n3);
        case "EmptyStatement":
          return "";
        case "ExpressionStatement":
          if (i3.directive)
            return [IB(i3.expression, t3), u3];
          if (t3.parser === "__vue_event_binding") {
            const t4 = e21.getParentNode();
            if (t4.type === "Program" && t4.body.length === 1 && t4.body[0] === i3)
              return [
                n3("expression"),
                XT(i3.expression) ? ";" : ""
              ];
          }
          return [n3("expression"), _T(t3, e21) ? "" : u3];
        case "ParenthesizedExpression":
          return !LT(i3.expression) && (i3.expression.type === "ObjectExpression" || i3.expression.type === "ArrayExpression") ? ["(", n3("expression"), ")"] : NT(["(", kT([BT, n3("expression")]), BT, ")"]);
        case "AssignmentExpression":
          return SB(e21, t3, n3);
        case "VariableDeclarator":
          return FB(e21, t3, n3);
        case "BinaryExpression":
        case "LogicalExpression":
          return xB(e21, t3, n3);
        case "AssignmentPattern":
          return [n3("left"), " = ", n3("right")];
        case "OptionalMemberExpression":
        case "MemberExpression":
          return TB(e21, t3, n3);
        case "MetaProperty":
          return [n3("meta"), ".", n3("property")];
        case "BindExpression":
          return i3.object && o3.push(n3("object")), o3.push(NT(kT([BT, nB(e21, t3, n3)]))), o3;
        case "Identifier":
          return [i3.name, tB(e21), rB(e21, t3, n3)];
        case "V8IntrinsicIdentifier":
          return ["%", i3.name];
        case "SpreadElement":
        case "SpreadElementPattern":
        case "SpreadProperty":
        case "SpreadPropertyPattern":
        case "RestElement":
          return uB(e21, t3, n3);
        case "FunctionDeclaration":
        case "FunctionExpression":
          return DB(e21, n3, t3, r3);
        case "ArrowFunctionExpression":
          return EB(e21, t3, n3, r3);
        case "YieldExpression":
          return o3.push("yield"), i3.delegate && o3.push("*"), i3.argument && o3.push(" ", n3("argument")), o3;
        case "AwaitExpression":
          if (o3.push("await"), i3.argument) {
            o3.push(" ", n3("argument"));
            const t4 = e21.getParentNode();
            if (UT(t4) && t4.callee === i3 || zT(t4) && t4.object === i3) {
              o3 = [kT([BT, ...o3]), BT];
              const t5 = e21.findAncestor((e22) => e22.type === "AwaitExpression" || e22.type === "BlockStatement");
              if (!t5 || t5.type !== "AwaitExpression")
                return NT(o3);
            }
          }
          return o3;
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
          return sB(e21, t3, n3);
        case "ExportAllDeclaration":
          return aB(e21, t3, n3);
        case "ImportDeclaration":
          return oB(e21, t3, n3);
        case "ImportSpecifier":
        case "ExportSpecifier":
        case "ImportNamespaceSpecifier":
        case "ExportNamespaceSpecifier":
        case "ImportDefaultSpecifier":
        case "ExportDefaultSpecifier":
          return cB(e21, t3, n3);
        case "ImportAttribute":
          return [n3("key"), ": ", n3("value")];
        case "Import":
          return "import";
        case "BlockStatement":
        case "StaticBlock":
        case "ClassBody":
          return BB(e21, t3, n3);
        case "ThrowStatement":
          return AB(e21, t3, n3);
        case "ReturnStatement":
          return bB(e21, t3, n3);
        case "NewExpression":
        case "ImportExpression":
        case "OptionalCallExpression":
        case "CallExpression":
          return vB(e21, t3, n3);
        case "ObjectExpression":
        case "ObjectPattern":
        case "RecordExpression":
          return dB(e21, t3, n3);
        case "ObjectProperty":
        case "Property":
          return i3.method || i3.kind === "get" || i3.kind === "set" ? CB(e21, t3, n3) : yB(e21, t3, n3);
        case "ObjectMethod":
          return CB(e21, t3, n3);
        case "Decorator":
          return ["@", n3("expression")];
        case "ArrayExpression":
        case "ArrayPattern":
        case "TupleExpression":
          return fB(e21, t3, n3);
        case "SequenceExpression": {
          const t4 = e21.getParentNode(0);
          if (t4.type === "ExpressionStatement" || t4.type === "ForStatement") {
            const t5 = [];
            return e21.each((e22, r4) => {
              r4 === 0 ? t5.push(n3()) : t5.push(",", kT([wT, n3()]));
            }, "expressions"), NT(t5);
          }
          return NT(xT([",", wT], e21.map(n3, "expressions")));
        }
        case "ThisExpression":
          return "this";
        case "Super":
          return "super";
        case "Directive":
          return [n3("value"), u3];
        case "DirectiveLiteral":
          return IB(i3, t3);
        case "UnaryExpression":
          return o3.push(i3.operator), /[a-z]$/.test(i3.operator) && o3.push(" "), LT(i3.argument) ? o3.push(NT(["(", kT([BT, n3("argument")]), BT, ")"])) : o3.push(n3("argument")), o3;
        case "UpdateExpression":
          return o3.push(n3("argument"), i3.operator), i3.prefix && o3.reverse(), o3;
        case "ConditionalExpression":
          return lB(e21, t3, n3);
        case "VariableDeclaration": {
          const t4 = e21.map(n3, "declarations"), r4 = e21.getParentNode(), s3 = r4.type === "ForStatement" || r4.type === "ForInStatement" || r4.type === "ForOfStatement", a3 = i3.declarations.some((e22) => e22.init);
          let c2;
          return t4.length !== 1 || LT(i3.declarations[0]) ? t4.length > 0 && (c2 = kT(t4[0])) : c2 = t4[0], o3 = [
            i3.declare ? "declare " : "",
            i3.kind,
            c2 ? [" ", c2] : "",
            kT(t4.slice(1).map((e22) => [",", a3 && !s3 ? TT : wT, e22]))
          ], s3 && r4.body !== i3 || o3.push(u3), NT(o3);
        }
        case "WithStatement":
          return NT([
            "with (",
            n3("object"),
            ")",
            iB(i3.body, n3("body"))
          ]);
        case "IfStatement": {
          const r4 = iB(i3.consequent, n3("consequent")), u4 = NT(["if (", NT([kT([BT, n3("test")]), BT]), ")", r4]);
          if (o3.push(u4), i3.alternate) {
            const r5 = LT(i3.consequent, jT.Trailing | jT.Line) || VT(i3), u5 = i3.consequent.type === "BlockStatement" && !r5;
            o3.push(u5 ? " " : TT), LT(i3, jT.Dangling) && o3.push(FT(e21, t3, true), r5 ? TT : " "), o3.push("else", NT(iB(i3.alternate, n3("alternate"), i3.alternate.type === "IfStatement")));
          }
          return o3;
        }
        case "ForStatement": {
          const r4 = iB(i3.body, n3("body")), u4 = FT(e21, t3, true), o4 = u4 ? [u4, BT] : "";
          return i3.init || i3.test || i3.update ? [
            o4,
            NT([
              "for (",
              NT([
                kT([
                  BT,
                  n3("init"),
                  ";",
                  wT,
                  n3("test"),
                  ";",
                  wT,
                  n3("update")
                ]),
                BT
              ]),
              ")",
              r4
            ])
          ] : [o4, NT(["for (;;)", r4])];
        }
        case "WhileStatement":
          return NT([
            "while (",
            NT([kT([BT, n3("test")]), BT]),
            ")",
            iB(i3.body, n3("body"))
          ]);
        case "ForInStatement":
          return NT([
            "for (",
            n3("left"),
            " in ",
            n3("right"),
            ")",
            iB(i3.body, n3("body"))
          ]);
        case "ForOfStatement":
          return NT([
            "for",
            i3.await ? " await" : "",
            " (",
            n3("left"),
            " of ",
            n3("right"),
            ")",
            iB(i3.body, n3("body"))
          ]);
        case "DoWhileStatement": {
          const e22 = iB(i3.body, n3("body"));
          return o3 = [NT(["do", e22])], i3.body.type === "BlockStatement" ? o3.push(" ") : o3.push(TT), o3.push("while (", NT([kT([BT, n3("test")]), BT]), ")", u3), o3;
        }
        case "DoExpression":
          return [i3.async ? "async " : "", "do ", n3("body")];
        case "BreakStatement":
          return o3.push("break"), i3.label && o3.push(" ", n3("label")), o3.push(u3), o3;
        case "ContinueStatement":
          return o3.push("continue"), i3.label && o3.push(" ", n3("label")), o3.push(u3), o3;
        case "LabeledStatement":
          return i3.body.type === "EmptyStatement" ? [n3("label"), ":;"] : [n3("label"), ": ", n3("body")];
        case "TryStatement":
          return [
            "try ",
            n3("block"),
            i3.handler ? [" ", n3("handler")] : "",
            i3.finalizer ? [" finally ", n3("finalizer")] : ""
          ];
        case "CatchClause":
          if (i3.param) {
            const e22 = LT(i3.param, (e23) => !MT(e23) || e23.leading && ST(t3.originalText, HT(e23)) || e23.trailing && ST(t3.originalText, GT(e23), {
              backwards: true
            })), r4 = n3("param");
            return [
              "catch ",
              e22 ? ["(", kT([BT, r4]), BT, ") "] : ["(", r4, ") "],
              n3("body")
            ];
          }
          return ["catch ", n3("body")];
        case "SwitchStatement":
          return [
            NT(["switch (", kT([BT, n3("discriminant")]), BT, ")"]),
            " {",
            i3.cases.length > 0 ? kT([
              TT,
              xT(TT, e21.map((e22, r4, i4) => {
                const u4 = e22.getValue();
                return [
                  n3(),
                  r4 !== i4.length - 1 && $T(u4, t3) ? TT : ""
                ];
              }, "cases"))
            ]) : "",
            TT,
            "}"
          ];
        case "SwitchCase": {
          i3.test ? o3.push("case ", n3("test"), ":") : o3.push("default:");
          const r4 = i3.consequent.filter((e22) => e22.type !== "EmptyStatement");
          if (r4.length > 0) {
            const i4 = wB(e21, t3, n3);
            o3.push(r4.length === 1 && r4[0].type === "BlockStatement" ? [" ", i4] : kT([TT, i4]));
          }
          return o3;
        }
        case "DebuggerStatement":
          return ["debugger", u3];
        case "ClassDeclaration":
        case "ClassExpression":
          return hB(e21, t3, n3);
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "MethodDefinition":
          return gB(e21, t3, n3);
        case "ClassProperty":
        case "PropertyDefinition":
        case "ClassPrivateProperty":
          return mB(e21, t3, n3);
        case "TemplateElement":
          return PT(i3.value.raw);
        case "TemplateLiteral":
          return pB(e21, n3, t3);
        case "TaggedTemplateExpression":
          return [n3("tag"), n3("typeParameters"), n3("quasi")];
        case "PrivateIdentifier":
          return ["#", n3("name")];
        case "PrivateName":
          return ["#", n3("id")];
        case "InterpreterDirective":
          return o3.push("#!", i3.value, TT), $T(i3, t3) && o3.push(TT), o3;
        case "TopicReference":
          return "%";
        case "ArgumentPlaceholder":
          return "?";
        case "ModuleExpression": {
          o3.push("module {");
          const e22 = n3("body");
          return e22 && o3.push(kT([TT, e22]), TT), o3.push("}"), o3;
        }
        default:
          throw new Error("unknown type: " + JSON.stringify(i3.type));
      }
    }(e20, t2, n2, r2);
    if (!i2)
      return "";
    const u2 = e20.getValue(), { type: o2 } = u2;
    if (o2 === "ClassMethod" || o2 === "ClassPrivateMethod" || o2 === "ClassProperty" || o2 === "PropertyDefinition" || o2 === "TSAbstractClassProperty" || o2 === "ClassPrivateProperty" || o2 === "MethodDefinition" || o2 === "TSAbstractMethodDefinition" || o2 === "TSDeclareMethod")
      return i2;
    const s2 = OB(e20, t2, n2);
    if (s2)
      return NT([...s2, i2]);
    if (!Qy(e20, t2))
      return r2 && r2.needsSemi ? [";", i2] : i2;
    const a2 = [r2 && r2.needsSemi ? ";(" : "(", i2];
    if (IT(u2)) {
      const [e21] = u2.trailingComments;
      a2.push(" /*", e21.value.trimStart(), "*/"), e21.printed = true;
    }
    return a2.push(")"), a2;
  },
  embed: Kg,
  insertPragma: OT,
  massageAstNode: nm,
  hasPrettierIgnore: (e20) => qT(e20) || QT(e20),
  willPrintOwnComments: jy.willPrintOwnComments,
  canAttachComment: function(e20) {
    return e20.type && !MT(e20) && !RT(e20) && e20.type !== "EmptyStatement" && e20.type !== "TemplateElement" && e20.type !== "Import" && e20.type !== "TSEmptyBodyFunctionExpression";
  },
  printComment: kB,
  isBlockComment: MT,
  handleComments: {
    avoidAstMutation: true,
    ownLine: jy.handleOwnLineComment,
    endOfLine: jy.handleEndOfLineComment,
    remaining: jy.handleRemainingComment
  },
  getCommentChildNodes: jy.getCommentChildNodes
};
const {
  builders: { hardline: jB, indent: _B, join: MB }
} = eu$1;
const RB = new Set([
  "start",
  "end",
  "extra",
  "loc",
  "comments",
  "leadingComments",
  "trailingComments",
  "innerComments",
  "errors",
  "range",
  "tokens"
]);
function $B(e20, t2) {
  const { type: n2 } = e20;
  if (n2 !== "ObjectProperty" || e20.key.type !== "Identifier") {
    if (n2 === "UnaryExpression" && e20.operator === "+")
      return t2.argument;
    if (n2 !== "ArrayExpression")
      return n2 === "TemplateLiteral" ? { type: "StringLiteral", value: e20.quasis[0].value.cooked } : void 0;
    for (const [n3, r2] of e20.elements.entries())
      r2 === null && t2.elements.splice(n3, 0, { type: "NullLiteral" });
  } else
    t2.key = { type: "StringLiteral", value: e20.key.name };
}
$B.ignoredProperties = RB;
var VB = {
  preprocess: Zy,
  print: function(e20, t2, n2) {
    const r2 = e20.getValue();
    switch (r2.type) {
      case "JsonRoot":
        return [n2("node"), jB];
      case "ArrayExpression": {
        if (r2.elements.length === 0)
          return "[]";
        const t3 = e20.map(() => e20.getValue() === null ? "null" : n2(), "elements");
        return ["[", _B([jB, MB([",", jB], t3)]), jB, "]"];
      }
      case "ObjectExpression":
        return r2.properties.length === 0 ? "{}" : [
          "{",
          _B([jB, MB([",", jB], e20.map(n2, "properties"))]),
          jB,
          "}"
        ];
      case "ObjectProperty":
        return [n2("key"), ": ", n2("value")];
      case "UnaryExpression":
        return [r2.operator === "+" ? "" : r2.operator, n2("argument")];
      case "NullLiteral":
        return "null";
      case "BooleanLiteral":
        return r2.value ? "true" : "false";
      case "StringLiteral":
      case "NumericLiteral":
        return JSON.stringify(r2.value);
      case "Identifier": {
        const t3 = e20.getParentNode();
        return t3 && t3.type === "ObjectProperty" && t3.key === r2 ? JSON.stringify(r2.name) : r2.name;
      }
      case "TemplateLiteral":
        return n2(["quasis", 0]);
      case "TemplateElement":
        return JSON.stringify(r2.value.cooked);
      default:
        throw new Error("unknown type: " + JSON.stringify(r2.type));
    }
  },
  massageAstNode: $B
};
var WB = {
  bracketSpacing: {
    since: "0.0.0",
    category: "Common",
    type: "boolean",
    default: true,
    description: "Print spaces between brackets.",
    oppositeDescription: "Do not print spaces between brackets."
  },
  singleQuote: {
    since: "0.0.0",
    category: "Common",
    type: "boolean",
    default: false,
    description: "Use single quotes instead of double quotes."
  },
  proseWrap: {
    since: "1.8.2",
    category: "Common",
    type: "choice",
    default: [
      { since: "1.8.2", value: true },
      { since: "1.9.0", value: "preserve" }
    ],
    description: "How to wrap prose.",
    choices: [
      {
        since: "1.9.0",
        value: "always",
        description: "Wrap prose if it exceeds the print width."
      },
      {
        since: "1.9.0",
        value: "never",
        description: "Do not wrap prose."
      },
      {
        since: "1.9.0",
        value: "preserve",
        description: "Wrap prose as-is."
      }
    ]
  },
  bracketSameLine: {
    since: "2.4.0",
    category: "Common",
    type: "boolean",
    default: false,
    description: "Put > of opening tags on the last line instead of on a new line."
  }
};
var qB = {
  arrowParens: {
    since: "1.9.0",
    category: "JavaScript",
    type: "choice",
    default: [
      { since: "1.9.0", value: "avoid" },
      { since: "2.0.0", value: "always" }
    ],
    description: "Include parentheses around a sole arrow function parameter.",
    choices: [
      {
        value: "always",
        description: "Always include parens. Example: `(x) => x`"
      },
      {
        value: "avoid",
        description: "Omit parens when possible. Example: `x => x`"
      }
    ]
  },
  bracketSameLine: WB.bracketSameLine,
  bracketSpacing: WB.bracketSpacing,
  jsxBracketSameLine: {
    since: "0.17.0",
    category: "JavaScript",
    type: "boolean",
    description: "Put > on the last line instead of at a new line.",
    deprecated: "2.4.0"
  },
  semi: {
    since: "1.0.0",
    category: "JavaScript",
    type: "boolean",
    default: true,
    description: "Print semicolons.",
    oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them."
  },
  singleQuote: WB.singleQuote,
  jsxSingleQuote: {
    since: "1.15.0",
    category: "JavaScript",
    type: "boolean",
    default: false,
    description: "Use single quotes in JSX."
  },
  quoteProps: {
    since: "1.17.0",
    category: "JavaScript",
    type: "choice",
    default: "as-needed",
    description: "Change when properties in objects are quoted.",
    choices: [
      {
        value: "as-needed",
        description: "Only add quotes around object properties where required."
      },
      {
        value: "consistent",
        description: "If at least one property in an object requires quotes, quote all properties."
      },
      {
        value: "preserve",
        description: "Respect the input use of quotes in object properties."
      }
    ]
  },
  trailingComma: {
    since: "0.0.0",
    category: "JavaScript",
    type: "choice",
    default: [
      { since: "0.0.0", value: false },
      { since: "0.19.0", value: "none" },
      { since: "2.0.0", value: "es5" }
    ],
    description: "Print trailing commas wherever possible when multi-line.",
    choices: [
      {
        value: "es5",
        description: "Trailing commas where valid in ES5 (objects, arrays, etc.)"
      },
      { value: "none", description: "No trailing commas." },
      {
        value: "all",
        description: "Trailing commas wherever possible (including function arguments)."
      }
    ]
  }
}, UB = {
  name: "JavaScript",
  type: "programming",
  tmScope: "source.js",
  aceMode: "javascript",
  codemirrorMode: "javascript",
  codemirrorMimeType: "text/javascript",
  color: "#f1e05a",
  aliases: ["js", "node"],
  extensions: [
    ".js",
    "._js",
    ".bones",
    ".cjs",
    ".es",
    ".es6",
    ".frag",
    ".gs",
    ".jake",
    ".jsb",
    ".jscad",
    ".jsfl",
    ".jsm",
    ".jss",
    ".jsx",
    ".mjs",
    ".njs",
    ".pac",
    ".sjs",
    ".ssjs",
    ".xsjs",
    ".xsjslib"
  ],
  filenames: ["Jakefile"],
  interpreters: [
    "chakra",
    "d8",
    "gjs",
    "js",
    "node",
    "nodejs",
    "qjs",
    "rhino",
    "v8",
    "v8-shell"
  ],
  languageId: 183
}, zB = {
  name: "TypeScript",
  type: "programming",
  color: "#2b7489",
  aliases: ["ts"],
  interpreters: ["deno", "ts-node"],
  extensions: [".ts"],
  tmScope: "source.ts",
  aceMode: "typescript",
  codemirrorMode: "javascript",
  codemirrorMimeType: "application/typescript",
  languageId: 378
}, GB = {
  name: "TSX",
  type: "programming",
  group: "TypeScript",
  extensions: [".tsx"],
  tmScope: "source.tsx",
  aceMode: "javascript",
  codemirrorMode: "jsx",
  codemirrorMimeType: "text/jsx",
  languageId: 94901924
}, HB = {
  name: "JSON",
  type: "data",
  tmScope: "source.json",
  aceMode: "json",
  codemirrorMode: "javascript",
  codemirrorMimeType: "application/json",
  extensions: [
    ".json",
    ".avsc",
    ".geojson",
    ".gltf",
    ".har",
    ".ice",
    ".JSON-tmLanguage",
    ".jsonl",
    ".mcmeta",
    ".tfstate",
    ".tfstate.backup",
    ".topojson",
    ".webapp",
    ".webmanifest",
    ".yy",
    ".yyp"
  ],
  filenames: [
    ".arcconfig",
    ".htmlhintrc",
    ".imgbotconfig",
    ".tern-config",
    ".tern-project",
    ".watchmanconfig",
    "Pipfile.lock",
    "composer.lock",
    "mcmod.info"
  ],
  languageId: 174
}, JB = {
  name: "JSON with Comments",
  type: "data",
  group: "JSON",
  tmScope: "source.js",
  aceMode: "javascript",
  codemirrorMode: "javascript",
  codemirrorMimeType: "text/javascript",
  aliases: ["jsonc"],
  extensions: [
    ".jsonc",
    ".sublime-build",
    ".sublime-commands",
    ".sublime-completions",
    ".sublime-keymap",
    ".sublime-macro",
    ".sublime-menu",
    ".sublime-mousemap",
    ".sublime-project",
    ".sublime-settings",
    ".sublime-theme",
    ".sublime-workspace",
    ".sublime_metrics",
    ".sublime_session"
  ],
  filenames: [
    ".babelrc",
    ".eslintrc.json",
    ".jscsrc",
    ".jshintrc",
    ".jslintrc",
    "api-extractor.json",
    "devcontainer.json",
    "jsconfig.json",
    "language-configuration.json",
    "tsconfig.json",
    "tslint.json"
  ],
  languageId: 423
}, XB = {
  name: "JSON5",
  type: "data",
  extensions: [".json5"],
  tmScope: "source.js",
  aceMode: "javascript",
  codemirrorMode: "javascript",
  codemirrorMimeType: "application/json",
  languageId: 175
};
var YB = {
  languages: [
    Xd(UB, (e20) => ({
      since: "0.0.0",
      parsers: [
        "babel",
        "espree",
        "meriyah",
        "babel-flow",
        "babel-ts",
        "flow",
        "typescript"
      ],
      vscodeLanguageIds: ["javascript", "mongo"],
      interpreters: [...e20.interpreters, "zx"],
      extensions: [...e20.extensions.filter((e21) => e21 !== ".jsx"), ".wxs"]
    })),
    Xd(UB, () => ({
      name: "Flow",
      since: "0.0.0",
      parsers: ["flow", "babel-flow"],
      vscodeLanguageIds: ["javascript"],
      aliases: [],
      filenames: [],
      extensions: [".js.flow"]
    })),
    Xd(UB, () => ({
      name: "JSX",
      since: "0.0.0",
      parsers: [
        "babel",
        "babel-flow",
        "babel-ts",
        "flow",
        "typescript",
        "espree",
        "meriyah"
      ],
      vscodeLanguageIds: ["javascriptreact"],
      aliases: void 0,
      filenames: void 0,
      extensions: [".jsx"],
      group: "JavaScript",
      interpreters: void 0,
      tmScope: "source.js.jsx",
      aceMode: "javascript",
      codemirrorMode: "jsx",
      codemirrorMimeType: "text/jsx",
      color: void 0
    })),
    Xd(zB, () => ({
      since: "1.4.0",
      parsers: ["typescript", "babel-ts"],
      vscodeLanguageIds: ["typescript"]
    })),
    Xd(GB, () => ({
      since: "1.4.0",
      parsers: ["typescript", "babel-ts"],
      vscodeLanguageIds: ["typescriptreact"]
    })),
    Xd(HB, () => ({
      name: "JSON.stringify",
      since: "1.13.0",
      parsers: ["json-stringify"],
      vscodeLanguageIds: ["json"],
      extensions: [],
      filenames: ["package.json", "package-lock.json", "composer.json"]
    })),
    Xd(HB, (e20) => ({
      since: "1.5.0",
      parsers: ["json"],
      vscodeLanguageIds: ["json"],
      extensions: e20.extensions.filter((e21) => e21 !== ".jsonl")
    })),
    Xd(JB, (e20) => ({
      since: "1.5.0",
      parsers: ["json"],
      vscodeLanguageIds: ["jsonc"],
      filenames: [...e20.filenames, ".eslintrc"]
    })),
    Xd(XB, () => ({
      since: "1.13.0",
      parsers: ["json5"],
      vscodeLanguageIds: ["json5"]
    }))
  ],
  options: qB,
  printers: { estree: LB, "estree-json": VB },
  parsers: void 0
};
const { isFrontMatterNode: KB } = yi$2, QB = new Set([
  "raw",
  "raws",
  "sourceIndex",
  "source",
  "before",
  "after",
  "trailingComma"
]);
function ZB(e20, t2, n2) {
  if (KB(e20) && e20.lang === "yaml" && delete t2.value, e20.type === "css-comment" && n2.type === "css-root" && n2.nodes.length > 0) {
    if ((n2.nodes[0] === e20 || KB(n2.nodes[0]) && n2.nodes[1] === e20) && (delete t2.text, /^\*\s*@(?:format|prettier)\s*$/.test(e20.text)))
      return null;
    if (n2.type === "css-root" && Ln$2(n2.nodes) === e20)
      return null;
  }
  if (e20.type === "value-root" && delete t2.text, e20.type !== "media-query" && e20.type !== "media-query-list" && e20.type !== "media-feature-expression" || delete t2.value, e20.type === "css-rule" && delete t2.params, e20.type === "selector-combinator" && (t2.value = t2.value.replace(/\s+/g, " ")), e20.type === "media-feature" && (t2.value = t2.value.replace(/ /g, "")), (e20.type === "value-word" && (e20.isColor && e20.isHex || ["initial", "inherit", "unset", "revert"].includes(t2.value.replace().toLowerCase())) || e20.type === "media-feature" || e20.type === "selector-root-invalid" || e20.type === "selector-pseudo") && (t2.value = t2.value.toLowerCase()), e20.type === "css-decl" && (t2.prop = t2.prop.toLowerCase()), e20.type !== "css-atrule" && e20.type !== "css-import" || (t2.name = t2.name.toLowerCase()), e20.type === "value-number" && (t2.unit = t2.unit.toLowerCase()), e20.type !== "media-feature" && e20.type !== "media-keyword" && e20.type !== "media-type" && e20.type !== "media-unknown" && e20.type !== "media-url" && e20.type !== "media-value" && e20.type !== "selector-attribute" && e20.type !== "selector-string" && e20.type !== "selector-class" && e20.type !== "selector-combinator" && e20.type !== "value-string" || !t2.value || (t2.value = t2.value.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1")), e20.type === "selector-attribute" && (t2.attribute = t2.attribute.trim(), t2.namespace && typeof t2.namespace == "string" && (t2.namespace = t2.namespace.trim(), t2.namespace.length === 0 && (t2.namespace = true)), t2.value && (t2.value = t2.value.trim().replace(/^["']|["']$/g, ""), delete t2.quoted)), e20.type !== "media-value" && e20.type !== "media-type" && e20.type !== "value-number" && e20.type !== "selector-root-invalid" && e20.type !== "selector-class" && e20.type !== "selector-combinator" && e20.type !== "selector-tag" || !t2.value || (t2.value = t2.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, (e21, t3, n3) => {
    const r2 = Number(t3);
    return Number.isNaN(r2) ? e21 : r2 + n3.toLowerCase();
  })), e20.type === "selector-tag") {
    const n3 = e20.value.toLowerCase();
    ["from", "to"].includes(n3) && (t2.value = n3);
  }
  e20.type === "css-atrule" && e20.name.toLowerCase() === "supports" && delete t2.value, e20.type === "selector-unknown" && delete t2.value;
}
ZB.ignoredProperties = QB;
var eN = ZB;
const {
  builders: { hardline: tN, markAsRoot: nN }
} = eu$1;
var rN = function(e20, t2) {
  if (e20.lang === "yaml") {
    const n2 = e20.value.trim(), r2 = n2 ? t2(n2, { parser: "yaml" }, { stripTrailingHardline: true }) : "";
    return nN([e20.startDelimiter, tN, r2, r2 ? tN : "", e20.endDelimiter]);
  }
};
const {
  builders: { hardline: iN }
} = eu$1;
var uN = function(e20, t2, n2) {
  const r2 = e20.getValue();
  if (r2.type === "front-matter") {
    const e21 = rN(r2, n2);
    return e21 ? [e21, iN] : "";
  }
};
const oN = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
var sN = function(e20) {
  const t2 = e20.match(oN);
  if (!t2)
    return { content: e20 };
  const {
    startDelimiter: n2,
    language: r2,
    value: i2 = "",
    endDelimiter: u2
  } = t2.groups;
  let o2 = r2.trim() || "yaml";
  if (n2 === "+++" && (o2 = "toml"), o2 !== "yaml" && n2 !== u2)
    return { content: e20 };
  const [s2] = t2;
  return {
    frontMatter: {
      type: "front-matter",
      lang: o2,
      value: i2,
      startDelimiter: n2,
      endDelimiter: u2,
      raw: s2.replace(/\n$/, "")
    },
    content: s2.replace(/[^\n]/g, " ") + e20.slice(s2.length)
  };
};
var aN = {
  hasPragma: function(e20) {
    return km.hasPragma(sN(e20).content);
  },
  insertPragma: function(e20) {
    const { frontMatter: t2, content: n2 } = sN(e20);
    return (t2 ? t2.raw + "\n\n" : "") + km.insertPragma(n2);
  }
};
const { isNonEmptyArray: cN } = yi$2, lN = new Set([
  "red",
  "green",
  "blue",
  "alpha",
  "a",
  "rgb",
  "hue",
  "h",
  "saturation",
  "s",
  "lightness",
  "l",
  "whiteness",
  "w",
  "blackness",
  "b",
  "tint",
  "shade",
  "blend",
  "blenda",
  "contrast",
  "hsl",
  "hsla",
  "hwb",
  "hwba"
]), pN = new Set(["import", "use", "forward"]);
function fN(e20, t2) {
  const n2 = Array.isArray(t2) ? t2 : [t2];
  let r2, i2 = -1;
  for (; r2 = e20.getParentNode(++i2); )
    if (n2.includes(r2.type))
      return i2;
  return -1;
}
function dN(e20, t2) {
  const n2 = fN(e20, t2);
  return n2 === -1 ? null : e20.getParentNode(n2);
}
function hN(e20) {
  return e20.type === "value-operator" && e20.value === "*";
}
function gN(e20) {
  return e20.type === "value-operator" && e20.value === "/";
}
function mN(e20) {
  return e20.type === "value-operator" && e20.value === "+";
}
function yN(e20) {
  return e20.type === "value-operator" && e20.value === "-";
}
function DN(e20) {
  return e20.type === "value-operator" && e20.value === "%";
}
function EN(e20) {
  return e20.type === "value-comma_group" && e20.groups && e20.groups[1] && e20.groups[1].type === "value-colon";
}
function CN(e20) {
  return e20.type === "value-paren_group" && e20.groups && e20.groups[0] && EN(e20.groups[0]);
}
function bN(e20) {
  return e20 && e20.type === "value-colon";
}
var AN = {
  getAncestorCounter: fN,
  getAncestorNode: dN,
  getPropOfDeclNode: function(e20) {
    const t2 = dN(e20, "css-decl");
    return t2 && t2.prop && t2.prop.toLowerCase();
  },
  hasSCSSInterpolation: function(e20) {
    if (cN(e20)) {
      for (let t2 = e20.length - 1; t2 > 0; t2--)
        if (e20[t2].type === "word" && e20[t2].value === "{" && e20[t2 - 1].type === "word" && e20[t2 - 1].value.endsWith("#"))
          return true;
    }
    return false;
  },
  hasStringOrFunction: function(e20) {
    if (cN(e20)) {
      for (let t2 = 0; t2 < e20.length; t2++)
        if (e20[t2].type === "string" || e20[t2].type === "func")
          return true;
    }
    return false;
  },
  maybeToLowerCase: function(e20) {
    return e20.includes("$") || e20.includes("@") || e20.includes("#") || e20.startsWith("%") || e20.startsWith("--") || e20.startsWith(":--") || e20.includes("(") && e20.includes(")") ? e20 : e20.toLowerCase();
  },
  insideValueFunctionNode: function(e20, t2) {
    const n2 = dN(e20, "value-func");
    return n2 && n2.value && n2.value.toLowerCase() === t2;
  },
  insideICSSRuleNode: function(e20) {
    const t2 = dN(e20, "css-rule");
    return t2 && t2.raws && t2.raws.selector && (t2.raws.selector.startsWith(":import") || t2.raws.selector.startsWith(":export"));
  },
  insideAtRuleNode: function(e20, t2) {
    const n2 = Array.isArray(t2) ? t2 : [t2], r2 = dN(e20, "css-atrule");
    return r2 && n2.includes(r2.name.toLowerCase());
  },
  insideURLFunctionInImportAtRuleNode: function(e20) {
    const t2 = e20.getValue(), n2 = dN(e20, "css-atrule");
    return n2 && n2.name === "import" && t2.groups[0].value === "url" && t2.groups.length === 2;
  },
  isKeyframeAtRuleKeywords: function(e20, t2) {
    const n2 = dN(e20, "css-atrule");
    return n2 && n2.name && n2.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(t2.toLowerCase());
  },
  isWideKeywords: function(e20) {
    return ["initial", "inherit", "unset", "revert"].includes(e20.toLowerCase());
  },
  isSCSS: function(e20, t2) {
    return e20 === "less" || e20 === "scss" ? e20 === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(t2);
  },
  isSCSSVariable: function(e20) {
    return Boolean(e20 && e20.type === "word" && e20.value.startsWith("$"));
  },
  isLastNode: function(e20, t2) {
    const n2 = e20.getParentNode();
    if (!n2)
      return false;
    const { nodes: r2 } = n2;
    return r2 && r2.indexOf(t2) === r2.length - 1;
  },
  isLessParser: function(e20) {
    return e20.parser === "css" || e20.parser === "less";
  },
  isSCSSControlDirectiveNode: function(e20) {
    return e20.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(e20.name);
  },
  isDetachedRulesetDeclarationNode: function(e20) {
    return !!e20.selector && (typeof e20.selector == "string" && /^@.+:.*$/.test(e20.selector) || e20.selector.value && /^@.+:.*$/.test(e20.selector.value));
  },
  isRelationalOperatorNode: function(e20) {
    return e20.type === "value-word" && ["<", ">", "<=", ">="].includes(e20.value);
  },
  isEqualityOperatorNode: function(e20) {
    return e20.type === "value-word" && ["==", "!="].includes(e20.value);
  },
  isMultiplicationNode: hN,
  isDivisionNode: gN,
  isAdditionNode: mN,
  isSubtractionNode: yN,
  isModuloNode: DN,
  isMathOperatorNode: function(e20) {
    return hN(e20) || gN(e20) || mN(e20) || yN(e20) || DN(e20);
  },
  isEachKeywordNode: function(e20) {
    return e20.type === "value-word" && e20.value === "in";
  },
  isForKeywordNode: function(e20) {
    return e20.type === "value-word" && ["from", "through", "end"].includes(e20.value);
  },
  isURLFunctionNode: function(e20) {
    return e20.type === "value-func" && e20.value.toLowerCase() === "url";
  },
  isIfElseKeywordNode: function(e20) {
    return e20.type === "value-word" && ["and", "or", "not"].includes(e20.value);
  },
  hasComposesNode: function(e20) {
    return e20.value && e20.value.type === "value-root" && e20.value.group && e20.value.group.type === "value-value" && e20.prop.toLowerCase() === "composes";
  },
  hasParensAroundNode: function(e20) {
    return e20.value && e20.value.group && e20.value.group.group && e20.value.group.group.type === "value-paren_group" && e20.value.group.group.open !== null && e20.value.group.group.close !== null;
  },
  hasEmptyRawBefore: function(e20) {
    return e20.raws && e20.raws.before === "";
  },
  isSCSSNestedPropertyNode: function(e20) {
    return !!e20.selector && e20.selector.replace(/\/\*.*?\*\//, "").replace(/\/\/.*?\n/, "").trim().endsWith(":");
  },
  isDetachedRulesetCallNode: function(e20) {
    return e20.raws && e20.raws.params && /^\(\s*\)$/.test(e20.raws.params);
  },
  isTemplatePlaceholderNode: function(e20) {
    return e20.name.startsWith("prettier-placeholder");
  },
  isTemplatePropNode: function(e20) {
    return e20.prop.startsWith("@prettier-placeholder");
  },
  isPostcssSimpleVarNode: function(e20, t2) {
    return e20.value === "$$" && e20.type === "value-func" && t2 && t2.type === "value-word" && !t2.raws.before;
  },
  isKeyValuePairNode: EN,
  isKeyValuePairInParenGroupNode: CN,
  isKeyInValuePairNode: function(e20, t2) {
    if (!EN(t2))
      return false;
    const { groups: n2 } = t2, r2 = n2.indexOf(e20);
    return r2 !== -1 && bN(n2[r2 + 1]);
  },
  isSCSSMapItemNode: function(e20) {
    const t2 = e20.getValue();
    if (t2.groups.length === 0)
      return false;
    const n2 = e20.getParentNode(1);
    if (!(CN(t2) || n2 && CN(n2)))
      return false;
    const r2 = dN(e20, "css-decl");
    return !!(r2 && r2.prop && r2.prop.startsWith("$")) || !!CN(n2) || n2.type === "value-func";
  },
  isInlineValueCommentNode: function(e20) {
    return e20.type === "value-comment" && e20.inline;
  },
  isHashNode: function(e20) {
    return e20.type === "value-word" && e20.value === "#";
  },
  isLeftCurlyBraceNode: function(e20) {
    return e20.type === "value-word" && e20.value === "{";
  },
  isRightCurlyBraceNode: function(e20) {
    return e20.type === "value-word" && e20.value === "}";
  },
  isWordNode: function(e20) {
    return ["value-word", "value-atword"].includes(e20.type);
  },
  isColonNode: bN,
  isMediaAndSupportsKeywords: function(e20) {
    return e20.value && ["not", "and", "or"].includes(e20.value.toLowerCase());
  },
  isColorAdjusterFuncNode: function(e20) {
    return e20.type === "value-func" && lN.has(e20.value.toLowerCase());
  },
  lastLineHasInlineComment: function(e20) {
    return /\/\//.test(e20.split(/[\n\r]/).pop());
  },
  stringifyNode: function e8(t2) {
    if (t2.groups) {
      return (t2.open && t2.open.value ? t2.open.value : "") + t2.groups.reduce((n3, r3, i2) => n3 + e8(r3) + (t2.groups[0].type === "comma_group" && i2 !== t2.groups.length - 1 ? "," : ""), "") + (t2.close && t2.close.value ? t2.close.value : "");
    }
    const n2 = t2.raws && t2.raws.before ? t2.raws.before : "", r2 = t2.raws && t2.raws.quote ? t2.raws.quote : "";
    return n2 + r2 + (t2.type === "atword" ? "@" : "") + (t2.value ? t2.value : "") + r2 + (t2.unit ? t2.unit : "") + (t2.group ? e8(t2.group) : "") + (t2.raws && t2.raws.after ? t2.raws.after : "");
  },
  isAtWordPlaceholderNode: function(e20) {
    return e20 && e20.type === "value-atword" && e20.value.startsWith("prettier-placeholder-");
  },
  isModuleRuleName: function(e20) {
    return pN.has(e20);
  }
}, vN = function(e20, t2) {
  let n2 = 0;
  for (let r2 = 0; r2 < e20.line - 1; ++r2)
    n2 = t2.indexOf("\n", n2) + 1;
  return n2 + e20.column;
};
const { getLast: FN, skipEverythingButNewLine: SN } = yi$2;
function xN(e20, t2) {
  return typeof e20.sourceIndex == "number" ? e20.sourceIndex : e20.source ? vN(e20.source.start, t2) - 1 : null;
}
function wN(e20, t2) {
  if (e20.type === "css-comment" && e20.inline)
    return SN(t2, e20.source.startOffset);
  const n2 = e20.nodes && FN(e20.nodes);
  return n2 && e20.source && !e20.source.end && (e20 = n2), e20.source && e20.source.end ? vN(e20.source.end, t2) : null;
}
function TN(e20, t2, n2) {
  e20.source && (e20.source.startOffset = xN(e20, n2) + t2, e20.source.endOffset = wN(e20, n2) + t2);
  for (const r2 in e20) {
    const i2 = e20[r2];
    r2 !== "source" && i2 && typeof i2 == "object" && TN(i2, t2, n2);
  }
}
function BN(e20) {
  let t2 = e20.source.startOffset;
  return typeof e20.prop == "string" && (t2 += e20.prop.length), e20.type === "css-atrule" && typeof e20.name == "string" && (t2 += 1 + e20.name.length + e20.raws.afterName.match(/^\s*:?\s*/)[0].length), e20.type !== "css-atrule" && e20.raws && typeof e20.raws.between == "string" && (t2 += e20.raws.between.length), t2;
}
var NN = {
  locStart: function(e20) {
    return e20.source.startOffset;
  },
  locEnd: function(e20) {
    return e20.source.endOffset;
  },
  calculateLoc: function e9(t2, n2) {
    t2.source && (t2.source.startOffset = xN(t2, n2), t2.source.endOffset = wN(t2, n2));
    for (const r2 in t2) {
      const i2 = t2[r2];
      r2 !== "source" && i2 && typeof i2 == "object" && (i2.type === "value-root" || i2.type === "value-unknown" ? TN(i2, BN(t2), i2.text || i2.value) : e9(i2, n2));
    }
  },
  replaceQuotesInInlineComments: function(e20) {
    let t2, n2 = "initial", r2 = "initial", i2 = false;
    const u2 = [];
    for (let o2 = 0; o2 < e20.length; o2++) {
      const s2 = e20[o2];
      switch (n2) {
        case "initial":
          if (s2 === "'") {
            n2 = "single-quotes";
            continue;
          }
          if (s2 === '"') {
            n2 = "double-quotes";
            continue;
          }
          if ((s2 === "u" || s2 === "U") && e20.slice(o2, o2 + 4).toLowerCase() === "url(") {
            n2 = "url", o2 += 3;
            continue;
          }
          if (s2 === "*" && e20[o2 - 1] === "/") {
            n2 = "comment-block";
            continue;
          }
          if (s2 === "/" && e20[o2 - 1] === "/") {
            n2 = "comment-inline", t2 = o2 - 1;
            continue;
          }
          continue;
        case "single-quotes":
          if (s2 === "'" && e20[o2 - 1] !== "\\" && (n2 = r2, r2 = "initial"), s2 === "\n" || s2 === "\r")
            return e20;
          continue;
        case "double-quotes":
          if (s2 === '"' && e20[o2 - 1] !== "\\" && (n2 = r2, r2 = "initial"), s2 === "\n" || s2 === "\r")
            return e20;
          continue;
        case "url":
          if (s2 === ")" && (n2 = "initial"), s2 === "\n" || s2 === "\r")
            return e20;
          if (s2 === "'") {
            n2 = "single-quotes", r2 = "url";
            continue;
          }
          if (s2 === '"') {
            n2 = "double-quotes", r2 = "url";
            continue;
          }
          continue;
        case "comment-block":
          s2 === "/" && e20[o2 - 1] === "*" && (n2 = "initial");
          continue;
        case "comment-inline":
          s2 !== '"' && s2 !== "'" && s2 !== "*" || (i2 = true), s2 !== "\n" && s2 !== "\r" || (i2 && u2.push([t2, o2]), n2 = "initial", i2 = false);
          continue;
      }
    }
    for (const [t3, n3] of u2)
      e20 = e20.slice(0, t3) + e20.slice(t3, n3).replace(/["'*]/g, " ") + e20.slice(n3);
    return e20;
  }
};
const {
  printNumber: kN,
  printString: PN,
  hasNewline: ON,
  isFrontMatterNode: IN,
  isNextLineEmpty: LN,
  isNonEmptyArray: jN
} = yi$2, {
  builders: {
    join: _N,
    line: MN,
    hardline: RN,
    softline: $N,
    group: VN,
    fill: WN,
    indent: qN,
    dedent: UN,
    ifBreak: zN,
    breakParent: GN
  },
  utils: { removeLines: HN, getDocParts: JN }
} = eu$1, { insertPragma: XN } = aN, {
  getAncestorNode: YN,
  getPropOfDeclNode: KN,
  maybeToLowerCase: QN,
  insideValueFunctionNode: ZN,
  insideICSSRuleNode: ek,
  insideAtRuleNode: tk,
  insideURLFunctionInImportAtRuleNode: nk,
  isKeyframeAtRuleKeywords: rk,
  isWideKeywords: ik,
  isSCSS: uk,
  isLastNode: ok,
  isLessParser: sk,
  isSCSSControlDirectiveNode: ak,
  isDetachedRulesetDeclarationNode: ck,
  isRelationalOperatorNode: lk,
  isEqualityOperatorNode: pk,
  isMultiplicationNode: fk,
  isDivisionNode: dk,
  isAdditionNode: hk,
  isSubtractionNode: gk,
  isMathOperatorNode: mk,
  isEachKeywordNode: yk,
  isForKeywordNode: Dk,
  isURLFunctionNode: Ek,
  isIfElseKeywordNode: Ck,
  hasComposesNode: bk,
  hasParensAroundNode: Ak,
  hasEmptyRawBefore: vk,
  isKeyValuePairNode: Fk,
  isKeyInValuePairNode: Sk,
  isDetachedRulesetCallNode: xk,
  isTemplatePlaceholderNode: wk,
  isTemplatePropNode: Tk,
  isPostcssSimpleVarNode: Bk,
  isSCSSMapItemNode: Nk,
  isInlineValueCommentNode: kk,
  isHashNode: Pk,
  isLeftCurlyBraceNode: Ok,
  isRightCurlyBraceNode: Ik,
  isWordNode: Lk,
  isColonNode: jk,
  isMediaAndSupportsKeywords: _k,
  isColorAdjusterFuncNode: Mk,
  lastLineHasInlineComment: Rk,
  isAtWordPlaceholderNode: $k
} = AN, { locStart: Vk, locEnd: Wk } = NN;
function qk(e20) {
  return e20.trailingComma === "es5" || e20.trailingComma === "all";
}
function Uk(e20, t2, n2) {
  const r2 = [];
  return e20.each((e21, i2, u2) => {
    const o2 = u2[i2 - 1];
    if (o2 && o2.type === "css-comment" && o2.text.trim() === "prettier-ignore") {
      const n3 = e21.getValue();
      r2.push(t2.originalText.slice(Vk(n3), Wk(n3)));
    } else
      r2.push(n2());
    i2 !== u2.length - 1 && (u2[i2 + 1].type === "css-comment" && !ON(t2.originalText, Vk(u2[i2 + 1]), { backwards: true }) && !IN(u2[i2]) || u2[i2 + 1].type === "css-atrule" && u2[i2 + 1].name === "else" && u2[i2].type !== "css-comment" ? r2.push(" ") : (r2.push(t2.__isHTMLStyleAttribute ? MN : RN), LN(t2.originalText, e21.getValue(), Wk) && !IN(u2[i2]) && r2.push(RN)));
  }, "nodes"), r2;
}
const zk = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, Gk = new RegExp(zk.source + `|(${/[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g.source})?(${/(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g.source})(${/[A-Za-z]+/g.source})?`, "g");
function Hk(e20, t2) {
  return e20.replace(zk, (e21) => PN(e21, t2));
}
function Jk(e20, t2) {
  const n2 = t2.singleQuote ? "'" : '"';
  return e20.includes('"') || e20.includes("'") ? e20 : n2 + e20 + n2;
}
function Xk(e20) {
  return e20.replace(Gk, (e21, t2, n2, r2, i2) => !n2 && r2 ? Yk(r2) + QN(i2 || "") : e21);
}
function Yk(e20) {
  return kN(e20).replace(/\.0(?=$|e)/, "");
}
var Kk = {
  print: function(e20, t2, n2) {
    const r2 = e20.getValue();
    if (!r2)
      return "";
    if (typeof r2 == "string")
      return r2;
    switch (r2.type) {
      case "front-matter":
        return [r2.raw, RN];
      case "css-root": {
        const i2 = Uk(e20, t2, n2), u2 = r2.raws.after.trim();
        return [i2, u2 ? ` ${u2}` : "", JN(i2).length > 0 ? RN : ""];
      }
      case "css-comment": {
        const e21 = r2.inline || r2.raws.inline, n3 = t2.originalText.slice(Vk(r2), Wk(r2));
        return e21 ? n3.trimEnd() : n3;
      }
      case "css-rule":
        return [
          n2("selector"),
          r2.important ? " !important" : "",
          r2.nodes ? [
            r2.selector && r2.selector.type === "selector-unknown" && Rk(r2.selector.value) ? MN : " ",
            "{",
            r2.nodes.length > 0 ? qN([RN, Uk(e20, t2, n2)]) : "",
            RN,
            "}",
            ck(r2) ? ";" : ""
          ] : ";"
        ];
      case "css-decl": {
        const i2 = e20.getParentNode(), { between: u2 } = r2.raws, o2 = u2.trim(), s2 = o2 === ":";
        let a2 = bk(r2) ? HN(n2("value")) : n2("value");
        return !s2 && Rk(o2) && (a2 = qN([RN, UN(a2)])), [
          r2.raws.before.replace(/[\s;]/g, ""),
          ek(e20) ? r2.prop : QN(r2.prop),
          o2.startsWith("//") ? " " : "",
          o2,
          r2.extend ? "" : " ",
          sk(t2) && r2.extend && r2.selector ? ["extend(", n2("selector"), ")"] : "",
          a2,
          r2.raws.important ? r2.raws.important.replace(/\s*!\s*important/i, " !important") : r2.important ? " !important" : "",
          r2.raws.scssDefault ? r2.raws.scssDefault.replace(/\s*!default/i, " !default") : r2.scssDefault ? " !default" : "",
          r2.raws.scssGlobal ? r2.raws.scssGlobal.replace(/\s*!global/i, " !global") : r2.scssGlobal ? " !global" : "",
          r2.nodes ? [" {", qN([$N, Uk(e20, t2, n2)]), $N, "}"] : Tk(r2) && !i2.raws.semicolon && t2.originalText[Wk(r2) - 1] !== ";" ? "" : t2.__isHTMLStyleAttribute && ok(e20, r2) ? zN(";") : ";"
        ];
      }
      case "css-atrule": {
        const i2 = e20.getParentNode(), u2 = wk(r2) && !i2.raws.semicolon && t2.originalText[Wk(r2) - 1] !== ";";
        if (sk(t2)) {
          if (r2.mixin)
            return [
              n2("selector"),
              r2.important ? " !important" : "",
              u2 ? "" : ";"
            ];
          if (r2.function)
            return [r2.name, n2("params"), u2 ? "" : ";"];
          if (r2.variable)
            return [
              "@",
              r2.name,
              ": ",
              r2.value ? n2("value") : "",
              r2.raws.between.trim() ? r2.raws.between.trim() + " " : "",
              r2.nodes ? [
                "{",
                qN([
                  r2.nodes.length > 0 ? $N : "",
                  Uk(e20, t2, n2)
                ]),
                $N,
                "}"
              ] : "",
              u2 ? "" : ";"
            ];
        }
        return [
          "@",
          xk(r2) || r2.name.endsWith(":") ? r2.name : QN(r2.name),
          r2.params ? [
            xk(r2) ? "" : wk(r2) ? r2.raws.afterName === "" ? "" : r2.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(r2.raws.afterName) ? [RN, RN] : /^\s*\n/.test(r2.raws.afterName) ? RN : " " : " ",
            n2("params")
          ] : "",
          r2.selector ? qN([" ", n2("selector")]) : "",
          r2.value ? VN([
            " ",
            n2("value"),
            ak(r2) ? Ak(r2) ? " " : MN : ""
          ]) : r2.name === "else" ? " " : "",
          r2.nodes ? [
            ak(r2) ? "" : r2.selector && !r2.selector.nodes && typeof r2.selector.value == "string" && Rk(r2.selector.value) || !r2.selector && typeof r2.params == "string" && Rk(r2.params) ? MN : " ",
            "{",
            qN([
              r2.nodes.length > 0 ? $N : "",
              Uk(e20, t2, n2)
            ]),
            $N,
            "}"
          ] : u2 ? "" : ";"
        ];
      }
      case "media-query-list": {
        const t3 = [];
        return e20.each((e21) => {
          const r3 = e21.getValue();
          r3.type === "media-query" && r3.value === "" || t3.push(n2());
        }, "nodes"), VN(qN(_N(MN, t3)));
      }
      case "media-query":
        return [_N(" ", e20.map(n2, "nodes")), ok(e20, r2) ? "" : ","];
      case "media-type":
        return Xk(Hk(r2.value, t2));
      case "media-feature-expression":
        return r2.nodes ? ["(", ...e20.map(n2, "nodes"), ")"] : r2.value;
      case "media-feature":
        return QN(Hk(r2.value.replace(/ +/g, " "), t2));
      case "media-colon":
        return [r2.value, " "];
      case "media-value":
        return Xk(Hk(r2.value, t2));
      case "media-keyword":
        return Hk(r2.value, t2);
      case "media-url":
        return Hk(r2.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/g, ")"), t2);
      case "media-unknown":
        return r2.value;
      case "selector-root":
        return VN([
          tk(e20, "custom-selector") ? [YN(e20, "css-atrule").customSelector, MN] : "",
          _N([
            ",",
            tk(e20, ["extend", "custom-selector", "nest"]) ? MN : RN
          ], e20.map(n2, "nodes"))
        ]);
      case "selector-selector":
        return VN(qN(e20.map(n2, "nodes")));
      case "selector-comment":
        return r2.value;
      case "selector-string":
        return Hk(r2.value, t2);
      case "selector-tag": {
        const t3 = e20.getParentNode(), n3 = t3 && t3.nodes.indexOf(r2), i2 = n3 && t3.nodes[n3 - 1];
        return [
          r2.namespace ? [
            r2.namespace === true ? "" : r2.namespace.trim(),
            "|"
          ] : "",
          i2.type === "selector-nesting" ? r2.value : Xk(rk(e20, r2.value) ? r2.value.toLowerCase() : r2.value)
        ];
      }
      case "selector-id":
        return ["#", r2.value];
      case "selector-class":
        return [".", Xk(Hk(r2.value, t2))];
      case "selector-attribute":
        return [
          "[",
          r2.namespace ? [
            r2.namespace === true ? "" : r2.namespace.trim(),
            "|"
          ] : "",
          r2.attribute.trim(),
          r2.operator ? r2.operator : "",
          r2.value ? Jk(Hk(r2.value.trim(), t2), t2) : "",
          r2.insensitive ? " i" : "",
          "]"
        ];
      case "selector-combinator":
        if (r2.value === "+" || r2.value === ">" || r2.value === "~" || r2.value === ">>>") {
          const t3 = e20.getParentNode();
          return [
            t3.type === "selector-selector" && t3.nodes[0] === r2 ? "" : MN,
            r2.value,
            ok(e20, r2) ? "" : " "
          ];
        }
        return [
          r2.value.trim().startsWith("(") ? MN : "",
          Xk(Hk(r2.value.trim(), t2)) || MN
        ];
      case "selector-universal":
        return [
          r2.namespace ? [
            r2.namespace === true ? "" : r2.namespace.trim(),
            "|"
          ] : "",
          r2.value
        ];
      case "selector-pseudo":
        return [
          QN(r2.value),
          jN(r2.nodes) ? ["(", _N(", ", e20.map(n2, "nodes")), ")"] : ""
        ];
      case "selector-nesting":
        return r2.value;
      case "selector-unknown": {
        const n3 = YN(e20, "css-rule");
        if (n3 && n3.isSCSSNesterProperty)
          return Xk(Hk(QN(r2.value), t2));
        const i2 = e20.getParentNode();
        if (i2.raws && i2.raws.selector) {
          const e21 = Vk(i2), n4 = e21 + i2.raws.selector.length;
          return t2.originalText.slice(e21, n4).trim();
        }
        const u2 = e20.getParentNode(1);
        if (i2.type === "value-paren_group" && u2 && u2.type === "value-func" && u2.value === "selector") {
          const e21 = Vk(i2.open) + 1, n4 = Wk(i2.close) - 1, r3 = t2.originalText.slice(e21, n4).trim();
          return Rk(r3) ? [GN, r3] : r3;
        }
        return r2.value;
      }
      case "value-value":
      case "value-root":
        return n2("group");
      case "value-comment":
        return t2.originalText.slice(Vk(r2), Wk(r2));
      case "value-comma_group": {
        const t3 = e20.getParentNode(), i2 = e20.getParentNode(1), u2 = KN(e20), o2 = u2 && t3.type === "value-value" && (u2 === "grid" || u2.startsWith("grid-template")), s2 = YN(e20, "css-atrule"), a2 = s2 && ak(s2), c2 = r2.groups.some((e21) => kk(e21)), l2 = e20.map(n2, "groups"), p2 = [], f2 = ZN(e20, "url");
        let d2 = false, h2 = false;
        for (let n3 = 0; n3 < r2.groups.length; ++n3) {
          p2.push(l2[n3]);
          const u3 = r2.groups[n3 - 1], c3 = r2.groups[n3], g2 = r2.groups[n3 + 1], m2 = r2.groups[n3 + 2];
          if (f2) {
            (g2 && hk(g2) || hk(c3)) && p2.push(" ");
            continue;
          }
          if (tk(e20, "forward") && c3.type === "value-word" && c3.value && u3.type === "value-word" && u3.value === "as" && g2.type === "value-operator" && g2.value === "*")
            continue;
          if (!g2)
            continue;
          if (c3.type === "value-word" && c3.value.endsWith("-") && $k(g2))
            continue;
          const y2 = c3.type === "value-string" && c3.value.startsWith("#{"), D2 = d2 && g2.type === "value-string" && g2.value.endsWith("}");
          if (y2 || D2) {
            d2 = !d2;
            continue;
          }
          if (d2)
            continue;
          if (jk(c3) || jk(g2))
            continue;
          if (c3.type === "value-atword" && c3.value === "")
            continue;
          if (c3.value === "~")
            continue;
          if (c3.value && c3.value.includes("\\") && g2 && g2.type !== "value-comment")
            continue;
          if (u3 && u3.value && u3.value.indexOf("\\") === u3.value.length - 1 && c3.type === "value-operator" && c3.value === "/")
            continue;
          if (c3.value === "\\")
            continue;
          if (Bk(c3, g2))
            continue;
          if (Pk(c3) || Ok(c3) || Ik(g2) || Ok(g2) && vk(g2) || Ik(c3) && vk(g2))
            continue;
          if (c3.value === "--" && Pk(g2))
            continue;
          const E2 = mk(c3), C2 = mk(g2);
          if ((E2 && Pk(g2) || C2 && Ik(c3)) && vk(g2))
            continue;
          if (!u3 && dk(c3))
            continue;
          if (ZN(e20, "calc") && (hk(c3) || hk(g2) || gk(c3) || gk(g2)) && vk(g2))
            continue;
          const b2 = (hk(c3) || gk(c3)) && n3 === 0 && (g2.type === "value-number" || g2.isHex) && i2 && Mk(i2) && !vk(g2), A2 = m2 && m2.type === "value-func" || m2 && Lk(m2) || c3.type === "value-func" || Lk(c3), v2 = g2.type === "value-func" || Lk(g2) || u3 && u3.type === "value-func" || u3 && Lk(u3);
          if (fk(g2) || fk(c3) || ZN(e20, "calc") || b2 || !(dk(g2) && !A2 || dk(c3) && !v2 || hk(g2) && !A2 || hk(c3) && !v2 || gk(g2) || gk(c3)) || !(vk(g2) || E2 && (!u3 || u3 && mk(u3))))
            if (kk(c3)) {
              if (t3.type === "value-paren_group") {
                p2.push(UN(RN));
                continue;
              }
              p2.push(RN);
            } else
              a2 && (pk(g2) || lk(g2) || Ck(g2) || yk(c3) || Dk(c3)) || s2 && s2.name.toLowerCase() === "namespace" ? p2.push(" ") : o2 ? c3.source && g2.source && c3.source.start.line !== g2.source.start.line ? (p2.push(RN), h2 = true) : p2.push(" ") : C2 ? p2.push(" ") : g2 && g2.value === "..." || $k(c3) && $k(g2) && Wk(c3) === Vk(g2) || p2.push(MN);
        }
        return c2 && p2.push(GN), h2 && p2.unshift(RN), a2 ? VN(qN(p2)) : nk(e20) ? VN(WN(p2)) : VN(qN(WN(p2)));
      }
      case "value-paren_group": {
        const i2 = e20.getParentNode();
        if (i2 && Ek(i2) && (r2.groups.length === 1 || r2.groups.length > 0 && r2.groups[0].type === "value-comma_group" && r2.groups[0].groups.length > 0 && r2.groups[0].groups[0].type === "value-word" && r2.groups[0].groups[0].value.startsWith("data:")))
          return [
            r2.open ? n2("open") : "",
            _N(",", e20.map(n2, "groups")),
            r2.close ? n2("close") : ""
          ];
        if (!r2.open) {
          const t3 = e20.map(n2, "groups"), r3 = [];
          for (let e21 = 0; e21 < t3.length; e21++)
            e21 !== 0 && r3.push([",", MN]), r3.push(t3[e21]);
          return VN(qN(WN(r3)));
        }
        const u2 = Nk(e20), o2 = Ln$2(r2.groups), s2 = o2 && o2.type === "value-comment", a2 = Sk(r2, i2), c2 = VN([
          r2.open ? n2("open") : "",
          qN([
            $N,
            _N([",", MN], e20.map((e21) => {
              const t3 = e21.getValue(), r3 = n2();
              if (Fk(t3) && t3.type === "value-comma_group" && t3.groups && t3.groups[0].type !== "value-paren_group" && t3.groups[2] && t3.groups[2].type === "value-paren_group") {
                const e22 = JN(r3.contents.contents);
                return e22[1] = VN(e22[1]), VN(UN(r3));
              }
              return r3;
            }, "groups"))
          ]),
          zN(!s2 && uk(t2.parser, t2.originalText) && u2 && qk(t2) ? "," : ""),
          $N,
          r2.close ? n2("close") : ""
        ], { shouldBreak: u2 && !a2 });
        return a2 ? UN(c2) : c2;
      }
      case "value-func":
        return [
          r2.value,
          tk(e20, "supports") && _k(r2) ? " " : "",
          n2("group")
        ];
      case "value-paren":
        return r2.value;
      case "value-number":
        return [Yk(r2.value), QN(r2.unit)];
      case "value-operator":
        return r2.value;
      case "value-word":
        return r2.isColor && r2.isHex || ik(r2.value) ? r2.value.toLowerCase() : r2.value;
      case "value-colon": {
        const t3 = e20.getParentNode(), n3 = t3 && t3.groups.indexOf(r2), i2 = n3 && t3.groups[n3 - 1];
        return [
          r2.value,
          i2 && typeof i2.value == "string" && Ln$2(i2.value) === "\\" || ZN(e20, "url") ? "" : MN
        ];
      }
      case "value-comma":
        return [r2.value, " "];
      case "value-string":
        return PN(r2.raws.quote + r2.value + r2.raws.quote, t2);
      case "value-atword":
        return ["@", r2.value];
      case "value-unicode-range":
      case "value-unknown":
        return r2.value;
      default:
        throw new Error(`Unknown postcss type ${JSON.stringify(r2.type)}`);
    }
  },
  embed: uN,
  insertPragma: XN,
  massageAstNode: eN
}, Qk = { singleQuote: WB.singleQuote }, Zk = {
  name: "PostCSS",
  type: "markup",
  tmScope: "source.postcss",
  group: "CSS",
  extensions: [".pcss", ".postcss"],
  aceMode: "text",
  languageId: 262764437
}, eP = {
  name: "Less",
  type: "markup",
  color: "#1d365d",
  extensions: [".less"],
  tmScope: "source.css.less",
  aceMode: "less",
  codemirrorMode: "css",
  codemirrorMimeType: "text/css",
  languageId: 198
}, tP = {
  name: "SCSS",
  type: "markup",
  color: "#c6538c",
  tmScope: "source.css.scss",
  aceMode: "scss",
  codemirrorMode: "css",
  codemirrorMimeType: "text/x-scss",
  extensions: [".scss"],
  languageId: 329
};
var nP = {
  languages: [
    Xd({
      name: "CSS",
      type: "markup",
      tmScope: "source.css",
      aceMode: "css",
      codemirrorMode: "css",
      codemirrorMimeType: "text/css",
      color: "#563d7c",
      extensions: [".css"],
      languageId: 50
    }, (e20) => ({
      since: "1.4.0",
      parsers: ["css"],
      vscodeLanguageIds: ["css"],
      extensions: [...e20.extensions, ".wxss"]
    })),
    Xd(Zk, () => ({
      since: "1.4.0",
      parsers: ["css"],
      vscodeLanguageIds: ["postcss"]
    })),
    Xd(eP, () => ({
      since: "1.4.0",
      parsers: ["less"],
      vscodeLanguageIds: ["less"]
    })),
    Xd(tP, () => ({
      since: "1.4.0",
      parsers: ["scss"],
      vscodeLanguageIds: ["scss"]
    }))
  ],
  options: Qk,
  printers: { postcss: Kk },
  parsers: void 0
};
var rP = {
  locStart: function(e20) {
    return e20.loc.start.offset;
  },
  locEnd: function(e20) {
    return e20.loc.end.offset;
  }
};
function iP(e20, t2) {
  if (e20.type === "TextNode") {
    const n2 = e20.chars.trim();
    if (!n2)
      return null;
    t2.chars = n2.replace(/[\t\n\f\r ]+/g, " ");
  }
  e20.type === "AttrNode" && e20.name.toLowerCase() === "class" && delete t2.value;
}
iP.ignoredProperties = new Set(["loc", "selfClosing"]);
var uP = iP;
const oP = new Set([
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "menuitem",
  "meta",
  "nextid",
  "param",
  "source",
  "track",
  "wbr"
]);
function sP(e20) {
  return aP(e20, ["TextNode"]) && !/\S/.test(e20.chars);
}
function aP(e20, t2) {
  return e20 && t2.includes(e20.type);
}
function cP(e20, t2) {
  return aP(e20.getParentNode(0), t2);
}
function lP(e20, t2) {
  const n2 = e20.getValue(), r2 = e20.getParentNode(0) || {}, i2 = r2.children || r2.body || r2.parts || [], u2 = i2.indexOf(n2);
  return u2 !== -1 && i2[u2 + t2];
}
function pP(e20, t2 = 1) {
  return lP(e20, -t2);
}
function fP(e20) {
  return lP(e20, 1);
}
function dP(e20) {
  return aP(e20, ["MustacheCommentStatement"]) && typeof e20.value == "string" && e20.value.trim() === "prettier-ignore";
}
var hP = {
  getNextNode: fP,
  getPreviousNode: pP,
  hasPrettierIgnore: function(e20) {
    const t2 = e20.getValue(), n2 = pP(e20, 2);
    return dP(t2) || dP(n2);
  },
  isLastNodeOfSiblings: function(e20) {
    const t2 = e20.getValue(), n2 = e20.getParentNode(0);
    return !(!cP(e20, ["ElementNode"]) || Ln$2(n2.children) !== t2) || !(!cP(e20, ["Block"]) || Ln$2(n2.body) !== t2);
  },
  isNextNodeOfSomeType: function(e20, t2) {
    return aP(fP(e20), t2);
  },
  isNodeOfSomeType: aP,
  isParentOfSomeType: cP,
  isPreviousNodeOfSomeType: function(e20, t2) {
    return aP(pP(e20), t2);
  },
  isVoid: function(e20) {
    return function(e21) {
      return aP(e21, ["ElementNode"]) && typeof e21.tag == "string" && (function(e22) {
        return e22.toUpperCase() === e22;
      }(e21.tag[0]) || e21.tag.includes("."));
    }(e20) && e20.children.every((e21) => sP(e21)) || oP.has(e20.tag);
  },
  isWhitespaceNode: sP
};
const {
  builders: {
    dedent: gP,
    fill: mP,
    group: yP,
    hardline: DP,
    ifBreak: EP,
    indent: CP,
    join: bP,
    line: AP,
    softline: vP
  },
  utils: { getDocParts: FP, replaceTextEndOfLine: SP }
} = eu$1, { isNonEmptyArray: xP } = yi$2, { locStart: wP, locEnd: TP } = rP, {
  getNextNode: BP,
  getPreviousNode: NP,
  hasPrettierIgnore: kP,
  isLastNodeOfSiblings: PP,
  isNextNodeOfSomeType: OP,
  isNodeOfSomeType: IP,
  isParentOfSomeType: LP,
  isPreviousNodeOfSomeType: jP,
  isVoid: _P,
  isWhitespaceNode: MP
} = hP;
function RP(e20, t2) {
  return wP(e20) - wP(t2);
}
function $P(e20, t2, n2) {
  const r2 = e20.getValue().children.every((e21) => MP(e21));
  return t2.htmlWhitespaceSensitivity === "ignore" && r2 ? "" : e20.map((e21, r3) => {
    const i2 = n2();
    return r3 === 0 && t2.htmlWhitespaceSensitivity === "ignore" ? [vP, i2] : i2;
  }, "children");
}
function VP(e20) {
  return _P(e20) ? EP([vP, "/>"], [" />", vP]) : EP([vP, ">"], ">");
}
function WP(e20) {
  return [
    e20.escaped === false ? "{{{" : "{{",
    e20.strip && e20.strip.open ? "~" : ""
  ];
}
function qP(e20) {
  const t2 = e20.escaped === false ? "}}}" : "}}";
  return [e20.strip && e20.strip.close ? "~" : "", t2];
}
function UP(e20) {
  return [WP(e20), e20.closeStrip.open ? "~" : "", "/"];
}
function zP(e20) {
  const t2 = qP(e20);
  return [e20.closeStrip.close ? "~" : "", t2];
}
function GP(e20) {
  return [WP(e20), e20.inverseStrip.open ? "~" : ""];
}
function HP(e20) {
  const t2 = qP(e20);
  return [e20.inverseStrip.close ? "~" : "", t2];
}
function JP(e20, t2) {
  const n2 = e20.getValue(), r2 = function(e21) {
    return [WP(e21), e21.openStrip.open ? "~" : "", "#"];
  }(n2), i2 = function(e21) {
    const t3 = qP(e21);
    return [e21.openStrip.close ? "~" : "", t3];
  }(n2), u2 = [aO(e20, t2)], o2 = cO(e20, t2);
  if (o2 && u2.push(AP, o2), xP(n2.program.blockParams)) {
    const e21 = lO(n2.program);
    u2.push(AP, e21);
  }
  return yP([r2, CP(u2), vP, i2]);
}
function XP(e20, t2) {
  return [
    t2.htmlWhitespaceSensitivity === "ignore" ? DP : "",
    GP(e20),
    "else",
    HP(e20)
  ];
}
function YP(e20, t2) {
  const n2 = e20.getParentNode(1);
  return [GP(n2), "else if ", cO(e20, t2), HP(n2)];
}
function KP(e20, t2, n2) {
  const r2 = e20.getValue();
  if (n2.htmlWhitespaceSensitivity === "ignore") {
    return [QP(r2) ? vP : DP, UP(r2), t2("path"), zP(r2)];
  }
  return [UP(r2), t2("path"), zP(r2)];
}
function QP(e20) {
  return IP(e20, ["BlockStatement"]) && e20.program.body.every((e21) => MP(e21));
}
function ZP(e20) {
  return IP(e20, ["BlockStatement"]) && e20.inverse;
}
function eO(e20, t2, n2) {
  if (QP(e20.getValue()))
    return "";
  const r2 = t2("program");
  return n2.htmlWhitespaceSensitivity === "ignore" ? CP([DP, r2]) : CP(r2);
}
function tO(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = t2("inverse"), u2 = n2.htmlWhitespaceSensitivity === "ignore" ? [DP, i2] : i2;
  return function(e21) {
    return ZP(e21) && e21.inverse.body.length === 1 && IP(e21.inverse.body[0], ["BlockStatement"]) && e21.inverse.body[0].path.parts[0] === "if";
  }(r2) ? u2 : ZP(r2) ? [XP(r2, n2), CP(u2)] : "";
}
function nO(e20) {
  return FP(bP(AP, function(e21) {
    return e21.split(/[\t\n\f\r ]+/);
  }(e20)));
}
function rO(e20) {
  return (e20 = typeof e20 == "string" ? e20 : "").split("\n").length - 1;
}
function iO(e20 = 0) {
  return new Array(Math.min(e20, 2)).fill(DP);
}
function uO(e20, t2) {
  const n2 = { quote: '"', regex: /"/g }, r2 = { quote: "'", regex: /'/g }, i2 = e20.singleQuote ? r2 : n2, u2 = i2 === r2 ? n2 : r2;
  let o2 = false;
  if (t2.includes(i2.quote) || t2.includes(u2.quote)) {
    o2 = (t2.match(i2.regex) || []).length > (t2.match(u2.regex) || []).length;
  }
  return o2 ? u2 : i2;
}
function oO(e20, t2) {
  const n2 = aO(e20, t2), r2 = cO(e20, t2);
  return r2 ? CP([n2, AP, yP(r2)]) : n2;
}
function sO(e20, t2) {
  const n2 = aO(e20, t2), r2 = cO(e20, t2);
  return r2 ? [CP([n2, AP, r2]), vP] : n2;
}
function aO(e20, t2) {
  return t2("path");
}
function cO(e20, t2) {
  const n2 = e20.getValue(), r2 = [];
  if (n2.params.length > 0) {
    const n3 = e20.map(t2, "params");
    r2.push(...n3);
  }
  if (n2.hash && n2.hash.pairs.length > 0) {
    const e21 = t2("hash");
    r2.push(e21);
  }
  return r2.length === 0 ? "" : bP(AP, r2);
}
function lO(e20) {
  return ["as |", e20.blockParams.join(" "), "|"];
}
var pO = {
  print: function(e20, t2, n2) {
    const r2 = e20.getValue();
    if (!r2)
      return "";
    if (kP(e20))
      return t2.originalText.slice(wP(r2), TP(r2));
    switch (r2.type) {
      case "Block":
      case "Program":
      case "Template":
        return yP(e20.map(n2, "body"));
      case "ElementNode": {
        const i2 = yP(function(e21, t3) {
          const n3 = e21.getValue(), r3 = [
            "attributes",
            "modifiers",
            "comments"
          ].filter((e22) => xP(n3[e22])), i3 = r3.flatMap((e22) => n3[e22]).sort(RP);
          for (const n4 of r3)
            e21.each((e22) => {
              const n5 = i3.indexOf(e22.getValue());
              i3.splice(n5, 1, [AP, t3()]);
            }, n4);
          xP(n3.blockParams) && i3.push(AP, lO(n3));
          return ["<", n3.tag, CP(i3), VP(n3)];
        }(e20, n2)), u2 = t2.htmlWhitespaceSensitivity === "ignore" && OP(e20, ["ElementNode"]) ? vP : "";
        if (_P(r2))
          return [i2, u2];
        const o2 = ["</", r2.tag, ">"];
        return r2.children.length === 0 ? [i2, CP(o2), u2] : t2.htmlWhitespaceSensitivity === "ignore" ? [i2, CP($P(e20, t2, n2)), DP, CP(o2), u2] : [i2, CP(yP($P(e20, t2, n2))), CP(o2), u2];
      }
      case "BlockStatement": {
        const i2 = e20.getParentNode(1);
        return i2 && i2.inverse && i2.inverse.body.length === 1 && i2.inverse.body[0] === r2 && i2.inverse.body[0].path.parts[0] === "if" ? [YP(e20, n2), eO(e20, n2, t2), tO(e20, n2, t2)] : [JP(e20, n2), yP([eO(e20, n2, t2), tO(e20, n2, t2), KP(e20, n2, t2)])];
      }
      case "ElementModifierStatement":
        return yP(["{{", sO(e20, n2), "}}"]);
      case "MustacheStatement":
        return yP([WP(r2), sO(e20, n2), qP(r2)]);
      case "SubExpression":
        return yP(["(", oO(e20, n2), vP, ")"]);
      case "AttrNode": {
        const e21 = r2.value.type === "TextNode";
        if (e21 && r2.value.chars === "" && wP(r2.value) === TP(r2.value))
          return r2.name;
        const i2 = e21 ? uO(t2, r2.value.chars).quote : r2.value.type === "ConcatStatement" ? uO(t2, r2.value.parts.filter((e22) => e22.type === "TextNode").map((e22) => e22.chars).join("")).quote : "", u2 = n2("value");
        return [
          r2.name,
          "=",
          i2,
          r2.name === "class" && i2 ? yP(CP(u2)) : u2,
          i2
        ];
      }
      case "ConcatStatement":
        return e20.map(n2, "parts");
      case "Hash":
        return bP(AP, e20.map(n2, "pairs"));
      case "HashPair":
        return [r2.key, "=", n2("value")];
      case "TextNode": {
        let n3 = r2.chars.replace(/{{/g, "\\{{");
        const i2 = function(e21) {
          for (let t3 = 0; t3 < 2; t3++) {
            const n4 = e21.getParentNode(t3);
            if (n4 && n4.type === "AttrNode")
              return n4.name.toLowerCase();
          }
        }(e20);
        if (i2) {
          if (i2 === "class") {
            const t3 = n3.trim().split(/\s+/).join(" ");
            let r3 = false, i3 = false;
            return LP(e20, ["ConcatStatement"]) && (jP(e20, ["MustacheStatement"]) && /^\s/.test(n3) && (r3 = true), OP(e20, ["MustacheStatement"]) && /\s$/.test(n3) && t3 !== "" && (i3 = true)), [r3 ? AP : "", t3, i3 ? AP : ""];
          }
          return SP(n3);
        }
        const u2 = /^[\t\n\f\r ]*$/.test(n3), o2 = !NP(e20), s2 = !BP(e20);
        if (t2.htmlWhitespaceSensitivity !== "ignore") {
          const t3 = /^[\t\n\f\r ]*/, r3 = /[\t\n\f\r ]*$/, i3 = s2 && LP(e20, ["Template"]), a3 = o2 && LP(e20, ["Template"]);
          if (u2) {
            if (a3 || i3)
              return "";
            let t4 = [AP];
            const r4 = rO(n3);
            return r4 && (t4 = iO(r4)), PP(e20) && (t4 = t4.map((e21) => gP(e21))), t4;
          }
          const [c3] = n3.match(t3), [l3] = n3.match(r3);
          let p3 = [];
          if (c3) {
            p3 = [AP];
            const e21 = rO(c3);
            e21 && (p3 = iO(e21)), n3 = n3.replace(t3, "");
          }
          let f3 = [];
          if (l3) {
            if (!i3) {
              f3 = [AP];
              const t4 = rO(l3);
              t4 && (f3 = iO(t4)), PP(e20) && (f3 = f3.map((e21) => gP(e21)));
            }
            n3 = n3.replace(r3, "");
          }
          return [...p3, mP(nO(n3)), ...f3];
        }
        const a2 = rO(n3);
        let c2 = function(e21) {
          return rO(((e21 = typeof e21 == "string" ? e21 : "").match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "");
        }(n3), l2 = function(e21) {
          return rO(((e21 = typeof e21 == "string" ? e21 : "").match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "");
        }(n3);
        if ((o2 || s2) && u2 && LP(e20, ["Block", "ElementNode", "Template"]))
          return "";
        u2 && a2 ? (c2 = Math.min(a2, 2), l2 = 0) : (OP(e20, ["BlockStatement", "ElementNode"]) && (l2 = Math.max(l2, 1)), jP(e20, ["BlockStatement", "ElementNode"]) && (c2 = Math.max(c2, 1)));
        let p2 = "", f2 = "";
        return l2 === 0 && OP(e20, ["MustacheStatement"]) && (f2 = " "), c2 === 0 && jP(e20, ["MustacheStatement"]) && (p2 = " "), o2 && (c2 = 0, p2 = ""), s2 && (l2 = 0, f2 = ""), n3 = n3.replace(/^[\t\n\f\r ]+/g, p2).replace(/[\t\n\f\r ]+$/, f2), [...iO(c2), mP(nO(n3)), ...iO(l2)];
      }
      case "MustacheCommentStatement": {
        const e21 = wP(r2), n3 = TP(r2), i2 = t2.originalText.charAt(e21 + 2) === "~", u2 = t2.originalText.charAt(n3 - 3) === "~", o2 = r2.value.includes("}}") ? "--" : "";
        return [
          "{{",
          i2 ? "~" : "",
          "!",
          o2,
          r2.value,
          o2,
          u2 ? "~" : "",
          "}}"
        ];
      }
      case "PathExpression":
        return r2.original;
      case "BooleanLiteral":
        return String(r2.value);
      case "CommentStatement":
        return ["<!--", r2.value, "-->"];
      case "StringLiteral":
        return function(e21, t3) {
          const { quote: n3, regex: r3 } = uO(t3, e21);
          return [n3, e21.replace(r3, `\\${n3}`), n3];
        }(r2.value, t2);
      case "NumberLiteral":
        return String(r2.value);
      case "UndefinedLiteral":
        return "undefined";
      case "NullLiteral":
        return "null";
      default:
        throw new Error("unknown glimmer type: " + JSON.stringify(r2.type));
    }
  },
  massageAstNode: uP
};
var fO = {
  languages: [
    Xd({
      name: "Handlebars",
      type: "markup",
      color: "#f7931e",
      aliases: ["hbs", "htmlbars"],
      extensions: [".handlebars", ".hbs"],
      tmScope: "text.html.handlebars",
      aceMode: "handlebars",
      languageId: 155
    }, () => ({
      since: "2.3.0",
      parsers: ["glimmer"],
      vscodeLanguageIds: ["handlebars"]
    }))
  ],
  printers: { glimmer: pO },
  parsers: void 0
};
var dO = {
  hasPragma: function(e20) {
    return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(e20);
  },
  insertPragma: function(e20) {
    return "# @format\n\n" + e20;
  }
};
var hO = {
  locStart: function(e20) {
    return typeof e20.start == "number" ? e20.start : e20.loc && e20.loc.start;
  },
  locEnd: function(e20) {
    return typeof e20.end == "number" ? e20.end : e20.loc && e20.loc.end;
  }
};
const {
  builders: {
    join: gO,
    hardline: mO,
    line: yO,
    softline: DO,
    group: EO,
    indent: CO,
    ifBreak: bO
  }
} = eu$1, { isNextLineEmpty: AO, isNonEmptyArray: vO } = yi$2, { insertPragma: FO } = dO, { locStart: SO, locEnd: xO } = hO;
function wO(e20, t2, n2) {
  if (n2.directives.length === 0)
    return "";
  const r2 = gO(yO, e20.map(t2, "directives"));
  return n2.kind === "FragmentDefinition" || n2.kind === "OperationDefinition" ? EO([yO, r2]) : [" ", EO(CO([DO, r2]))];
}
function TO(e20, t2, n2) {
  const r2 = e20.getValue().length;
  return e20.map((e21, i2) => {
    const u2 = n2();
    return AO(t2.originalText, e21.getValue(), xO) && i2 < r2 - 1 ? [u2, mO] : u2;
  });
}
function BO(e20, t2, n2) {
  const r2 = e20.getNode(), i2 = [], { interfaces: u2 } = r2, o2 = e20.map((e21) => n2(e21), "interfaces");
  for (let e21 = 0; e21 < u2.length; e21++) {
    const n3 = u2[e21];
    i2.push(o2[e21]);
    const r3 = u2[e21 + 1];
    if (r3) {
      const e22 = t2.originalText.slice(n3.loc.end, r3.loc.start), u3 = e22.includes("#"), o3 = e22.replace(/#.*/g, "").trim();
      i2.push(o3 === "," ? "," : " &", u3 ? yO : " ");
    }
  }
  return i2;
}
function NO() {
}
NO.ignoredProperties = new Set(["loc", "comments"]);
var kO = {
  print: function(e20, t2, n2) {
    const r2 = e20.getValue();
    if (!r2)
      return "";
    if (typeof r2 == "string")
      return r2;
    switch (r2.kind) {
      case "Document": {
        const r3 = [];
        return e20.each((e21, i2, u2) => {
          r3.push(n2()), i2 !== u2.length - 1 && (r3.push(mO), AO(t2.originalText, e21.getValue(), xO) && r3.push(mO));
        }, "definitions"), [...r3, mO];
      }
      case "OperationDefinition": {
        const i2 = t2.originalText[SO(r2)] !== "{", u2 = Boolean(r2.name);
        return [
          i2 ? r2.operation : "",
          i2 && u2 ? [" ", n2("name")] : "",
          i2 && !u2 && vO(r2.variableDefinitions) ? " " : "",
          vO(r2.variableDefinitions) ? EO([
            "(",
            CO([
              DO,
              gO([bO("", ", "), DO], e20.map(n2, "variableDefinitions"))
            ]),
            DO,
            ")"
          ]) : "",
          wO(e20, n2, r2),
          r2.selectionSet && (i2 || u2) ? " " : "",
          n2("selectionSet")
        ];
      }
      case "FragmentDefinition":
        return [
          "fragment ",
          n2("name"),
          vO(r2.variableDefinitions) ? EO([
            "(",
            CO([
              DO,
              gO([bO("", ", "), DO], e20.map(n2, "variableDefinitions"))
            ]),
            DO,
            ")"
          ]) : "",
          " on ",
          n2("typeCondition"),
          wO(e20, n2, r2),
          " ",
          n2("selectionSet")
        ];
      case "SelectionSet":
        return [
          "{",
          CO([
            mO,
            gO(mO, e20.call((e21) => TO(e21, t2, n2), "selections"))
          ]),
          mO,
          "}"
        ];
      case "Field":
        return EO([
          r2.alias ? [n2("alias"), ": "] : "",
          n2("name"),
          r2.arguments.length > 0 ? EO([
            "(",
            CO([
              DO,
              gO([bO("", ", "), DO], e20.call((e21) => TO(e21, t2, n2), "arguments"))
            ]),
            DO,
            ")"
          ]) : "",
          wO(e20, n2, r2),
          r2.selectionSet ? " " : "",
          n2("selectionSet")
        ]);
      case "Name":
        return r2.value;
      case "StringValue":
        return r2.block ? [
          '"""',
          mO,
          gO(mO, r2.value.replace(/"""/g, "\\$&").split("\n")),
          mO,
          '"""'
        ] : [
          '"',
          r2.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"),
          '"'
        ];
      case "IntValue":
      case "FloatValue":
      case "EnumValue":
        return r2.value;
      case "BooleanValue":
        return r2.value ? "true" : "false";
      case "NullValue":
        return "null";
      case "Variable":
        return ["$", n2("name")];
      case "ListValue":
        return EO([
          "[",
          CO([DO, gO([bO("", ", "), DO], e20.map(n2, "values"))]),
          DO,
          "]"
        ]);
      case "ObjectValue":
        return EO([
          "{",
          t2.bracketSpacing && r2.fields.length > 0 ? " " : "",
          CO([DO, gO([bO("", ", "), DO], e20.map(n2, "fields"))]),
          DO,
          bO("", t2.bracketSpacing && r2.fields.length > 0 ? " " : ""),
          "}"
        ]);
      case "ObjectField":
      case "Argument":
        return [n2("name"), ": ", n2("value")];
      case "Directive":
        return [
          "@",
          n2("name"),
          r2.arguments.length > 0 ? EO([
            "(",
            CO([
              DO,
              gO([bO("", ", "), DO], e20.call((e21) => TO(e21, t2, n2), "arguments"))
            ]),
            DO,
            ")"
          ]) : ""
        ];
      case "NamedType":
        return n2("name");
      case "VariableDefinition":
        return [
          n2("variable"),
          ": ",
          n2("type"),
          r2.defaultValue ? [" = ", n2("defaultValue")] : "",
          wO(e20, n2, r2)
        ];
      case "ObjectTypeExtension":
      case "ObjectTypeDefinition":
        return [
          n2("description"),
          r2.description ? mO : "",
          r2.kind === "ObjectTypeExtension" ? "extend " : "",
          "type ",
          n2("name"),
          r2.interfaces.length > 0 ? [" implements ", ...BO(e20, t2, n2)] : "",
          wO(e20, n2, r2),
          r2.fields.length > 0 ? [
            " {",
            CO([
              mO,
              gO(mO, e20.call((e21) => TO(e21, t2, n2), "fields"))
            ]),
            mO,
            "}"
          ] : ""
        ];
      case "FieldDefinition":
        return [
          n2("description"),
          r2.description ? mO : "",
          n2("name"),
          r2.arguments.length > 0 ? EO([
            "(",
            CO([
              DO,
              gO([bO("", ", "), DO], e20.call((e21) => TO(e21, t2, n2), "arguments"))
            ]),
            DO,
            ")"
          ]) : "",
          ": ",
          n2("type"),
          wO(e20, n2, r2)
        ];
      case "DirectiveDefinition":
        return [
          n2("description"),
          r2.description ? mO : "",
          "directive ",
          "@",
          n2("name"),
          r2.arguments.length > 0 ? EO([
            "(",
            CO([
              DO,
              gO([bO("", ", "), DO], e20.call((e21) => TO(e21, t2, n2), "arguments"))
            ]),
            DO,
            ")"
          ]) : "",
          r2.repeatable ? " repeatable" : "",
          " on ",
          gO(" | ", e20.map(n2, "locations"))
        ];
      case "EnumTypeExtension":
      case "EnumTypeDefinition":
        return [
          n2("description"),
          r2.description ? mO : "",
          r2.kind === "EnumTypeExtension" ? "extend " : "",
          "enum ",
          n2("name"),
          wO(e20, n2, r2),
          r2.values.length > 0 ? [
            " {",
            CO([
              mO,
              gO(mO, e20.call((e21) => TO(e21, t2, n2), "values"))
            ]),
            mO,
            "}"
          ] : ""
        ];
      case "EnumValueDefinition":
        return [
          n2("description"),
          r2.description ? mO : "",
          n2("name"),
          wO(e20, n2, r2)
        ];
      case "InputValueDefinition":
        return [
          n2("description"),
          r2.description ? r2.description.block ? mO : yO : "",
          n2("name"),
          ": ",
          n2("type"),
          r2.defaultValue ? [" = ", n2("defaultValue")] : "",
          wO(e20, n2, r2)
        ];
      case "InputObjectTypeExtension":
      case "InputObjectTypeDefinition":
        return [
          n2("description"),
          r2.description ? mO : "",
          r2.kind === "InputObjectTypeExtension" ? "extend " : "",
          "input ",
          n2("name"),
          wO(e20, n2, r2),
          r2.fields.length > 0 ? [
            " {",
            CO([
              mO,
              gO(mO, e20.call((e21) => TO(e21, t2, n2), "fields"))
            ]),
            mO,
            "}"
          ] : ""
        ];
      case "SchemaDefinition":
        return [
          "schema",
          wO(e20, n2, r2),
          " {",
          r2.operationTypes.length > 0 ? CO([
            mO,
            gO(mO, e20.call((e21) => TO(e21, t2, n2), "operationTypes"))
          ]) : "",
          mO,
          "}"
        ];
      case "OperationTypeDefinition":
        return [n2("operation"), ": ", n2("type")];
      case "InterfaceTypeExtension":
      case "InterfaceTypeDefinition":
        return [
          n2("description"),
          r2.description ? mO : "",
          r2.kind === "InterfaceTypeExtension" ? "extend " : "",
          "interface ",
          n2("name"),
          r2.interfaces.length > 0 ? [" implements ", ...BO(e20, t2, n2)] : "",
          wO(e20, n2, r2),
          r2.fields.length > 0 ? [
            " {",
            CO([
              mO,
              gO(mO, e20.call((e21) => TO(e21, t2, n2), "fields"))
            ]),
            mO,
            "}"
          ] : ""
        ];
      case "FragmentSpread":
        return ["...", n2("name"), wO(e20, n2, r2)];
      case "InlineFragment":
        return [
          "...",
          r2.typeCondition ? [" on ", n2("typeCondition")] : "",
          wO(e20, n2, r2),
          " ",
          n2("selectionSet")
        ];
      case "UnionTypeExtension":
      case "UnionTypeDefinition":
        return EO([
          n2("description"),
          r2.description ? mO : "",
          EO([
            r2.kind === "UnionTypeExtension" ? "extend " : "",
            "union ",
            n2("name"),
            wO(e20, n2, r2),
            r2.types.length > 0 ? [
              " =",
              bO("", " "),
              CO([
                bO([yO, "  "]),
                gO([yO, "| "], e20.map(n2, "types"))
              ])
            ] : ""
          ])
        ]);
      case "ScalarTypeExtension":
      case "ScalarTypeDefinition":
        return [
          n2("description"),
          r2.description ? mO : "",
          r2.kind === "ScalarTypeExtension" ? "extend " : "",
          "scalar ",
          n2("name"),
          wO(e20, n2, r2)
        ];
      case "NonNullType":
        return [n2("type"), "!"];
      case "ListType":
        return ["[", n2("type"), "]"];
      default:
        throw new Error("unknown graphql type: " + JSON.stringify(r2.kind));
    }
  },
  massageAstNode: NO,
  hasPrettierIgnore: function(e20) {
    const t2 = e20.getValue();
    return t2 && Array.isArray(t2.comments) && t2.comments.some((e21) => e21.value.trim() === "prettier-ignore");
  },
  insertPragma: FO,
  printComment: function(e20) {
    const t2 = e20.getValue();
    if (t2.kind === "Comment")
      return "#" + t2.value.trimEnd();
    throw new Error("Not a comment: " + JSON.stringify(t2));
  },
  canAttachComment: function(e20) {
    return e20.kind && e20.kind !== "Comment";
  }
}, PO = { bracketSpacing: WB.bracketSpacing };
var OO = {
  languages: [
    Xd({
      name: "GraphQL",
      type: "data",
      color: "#e10098",
      extensions: [".graphql", ".gql", ".graphqls"],
      tmScope: "source.graphql",
      aceMode: "text",
      languageId: 139
    }, () => ({
      since: "1.5.0",
      parsers: ["graphql"],
      vscodeLanguageIds: ["graphql"]
    }))
  ],
  options: PO,
  printers: { graphql: kO },
  parsers: void 0
};
var IO = {
  locStart: function(e20) {
    return e20.position.start.offset;
  },
  locEnd: function(e20) {
    return e20.position.end.offset;
  }
};
const { getLast: LO } = yi$2, { locStart: jO, locEnd: _O } = IO, {
  cjkPattern: MO,
  kPattern: RO,
  punctuationPattern: $O
} = {
  cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?",
  kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]",
  punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]"
}, VO = [
  "liquidNode",
  "inlineCode",
  "emphasis",
  "strong",
  "delete",
  "wikiLink",
  "link",
  "linkReference",
  "image",
  "imageReference",
  "footnote",
  "footnoteReference",
  "sentence",
  "whitespace",
  "word",
  "break",
  "inlineMath"
], WO = [...VO, "tableCell", "paragraph", "heading"], qO = new RegExp(RO), UO = new RegExp($O);
function zO(e20, t2) {
  const [, n2, r2, i2] = t2.slice(e20.position.start.offset, e20.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
  return { numberText: n2, marker: r2, leadingSpaces: i2 };
}
var GO = {
  mapAst: function(e20, t2) {
    return function e21(n2, r2, i2) {
      const u2 = Object.assign({}, t2(n2, r2, i2));
      return u2.children && (u2.children = u2.children.map((t3, n3) => e21(t3, n3, [u2, ...i2]))), u2;
    }(e20, null, []);
  },
  splitText: function(e20, t2) {
    const n2 = "non-cjk", r2 = "cj-letter", i2 = "cjk-punctuation", u2 = [], o2 = (t2.proseWrap === "preserve" ? e20 : e20.replace(new RegExp(`(${MO})
(${MO})`, "g"), "$1$2")).split(/([\t\n ]+)/);
    for (const [e21, t3] of o2.entries()) {
      if (e21 % 2 == 1) {
        u2.push({
          type: "whitespace",
          value: /\n/.test(t3) ? "\n" : " "
        });
        continue;
      }
      if ((e21 === 0 || e21 === o2.length - 1) && t3 === "")
        continue;
      const a2 = t3.split(new RegExp(`(${MO})`));
      for (const [e22, t4] of a2.entries())
        (e22 !== 0 && e22 !== a2.length - 1 || t4 !== "") && (e22 % 2 != 0 ? s2(UO.test(t4) ? {
          type: "word",
          value: t4,
          kind: i2,
          hasLeadingPunctuation: true,
          hasTrailingPunctuation: true
        } : {
          type: "word",
          value: t4,
          kind: qO.test(t4) ? "k-letter" : r2,
          hasLeadingPunctuation: false,
          hasTrailingPunctuation: false
        }) : t4 !== "" && s2({
          type: "word",
          value: t4,
          kind: n2,
          hasLeadingPunctuation: UO.test(t4[0]),
          hasTrailingPunctuation: UO.test(LO(t4))
        }));
    }
    return u2;
    function s2(e21) {
      const t3 = LO(u2);
      var o3, s3;
      t3 && t3.type === "word" && (t3.kind === n2 && e21.kind === r2 && !t3.hasTrailingPunctuation || t3.kind === r2 && e21.kind === n2 && !e21.hasLeadingPunctuation ? u2.push({ type: "whitespace", value: " " }) : (o3 = n2, s3 = i2, t3.kind === o3 && e21.kind === s3 || t3.kind === s3 && e21.kind === o3 || [t3.value, e21.value].some((e22) => /\u3000/.test(e22)) || u2.push({ type: "whitespace", value: "" }))), u2.push(e21);
    }
  },
  punctuationPattern: $O,
  getFencedCodeBlockValue: function(e20, t2) {
    const { value: n2 } = e20;
    return e20.position.end.offset === t2.length && n2.endsWith("\n") && t2.endsWith("\n") ? n2.slice(0, -1) : n2;
  },
  getOrderedListItemInfo: zO,
  hasGitDiffFriendlyOrderedList: function(e20, t2) {
    if (!e20.ordered)
      return false;
    if (e20.children.length < 2)
      return false;
    const n2 = Number(zO(e20.children[0], t2.originalText).numberText), r2 = Number(zO(e20.children[1], t2.originalText).numberText);
    if (n2 === 0 && e20.children.length > 2) {
      const n3 = Number(zO(e20.children[2], t2.originalText).numberText);
      return r2 === 1 && n3 === 1;
    }
    return r2 === 1;
  },
  INLINE_NODE_TYPES: VO,
  INLINE_NODE_WRAPPER_TYPES: WO,
  isAutolink: function(e20) {
    if (!e20 || e20.type !== "link" || e20.children.length !== 1)
      return false;
    const t2 = e20.children[0];
    return t2 && jO(e20) === jO(t2) && _O(e20) === _O(t2);
  }
};
const { inferParserByLanguage: HO, getMaxContinuousCount: JO } = yi$2, {
  builders: { hardline: XO, markAsRoot: YO },
  utils: { replaceEndOfLine: KO }
} = eu$1, { getFencedCodeBlockValue: QO } = GO;
var ZO = function(e20, t2, n2, r2) {
  const i2 = e20.getValue();
  if (i2.type === "code" && i2.lang !== null) {
    const e21 = HO(i2.lang, r2);
    if (e21) {
      const t3 = r2.__inJsTemplate ? "~" : "`", u2 = t3.repeat(Math.max(3, JO(i2.value, t3) + 1)), o2 = n2(QO(i2, r2.originalText), { parser: e21 }, { stripTrailingHardline: true });
      return YO([
        u2,
        i2.lang,
        i2.meta ? " " + i2.meta : "",
        XO,
        KO(o2),
        XO,
        u2
      ]);
    }
  }
  switch (i2.type) {
    case "front-matter":
      return rN(i2, n2);
    case "importExport":
      return [
        n2(i2.value, { parser: "babel" }, { stripTrailingHardline: true }),
        XO
      ];
    case "jsx":
      return n2(`<$>${i2.value}</$>`, { parser: "__js_expression", rootMarker: "mdx" }, { stripTrailingHardline: true });
  }
  return null;
};
const eI = ["format", "prettier"];
function tI(e20) {
  const t2 = `@(${eI.join("|")})`, n2 = new RegExp([
    `<!--\\s*${t2}\\s*-->`,
    `<!--.*\r?
[\\s\\S]*(^|
)[^\\S
]*${t2}[^\\S
]*($|
)[\\s\\S]*
.*-->`
  ].join("|"), "m"), r2 = e20.match(n2);
  return r2 && r2.index === 0;
}
var nI = {
  startWithPragma: tI,
  hasPragma: (e20) => tI(sN(e20).content.trimStart()),
  insertPragma: (e20) => {
    const t2 = sN(e20), n2 = `<!-- @${eI[0]} -->`;
    return t2.frontMatter ? `${t2.frontMatter.raw}

${n2}

${t2.content}` : `${n2}

${t2.content}`;
  }
};
const { getOrderedListItemInfo: rI, mapAst: iI, splitText: uI } = GO, oI = /^.$/su;
function sI(e20, t2, n2) {
  return iI(e20, (e21) => {
    if (!e21.children)
      return e21;
    const r2 = e21.children.reduce((e22, r3) => {
      const i2 = Ln$2(e22);
      return i2 && t2(i2, r3) ? e22.splice(-1, 1, n2(i2, r3)) : e22.push(r3), e22;
    }, []);
    return Object.assign(Object.assign({}, e21), {}, { children: r2 });
  });
}
var aI = function(e20, t2) {
  return e20 = function(e21) {
    return sI(e21, (e22, t3) => e22.type === "importExport" && t3.type === "importExport", (e22, t3) => ({
      type: "importExport",
      value: e22.value + "\n\n" + t3.value,
      position: { start: e22.position.start, end: t3.position.end }
    }));
  }(e20 = function(e21) {
    return iI(e21, (e22) => e22.type !== "import" && e22.type !== "export" ? e22 : Object.assign(Object.assign({}, e22), {}, { type: "importExport" }));
  }(e20 = function(e21, t3) {
    return iI(e21, (e22, n2, [r2]) => {
      if (e22.type !== "text")
        return e22;
      let { value: i2 } = e22;
      return r2.type === "paragraph" && (n2 === 0 && (i2 = i2.trimStart()), n2 === r2.children.length - 1 && (i2 = i2.trimEnd())), {
        type: "sentence",
        position: e22.position,
        children: uI(i2, t3)
      };
    });
  }(e20 = function(e21, t3) {
    return iI(e21, (e22, t4, n3) => {
      if (e22.type === "list" && e22.children.length > 0) {
        for (let t5 = 0; t5 < n3.length; t5++) {
          const r3 = n3[t5];
          if (r3.type === "list" && !r3.isAligned)
            return e22.isAligned = false, e22;
        }
        e22.isAligned = r2(e22);
      }
      return e22;
    });
    function n2(e22) {
      return e22.children.length === 0 ? -1 : e22.children[0].position.start.column - 1;
    }
    function r2(e22) {
      if (!e22.ordered)
        return true;
      const [r3, i2] = e22.children;
      if (rI(r3, t3.originalText).leadingSpaces.length > 1)
        return true;
      const u2 = n2(r3);
      if (u2 === -1)
        return false;
      if (e22.children.length === 1)
        return u2 % t3.tabWidth == 0;
      if (u2 !== n2(i2))
        return false;
      if (u2 % t3.tabWidth == 0)
        return true;
      return rI(i2, t3.originalText).leadingSpaces.length > 1;
    }
  }(e20 = function(e21, t3) {
    return iI(e21, (e22, n2, r2) => {
      if (e22.type === "code") {
        const n3 = /^\n?(?: {4,}|\t)/.test(t3.originalText.slice(e22.position.start.offset, e22.position.end.offset));
        if (e22.isIndented = n3, n3)
          for (let e23 = 0; e23 < r2.length; e23++) {
            const t4 = r2[e23];
            if (t4.hasIndentedCodeblock)
              break;
            t4.type === "list" && (t4.hasIndentedCodeblock = true);
          }
      }
      return e22;
    });
  }(e20 = function(e21) {
    return iI(e21, (e22) => e22.type !== "inlineCode" ? e22 : Object.assign(Object.assign({}, e22), {}, {
      value: e22.value.replace(/\s+/g, " ")
    }));
  }(e20 = function(e21) {
    return sI(e21, (e22, t3) => e22.type === "text" && t3.type === "text", (e22, t3) => ({
      type: "text",
      value: e22.value + t3.value,
      position: {
        start: e22.position.start,
        end: t3.position.end
      }
    }));
  }(e20 = function(e21, t3) {
    return iI(e21, (e22) => e22.type === "text" && e22.value !== "*" && e22.value !== "_" && oI.test(e22.value) && e22.position.end.offset - e22.position.start.offset !== e22.value.length ? Object.assign(Object.assign({}, e22), {}, {
      value: t3.originalText.slice(e22.position.start.offset, e22.position.end.offset)
    }) : e22);
  }(e20, t2))), t2), t2), t2)));
};
const { isFrontMatterNode: cI } = yi$2, { startWithPragma: lI } = nI, pI = new Set(["position", "raw"]);
function fI(e20, t2, n2) {
  return e20.type !== "front-matter" && e20.type !== "code" && e20.type !== "yaml" && e20.type !== "import" && e20.type !== "export" && e20.type !== "jsx" || delete t2.value, e20.type === "list" && delete t2.isAligned, e20.type !== "list" && e20.type !== "listItem" || (delete t2.spread, delete t2.loose), e20.type === "text" ? null : (e20.type === "inlineCode" && (t2.value = e20.value.replace(/[\t\n ]+/g, " ")), e20.type === "wikiLink" && (t2.value = e20.value.trim().replace(/[\t\n]+/g, " ")), e20.type !== "definition" && e20.type !== "linkReference" || (t2.label = e20.label.trim().replace(/[\t\n ]+/g, " ").toLowerCase()), e20.type !== "definition" && e20.type !== "link" && e20.type !== "image" || !e20.title || (t2.title = e20.title.replace(/\\(["')])/g, "$1")), n2 && n2.type === "root" && n2.children.length > 0 && (n2.children[0] === e20 || cI(n2.children[0]) && n2.children[1] === e20) && e20.type === "html" && lI(e20.value) ? null : void 0);
}
fI.ignoredProperties = pI;
var dI = fI;
const {
  getLast: hI,
  getMinNotPresentContinuousCount: gI,
  getMaxContinuousCount: mI,
  getStringWidth: yI,
  isNonEmptyArray: DI
} = yi$2, {
  builders: {
    breakParent: EI,
    join: CI,
    line: bI,
    literalline: AI,
    markAsRoot: vI,
    hardline: FI,
    softline: SI,
    ifBreak: xI,
    fill: wI,
    align: TI,
    indent: BI,
    group: NI,
    hardlineWithoutBreakParent: kI
  },
  utils: { normalizeDoc: PI, replaceTextEndOfLine: OI },
  printer: { printDocToString: II }
} = eu$1, { insertPragma: LI } = nI, { locStart: jI, locEnd: _I } = IO, {
  getFencedCodeBlockValue: MI,
  hasGitDiffFriendlyOrderedList: RI,
  splitText: $I,
  punctuationPattern: VI,
  INLINE_NODE_TYPES: WI,
  INLINE_NODE_WRAPPER_TYPES: qI,
  isAutolink: UI
} = GO, zI = new Set(["importExport"]), GI = ["heading", "tableCell", "link", "wikiLink"], HI = new Set(["listItem", "definition", "footnoteDefinition"]);
function JI(e20, t2, n2, r2) {
  const i2 = e20.getValue(), u2 = i2.checked === null ? "" : i2.checked ? "[x] " : "[ ] ";
  return [
    u2,
    eL(e20, t2, n2, {
      processor: (e21, i3) => {
        if (i3 === 0 && e21.getValue().type !== "list")
          return TI(" ".repeat(u2.length), n2());
        const o2 = " ".repeat(function(e22, t3, n3) {
          return e22 < t3 ? t3 : e22 > n3 ? n3 : e22;
        }(t2.tabWidth - r2.length, 0, 3));
        return [o2, TI(o2, n2())];
      }
    })
  ];
}
function XI(e20, t2) {
  return function(e21, t3, n2) {
    let r2 = -1;
    for (const i2 of t3.children)
      if (i2.type === e21.type && n2(i2) ? r2++ : r2 = -1, i2 === e21)
        return r2;
  }(e20, t2, (t3) => t3.ordered === e20.ordered);
}
function YI(e20, t2) {
  const n2 = Array.isArray(t2) ? t2 : [t2];
  let r2, i2 = -1;
  for (; r2 = e20.getParentNode(++i2); )
    if (n2.includes(r2.type))
      return i2;
  return -1;
}
function KI(e20, t2) {
  const n2 = YI(e20, t2);
  return n2 === -1 ? null : e20.getParentNode(n2);
}
function QI(e20, t2, n2) {
  if (n2.proseWrap === "preserve" && t2 === "\n")
    return FI;
  const r2 = n2.proseWrap === "always" && !KI(e20, GI);
  return t2 !== "" ? r2 ? bI : " " : r2 ? SI : "";
}
function ZI(e20, t2, n2) {
  const r2 = [];
  let i2 = null;
  const { children: u2 } = e20.getValue();
  for (const [e21, t3] of u2.entries())
    switch (nL(t3)) {
      case "start":
        i2 === null && (i2 = { index: e21, offset: t3.position.end.offset });
        break;
      case "end":
        i2 !== null && (r2.push({
          start: i2,
          end: { index: e21, offset: t3.position.start.offset }
        }), i2 = null);
    }
  return eL(e20, t2, n2, {
    processor: (e21, i3) => {
      if (r2.length > 0) {
        const e22 = r2[0];
        if (i3 === e22.start.index)
          return [
            u2[e22.start.index].value,
            t2.originalText.slice(e22.start.offset, e22.end.offset),
            u2[e22.end.index].value
          ];
        if (e22.start.index < i3 && i3 < e22.end.index)
          return false;
        if (i3 === e22.end.index)
          return r2.shift(), false;
      }
      return n2();
    }
  });
}
function eL(e20, t2, n2, r2 = {}) {
  const { postprocessor: i2 } = r2, u2 = r2.processor || (() => n2()), o2 = e20.getValue(), s2 = [];
  let a2;
  return e20.each((e21, n3) => {
    const r3 = e21.getValue(), i3 = u2(e21, n3);
    if (i3 !== false) {
      const e22 = { parts: s2, prevNode: a2, parentNode: o2, options: t2 };
      (function(e23, t3) {
        const n4 = t3.parts.length === 0, r4 = WI.includes(e23.type), i4 = e23.type === "html" && qI.includes(t3.parentNode.type);
        return !n4 && !r4 && !i4;
      })(r3, e22) && (s2.push(FI), a2 && zI.has(a2.type) || (function(e23, t3) {
        const n4 = (t3.prevNode && t3.prevNode.type) === e23.type && HI.has(e23.type), r4 = t3.parentNode.type === "listItem" && !t3.parentNode.loose, i4 = t3.prevNode && t3.prevNode.type === "listItem" && t3.prevNode.loose, u3 = nL(t3.prevNode) === "next", o3 = e23.type === "html" && t3.prevNode && t3.prevNode.type === "html" && t3.prevNode.position.end.line + 1 === e23.position.start.line, s3 = e23.type === "html" && t3.parentNode.type === "listItem" && t3.prevNode && t3.prevNode.type === "paragraph" && t3.prevNode.position.end.line + 1 === e23.position.start.line;
        return i4 || !(n4 || r4 || u3 || o3 || s3);
      }(r3, e22) || rL(r3, e22)) && s2.push(FI), rL(r3, e22) && s2.push(FI)), s2.push(i3), a2 = r3;
    }
  }, "children"), i2 ? i2(s2) : s2;
}
function tL(e20) {
  let t2 = e20;
  for (; DI(t2.children); )
    t2 = hI(t2.children);
  return t2;
}
function nL(e20) {
  if (e20.type !== "html")
    return false;
  const t2 = e20.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
  return t2 !== null && (t2[1] ? t2[1] : "next");
}
function rL(e20, t2) {
  const n2 = t2.prevNode && t2.prevNode.type === "list", r2 = e20.type === "code" && e20.isIndented;
  return n2 && r2;
}
function iL(e20, t2 = []) {
  const n2 = [" ", ...Array.isArray(t2) ? t2 : [t2]];
  return new RegExp(n2.map((e21) => `\\${e21}`).join("|")).test(e20) ? `<${e20}>` : e20;
}
function uL(e20, t2, n2 = true) {
  if (!e20)
    return "";
  if (n2)
    return " " + uL(e20, t2, false);
  if ((e20 = e20.replace(/\\(["')])/g, "$1")).includes('"') && e20.includes("'") && !e20.includes(")"))
    return `(${e20})`;
  const r2 = e20.split("'").length - 1, i2 = e20.split('"').length - 1, u2 = r2 > i2 ? '"' : i2 > r2 || t2.singleQuote ? "'" : '"';
  return `${u2}${e20 = (e20 = e20.replace(/\\/, "\\\\")).replace(new RegExp(`(${u2})`, "g"), "\\$1")}${u2}`;
}
var oL = {
  preprocess: aI,
  print: function(e20, t2, n2) {
    const r2 = e20.getValue();
    if (function(e21) {
      const t3 = KI(e21, ["linkReference", "imageReference"]);
      return t3 && (t3.type !== "linkReference" || t3.referenceType !== "full");
    }(e20))
      return $I(t2.originalText.slice(r2.position.start.offset, r2.position.end.offset), t2).map((n3) => n3.type === "word" ? n3.value : n3.value === "" ? "" : QI(e20, n3.value, t2));
    switch (r2.type) {
      case "front-matter":
        return t2.originalText.slice(r2.position.start.offset, r2.position.end.offset);
      case "root":
        return r2.children.length === 0 ? "" : [PI(ZI(e20, t2, n2)), zI.has(tL(r2).type) ? "" : FI];
      case "paragraph":
        return eL(e20, t2, n2, { postprocessor: wI });
      case "sentence":
        return eL(e20, t2, n2);
      case "word": {
        let t3 = r2.value.replace(/\*/g, "\\$&").replace(new RegExp([`(^|${VI})(_+)`, `(_+)(${VI}|$)`].join("|"), "g"), (e21, t4, n4, r3, i3) => (n4 ? `${t4}${n4}` : `${r3}${i3}`).replace(/_/g, "\\_"));
        const n3 = (e21, t4, n4) => e21.type === "sentence" && n4 === 0, i2 = (e21, t4, n4) => UI(e21.children[n4 - 1]);
        return t3 !== r2.value && (e20.match(void 0, n3, i2) || e20.match(void 0, n3, (e21, t4, n4) => e21.type === "emphasis" && n4 === 0, i2)) && (t3 = t3.replace(/^(\\?[*_])+/, (e21) => e21.replace(/\\/g, ""))), t3;
      }
      case "whitespace": {
        const n3 = e20.getParentNode(), i2 = n3.children.indexOf(r2), u2 = n3.children[i2 + 1], o2 = u2 && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(u2.value) ? "never" : t2.proseWrap;
        return QI(e20, r2.value, { proseWrap: o2 });
      }
      case "emphasis": {
        let i2;
        if (UI(r2.children[0]))
          i2 = t2.originalText[r2.position.start.offset];
        else {
          const t3 = e20.getParentNode(), n3 = t3.children.indexOf(r2), u2 = t3.children[n3 - 1], o2 = t3.children[n3 + 1];
          i2 = u2 && u2.type === "sentence" && u2.children.length > 0 && hI(u2.children).type === "word" && !hI(u2.children).hasTrailingPunctuation || o2 && o2.type === "sentence" && o2.children.length > 0 && o2.children[0].type === "word" && !o2.children[0].hasLeadingPunctuation || KI(e20, "emphasis") ? "*" : "_";
        }
        return [i2, eL(e20, t2, n2), i2];
      }
      case "strong":
        return ["**", eL(e20, t2, n2), "**"];
      case "delete":
        return ["~~", eL(e20, t2, n2), "~~"];
      case "inlineCode": {
        const e21 = gI(r2.value, "`"), t3 = "`".repeat(e21 || 1), n3 = e21 && !/^\s/.test(r2.value) ? " " : "";
        return [t3, n3, r2.value, n3, t3];
      }
      case "wikiLink": {
        let e21 = "";
        return e21 = t2.proseWrap === "preserve" ? r2.value : r2.value.replace(/[\t\n]+/g, " "), ["[[", e21, "]]"];
      }
      case "link":
        switch (t2.originalText[r2.position.start.offset]) {
          case "<": {
            const e21 = "mailto:";
            return [
              "<",
              r2.url.startsWith(e21) && t2.originalText.slice(r2.position.start.offset + 1, r2.position.start.offset + 1 + e21.length) !== e21 ? r2.url.slice(e21.length) : r2.url,
              ">"
            ];
          }
          case "[":
            return [
              "[",
              eL(e20, t2, n2),
              "](",
              iL(r2.url, ")"),
              uL(r2.title, t2),
              ")"
            ];
          default:
            return t2.originalText.slice(r2.position.start.offset, r2.position.end.offset);
        }
      case "image":
        return [
          "![",
          r2.alt || "",
          "](",
          iL(r2.url, ")"),
          uL(r2.title, t2),
          ")"
        ];
      case "blockquote":
        return ["> ", TI("> ", eL(e20, t2, n2))];
      case "heading":
        return ["#".repeat(r2.depth) + " ", eL(e20, t2, n2)];
      case "code": {
        if (r2.isIndented) {
          const e22 = " ".repeat(4);
          return TI(e22, [e22, ...OI(r2.value, FI)]);
        }
        const e21 = t2.__inJsTemplate ? "~" : "`", n3 = e21.repeat(Math.max(3, mI(r2.value, e21) + 1));
        return [
          n3,
          r2.lang || "",
          r2.meta ? " " + r2.meta : "",
          FI,
          ...OI(MI(r2, t2.originalText), FI),
          FI,
          n3
        ];
      }
      case "html": {
        const t3 = e20.getParentNode(), n3 = t3.type === "root" && hI(t3.children) === r2 ? r2.value.trimEnd() : r2.value, i2 = /^<!--.*-->$/s.test(n3);
        return OI(n3, i2 ? FI : vI(AI));
      }
      case "list": {
        const i2 = XI(r2, e20.getParentNode()), u2 = RI(r2, t2);
        return eL(e20, t2, n2, {
          processor: (e21, o2) => {
            const s2 = function() {
              const e22 = r2.ordered ? (o2 === 0 ? r2.start : u2 ? 1 : r2.start + o2) + (i2 % 2 == 0 ? ". " : ") ") : i2 % 2 == 0 ? "- " : "* ";
              return r2.isAligned || r2.hasIndentedCodeblock ? function(e23, t3) {
                const n3 = r3();
                return e23 + " ".repeat(n3 >= 4 ? 0 : n3);
                function r3() {
                  const n4 = e23.length % t3.tabWidth;
                  return n4 === 0 ? 0 : t3.tabWidth - n4;
                }
              }(e22, t2) : e22;
            }(), a2 = e21.getValue();
            return a2.children.length === 2 && a2.children[1].type === "html" && a2.children[0].position.start.column !== a2.children[1].position.start.column ? [s2, JI(e21, t2, n2, s2)] : [s2, TI(" ".repeat(s2.length), JI(e21, t2, n2, s2))];
          }
        });
      }
      case "thematicBreak": {
        const t3 = YI(e20, "list");
        if (t3 === -1)
          return "---";
        return XI(e20.getParentNode(t3), e20.getParentNode(t3 + 1)) % 2 == 0 ? "***" : "---";
      }
      case "linkReference":
        return [
          "[",
          eL(e20, t2, n2),
          "]",
          r2.referenceType === "full" ? ["[", r2.identifier, "]"] : r2.referenceType === "collapsed" ? "[]" : ""
        ];
      case "imageReference":
        switch (r2.referenceType) {
          case "full":
            return ["![", r2.alt || "", "][", r2.identifier, "]"];
          default:
            return [
              "![",
              r2.alt,
              "]",
              r2.referenceType === "collapsed" ? "[]" : ""
            ];
        }
      case "definition": {
        const e21 = t2.proseWrap === "always" ? bI : " ";
        return NI([
          "[",
          r2.identifier,
          "]:",
          BI([
            e21,
            iL(r2.url),
            r2.title === null ? "" : [e21, uL(r2.title, t2, false)]
          ])
        ]);
      }
      case "footnote":
        return ["[^", eL(e20, t2, n2), "]"];
      case "footnoteReference":
        return ["[^", r2.identifier, "]"];
      case "footnoteDefinition": {
        const i2 = e20.getParentNode().children[e20.getName() + 1], u2 = r2.children.length === 1 && r2.children[0].type === "paragraph" && (t2.proseWrap === "never" || t2.proseWrap === "preserve" && r2.children[0].position.start.line === r2.children[0].position.end.line);
        return [
          "[^",
          r2.identifier,
          "]: ",
          u2 ? eL(e20, t2, n2) : NI([
            TI(" ".repeat(4), eL(e20, t2, n2, {
              processor: (e21, t3) => t3 === 0 ? NI([SI, n2()]) : n2()
            })),
            i2 && i2.type === "footnoteDefinition" ? SI : ""
          ])
        ];
      }
      case "table":
        return function(e21, t3, n3) {
          const r3 = e21.getValue(), i2 = [], u2 = e21.map((e22) => e22.map((e23, r4) => {
            const u3 = II(n3(), t3).formatted, o3 = yI(u3);
            return i2[r4] = Math.max(i2[r4] || 3, o3), { text: u3, width: o3 };
          }, "children"), "children"), o2 = a2(false);
          if (t3.proseWrap !== "never")
            return [EI, o2];
          const s2 = a2(true);
          return [EI, NI(xI(s2, o2))];
          function a2(e22) {
            const t4 = [l2(u2[0], e22), c2(e22)];
            return u2.length > 1 && t4.push(CI(kI, u2.slice(1).map((t5) => l2(t5, e22)))), CI(kI, t4);
          }
          function c2(e22) {
            return `| ${i2.map((t4, n4) => {
              const i3 = r3.align[n4], u3 = i3 === "center" || i3 === "right" ? ":" : "-";
              return `${i3 === "center" || i3 === "left" ? ":" : "-"}${e22 ? "-" : "-".repeat(t4 - 2)}${u3}`;
            }).join(" | ")} |`;
          }
          function l2(e22, t4) {
            return `| ${e22.map(({ text: e23, width: n4 }, u3) => {
              if (t4)
                return e23;
              const o3 = i2[u3] - n4, s3 = r3.align[u3];
              let a3 = 0;
              s3 === "right" ? a3 = o3 : s3 === "center" && (a3 = Math.floor(o3 / 2));
              const c3 = o3 - a3;
              return `${" ".repeat(a3)}${e23}${" ".repeat(c3)}`;
            }).join(" | ")} |`;
          }
        }(e20, t2, n2);
      case "tableCell":
        return eL(e20, t2, n2);
      case "break":
        return /\s/.test(t2.originalText[r2.position.start.offset]) ? ["  ", vI(AI)] : ["\\", FI];
      case "liquidNode":
        return OI(r2.value, FI);
      case "importExport":
        return [r2.value, FI];
      case "jsx":
        return r2.value;
      case "math":
        return [
          "$$",
          FI,
          r2.value ? [...OI(r2.value, FI), FI] : "",
          "$$"
        ];
      case "inlineMath":
        return t2.originalText.slice(jI(r2), _I(r2));
      case "tableRow":
      case "listItem":
      default:
        throw new Error(`Unknown markdown type ${JSON.stringify(r2.type)}`);
    }
  },
  embed: ZO,
  massageAstNode: dI,
  hasPrettierIgnore: function(e20) {
    const t2 = Number(e20.getName());
    return t2 !== 0 && nL(e20.getParentNode().children[t2 - 1]) === "next";
  },
  insertPragma: LI
}, sL = { proseWrap: WB.proseWrap, singleQuote: WB.singleQuote }, aL = {
  name: "Markdown",
  type: "prose",
  color: "#083fa1",
  aliases: ["pandoc"],
  aceMode: "markdown",
  codemirrorMode: "gfm",
  codemirrorMimeType: "text/x-gfm",
  wrap: true,
  extensions: [
    ".md",
    ".markdown",
    ".mdown",
    ".mdwn",
    ".mdx",
    ".mkd",
    ".mkdn",
    ".mkdown",
    ".ronn",
    ".scd",
    ".workbook"
  ],
  filenames: ["contents.lr"],
  tmScope: "source.gfm",
  languageId: 222
};
var cL = {
  languages: [
    Xd(aL, (e20) => ({
      since: "1.8.0",
      parsers: ["markdown"],
      vscodeLanguageIds: ["markdown"],
      filenames: [...e20.filenames, "README"],
      extensions: e20.extensions.filter((e21) => e21 !== ".mdx")
    })),
    Xd(aL, () => ({
      name: "MDX",
      since: "1.15.0",
      parsers: ["mdx"],
      vscodeLanguageIds: ["mdx"],
      filenames: [],
      extensions: [".mdx"]
    }))
  ],
  options: sL,
  printers: { mdast: oL },
  parsers: void 0
};
const { isFrontMatterNode: lL } = yi$2, pL = new Set([
  "sourceSpan",
  "startSourceSpan",
  "endSourceSpan",
  "nameSpan",
  "valueSpan"
]);
function fL(e20, t2) {
  return e20.type === "text" || e20.type === "comment" || lL(e20) || e20.type === "yaml" || e20.type === "toml" ? null : (e20.type === "attribute" && delete t2.value, void (e20.type === "docType" && delete t2.value));
}
fL.ignoredProperties = pL;
var dL = fL, hL = {
  "*": [
    "accesskey",
    "autocapitalize",
    "autofocus",
    "class",
    "contenteditable",
    "dir",
    "draggable",
    "enterkeyhint",
    "hidden",
    "id",
    "inputmode",
    "is",
    "itemid",
    "itemprop",
    "itemref",
    "itemscope",
    "itemtype",
    "lang",
    "nonce",
    "slot",
    "spellcheck",
    "style",
    "tabindex",
    "title",
    "translate"
  ],
  a: [
    "accesskey",
    "charset",
    "coords",
    "download",
    "href",
    "hreflang",
    "name",
    "ping",
    "referrerpolicy",
    "rel",
    "rev",
    "shape",
    "tabindex",
    "target",
    "type"
  ],
  abbr: ["title"],
  applet: [
    "align",
    "alt",
    "archive",
    "code",
    "codebase",
    "height",
    "hspace",
    "name",
    "object",
    "vspace",
    "width"
  ],
  area: [
    "accesskey",
    "alt",
    "coords",
    "download",
    "href",
    "hreflang",
    "nohref",
    "ping",
    "referrerpolicy",
    "rel",
    "shape",
    "tabindex",
    "target",
    "type"
  ],
  audio: [
    "autoplay",
    "controls",
    "crossorigin",
    "loop",
    "muted",
    "preload",
    "src"
  ],
  base: ["href", "target"],
  basefont: ["color", "face", "size"],
  bdo: ["dir"],
  blockquote: ["cite"],
  body: ["alink", "background", "bgcolor", "link", "text", "vlink"],
  br: ["clear"],
  button: [
    "accesskey",
    "autofocus",
    "disabled",
    "form",
    "formaction",
    "formenctype",
    "formmethod",
    "formnovalidate",
    "formtarget",
    "name",
    "tabindex",
    "type",
    "value"
  ],
  canvas: ["height", "width"],
  caption: ["align"],
  col: ["align", "char", "charoff", "span", "valign", "width"],
  colgroup: ["align", "char", "charoff", "span", "valign", "width"],
  data: ["value"],
  del: ["cite", "datetime"],
  details: ["open"],
  dfn: ["title"],
  dialog: ["open"],
  dir: ["compact"],
  div: ["align"],
  dl: ["compact"],
  embed: ["height", "src", "type", "width"],
  fieldset: ["disabled", "form", "name"],
  font: ["color", "face", "size"],
  form: [
    "accept",
    "accept-charset",
    "action",
    "autocomplete",
    "enctype",
    "method",
    "name",
    "novalidate",
    "target"
  ],
  frame: [
    "frameborder",
    "longdesc",
    "marginheight",
    "marginwidth",
    "name",
    "noresize",
    "scrolling",
    "src"
  ],
  frameset: ["cols", "rows"],
  h1: ["align"],
  h2: ["align"],
  h3: ["align"],
  h4: ["align"],
  h5: ["align"],
  h6: ["align"],
  head: ["profile"],
  hr: ["align", "noshade", "size", "width"],
  html: ["manifest", "version"],
  iframe: [
    "align",
    "allow",
    "allowfullscreen",
    "allowpaymentrequest",
    "allowusermedia",
    "frameborder",
    "height",
    "loading",
    "longdesc",
    "marginheight",
    "marginwidth",
    "name",
    "referrerpolicy",
    "sandbox",
    "scrolling",
    "src",
    "srcdoc",
    "width"
  ],
  img: [
    "align",
    "alt",
    "border",
    "crossorigin",
    "decoding",
    "height",
    "hspace",
    "ismap",
    "loading",
    "longdesc",
    "name",
    "referrerpolicy",
    "sizes",
    "src",
    "srcset",
    "usemap",
    "vspace",
    "width"
  ],
  input: [
    "accept",
    "accesskey",
    "align",
    "alt",
    "autocomplete",
    "autofocus",
    "checked",
    "dirname",
    "disabled",
    "form",
    "formaction",
    "formenctype",
    "formmethod",
    "formnovalidate",
    "formtarget",
    "height",
    "ismap",
    "list",
    "max",
    "maxlength",
    "min",
    "minlength",
    "multiple",
    "name",
    "pattern",
    "placeholder",
    "readonly",
    "required",
    "size",
    "src",
    "step",
    "tabindex",
    "title",
    "type",
    "usemap",
    "value",
    "width"
  ],
  ins: ["cite", "datetime"],
  isindex: ["prompt"],
  label: ["accesskey", "for", "form"],
  legend: ["accesskey", "align"],
  li: ["type", "value"],
  link: [
    "as",
    "charset",
    "color",
    "crossorigin",
    "disabled",
    "href",
    "hreflang",
    "imagesizes",
    "imagesrcset",
    "integrity",
    "media",
    "nonce",
    "referrerpolicy",
    "rel",
    "rev",
    "sizes",
    "target",
    "title",
    "type"
  ],
  map: ["name"],
  menu: ["compact"],
  meta: ["charset", "content", "http-equiv", "name", "scheme"],
  meter: ["high", "low", "max", "min", "optimum", "value"],
  object: [
    "align",
    "archive",
    "border",
    "classid",
    "codebase",
    "codetype",
    "data",
    "declare",
    "form",
    "height",
    "hspace",
    "name",
    "standby",
    "tabindex",
    "type",
    "typemustmatch",
    "usemap",
    "vspace",
    "width"
  ],
  ol: ["compact", "reversed", "start", "type"],
  optgroup: ["disabled", "label"],
  option: ["disabled", "label", "selected", "value"],
  output: ["for", "form", "name"],
  p: ["align"],
  param: ["name", "type", "value", "valuetype"],
  pre: ["width"],
  progress: ["max", "value"],
  q: ["cite"],
  script: [
    "async",
    "charset",
    "crossorigin",
    "defer",
    "integrity",
    "language",
    "nomodule",
    "nonce",
    "referrerpolicy",
    "src",
    "type"
  ],
  select: [
    "autocomplete",
    "autofocus",
    "disabled",
    "form",
    "multiple",
    "name",
    "required",
    "size",
    "tabindex"
  ],
  slot: ["name"],
  source: ["media", "sizes", "src", "srcset", "type"],
  style: ["media", "nonce", "title", "type"],
  table: [
    "align",
    "bgcolor",
    "border",
    "cellpadding",
    "cellspacing",
    "frame",
    "rules",
    "summary",
    "width"
  ],
  tbody: ["align", "char", "charoff", "valign"],
  td: [
    "abbr",
    "align",
    "axis",
    "bgcolor",
    "char",
    "charoff",
    "colspan",
    "headers",
    "height",
    "nowrap",
    "rowspan",
    "scope",
    "valign",
    "width"
  ],
  textarea: [
    "accesskey",
    "autocomplete",
    "autofocus",
    "cols",
    "dirname",
    "disabled",
    "form",
    "maxlength",
    "minlength",
    "name",
    "placeholder",
    "readonly",
    "required",
    "rows",
    "tabindex",
    "wrap"
  ],
  tfoot: ["align", "char", "charoff", "valign"],
  th: [
    "abbr",
    "align",
    "axis",
    "bgcolor",
    "char",
    "charoff",
    "colspan",
    "headers",
    "height",
    "nowrap",
    "rowspan",
    "scope",
    "valign",
    "width"
  ],
  thead: ["align", "char", "charoff", "valign"],
  time: ["datetime"],
  tr: ["align", "bgcolor", "char", "charoff", "valign"],
  track: ["default", "kind", "label", "src", "srclang"],
  ul: ["compact", "type"],
  video: [
    "autoplay",
    "controls",
    "crossorigin",
    "height",
    "loop",
    "muted",
    "playsinline",
    "poster",
    "preload",
    "src",
    "width"
  ]
};
const { inferParserByLanguage: gL, isFrontMatterNode: mL } = yi$2, {
  builders: { line: yL, hardline: DL, join: EL },
  utils: { getDocParts: CL, replaceTextEndOfLine: bL }
} = eu$1, {
  CSS_DISPLAY_TAGS: AL,
  CSS_DISPLAY_DEFAULT: vL,
  CSS_WHITE_SPACE_TAGS: FL,
  CSS_WHITE_SPACE_DEFAULT: SL
} = {
  CSS_DISPLAY_TAGS: {
    area: "none",
    base: "none",
    basefont: "none",
    datalist: "none",
    head: "none",
    link: "none",
    meta: "none",
    noembed: "none",
    noframes: "none",
    param: "block",
    rp: "none",
    script: "block",
    source: "block",
    style: "none",
    template: "inline",
    track: "block",
    title: "none",
    html: "block",
    body: "block",
    address: "block",
    blockquote: "block",
    center: "block",
    div: "block",
    figure: "block",
    figcaption: "block",
    footer: "block",
    form: "block",
    header: "block",
    hr: "block",
    legend: "block",
    listing: "block",
    main: "block",
    p: "block",
    plaintext: "block",
    pre: "block",
    xmp: "block",
    slot: "contents",
    ruby: "ruby",
    rt: "ruby-text",
    article: "block",
    aside: "block",
    h1: "block",
    h2: "block",
    h3: "block",
    h4: "block",
    h5: "block",
    h6: "block",
    hgroup: "block",
    nav: "block",
    section: "block",
    dir: "block",
    dd: "block",
    dl: "block",
    dt: "block",
    ol: "block",
    ul: "block",
    li: "list-item",
    table: "table",
    caption: "table-caption",
    colgroup: "table-column-group",
    col: "table-column",
    thead: "table-header-group",
    tbody: "table-row-group",
    tfoot: "table-footer-group",
    tr: "table-row",
    td: "table-cell",
    th: "table-cell",
    fieldset: "block",
    button: "inline-block",
    details: "block",
    summary: "block",
    dialog: "block",
    meter: "inline-block",
    progress: "inline-block",
    object: "inline-block",
    video: "inline-block",
    audio: "inline-block",
    select: "inline-block",
    option: "block",
    optgroup: "block"
  },
  CSS_DISPLAY_DEFAULT: "inline",
  CSS_WHITE_SPACE_TAGS: {
    listing: "pre",
    plaintext: "pre",
    pre: "pre",
    xmp: "pre",
    nobr: "nowrap",
    table: "initial",
    textarea: "pre-wrap"
  },
  CSS_WHITE_SPACE_DEFAULT: "normal"
}, xL = PL([
  "a",
  "abbr",
  "acronym",
  "address",
  "applet",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "basefont",
  "bdi",
  "bdo",
  "bgsound",
  "big",
  "blink",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "center",
  "cite",
  "code",
  "col",
  "colgroup",
  "command",
  "content",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "element",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "font",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "image",
  "img",
  "input",
  "ins",
  "isindex",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "listing",
  "main",
  "map",
  "mark",
  "marquee",
  "math",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "multicol",
  "nav",
  "nextid",
  "nobr",
  "noembed",
  "noframes",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "plaintext",
  "pre",
  "progress",
  "q",
  "rb",
  "rbc",
  "rp",
  "rt",
  "rtc",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "shadow",
  "slot",
  "small",
  "source",
  "spacer",
  "span",
  "strike",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "svg",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "tt",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  "xmp"
]), wL = function(e20, t2) {
  const n2 = Object.create(null);
  for (const [r2, i2] of Object.entries(e20))
    n2[r2] = t2(i2, r2);
  return n2;
}(hL, PL), TL = new Set(["	", "\n", "\f", "\r", " "]), BL = (e20) => e20.replace(/[\t\n\f\r ]+$/, ""), NL = (e20) => ((e21) => e21.replace(/^[\t\f\r ]*?\n/g, ""))(BL(e20)), kL = (e20) => e20.match(/^[\t\n\f\r ]*/)[0];
function PL(e20) {
  const t2 = Object.create(null);
  for (const n2 of e20)
    t2[n2] = true;
  return t2;
}
function OL(e20) {
  return e20.type === "element" && (e20.fullName === "script" || e20.fullName === "style" || e20.fullName === "svg:style" || UL(e20) && (e20.name === "script" || e20.name === "style"));
}
function IL(e20) {
  return zL(e20).startsWith("pre");
}
function LL(e20) {
  return e20.type === "element" && e20.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(e20.name) || e20.cssDisplay.startsWith("table") && e20.cssDisplay !== "table-cell");
}
function jL(e20) {
  return $L(e20) || e20.type === "element" && e20.fullName === "br" || _L(e20);
}
function _L(e20) {
  return ML(e20) && RL(e20);
}
function ML(e20) {
  return e20.hasLeadingSpaces && (e20.prev ? e20.prev.sourceSpan.end.line < e20.sourceSpan.start.line : e20.parent.type === "root" || e20.parent.startSourceSpan.end.line < e20.sourceSpan.start.line);
}
function RL(e20) {
  return e20.hasTrailingSpaces && (e20.next ? e20.next.sourceSpan.start.line > e20.sourceSpan.end.line : e20.parent.type === "root" || e20.parent.endSourceSpan && e20.parent.endSourceSpan.start.line > e20.sourceSpan.end.line);
}
function $L(e20) {
  switch (e20.type) {
    case "ieConditionalComment":
    case "comment":
    case "directive":
      return true;
    case "element":
      return ["script", "select"].includes(e20.name);
  }
  return false;
}
function VL(e20) {
  const { type: t2, lang: n2 } = e20.attrMap;
  return t2 === "module" || t2 === "text/javascript" || t2 === "text/babel" || t2 === "application/javascript" || n2 === "jsx" ? "babel" : t2 === "application/x-typescript" || n2 === "ts" || n2 === "tsx" ? "typescript" : t2 === "text/markdown" ? "markdown" : t2 === "text/html" ? "html" : t2 && (t2.endsWith("json") || t2.endsWith("importmap")) ? "json" : t2 === "text/x-handlebars-template" ? "glimmer" : void 0;
}
function WL(e20) {
  return e20 === "block" || e20 === "list-item" || e20.startsWith("table");
}
function qL(e20) {
  return zL(e20).startsWith("pre");
}
function UL(e20) {
  return e20.type === "element" && !e20.hasExplicitNamespace && !["html", "svg"].includes(e20.namespace);
}
function zL(e20) {
  return e20.type === "element" && (!e20.namespace || UL(e20)) && FL[e20.name] || SL;
}
function GL(e20, t2 = function(e21) {
  let t3 = Number.POSITIVE_INFINITY;
  for (const n2 of e21.split("\n")) {
    if (n2.length === 0)
      continue;
    if (!TL.has(n2[0]))
      return 0;
    const e22 = kL(n2).length;
    n2.length !== e22 && e22 < t3 && (t3 = e22);
  }
  return t3 === Number.POSITIVE_INFINITY ? 0 : t3;
}(e20)) {
  return t2 === 0 ? e20 : e20.split("\n").map((e21) => e21.slice(t2)).join("\n");
}
const HL = new Set(["template", "style", "script"]);
function JL(e20, t2) {
  return XL(e20, t2) && !HL.has(e20.fullName);
}
function XL(e20, t2) {
  return t2.parser === "vue" && e20.type === "element" && e20.parent.type === "root" && e20.fullName.toLowerCase() !== "html";
}
function YL(e20, t2) {
  return XL(e20, t2) && (JL(e20, t2) || e20.attrMap.lang && e20.attrMap.lang !== "html");
}
var KL = {
  HTML_ELEMENT_ATTRIBUTES: wL,
  HTML_TAGS: xL,
  htmlTrim: (e20) => ((e21) => e21.replace(/^[\t\n\f\r ]+/, ""))(BL(e20)),
  htmlTrimPreserveIndentation: NL,
  hasHtmlWhitespace: (e20) => /[\t\n\f\r ]/.test(e20),
  getLeadingAndTrailingHtmlWhitespace: (e20) => {
    const [, t2, n2, r2] = e20.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
    return { leadingWhitespace: t2, trailingWhitespace: r2, text: n2 };
  },
  canHaveInterpolation: function(e20) {
    return e20.children && !OL(e20);
  },
  countChars: function(e20, t2) {
    let n2 = 0;
    for (let r2 = 0; r2 < e20.length; r2++)
      e20[r2] === t2 && n2++;
    return n2;
  },
  countParents: function(e20, t2) {
    let n2 = 0;
    for (let r2 = e20.stack.length - 1; r2 >= 0; r2--) {
      const i2 = e20.stack[r2];
      i2 && typeof i2 == "object" && !Array.isArray(i2) && t2(i2) && n2++;
    }
    return n2;
  },
  dedentString: GL,
  forceBreakChildren: LL,
  forceBreakContent: function(e20) {
    return LL(e20) || e20.type === "element" && e20.children.length > 0 && (["body", "script", "style"].includes(e20.name) || e20.children.some((e21) => function(e22) {
      return e22.children && e22.children.some((e23) => e23.type !== "text");
    }(e21))) || e20.firstChild && e20.firstChild === e20.lastChild && e20.firstChild.type !== "text" && ML(e20.firstChild) && (!e20.lastChild.isTrailingSpaceSensitive || RL(e20.lastChild));
  },
  forceNextEmptyLine: function(e20) {
    return mL(e20) || e20.next && e20.sourceSpan.end && e20.sourceSpan.end.line + 1 < e20.next.sourceSpan.start.line;
  },
  getLastDescendant: function e10(t2) {
    return t2.lastChild ? e10(t2.lastChild) : t2;
  },
  getNodeCssStyleDisplay: function(e20, t2) {
    if (e20.prev && e20.prev.type === "comment") {
      const t3 = e20.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
      if (t3)
        return t3[1];
    }
    let n2 = false;
    if (e20.type === "element" && e20.namespace === "svg") {
      if (!function(e21, t3) {
        let n3 = e21;
        for (; n3; ) {
          if (t3(n3))
            return true;
          n3 = n3.parent;
        }
        return false;
      }(e20, (e21) => e21.fullName === "svg:foreignObject"))
        return e20.name === "svg" ? "inline-block" : "block";
      n2 = true;
    }
    switch (t2.htmlWhitespaceSensitivity) {
      case "strict":
        return "inline";
      case "ignore":
        return "block";
      default:
        return t2.parser === "vue" && e20.parent && e20.parent.type === "root" ? "block" : e20.type === "element" && (!e20.namespace || n2 || UL(e20)) && AL[e20.name] || vL;
    }
  },
  getNodeCssStyleWhiteSpace: zL,
  hasPrettierIgnore: function(e20) {
    return e20.type !== "attribute" && !!e20.parent && typeof e20.index == "number" && e20.index !== 0 && function(e21) {
      return e21.type === "comment" && e21.value.trim() === "prettier-ignore";
    }(e20.parent.children[e20.index - 1]);
  },
  inferScriptParser: function(e20, t2) {
    return e20.name !== "script" || e20.attrMap.src ? e20.name === "style" ? function(e21) {
      const { lang: t3 } = e21.attrMap;
      return t3 && t3 !== "postcss" && t3 !== "css" ? t3 === "scss" ? "scss" : t3 === "less" ? "less" : void 0 : "css";
    }(e20) : t2 && YL(e20, t2) ? VL(e20) || !("src" in e20.attrMap) && gL(e20.attrMap.lang, t2) : void 0 : e20.attrMap.lang || e20.attrMap.type ? VL(e20) : "babel";
  },
  isVueCustomBlock: JL,
  isVueNonHtmlBlock: YL,
  isVueSlotAttribute: function(e20) {
    const t2 = e20.fullName;
    return t2.charAt(0) === "#" || t2 === "slot-scope" || t2 === "v-slot" || t2.startsWith("v-slot:");
  },
  isVueSfcBindingsAttribute: function(e20, t2) {
    const n2 = e20.parent;
    if (!XL(n2, t2))
      return false;
    const r2 = n2.fullName, i2 = e20.fullName;
    return r2 === "script" && i2 === "setup" || r2 === "style" && i2 === "vars";
  },
  isDanglingSpaceSensitiveNode: function(e20) {
    return !(t2 = e20.cssDisplay, WL(t2) || t2 === "inline-block" || OL(e20));
    var t2;
  },
  isIndentationSensitiveNode: IL,
  isLeadingSpaceSensitiveNode: function(e20, t2) {
    const n2 = function() {
      if (mL(e20))
        return false;
      if ((e20.type === "text" || e20.type === "interpolation") && e20.prev && (e20.prev.type === "text" || e20.prev.type === "interpolation"))
        return true;
      if (!e20.parent || e20.parent.cssDisplay === "none")
        return false;
      if (qL(e20.parent))
        return true;
      if (!e20.prev && (e20.parent.type === "root" || qL(e20) && e20.parent || OL(e20.parent) || JL(e20.parent, t2) || (n3 = e20.parent.cssDisplay, WL(n3) || n3 === "inline-block")))
        return false;
      var n3;
      if (e20.prev && !function(e21) {
        return !WL(e21);
      }(e20.prev.cssDisplay))
        return false;
      return true;
    }();
    return n2 && !e20.prev && e20.parent && e20.parent.tagDefinition && e20.parent.tagDefinition.ignoreFirstLf ? e20.type === "interpolation" : n2;
  },
  isPreLikeNode: qL,
  isScriptLikeTag: OL,
  isTextLikeNode: function(e20) {
    return e20.type === "text" || e20.type === "comment";
  },
  isTrailingSpaceSensitiveNode: function(e20, t2) {
    return !mL(e20) && (!(e20.type !== "text" && e20.type !== "interpolation" || !e20.next || e20.next.type !== "text" && e20.next.type !== "interpolation") || !(!e20.parent || e20.parent.cssDisplay === "none") && (!!qL(e20.parent) || !(!e20.next && (e20.parent.type === "root" || qL(e20) && e20.parent || OL(e20.parent) || JL(e20.parent, t2) || (n2 = e20.parent.cssDisplay, WL(n2) || n2 === "inline-block"))) && !(e20.next && !function(e21) {
      return !WL(e21);
    }(e20.next.cssDisplay))));
    var n2;
  },
  isWhitespaceSensitiveNode: function(e20) {
    return OL(e20) || e20.type === "interpolation" || IL(e20);
  },
  isUnknownNamespace: UL,
  preferHardlineAsLeadingSpaces: function(e20) {
    return $L(e20) || e20.prev && jL(e20.prev) || _L(e20);
  },
  preferHardlineAsTrailingSpaces: jL,
  shouldPreserveContent: function(e20, t2) {
    return !(e20.type !== "ieConditionalComment" || !e20.lastChild || e20.lastChild.isSelfClosing || e20.lastChild.endSourceSpan) || e20.type === "ieConditionalComment" && !e20.complete || !(!qL(e20) || !e20.children.some((e21) => e21.type !== "text" && e21.type !== "interpolation")) || !(!YL(e20, t2) || OL(e20) || e20.type === "interpolation");
  },
  unescapeQuoteEntities: function(e20) {
    return e20.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
  },
  getTextValueParts: function(e20, t2 = e20.value) {
    return e20.parent.isWhitespaceSensitive ? e20.parent.isIndentationSensitive ? bL(t2) : bL(GL(NL(t2)), DL) : CL(EL(yL, ((e21) => e21.split(/[\t\n\f\r ]+/))(t2)));
  }
}, QL = r$3(function(e20, t2) {
  function n2(e21) {
    return t2.$0 <= e21 && e21 <= t2.$9;
  }
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  Object.defineProperty(t2, "__esModule", { value: true }), t2.$EOF = 0, t2.$BSPACE = 8, t2.$TAB = 9, t2.$LF = 10, t2.$VTAB = 11, t2.$FF = 12, t2.$CR = 13, t2.$SPACE = 32, t2.$BANG = 33, t2.$DQ = 34, t2.$HASH = 35, t2.$$ = 36, t2.$PERCENT = 37, t2.$AMPERSAND = 38, t2.$SQ = 39, t2.$LPAREN = 40, t2.$RPAREN = 41, t2.$STAR = 42, t2.$PLUS = 43, t2.$COMMA = 44, t2.$MINUS = 45, t2.$PERIOD = 46, t2.$SLASH = 47, t2.$COLON = 58, t2.$SEMICOLON = 59, t2.$LT = 60, t2.$EQ = 61, t2.$GT = 62, t2.$QUESTION = 63, t2.$0 = 48, t2.$7 = 55, t2.$9 = 57, t2.$A = 65, t2.$E = 69, t2.$F = 70, t2.$X = 88, t2.$Z = 90, t2.$LBRACKET = 91, t2.$BACKSLASH = 92, t2.$RBRACKET = 93, t2.$CARET = 94, t2.$_ = 95, t2.$a = 97, t2.$b = 98, t2.$e = 101, t2.$f = 102, t2.$n = 110, t2.$r = 114, t2.$t = 116, t2.$u = 117, t2.$v = 118, t2.$x = 120, t2.$z = 122, t2.$LBRACE = 123, t2.$BAR = 124, t2.$RBRACE = 125, t2.$NBSP = 160, t2.$PIPE = 124, t2.$TILDA = 126, t2.$AT = 64, t2.$BT = 96, t2.isWhitespace = function(e21) {
    return e21 >= t2.$TAB && e21 <= t2.$SPACE || e21 == t2.$NBSP;
  }, t2.isDigit = n2, t2.isAsciiLetter = function(e21) {
    return e21 >= t2.$a && e21 <= t2.$z || e21 >= t2.$A && e21 <= t2.$Z;
  }, t2.isAsciiHexDigit = function(e21) {
    return e21 >= t2.$a && e21 <= t2.$f || e21 >= t2.$A && e21 <= t2.$F || n2(e21);
  }, t2.isNewLine = function(e21) {
    return e21 === t2.$LF || e21 === t2.$CR;
  }, t2.isOctalDigit = function(e21) {
    return t2.$0 <= e21 && e21 <= t2.$7;
  };
});
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class ZL {
  constructor(e20, t2, n2) {
    this.filePath = e20, this.name = t2, this.members = n2;
  }
  assertNoMembers() {
    if (this.members.length)
      throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);
  }
}
var ej = ZL;
var tj = class {
  constructor() {
    this.cache = new Map();
  }
  get(e20, t2, n2) {
    const r2 = `"${e20}".${t2}${(n2 = n2 || []).length ? `.${n2.join(".")}` : ""}`;
    let i2 = this.cache.get(r2);
    return i2 || (i2 = new ZL(e20, t2, n2), this.cache.set(r2, i2)), i2;
  }
}, nj = Object.defineProperty({ StaticSymbol: ej, StaticSymbolCache: tj }, "__esModule", { value: true });
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const rj = /-+([a-z0-9])/g;
var ij = function(e20) {
  return e20.replace(rj, (...e21) => e21[1].toUpperCase());
};
var uj = function(e20, t2) {
  return sj(e20, ":", t2);
};
var oj = function(e20, t2) {
  return sj(e20, ".", t2);
};
function sj(e20, t2, n2) {
  const r2 = e20.indexOf(t2);
  return r2 == -1 ? n2 : [e20.slice(0, r2).trim(), e20.slice(r2 + 1).trim()];
}
function aj(e20, t2, n2) {
  return Array.isArray(e20) ? t2.visitArray(e20, n2) : function(e21) {
    return typeof e21 == "object" && e21 !== null && Object.getPrototypeOf(e21) === bj;
  }(e20) ? t2.visitStringMap(e20, n2) : e20 == null || typeof e20 == "string" || typeof e20 == "number" || typeof e20 == "boolean" ? t2.visitPrimitive(e20, n2) : t2.visitOther(e20, n2);
}
var cj = aj;
var lj = function(e20) {
  return e20 != null;
};
var pj = function(e20) {
  return e20 === void 0 ? null : e20;
};
var fj = class {
  visitArray(e20, t2) {
    return e20.map((e21) => aj(e21, this, t2));
  }
  visitStringMap(e20, t2) {
    const n2 = {};
    return Object.keys(e20).forEach((r2) => {
      n2[r2] = aj(e20[r2], this, t2);
    }), n2;
  }
  visitPrimitive(e20, t2) {
    return e20;
  }
  visitOther(e20, t2) {
    return e20;
  }
}, dj = {
  assertSync: (e20) => {
    if (Sj(e20))
      throw new Error("Illegal state: value cannot be a promise");
    return e20;
  },
  then: (e20, t2) => Sj(e20) ? e20.then(t2) : t2(e20),
  all: (e20) => e20.some(Sj) ? Promise.all(e20) : e20
};
var hj = function(e20) {
  throw new Error(`Internal Error: ${e20}`);
};
var gj = function(e20, t2) {
  const n2 = Error(e20);
  return n2[mj] = true, t2 && (n2[yj] = t2), n2;
};
const mj = "ngSyntaxError", yj = "ngParseErrors";
var Dj = function(e20) {
  return e20[mj];
};
var Ej = function(e20) {
  return e20[yj] || [];
};
var Cj = function(e20) {
  return e20.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
};
const bj = Object.getPrototypeOf({});
var Aj = function(e20) {
  let t2 = "";
  for (let n2 = 0; n2 < e20.length; n2++) {
    let r2 = e20.charCodeAt(n2);
    if (r2 >= 55296 && r2 <= 56319 && e20.length > n2 + 1) {
      const t3 = e20.charCodeAt(n2 + 1);
      t3 >= 56320 && t3 <= 57343 && (n2++, r2 = (r2 - 55296 << 10) + t3 - 56320 + 65536);
    }
    r2 <= 127 ? t2 += String.fromCharCode(r2) : r2 <= 2047 ? t2 += String.fromCharCode(r2 >> 6 & 31 | 192, 63 & r2 | 128) : r2 <= 65535 ? t2 += String.fromCharCode(r2 >> 12 | 224, r2 >> 6 & 63 | 128, 63 & r2 | 128) : r2 <= 2097151 && (t2 += String.fromCharCode(r2 >> 18 & 7 | 240, r2 >> 12 & 63 | 128, r2 >> 6 & 63 | 128, 63 & r2 | 128));
  }
  return t2;
};
var vj = function e11(t2) {
  if (typeof t2 == "string")
    return t2;
  if (t2 instanceof Array)
    return "[" + t2.map(e11).join(", ") + "]";
  if (t2 == null)
    return "" + t2;
  if (t2.overriddenName)
    return `${t2.overriddenName}`;
  if (t2.name)
    return `${t2.name}`;
  if (!t2.toString)
    return "object";
  const n2 = t2.toString();
  if (n2 == null)
    return "" + n2;
  const r2 = n2.indexOf("\n");
  return r2 === -1 ? n2 : n2.substring(0, r2);
};
var Fj = function(e20) {
  return typeof e20 == "function" && e20.hasOwnProperty("__forward_ref__") ? e20() : e20;
};
function Sj(e20) {
  return !!e20 && typeof e20.then == "function";
}
var xj = Sj;
var wj = class {
  constructor(e20) {
    this.full = e20;
    const t2 = e20.split(".");
    this.major = t2[0], this.minor = t2[1], this.patch = t2.slice(2).join(".");
  }
};
const Tj = typeof window != "undefined" && window, Bj = typeof self != "undefined" && typeof WorkerGlobalScope != "undefined" && self instanceof WorkerGlobalScope && self;
var Nj = t$3 !== void 0 && t$3 || Tj || Bj, kj = Object.defineProperty({
  dashCaseToCamelCase: ij,
  splitAtColon: uj,
  splitAtPeriod: oj,
  visitValue: cj,
  isDefined: lj,
  noUndefined: pj,
  ValueTransformer: fj,
  SyncAsync: dj,
  error: hj,
  syntaxError: gj,
  isSyntaxError: Dj,
  getParseErrors: Ej,
  escapeRegExp: Cj,
  utf8Encode: Aj,
  stringify: vj,
  resolveForwardRef: Fj,
  isPromise: xj,
  Version: wj,
  global: Nj
}, "__esModule", { value: true }), Pj = r$3(function(e20, t2) {
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  Object.defineProperty(t2, "__esModule", { value: true });
  const n2 = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
  function r2(e21) {
    return e21.replace(/\W/g, "_");
  }
  t2.sanitizeIdentifier = r2;
  let i2 = 0;
  function u2(e21) {
    if (!e21 || !e21.reference)
      return null;
    const t3 = e21.reference;
    if (t3 instanceof nj.StaticSymbol)
      return t3.name;
    if (t3.__anonymousType)
      return t3.__anonymousType;
    let n3 = kj.stringify(t3);
    return n3.indexOf("(") >= 0 ? (n3 = "anonymous_" + i2++, t3.__anonymousType = n3) : n3 = r2(n3), n3;
  }
  var o2;
  t2.identifierName = u2, t2.identifierModuleUrl = function(e21) {
    const t3 = e21.reference;
    return t3 instanceof nj.StaticSymbol ? t3.filePath : `./${kj.stringify(t3)}`;
  }, t2.viewClassName = function(e21, t3) {
    return `View_${u2({ reference: e21 })}_${t3}`;
  }, t2.rendererTypeName = function(e21) {
    return `RenderType_${u2({ reference: e21 })}`;
  }, t2.hostViewClassName = function(e21) {
    return `HostView_${u2({ reference: e21 })}`;
  }, t2.componentFactoryName = function(e21) {
    return `${u2({ reference: e21 })}NgFactory`;
  }, function(e21) {
    e21[e21.Pipe = 0] = "Pipe", e21[e21.Directive = 1] = "Directive", e21[e21.NgModule = 2] = "NgModule", e21[e21.Injectable = 3] = "Injectable";
  }(o2 = t2.CompileSummaryKind || (t2.CompileSummaryKind = {})), t2.tokenName = function(e21) {
    return e21.value != null ? r2(e21.value) : u2(e21.identifier);
  }, t2.tokenReference = function(e21) {
    return e21.identifier != null ? e21.identifier.reference : e21.value;
  };
  t2.CompileStylesheetMetadata = class {
    constructor({ moduleUrl: e21, styles: t3, styleUrls: n3 } = {}) {
      this.moduleUrl = e21 || null, this.styles = a2(t3), this.styleUrls = a2(n3);
    }
  };
  t2.CompileTemplateMetadata = class {
    constructor({
      encapsulation: e21,
      template: t3,
      templateUrl: n3,
      htmlAst: r3,
      styles: i3,
      styleUrls: u3,
      externalStylesheets: o3,
      animations: s3,
      ngContentSelectors: l3,
      interpolation: p2,
      isInline: f2,
      preserveWhitespaces: d2
    }) {
      if (this.encapsulation = e21, this.template = t3, this.templateUrl = n3, this.htmlAst = r3, this.styles = a2(i3), this.styleUrls = a2(u3), this.externalStylesheets = a2(o3), this.animations = s3 ? c2(s3) : [], this.ngContentSelectors = l3 || [], p2 && p2.length != 2)
        throw new Error("'interpolation' should have a start and an end symbol.");
      this.interpolation = p2, this.isInline = f2, this.preserveWhitespaces = d2;
    }
    toSummary() {
      return {
        ngContentSelectors: this.ngContentSelectors,
        encapsulation: this.encapsulation,
        styles: this.styles,
        animations: this.animations
      };
    }
  };
  class s2 {
    static create({
      isHost: e21,
      type: t3,
      isComponent: r3,
      selector: i3,
      exportAs: u3,
      changeDetection: o3,
      inputs: a3,
      outputs: c3,
      host: l3,
      providers: p2,
      viewProviders: f2,
      queries: d2,
      guards: h2,
      viewQueries: g2,
      entryComponents: m2,
      template: y2,
      componentViewType: D2,
      rendererType: E2,
      componentFactory: C2
    }) {
      const b2 = {}, A2 = {}, v2 = {};
      l3 != null && Object.keys(l3).forEach((e22) => {
        const t4 = l3[e22], r4 = e22.match(n2);
        r4 === null ? v2[e22] = t4 : r4[1] != null ? A2[r4[1]] = t4 : r4[2] != null && (b2[r4[2]] = t4);
      });
      const F2 = {};
      a3 != null && a3.forEach((e22) => {
        const t4 = kj.splitAtColon(e22, [e22, e22]);
        F2[t4[0]] = t4[1];
      });
      const S2 = {};
      return c3 != null && c3.forEach((e22) => {
        const t4 = kj.splitAtColon(e22, [e22, e22]);
        S2[t4[0]] = t4[1];
      }), new s2({
        isHost: e21,
        type: t3,
        isComponent: !!r3,
        selector: i3,
        exportAs: u3,
        changeDetection: o3,
        inputs: F2,
        outputs: S2,
        hostListeners: b2,
        hostProperties: A2,
        hostAttributes: v2,
        providers: p2,
        viewProviders: f2,
        queries: d2,
        guards: h2,
        viewQueries: g2,
        entryComponents: m2,
        template: y2,
        componentViewType: D2,
        rendererType: E2,
        componentFactory: C2
      });
    }
    constructor({
      isHost: e21,
      type: t3,
      isComponent: n3,
      selector: r3,
      exportAs: i3,
      changeDetection: u3,
      inputs: o3,
      outputs: s3,
      hostListeners: c3,
      hostProperties: l3,
      hostAttributes: p2,
      providers: f2,
      viewProviders: d2,
      queries: h2,
      guards: g2,
      viewQueries: m2,
      entryComponents: y2,
      template: D2,
      componentViewType: E2,
      rendererType: C2,
      componentFactory: b2
    }) {
      this.isHost = !!e21, this.type = t3, this.isComponent = n3, this.selector = r3, this.exportAs = i3, this.changeDetection = u3, this.inputs = o3, this.outputs = s3, this.hostListeners = c3, this.hostProperties = l3, this.hostAttributes = p2, this.providers = a2(f2), this.viewProviders = a2(d2), this.queries = a2(h2), this.guards = g2, this.viewQueries = a2(m2), this.entryComponents = a2(y2), this.template = D2, this.componentViewType = E2, this.rendererType = C2, this.componentFactory = b2;
    }
    toSummary() {
      return {
        summaryKind: o2.Directive,
        type: this.type,
        isComponent: this.isComponent,
        selector: this.selector,
        exportAs: this.exportAs,
        inputs: this.inputs,
        outputs: this.outputs,
        hostListeners: this.hostListeners,
        hostProperties: this.hostProperties,
        hostAttributes: this.hostAttributes,
        providers: this.providers,
        viewProviders: this.viewProviders,
        queries: this.queries,
        guards: this.guards,
        viewQueries: this.viewQueries,
        entryComponents: this.entryComponents,
        changeDetection: this.changeDetection,
        template: this.template && this.template.toSummary(),
        componentViewType: this.componentViewType,
        rendererType: this.rendererType,
        componentFactory: this.componentFactory
      };
    }
  }
  t2.CompileDirectiveMetadata = s2;
  t2.CompilePipeMetadata = class {
    constructor({ type: e21, name: t3, pure: n3 }) {
      this.type = e21, this.name = t3, this.pure = !!n3;
    }
    toSummary() {
      return {
        summaryKind: o2.Pipe,
        type: this.type,
        name: this.name,
        pure: this.pure
      };
    }
  };
  t2.CompileShallowModuleMetadata = class {
  };
  t2.CompileNgModuleMetadata = class {
    constructor({
      type: e21,
      providers: t3,
      declaredDirectives: n3,
      exportedDirectives: r3,
      declaredPipes: i3,
      exportedPipes: u3,
      entryComponents: o3,
      bootstrapComponents: s3,
      importedModules: c3,
      exportedModules: l3,
      schemas: p2,
      transitiveModule: f2,
      id: d2
    }) {
      this.type = e21 || null, this.declaredDirectives = a2(n3), this.exportedDirectives = a2(r3), this.declaredPipes = a2(i3), this.exportedPipes = a2(u3), this.providers = a2(t3), this.entryComponents = a2(o3), this.bootstrapComponents = a2(s3), this.importedModules = a2(c3), this.exportedModules = a2(l3), this.schemas = a2(p2), this.id = d2 || null, this.transitiveModule = f2 || null;
    }
    toSummary() {
      const e21 = this.transitiveModule;
      return {
        summaryKind: o2.NgModule,
        type: this.type,
        entryComponents: e21.entryComponents,
        providers: e21.providers,
        modules: e21.modules,
        exportedDirectives: e21.exportedDirectives,
        exportedPipes: e21.exportedPipes
      };
    }
  };
  function a2(e21) {
    return e21 || [];
  }
  t2.TransitiveCompileNgModuleMetadata = class {
    constructor() {
      this.directivesSet = new Set(), this.directives = [], this.exportedDirectivesSet = new Set(), this.exportedDirectives = [], this.pipesSet = new Set(), this.pipes = [], this.exportedPipesSet = new Set(), this.exportedPipes = [], this.modulesSet = new Set(), this.modules = [], this.entryComponentsSet = new Set(), this.entryComponents = [], this.providers = [];
    }
    addProvider(e21, t3) {
      this.providers.push({ provider: e21, module: t3 });
    }
    addDirective(e21) {
      this.directivesSet.has(e21.reference) || (this.directivesSet.add(e21.reference), this.directives.push(e21));
    }
    addExportedDirective(e21) {
      this.exportedDirectivesSet.has(e21.reference) || (this.exportedDirectivesSet.add(e21.reference), this.exportedDirectives.push(e21));
    }
    addPipe(e21) {
      this.pipesSet.has(e21.reference) || (this.pipesSet.add(e21.reference), this.pipes.push(e21));
    }
    addExportedPipe(e21) {
      this.exportedPipesSet.has(e21.reference) || (this.exportedPipesSet.add(e21.reference), this.exportedPipes.push(e21));
    }
    addModule(e21) {
      this.modulesSet.has(e21.reference) || (this.modulesSet.add(e21.reference), this.modules.push(e21));
    }
    addEntryComponent(e21) {
      this.entryComponentsSet.has(e21.componentType) || (this.entryComponentsSet.add(e21.componentType), this.entryComponents.push(e21));
    }
  };
  function c2(e21) {
    return e21.reduce((e22, t3) => {
      const n3 = Array.isArray(t3) ? c2(t3) : t3;
      return e22.concat(n3);
    }, []);
  }
  function l2(e21) {
    return e21.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
  }
  t2.ProviderMeta = class {
    constructor(e21, {
      useClass: t3,
      useValue: n3,
      useExisting: r3,
      useFactory: i3,
      deps: u3,
      multi: o3
    }) {
      this.token = e21, this.useClass = t3 || null, this.useValue = n3, this.useExisting = r3, this.useFactory = i3 || null, this.dependencies = u3 || null, this.multi = !!o3;
    }
  }, t2.flatten = c2, t2.templateSourceUrl = function(e21, t3, n3) {
    let r3;
    return r3 = n3.isInline ? t3.type.reference instanceof nj.StaticSymbol ? `${t3.type.reference.filePath}.${t3.type.reference.name}.html` : `${u2(e21)}/${u2(t3.type)}.html` : n3.templateUrl, t3.type.reference instanceof nj.StaticSymbol ? r3 : l2(r3);
  }, t2.sharedStylesheetJitUrl = function(e21, t3) {
    const n3 = e21.moduleUrl.split(/\/\\/g);
    return l2(`css/${t3}${n3[n3.length - 1]}.ngstyle.js`);
  }, t2.ngModuleJitUrl = function(e21) {
    return l2(`${u2(e21.type)}/module.ngfactory.js`);
  }, t2.templateJitUrl = function(e21, t3) {
    return l2(`${u2(e21)}/${u2(t3.type)}.ngfactory.js`);
  };
}), Oj = r$3(function(e20, t2) {
  Object.defineProperty(t2, "__esModule", { value: true });
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class n2 {
    constructor(e21, t3, n3, r3) {
      this.file = e21, this.offset = t3, this.line = n3, this.col = r3;
    }
    toString() {
      return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
    }
    moveBy(e21) {
      const t3 = this.file.content, r3 = t3.length;
      let i3 = this.offset, u3 = this.line, o2 = this.col;
      for (; i3 > 0 && e21 < 0; ) {
        i3--, e21++;
        if (t3.charCodeAt(i3) == QL.$LF) {
          u3--;
          const e22 = t3.substr(0, i3 - 1).lastIndexOf(String.fromCharCode(QL.$LF));
          o2 = e22 > 0 ? i3 - e22 : i3;
        } else
          o2--;
      }
      for (; i3 < r3 && e21 > 0; ) {
        const n3 = t3.charCodeAt(i3);
        i3++, e21--, n3 == QL.$LF ? (u3++, o2 = 0) : o2++;
      }
      return new n2(this.file, i3, u3, o2);
    }
    getContext(e21, t3) {
      const n3 = this.file.content;
      let r3 = this.offset;
      if (r3 != null) {
        r3 > n3.length - 1 && (r3 = n3.length - 1);
        let i3 = r3, u3 = 0, o2 = 0;
        for (; u3 < e21 && r3 > 0 && (r3--, u3++, n3[r3] != "\n" || ++o2 != t3); )
          ;
        for (u3 = 0, o2 = 0; u3 < e21 && i3 < n3.length - 1 && (i3++, u3++, n3[i3] != "\n" || ++o2 != t3); )
          ;
        return {
          before: n3.substring(r3, this.offset),
          after: n3.substring(this.offset, i3 + 1)
        };
      }
      return null;
    }
  }
  t2.ParseLocation = n2;
  class r2 {
    constructor(e21, t3) {
      this.content = e21, this.url = t3;
    }
  }
  t2.ParseSourceFile = r2;
  class i2 {
    constructor(e21, t3, n3 = null) {
      this.start = e21, this.end = t3, this.details = n3;
    }
    toString() {
      return this.start.file.content.substring(this.start.offset, this.end.offset);
    }
  }
  var u2;
  t2.ParseSourceSpan = i2, t2.EMPTY_PARSE_LOCATION = new n2(new r2("", ""), 0, 0, 0), t2.EMPTY_SOURCE_SPAN = new i2(t2.EMPTY_PARSE_LOCATION, t2.EMPTY_PARSE_LOCATION), function(e21) {
    e21[e21.WARNING = 0] = "WARNING", e21[e21.ERROR = 1] = "ERROR";
  }(u2 = t2.ParseErrorLevel || (t2.ParseErrorLevel = {}));
  t2.ParseError = class {
    constructor(e21, t3, n3 = u2.ERROR) {
      this.span = e21, this.msg = t3, this.level = n3;
    }
    contextualMessage() {
      const e21 = this.span.start.getContext(100, 3);
      return e21 ? `${this.msg} ("${e21.before}[${u2[this.level]} ->]${e21.after}")` : this.msg;
    }
    toString() {
      const e21 = this.span.details ? `, ${this.span.details}` : "";
      return `${this.contextualMessage()}: ${this.span.start}${e21}`;
    }
  }, t2.typeSourceSpan = function(e21, t3) {
    const u3 = Pj.identifierModuleUrl(t3), o2 = u3 != null ? `in ${e21} ${Pj.identifierName(t3)} in ${u3}` : `in ${e21} ${Pj.identifierName(t3)}`, s2 = new r2("", o2);
    return new i2(new n2(s2, -1, -1, -1), new n2(s2, -1, -1, -1));
  }, t2.r3JitTypeSourceSpan = function(e21, t3, u3) {
    const o2 = new r2("", `in ${e21} ${t3} in ${u3}`);
    return new i2(new n2(o2, -1, -1, -1), new n2(o2, -1, -1, -1));
  };
});
const { ParseSourceSpan: Ij } = Oj, {
  htmlTrim: Lj,
  getLeadingAndTrailingHtmlWhitespace: jj,
  hasHtmlWhitespace: _j,
  canHaveInterpolation: Mj,
  getNodeCssStyleDisplay: Rj,
  isDanglingSpaceSensitiveNode: $j,
  isIndentationSensitiveNode: Vj,
  isLeadingSpaceSensitiveNode: Wj,
  isTrailingSpaceSensitiveNode: qj,
  isWhitespaceSensitiveNode: Uj
} = KL, zj = [
  function(e20) {
    e20.walk((e21) => {
      if (e21.type === "element" && e21.tagDefinition.ignoreFirstLf && e21.children.length > 0 && e21.children[0].type === "text" && e21.children[0].value[0] === "\n") {
        const [t2, ...n2] = e21.children;
        e21.setChildren(t2.value.length === 1 ? n2 : [t2.clone({ value: t2.value.slice(1) }), ...n2]);
      }
    });
  },
  function(e20) {
    const t2 = (e21) => e21.type === "element" && e21.prev && e21.prev.type === "ieConditionalStartComment" && e21.prev.sourceSpan.end.offset === e21.startSourceSpan.start.offset && e21.firstChild && e21.firstChild.type === "ieConditionalEndComment" && e21.firstChild.sourceSpan.start.offset === e21.startSourceSpan.end.offset;
    e20.walk((e21) => {
      if (e21.children) {
        const n2 = e21.children.map(t2);
        if (n2.some(Boolean)) {
          const t3 = [];
          for (let r2 = 0; r2 < e21.children.length; r2++) {
            const i2 = e21.children[r2];
            if (!n2[r2 + 1])
              if (n2[r2]) {
                const e22 = i2.prev, n3 = i2.firstChild, r3 = new Ij(e22.sourceSpan.start, n3.sourceSpan.end), u2 = new Ij(r3.start, i2.sourceSpan.end);
                t3.push(i2.clone({
                  condition: e22.condition,
                  sourceSpan: u2,
                  startSourceSpan: r3,
                  children: i2.children.slice(1)
                }));
              } else
                t3.push(i2);
          }
          e21.setChildren(t3);
        }
      }
    });
  },
  function(e20) {
    return function(e21, t2, n2) {
      e21.walk((e22) => {
        if (e22.children) {
          const r2 = e22.children.map(t2);
          if (r2.some(Boolean)) {
            const t3 = [];
            for (let i2 = 0; i2 < e22.children.length; i2++) {
              const u2 = e22.children[i2];
              if (u2.type !== "text" && !r2[i2]) {
                t3.push(u2);
                continue;
              }
              const o2 = u2.type === "text" ? u2 : u2.clone({
                type: "text",
                value: n2(u2)
              });
              if (t3.length === 0 || Ln$2(t3).type !== "text") {
                t3.push(o2);
                continue;
              }
              const s2 = t3.pop();
              t3.push(s2.clone({
                value: s2.value + o2.value,
                sourceSpan: new Ij(s2.sourceSpan.start, o2.sourceSpan.end)
              }));
            }
            e22.setChildren(t3);
          }
        }
      });
    }(e20, (e21) => e21.type === "cdata", (e21) => `<![CDATA[${e21.value}]]>`);
  },
  function(e20, t2) {
    if (t2.parser === "html")
      return;
    const n2 = /{{(.+?)}}/s;
    e20.walk((e21) => {
      if (!Mj(e21))
        return;
      const t3 = [];
      for (const r2 of e21.children) {
        if (r2.type !== "text") {
          t3.push(r2);
          continue;
        }
        let e22 = r2.sourceSpan.start, i2 = null;
        const u2 = r2.value.split(n2);
        for (let n3 = 0; n3 < u2.length; n3++, e22 = i2) {
          const r3 = u2[n3];
          n3 % 2 != 0 ? (i2 = e22.moveBy(r3.length + 4), t3.push({
            type: "interpolation",
            sourceSpan: new Ij(e22, i2),
            children: r3.length === 0 ? [] : [
              {
                type: "text",
                value: r3,
                sourceSpan: new Ij(e22.moveBy(2), i2.moveBy(-2))
              }
            ]
          })) : (i2 = e22.moveBy(r3.length), r3.length > 0 && t3.push({
            type: "text",
            value: r3,
            sourceSpan: new Ij(e22, i2)
          }));
        }
      }
      e21.setChildren(t3);
    });
  },
  function(e20) {
    e20.walk((e21) => {
      if (!e21.children)
        return;
      if (e21.children.length === 0 || e21.children.length === 1 && e21.children[0].type === "text" && Lj(e21.children[0].value).length === 0)
        return e21.hasDanglingSpaces = e21.children.length > 0, void (e21.children = []);
      const t2 = Uj(e21), n2 = Vj(e21);
      e21.setChildren(e21.children.flatMap((e22) => {
        if (e22.type !== "text" || t2)
          return e22;
        const n3 = [], {
          leadingWhitespace: r2,
          text: i2,
          trailingWhitespace: u2
        } = jj(e22.value);
        return r2 && n3.push(Gj), i2 && n3.push({
          type: "text",
          value: i2,
          sourceSpan: new Ij(e22.sourceSpan.start.moveBy(r2.length), e22.sourceSpan.end.moveBy(-u2.length))
        }), u2 && n3.push(Gj), n3;
      }).map((e22, t3, n3) => {
        if (e22 !== Gj)
          return Object.assign(Object.assign({}, e22), {}, {
            hasLeadingSpaces: n3[t3 - 1] === Gj,
            hasTrailingSpaces: n3[t3 + 1] === Gj
          });
      }).filter(Boolean)), e21.isWhitespaceSensitive = t2, e21.isIndentationSensitive = n2;
    });
  },
  function(e20, t2) {
    e20.walk((e21) => Object.assign(e21, { cssDisplay: Rj(e21, t2) }));
  },
  function(e20) {
    e20.walk((e21) => Object.assign(e21, {
      isSelfClosing: !e21.children || e21.type === "element" && (e21.tagDefinition.isVoid || e21.startSourceSpan === e21.endSourceSpan)
    }));
  },
  function(e20, t2) {
    e20.walk((e21) => e21.type !== "element" ? e21 : Object.assign(e21, {
      hasHtmComponentClosingTag: e21.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(t2.originalText.slice(e21.endSourceSpan.start.offset, e21.endSourceSpan.end.offset))
    }));
  },
  function(e20, t2) {
    e20.walk((e21) => {
      e21.children && (e21.children.length !== 0 ? e21.setChildren(e21.children.map((e22) => Object.assign(Object.assign({}, e22), {}, {
        isLeadingSpaceSensitive: Wj(e22, t2),
        isTrailingSpaceSensitive: qj(e22, t2)
      })).map((e22, t3, n2) => Object.assign(Object.assign({}, e22), {}, {
        isLeadingSpaceSensitive: (t3 === 0 || n2[t3 - 1].isTrailingSpaceSensitive) && e22.isLeadingSpaceSensitive,
        isTrailingSpaceSensitive: (t3 === n2.length - 1 || n2[t3 + 1].isLeadingSpaceSensitive) && e22.isTrailingSpaceSensitive
      }))) : e21.isDanglingSpaceSensitive = $j(e21));
    });
  },
  function(e20) {
    const t2 = (e21) => e21.type === "element" && e21.attrs.length === 0 && e21.children.length === 1 && e21.firstChild.type === "text" && !_j(e21.children[0].value) && !e21.firstChild.hasLeadingSpaces && !e21.firstChild.hasTrailingSpaces && e21.isLeadingSpaceSensitive && !e21.hasLeadingSpaces && e21.isTrailingSpaceSensitive && !e21.hasTrailingSpaces && e21.prev && e21.prev.type === "text" && e21.next && e21.next.type === "text";
    e20.walk((e21) => {
      if (e21.children) {
        const n2 = e21.children.map(t2);
        if (n2.some(Boolean)) {
          const t3 = [];
          for (let r2 = 0; r2 < e21.children.length; r2++) {
            const i2 = e21.children[r2];
            if (n2[r2]) {
              const n3 = t3.pop(), u2 = e21.children[++r2], {
                isTrailingSpaceSensitive: o2,
                hasTrailingSpaces: s2
              } = u2;
              t3.push(n3.clone({
                value: n3.value + `<${i2.rawName}>` + i2.firstChild.value + `</${i2.rawName}>` + u2.value,
                sourceSpan: new Ij(n3.sourceSpan.start, u2.sourceSpan.end),
                isTrailingSpaceSensitive: o2,
                hasTrailingSpaces: s2
              }));
            } else
              t3.push(i2);
          }
          e21.setChildren(t3);
        }
      }
    });
  }
];
const Gj = { type: "whitespace" };
var Hj = function(e20, t2) {
  const n2 = e20.map((e21) => e21);
  for (const e21 of zj)
    e21(n2, t2);
  return n2;
};
var Jj = {
  hasPragma: function(e20) {
    return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(e20);
  },
  insertPragma: function(e20) {
    return "<!-- @format -->\n\n" + e20.replace(/^\s*\n/, "");
  }
};
var Xj = {
  locStart: function(e20) {
    return e20.sourceSpan.start.offset;
  },
  locEnd: function(e20) {
    return e20.sourceSpan.end.offset;
  }
};
const { isNonEmptyArray: Yj } = yi$2, {
  builders: { indent: Kj, join: Qj, line: Zj, softline: e_ },
  utils: { replaceTextEndOfLine: t_ }
} = eu$1, { locStart: n_, locEnd: r_ } = Xj, {
  isTextLikeNode: i_,
  getLastDescendant: u_,
  isPreLikeNode: o_,
  hasPrettierIgnore: s_,
  shouldPreserveContent: a_
} = KL;
function c_(e20, t2) {
  return e20.lastChild && D_(e20.lastChild) ? "" : [p_(e20, t2), d_(e20, t2)];
}
function l_(e20, t2) {
  return (e20.next ? m_(e20.next) : y_(e20.parent)) ? "" : [h_(e20, t2), f_(e20, t2)];
}
function p_(e20, t2) {
  return y_(e20) ? h_(e20.lastChild, t2) : "";
}
function f_(e20, t2) {
  return D_(e20) ? d_(e20.parent, t2) : E_(e20) ? S_(e20.next) : "";
}
function d_(e20, t2) {
  if (mf(!e20.isSelfClosing), g_(e20, t2))
    return "";
  switch (e20.type) {
    case "ieConditionalComment":
      return "<!";
    case "element":
      if (e20.hasHtmComponentClosingTag)
        return "<//";
    default:
      return `</${e20.rawName}`;
  }
}
function h_(e20, t2) {
  if (g_(e20, t2))
    return "";
  switch (e20.type) {
    case "ieConditionalComment":
    case "ieConditionalEndComment":
      return "[endif]-->";
    case "ieConditionalStartComment":
      return "]><!-->";
    case "interpolation":
      return "}}";
    case "element":
      if (e20.isSelfClosing)
        return "/>";
    default:
      return ">";
  }
}
function g_(e20, t2) {
  return !e20.isSelfClosing && !e20.endSourceSpan && (s_(e20) || a_(e20.parent, t2));
}
function m_(e20) {
  return e20.prev && e20.prev.type !== "docType" && !i_(e20.prev) && e20.isLeadingSpaceSensitive && !e20.hasLeadingSpaces;
}
function y_(e20) {
  return e20.lastChild && e20.lastChild.isTrailingSpaceSensitive && !e20.lastChild.hasTrailingSpaces && !i_(u_(e20.lastChild)) && !o_(e20);
}
function D_(e20) {
  return !e20.next && !e20.hasTrailingSpaces && e20.isTrailingSpaceSensitive && i_(u_(e20));
}
function E_(e20) {
  return e20.next && !i_(e20.next) && i_(e20) && e20.isTrailingSpaceSensitive && !e20.hasTrailingSpaces;
}
function C_(e20) {
  return !e20.prev && e20.isLeadingSpaceSensitive && !e20.hasLeadingSpaces;
}
function b_(e20, t2, n2) {
  const r2 = e20.getValue();
  if (!Yj(r2.attrs))
    return r2.isSelfClosing ? " " : "";
  const i2 = r2.prev && r2.prev.type === "comment" && function(e21) {
    const t3 = e21.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
    return !!t3 && (!t3[1] || t3[1].split(/\s+/));
  }(r2.prev.value), u2 = typeof i2 == "boolean" ? () => i2 : Array.isArray(i2) ? (e21) => i2.includes(e21.rawName) : () => false, o2 = e20.map((e21) => {
    const r3 = e21.getValue();
    return u2(r3) ? t_(t2.originalText.slice(n_(r3), r_(r3))) : n2();
  }, "attrs"), s2 = r2.type === "element" && r2.fullName === "script" && r2.attrs.length === 1 && r2.attrs[0].fullName === "src" && r2.children.length === 0, a2 = [Kj([s2 ? " " : Zj, Qj(Zj, o2)])];
  return r2.firstChild && C_(r2.firstChild) || r2.isSelfClosing && y_(r2.parent) || s2 ? a2.push(r2.isSelfClosing ? " " : "") : a2.push(t2.bracketSameLine ? r2.isSelfClosing ? " " : "" : r2.isSelfClosing ? Zj : e_), a2;
}
function A_(e20) {
  return e20.firstChild && C_(e20.firstChild) ? "" : x_(e20);
}
function v_(e20, t2) {
  return e20.prev && E_(e20.prev) ? "" : [F_(e20, t2), S_(e20)];
}
function F_(e20, t2) {
  return C_(e20) ? x_(e20.parent) : m_(e20) ? h_(e20.prev, t2) : "";
}
function S_(e20) {
  switch (e20.type) {
    case "ieConditionalComment":
    case "ieConditionalStartComment":
      return `<!--[if ${e20.condition}`;
    case "ieConditionalEndComment":
      return "<!--<!";
    case "interpolation":
      return "{{";
    case "docType":
      return "<!DOCTYPE";
    case "element":
      if (e20.condition)
        return `<!--[if ${e20.condition}]><!--><${e20.rawName}`;
    default:
      return `<${e20.rawName}`;
  }
}
function x_(e20) {
  switch (mf(!e20.isSelfClosing), e20.type) {
    case "ieConditionalComment":
      return "]>";
    case "element":
      if (e20.condition)
        return "><!--<![endif]-->";
    default:
      return ">";
  }
}
var w_ = {
  printClosingTag: function(e20, t2) {
    return [e20.isSelfClosing ? "" : c_(e20, t2), l_(e20, t2)];
  },
  printClosingTagStart: c_,
  printClosingTagStartMarker: d_,
  printClosingTagEndMarker: h_,
  printClosingTagSuffix: f_,
  printClosingTagEnd: l_,
  needsToBorrowLastChildClosingTagEndMarker: y_,
  needsToBorrowParentClosingTagStartMarker: D_,
  needsToBorrowPrevClosingTagEndMarker: m_,
  printOpeningTag: function(e20, t2, n2) {
    const r2 = e20.getValue();
    return [v_(r2, t2), b_(e20, t2, n2), r2.isSelfClosing ? "" : A_(r2)];
  },
  printOpeningTagStart: v_,
  printOpeningTagPrefix: F_,
  printOpeningTagStartMarker: S_,
  printOpeningTagEndMarker: x_,
  needsToBorrowNextOpeningTagStartMarker: E_,
  needsToBorrowParentOpeningTagEndMarker: C_
}, T_ = r$3(function(e20) {
  var n2, r2;
  n2 = t$3, r2 = function() {
    return function(e21, t2) {
      var n3 = t2 && t2.logger || console;
      function r3(e22) {
        return e22 === " " || e22 === "	" || e22 === "\n" || e22 === "\f" || e22 === "\r";
      }
      function i2(t3) {
        var n4, r4 = t3.exec(e21.substring(y2));
        if (r4)
          return n4 = r4[0], y2 += n4.length, n4;
      }
      for (var u2, o2, s2, a2, c2, l2 = e21.length, p2 = /^[ \t\n\r\u000c]+/, f2 = /^[, \t\n\r\u000c]+/, d2 = /^[^ \t\n\r\u000c]+/, h2 = /[,]+$/, g2 = /^\d+$/, m2 = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, y2 = 0, D2 = []; ; ) {
        if (i2(f2), y2 >= l2)
          return D2;
        u2 = i2(d2), o2 = [], u2.slice(-1) === "," ? (u2 = u2.replace(h2, ""), C2()) : E2();
      }
      function E2() {
        for (i2(p2), s2 = "", a2 = "in descriptor"; ; ) {
          if (c2 = e21.charAt(y2), a2 === "in descriptor")
            if (r3(c2))
              s2 && (o2.push(s2), s2 = "", a2 = "after descriptor");
            else {
              if (c2 === ",")
                return y2 += 1, s2 && o2.push(s2), void C2();
              if (c2 === "(")
                s2 += c2, a2 = "in parens";
              else {
                if (c2 === "")
                  return s2 && o2.push(s2), void C2();
                s2 += c2;
              }
            }
          else if (a2 === "in parens")
            if (c2 === ")")
              s2 += c2, a2 = "in descriptor";
            else {
              if (c2 === "")
                return o2.push(s2), void C2();
              s2 += c2;
            }
          else if (a2 === "after descriptor")
            if (r3(c2))
              ;
            else {
              if (c2 === "")
                return void C2();
              a2 = "in descriptor", y2 -= 1;
            }
          y2 += 1;
        }
      }
      function C2() {
        var t3, r4, i3, s3, a3, c3, l3, p3, f3, d3 = false, h3 = {};
        for (s3 = 0; s3 < o2.length; s3++)
          c3 = (a3 = o2[s3])[a3.length - 1], l3 = a3.substring(0, a3.length - 1), p3 = parseInt(l3, 10), f3 = parseFloat(l3), g2.test(l3) && c3 === "w" ? ((t3 || r4) && (d3 = true), p3 === 0 ? d3 = true : t3 = p3) : m2.test(l3) && c3 === "x" ? ((t3 || r4 || i3) && (d3 = true), f3 < 0 ? d3 = true : r4 = f3) : g2.test(l3) && c3 === "h" ? ((i3 || r4) && (d3 = true), p3 === 0 ? d3 = true : i3 = p3) : d3 = true;
        d3 ? n3 && n3.error && n3.error("Invalid srcset descriptor found in '" + e21 + "' at '" + a3 + "'.") : (h3.url = u2, t3 && (h3.w = t3), r4 && (h3.d = r4), i3 && (h3.h = i3), D2.push(h3));
      }
    };
  }, e20.exports ? e20.exports = r2() : n2.parseSrcset = r2();
});
const {
  builders: {
    group: B_,
    ifBreak: N_,
    indent: k_,
    join: P_,
    line: O_,
    softline: I_
  }
} = eu$1;
const L_ = [":", "__", "--", "_", "-"];
function j_(e20) {
  const t2 = e20.search(/[^_-]/);
  if (t2 !== -1)
    for (const n2 of L_) {
      const r2 = e20.indexOf(n2, t2);
      if (r2 !== -1)
        return e20.slice(0, r2);
    }
  return e20;
}
var __ = {
  printImgSrcset: function(e20) {
    const t2 = T_(e20, {
      logger: {
        error(e21) {
          throw new Error(e21);
        }
      }
    }), n2 = t2.some(({ w: e21 }) => e21), r2 = t2.some(({ h: e21 }) => e21);
    if (n2 + r2 + t2.some(({ d: e21 }) => e21) > 1)
      throw new Error("Mixed descriptor in srcset is not supported");
    const i2 = n2 ? "w" : r2 ? "h" : "d", u2 = n2 ? "w" : r2 ? "h" : "x", o2 = (e21) => Math.max(...e21), s2 = t2.map((e21) => e21.url), a2 = o2(s2.map((e21) => e21.length)), c2 = t2.map((e21) => e21[i2]).map((e21) => e21 ? e21.toString() : ""), l2 = c2.map((e21) => {
      const t3 = e21.indexOf(".");
      return t3 === -1 ? e21.length : t3;
    }), p2 = o2(l2);
    return P_([",", O_], s2.map((e21, t3) => {
      const n3 = [e21], r3 = c2[t3];
      if (r3) {
        const i3 = a2 - e21.length + 1, o3 = p2 - l2[t3], s3 = " ".repeat(i3 + o3);
        n3.push(N_(s3, " "), r3 + u2);
      }
      return n3;
    }));
  },
  printClassNames: function(e20) {
    const t2 = e20.trim().split(/\s+/), n2 = [];
    let r2;
    for (let e21 = 0; e21 < t2.length; e21++) {
      const i2 = j_(t2[e21]);
      i2 !== r2 && i2 !== t2[e21 - 1] && n2.push([]), Ln$2(n2).push(t2[e21]), r2 = i2;
    }
    return [
      k_([
        I_,
        P_(O_, n2.map((e21) => B_(P_(O_, e21))))
      ]),
      I_
    ];
  }
};
const {
  builders: { group: M_ }
} = eu$1;
var R_ = {
  isVueEventBindingExpression: function(e20) {
    const t2 = e20.trim();
    return /^(?:[\w$]+|\([^)]*?\))\s*=>|^function\s*\(/.test(t2) || /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/.test(t2);
  },
  printVueFor: function(e20, t2) {
    const {
      left: n2,
      operator: r2,
      right: i2
    } = function(e21) {
      const t3 = /(.*?)\s+(in|of)\s+(.*)/s, n3 = /,([^,\]}]*)(?:,([^,\]}]*))?$/, r3 = /^\(|\)$/g, i3 = e21.match(t3);
      if (!i3)
        return;
      const u2 = {};
      u2.for = i3[3].trim();
      const o2 = i3[1].trim().replace(r3, ""), s2 = o2.match(n3);
      s2 ? (u2.alias = o2.replace(n3, ""), u2.iterator1 = s2[1].trim(), s2[2] && (u2.iterator2 = s2[2].trim())) : u2.alias = o2;
      return {
        left: `${[u2.alias, u2.iterator1, u2.iterator2].filter(Boolean).join(",")}`,
        operator: i3[2],
        right: u2.for
      };
    }(e20);
    return [
      M_(t2(`function _(${n2}) {}`, {
        parser: "babel",
        __isVueForBindingLeft: true
      })),
      " ",
      r2,
      " ",
      t2(i2, { parser: "__js_expression" }, { stripTrailingHardline: true })
    ];
  },
  printVueBindings: function(e20, t2) {
    return t2(`function _(${e20}) {}`, {
      parser: "babel",
      __isVueBindings: true
    });
  }
};
const {
  needsToBorrowParentClosingTagStartMarker: $_,
  printClosingTagStartMarker: V_,
  needsToBorrowLastChildClosingTagEndMarker: W_,
  printClosingTagEndMarker: q_,
  needsToBorrowParentOpeningTagEndMarker: U_,
  printOpeningTagEndMarker: z_
} = w_;
var G_ = function(e20, t2) {
  let n2 = e20.startSourceSpan.end.offset;
  e20.firstChild && U_(e20.firstChild) && (n2 -= z_(e20).length);
  let r2 = e20.endSourceSpan.start.offset;
  return e20.lastChild && $_(e20.lastChild) ? r2 += V_(e20, t2).length : W_(e20) && (r2 -= q_(e20.lastChild, t2).length), t2.originalText.slice(n2, r2);
};
const {
  builders: {
    breakParent: H_,
    group: J_,
    hardline: X_,
    indent: Y_,
    line: K_,
    fill: Q_,
    softline: Z_
  },
  utils: { mapDoc: eM, replaceTextEndOfLine: tM }
} = eu$1, {
  printClosingTag: nM,
  printClosingTagSuffix: rM,
  needsToBorrowPrevClosingTagEndMarker: iM,
  printOpeningTagPrefix: uM,
  printOpeningTag: oM
} = w_, { printImgSrcset: sM, printClassNames: aM } = __, {
  printVueFor: cM,
  printVueBindings: lM,
  isVueEventBindingExpression: pM
} = R_, {
  isScriptLikeTag: fM,
  isVueNonHtmlBlock: dM,
  inferScriptParser: hM,
  htmlTrimPreserveIndentation: gM,
  dedentString: mM,
  unescapeQuoteEntities: yM,
  isVueSlotAttribute: DM,
  isVueSfcBindingsAttribute: EM,
  getTextValueParts: CM
} = KL;
function bM(e20, t2, n2) {
  const r2 = (t3) => new RegExp(t3.join("|")).test(e20.fullName), i2 = () => yM(e20.value);
  let u2 = false;
  const o2 = (e21, t3) => {
    const n3 = e21.type === "NGRoot" ? e21.node.type === "NGMicrosyntax" && e21.node.body.length === 1 && e21.node.body[0].type === "NGMicrosyntaxExpression" ? e21.node.body[0].expression : e21.node : e21.type === "JsExpressionRoot" ? e21.node : e21;
    !n3 || n3.type !== "ObjectExpression" && n3.type !== "ArrayExpression" && (t3.parser !== "__vue_expression" || n3.type !== "TemplateLiteral" && n3.type !== "StringLiteral") || (u2 = true);
  }, s2 = (e21, t3 = true) => J_([Y_([Z_, e21]), t3 ? Z_ : ""]), a2 = (e21) => u2 ? ((e22) => J_(e22))(e21) : s2(e21), c2 = (e21, n3) => t2(e21, Object.assign({ __onHtmlBindingRoot: o2, __embeddedInHtml: true }, n3), { stripTrailingHardline: true });
  if (e20.fullName === "srcset" && (e20.parent.fullName === "img" || e20.parent.fullName === "source"))
    return s2(sM(i2()));
  if (e20.fullName === "class" && !n2.parentParser) {
    const e21 = i2();
    if (!e21.includes("{{"))
      return aM(e21);
  }
  if (e20.fullName === "style" && !n2.parentParser) {
    const e21 = i2();
    if (!e21.includes("{{"))
      return s2(c2(e21, { parser: "css", __isHTMLStyleAttribute: true }));
  }
  if (n2.parser === "vue") {
    if (e20.fullName === "v-for")
      return cM(i2(), c2);
    if (DM(e20) || EM(e20, n2))
      return lM(i2(), c2);
    const t3 = ["^:", "^v-bind:"], u3 = ["^v-"];
    if (r2(["^@", "^v-on:"])) {
      const e21 = i2();
      return a2(c2(e21, {
        parser: pM(e21) ? "__js_expression" : "__vue_event_binding"
      }));
    }
    if (r2(t3))
      return a2(c2(i2(), { parser: "__vue_expression" }));
    if (r2(u3))
      return a2(c2(i2(), { parser: "__js_expression" }));
  }
  if (n2.parser === "angular") {
    const t3 = (e21, t4) => c2(e21, Object.assign(Object.assign({}, t4), {}, { trailingComma: "none" })), n3 = ["^\\*"], u3 = [
      "^\\[.+\\]$",
      "^bind(on)?-",
      "^ng-(if|show|hide|class|style)$"
    ], o3 = ["^i18n(-.+)?$"];
    if (r2(["^\\(.+\\)$", "^on-"]))
      return a2(t3(i2(), { parser: "__ng_action" }));
    if (r2(u3))
      return a2(t3(i2(), { parser: "__ng_binding" }));
    if (r2(o3)) {
      const t4 = i2().trim();
      return s2(Q_(CM(e20, t4)), !t4.includes("@@"));
    }
    if (r2(n3))
      return a2(t3(i2(), { parser: "__ng_directive" }));
    const l2 = /{{(.+?)}}/s, p2 = i2();
    if (l2.test(p2)) {
      const e21 = [];
      for (const [n4, r3] of p2.split(l2).entries())
        if (n4 % 2 == 0)
          e21.push(tM(r3));
        else
          try {
            e21.push(J_([
              "{{",
              Y_([
                K_,
                t3(r3, {
                  parser: "__ng_interpolation",
                  __isInHtmlInterpolation: true
                })
              ]),
              K_,
              "}}"
            ]));
          } catch {
            e21.push("{{", tM(r3), "}}");
          }
      return J_(e21);
    }
  }
  return null;
}
var AM = function(e20, t2, n2, r2) {
  const i2 = e20.getValue();
  switch (i2.type) {
    case "element":
      if (fM(i2) || i2.type === "interpolation")
        return;
      if (!i2.isSelfClosing && dM(i2, r2)) {
        const u2 = hM(i2, r2);
        if (!u2)
          return;
        const o2 = G_(i2, r2);
        let s2 = /^\s*$/.test(o2), a2 = "";
        return s2 || (a2 = n2(gM(o2), { parser: u2, __embeddedInHtml: true }, { stripTrailingHardline: true }), s2 = a2 === ""), [
          uM(i2, r2),
          J_(oM(e20, r2, t2)),
          s2 ? "" : X_,
          a2,
          s2 ? "" : X_,
          nM(i2, r2),
          rM(i2, r2)
        ];
      }
      break;
    case "text":
      if (fM(i2.parent)) {
        const e21 = hM(i2.parent);
        if (e21) {
          const t3 = e21 === "markdown" ? mM(i2.value.replace(/^[^\S\n]*?\n/, "")) : i2.value, u2 = { parser: e21, __embeddedInHtml: true };
          if (r2.parser === "html" && e21 === "babel") {
            let e22 = "script";
            const { attrMap: t4 } = i2.parent;
            t4 && (t4.type === "module" || t4.type === "text/babel" && t4["data-type"] === "module") && (e22 = "module"), u2.__babelSourceType = e22;
          }
          return [
            H_,
            uM(i2, r2),
            n2(t3, u2, { stripTrailingHardline: true }),
            rM(i2, r2)
          ];
        }
      } else if (i2.parent.type === "interpolation") {
        const e21 = { __isInHtmlInterpolation: true, __embeddedInHtml: true };
        return r2.parser === "angular" ? (e21.parser = "__ng_interpolation", e21.trailingComma = "none") : r2.parser === "vue" ? e21.parser = "__vue_expression" : e21.parser = "__js_expression", [
          Y_([K_, n2(i2.value, e21, { stripTrailingHardline: true })]),
          i2.parent.next && iM(i2.parent.next) ? " " : K_
        ];
      }
      break;
    case "attribute": {
      if (!i2.value)
        break;
      if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(r2.originalText.slice(i2.valueSpan.start.offset, i2.valueSpan.end.offset)))
        return [i2.rawName, "=", i2.value];
      if (r2.parser === "lwc") {
        if (/^{.*}$/s.test(r2.originalText.slice(i2.valueSpan.start.offset, i2.valueSpan.end.offset)))
          return [i2.rawName, "=", i2.value];
      }
      const e21 = bM(i2, (e22, t3) => n2(e22, Object.assign({ __isInHtmlAttribute: true, __embeddedInHtml: true }, t3), { stripTrailingHardline: true }), r2);
      if (e21)
        return [
          i2.rawName,
          '="',
          J_(eM(e21, (e22) => typeof e22 == "string" ? e22.replace(/"/g, "&quot;") : e22)),
          '"'
        ];
      break;
    }
    case "front-matter":
      return rN(i2, n2);
  }
};
const {
  builders: {
    breakParent: vM,
    group: FM,
    ifBreak: SM,
    line: xM,
    softline: wM,
    hardline: TM
  },
  utils: { replaceTextEndOfLine: BM }
} = eu$1, { locStart: NM, locEnd: kM } = Xj, {
  forceBreakChildren: PM,
  forceNextEmptyLine: OM,
  isTextLikeNode: IM,
  hasPrettierIgnore: LM,
  preferHardlineAsLeadingSpaces: jM
} = KL, {
  printOpeningTagPrefix: _M,
  needsToBorrowNextOpeningTagStartMarker: MM,
  printOpeningTagStartMarker: RM,
  needsToBorrowPrevClosingTagEndMarker: $M,
  printClosingTagEndMarker: VM,
  printClosingTagSuffix: WM,
  needsToBorrowParentClosingTagStartMarker: qM
} = w_;
function UM(e20, t2, n2) {
  const r2 = e20.getValue();
  return LM(r2) ? [
    _M(r2, t2),
    ...BM(t2.originalText.slice(NM(r2) + (r2.prev && MM(r2.prev) ? RM(r2).length : 0), kM(r2) - (r2.next && $M(r2.next) ? VM(r2, t2).length : 0))),
    WM(r2, t2)
  ] : n2();
}
function zM(e20, t2) {
  return IM(e20) && IM(t2) ? e20.isTrailingSpaceSensitive ? e20.hasTrailingSpaces ? jM(t2) ? TM : xM : "" : jM(t2) ? TM : wM : MM(e20) && (LM(t2) || t2.firstChild || t2.isSelfClosing || t2.type === "element" && t2.attrs.length > 0) || e20.type === "element" && e20.isSelfClosing && $M(t2) ? "" : !t2.isLeadingSpaceSensitive || jM(t2) || $M(t2) && e20.lastChild && qM(e20.lastChild) && e20.lastChild.lastChild && qM(e20.lastChild.lastChild) ? TM : t2.hasLeadingSpaces ? xM : wM;
}
var GM = {
  printChildren: function(e20, t2, n2) {
    const r2 = e20.getValue();
    if (PM(r2))
      return [
        vM,
        ...e20.map((e21) => {
          const r3 = e21.getValue(), i3 = r3.prev ? zM(r3.prev, r3) : "";
          return [i3 ? [i3, OM(r3.prev) ? TM : ""] : "", UM(e21, t2, n2)];
        }, "children")
      ];
    const i2 = r2.children.map(() => Symbol(""));
    return e20.map((e21, r3) => {
      const u2 = e21.getValue();
      if (IM(u2)) {
        if (u2.prev && IM(u2.prev)) {
          const r4 = zM(u2.prev, u2);
          if (r4)
            return OM(u2.prev) ? [TM, TM, UM(e21, t2, n2)] : [r4, UM(e21, t2, n2)];
        }
        return UM(e21, t2, n2);
      }
      const o2 = [], s2 = [], a2 = [], c2 = [], l2 = u2.prev ? zM(u2.prev, u2) : "", p2 = u2.next ? zM(u2, u2.next) : "";
      return l2 && (OM(u2.prev) ? o2.push(TM, TM) : l2 === TM ? o2.push(TM) : IM(u2.prev) ? s2.push(l2) : s2.push(SM("", wM, { groupId: i2[r3 - 1] }))), p2 && (OM(u2) ? IM(u2.next) && c2.push(TM, TM) : p2 === TM ? IM(u2.next) && c2.push(TM) : a2.push(p2)), [...o2, FM([...s2, FM([UM(e21, t2, n2), ...a2], { id: i2[r3] })]), ...c2];
    }, "children");
  }
};
const {
  builders: {
    breakParent: HM,
    dedentToRoot: JM,
    group: XM,
    ifBreak: YM,
    indentIfBreak: KM,
    indent: QM,
    line: ZM,
    softline: eR
  },
  utils: { replaceTextEndOfLine: tR }
} = eu$1, {
  shouldPreserveContent: nR,
  isScriptLikeTag: rR,
  isVueCustomBlock: iR,
  countParents: uR,
  forceBreakContent: oR
} = KL, {
  printOpeningTagPrefix: sR,
  printOpeningTag: aR,
  printClosingTagSuffix: cR,
  printClosingTag: lR,
  needsToBorrowPrevClosingTagEndMarker: pR,
  needsToBorrowLastChildClosingTagEndMarker: fR
} = w_, { printChildren: dR } = GM;
var hR = {
  printElement: function(e20, t2, n2) {
    const r2 = e20.getValue();
    if (nR(r2, t2))
      return [
        sR(r2, t2),
        XM(aR(e20, t2, n2)),
        ...tR(G_(r2, t2)),
        ...lR(r2, t2),
        cR(r2, t2)
      ];
    const i2 = r2.children.length === 1 && r2.firstChild.type === "interpolation" && r2.firstChild.isLeadingSpaceSensitive && !r2.firstChild.hasLeadingSpaces && r2.lastChild.isTrailingSpaceSensitive && !r2.lastChild.hasTrailingSpaces, u2 = Symbol("element-attr-group-id"), o2 = (i3) => XM([XM(aR(e20, t2, n2), { id: u2 }), i3, lR(r2, t2)]);
    return r2.children.length === 0 ? o2(r2.hasDanglingSpaces && r2.isDanglingSpaceSensitive ? ZM : "") : o2([
      oR(r2) ? HM : "",
      (s2 = [
        i2 ? YM(eR, "", { groupId: u2 }) : r2.firstChild.hasLeadingSpaces && r2.firstChild.isLeadingSpaceSensitive ? ZM : r2.firstChild.type === "text" && r2.isWhitespaceSensitive && r2.isIndentationSensitive ? JM(eR) : eR,
        dR(e20, t2, n2)
      ], i2 ? KM(s2, { groupId: u2 }) : !rR(r2) && !iR(r2, t2) || r2.parent.type !== "root" || t2.parser !== "vue" || t2.vueIndentScriptAndStyle ? QM(s2) : s2),
      (r2.next ? pR(r2.next) : fR(r2.parent)) ? r2.lastChild.hasTrailingSpaces && r2.lastChild.isTrailingSpaceSensitive ? " " : "" : i2 ? YM(eR, "", { groupId: u2 }) : r2.lastChild.hasTrailingSpaces && r2.lastChild.isTrailingSpaceSensitive ? ZM : (r2.lastChild.type === "comment" || r2.lastChild.type === "text" && r2.isWhitespaceSensitive && r2.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${t2.tabWidth * uR(e20, (e21) => e21.parent && e21.parent.type !== "root")}}$`).test(r2.lastChild.value) ? "" : eR
    ]);
    var s2;
  }
};
const {
  builders: { fill: gR, group: mR, hardline: yR, literalline: DR },
  utils: {
    cleanDoc: ER,
    getDocParts: CR,
    isConcat: bR,
    replaceTextEndOfLine: AR
  }
} = eu$1, { countChars: vR, unescapeQuoteEntities: FR, getTextValueParts: SR } = KL, { insertPragma: xR } = Jj, { locStart: wR, locEnd: TR } = Xj, {
  printClosingTagSuffix: BR,
  printClosingTagEnd: NR,
  printOpeningTagPrefix: kR,
  printOpeningTagStart: PR
} = w_, { printElement: OR } = hR, { printChildren: IR } = GM;
var LR = {
  preprocess: Hj,
  print: function(e20, t2, n2) {
    const r2 = e20.getValue();
    switch (r2.type) {
      case "front-matter":
        return AR(r2.raw);
      case "root":
        return t2.__onHtmlRoot && t2.__onHtmlRoot(r2), [mR(IR(e20, t2, n2)), yR];
      case "element":
      case "ieConditionalComment":
        return OR(e20, t2, n2);
      case "ieConditionalStartComment":
      case "ieConditionalEndComment":
        return [PR(r2), NR(r2)];
      case "interpolation":
        return [PR(r2, t2), ...e20.map(n2, "children"), NR(r2, t2)];
      case "text": {
        if (r2.parent.type === "interpolation") {
          const e22 = /\n[^\S\n]*?$/, t3 = e22.test(r2.value), n3 = t3 ? r2.value.replace(e22, "") : r2.value;
          return [...AR(n3), t3 ? yR : ""];
        }
        const e21 = ER([kR(r2, t2), ...SR(r2), BR(r2, t2)]);
        return bR(e21) || e21.type === "fill" ? gR(CR(e21)) : e21;
      }
      case "docType":
        return [
          mR([
            PR(r2, t2),
            " ",
            r2.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")
          ]),
          NR(r2, t2)
        ];
      case "comment":
        return [
          kR(r2, t2),
          ...AR(t2.originalText.slice(wR(r2), TR(r2)), DR),
          BR(r2, t2)
        ];
      case "attribute": {
        if (r2.value === null)
          return r2.rawName;
        const e21 = FR(r2.value), t3 = vR(e21, "'") < vR(e21, '"') ? "'" : '"';
        return [
          r2.rawName,
          "=",
          t3,
          ...AR(t3 === '"' ? e21.replace(/"/g, "&quot;") : e21.replace(/'/g, "&apos;")),
          t3
        ];
      }
      default:
        throw new Error(`Unexpected node type ${r2.type}`);
    }
  },
  insertPragma: xR,
  massageAstNode: dL,
  embed: AM
};
var jR = {
  bracketSameLine: WB.bracketSameLine,
  htmlWhitespaceSensitivity: {
    since: "1.15.0",
    category: "HTML",
    type: "choice",
    default: "css",
    description: "How to handle whitespaces in HTML.",
    choices: [
      {
        value: "css",
        description: "Respect the default value of CSS display property."
      },
      {
        value: "strict",
        description: "Whitespaces are considered sensitive."
      },
      {
        value: "ignore",
        description: "Whitespaces are considered insensitive."
      }
    ]
  },
  vueIndentScriptAndStyle: {
    since: "1.19.0",
    category: "HTML",
    type: "boolean",
    default: false,
    description: "Indent script and style tags in Vue files."
  }
}, _R = {
  name: "HTML",
  type: "markup",
  tmScope: "text.html.basic",
  aceMode: "html",
  codemirrorMode: "htmlmixed",
  codemirrorMimeType: "text/html",
  color: "#e34c26",
  aliases: ["xhtml"],
  extensions: [".html", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"],
  languageId: 146
}, MR = {
  name: "Vue",
  type: "markup",
  color: "#41b883",
  extensions: [".vue"],
  tmScope: "text.html.vue",
  aceMode: "html",
  languageId: 391
};
var RR = {
  languages: [
    Xd(_R, () => ({
      name: "Angular",
      since: "1.15.0",
      parsers: ["angular"],
      vscodeLanguageIds: ["html"],
      extensions: [".component.html"],
      filenames: []
    })),
    Xd(_R, (e20) => ({
      since: "1.15.0",
      parsers: ["html"],
      vscodeLanguageIds: ["html"],
      extensions: [...e20.extensions, ".mjml"]
    })),
    Xd(_R, () => ({
      name: "Lightning Web Components",
      since: "1.17.0",
      parsers: ["lwc"],
      vscodeLanguageIds: ["html"],
      extensions: [],
      filenames: []
    })),
    Xd(MR, () => ({
      since: "1.10.0",
      parsers: ["vue"],
      vscodeLanguageIds: ["vue"]
    }))
  ],
  printers: { html: LR },
  options: jR,
  parsers: void 0
};
var $R = {
  isPragma: function(e20) {
    return /^\s*@(?:prettier|format)\s*$/.test(e20);
  },
  hasPragma: function(e20) {
    return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(e20);
  },
  insertPragma: function(e20) {
    return `# @format

${e20}`;
  }
};
var VR = {
  locStart: function(e20) {
    return e20.position.start.offset;
  },
  locEnd: function(e20) {
    return e20.position.end.offset;
  }
};
var WR = function(e20, t2, n2, r2) {
  if (e20.getValue().type === "root" && r2.filepath && /(?:[/\\]|^)\.(?:prettier|stylelint)rc$/.test(r2.filepath))
    return n2(r2.originalText, Object.assign(Object.assign({}, r2), {}, { parser: "json" }));
};
const { getLast: qR, isNonEmptyArray: UR } = yi$2;
function zR(e20, t2) {
  return e20 && typeof e20.type == "string" && (!t2 || t2.includes(e20.type));
}
function GR(e20) {
  return e20.value.trim() === "prettier-ignore";
}
function HR(e20) {
  return e20 && UR(e20.leadingComments);
}
function JR(e20) {
  return e20 && UR(e20.middleComments);
}
function XR(e20) {
  return e20 && e20.indicatorComment;
}
function YR(e20) {
  return e20 && e20.trailingComment;
}
function KR(e20) {
  return e20 && UR(e20.endComments);
}
function QR(e20) {
  const t2 = [];
  let n2;
  for (const r2 of e20.split(/( +)/))
    r2 !== " " ? n2 === " " ? t2.push(r2) : t2.push((t2.pop() || "") + r2) : n2 === void 0 && t2.unshift(""), n2 = r2;
  return n2 === " " && t2.push((t2.pop() || "") + " "), t2[0] === "" && (t2.shift(), t2.unshift(" " + (t2.shift() || ""))), t2;
}
var ZR = {
  getLast: qR,
  getAncestorCount: function(e20, t2) {
    let n2 = 0;
    const r2 = e20.stack.length - 1;
    for (let i2 = 0; i2 < r2; i2++) {
      const r3 = e20.stack[i2];
      zR(r3) && t2(r3) && n2++;
    }
    return n2;
  },
  isNode: zR,
  isEmptyNode: function(e20) {
    return !UR(e20.children) && !function(e21) {
      return HR(e21) || JR(e21) || XR(e21) || YR(e21) || KR(e21);
    }(e20);
  },
  isInlineNode: function(e20) {
    if (!e20)
      return true;
    switch (e20.type) {
      case "plain":
      case "quoteDouble":
      case "quoteSingle":
      case "alias":
      case "flowMapping":
      case "flowSequence":
        return true;
      default:
        return false;
    }
  },
  mapNode: function e12(t2, n2, r2) {
    return n2("children" in t2 ? Object.assign(Object.assign({}, t2), {}, { children: t2.children.map((r3) => e12(r3, n2, t2)) }) : t2, r2);
  },
  defineShortcut: function(e20, t2, n2) {
    Object.defineProperty(e20, t2, { get: n2, enumerable: false });
  },
  isNextLineEmpty: function(e20, t2) {
    let n2 = 0;
    const r2 = t2.length;
    for (let i2 = e20.position.end.offset - 1; i2 < r2; i2++) {
      const e21 = t2[i2];
      if (e21 === "\n" && n2++, n2 === 1 && /\S/.test(e21))
        return false;
      if (n2 === 2)
        return true;
    }
    return false;
  },
  isLastDescendantNode: function(e20) {
    switch (e20.getValue().type) {
      case "tag":
      case "anchor":
      case "comment":
        return false;
    }
    const t2 = e20.stack.length;
    for (let n2 = 1; n2 < t2; n2++) {
      const t3 = e20.stack[n2], r2 = e20.stack[n2 - 1];
      if (Array.isArray(r2) && typeof t3 == "number" && t3 !== r2.length - 1)
        return false;
    }
    return true;
  },
  getBlockValueLineContents: function(e20, { parentIndent: t2, isLastDescendant: n2, options: r2 }) {
    const i2 = e20.position.start.line === e20.position.end.line ? "" : r2.originalText.slice(e20.position.start.offset, e20.position.end.offset).match(/^[^\n]*?\n(.*)$/s)[1], u2 = e20.indent === null ? ((e21) => e21 ? e21[1].length : Number.POSITIVE_INFINITY)(i2.match(/^( *)\S/m)) : e20.indent - 1 + t2, o2 = i2.split("\n").map((e21) => e21.slice(u2));
    return r2.proseWrap === "preserve" || e20.type === "blockLiteral" ? s2(o2.map((e21) => e21.length === 0 ? [] : [e21])) : s2(o2.map((e21) => e21.length === 0 ? [] : QR(e21)).reduce((e21, t3, n3) => n3 !== 0 && o2[n3 - 1].length > 0 && t3.length > 0 && !/^\s/.test(t3[0]) && !/^\s|\s$/.test(qR(e21)) ? [...e21.slice(0, -1), [...qR(e21), ...t3]] : [...e21, t3], []).map((e21) => e21.reduce((e22, t3) => e22.length > 0 && /\s$/.test(qR(e22)) ? [...e22.slice(0, -1), qR(e22) + " " + t3] : [...e22, t3], [])).map((e21) => r2.proseWrap === "never" ? [e21.join(" ")] : e21));
    function s2(t3) {
      if (e20.chomping === "keep")
        return qR(t3).length === 0 ? t3.slice(0, -1) : t3;
      let r3 = 0;
      for (let e21 = t3.length - 1; e21 >= 0 && t3[e21].length === 0; e21--)
        r3++;
      return r3 === 0 ? t3 : r3 >= 2 && !n2 ? t3.slice(0, -(r3 - 1)) : t3.slice(0, -r3);
    }
  },
  getFlowScalarLineContents: function(e20, t2, n2) {
    const r2 = t2.split("\n").map((e21, t3, n3) => t3 === 0 && t3 === n3.length - 1 ? e21 : t3 !== 0 && t3 !== n3.length - 1 ? e21.trim() : t3 === 0 ? e21.trimEnd() : e21.trimStart());
    return n2.proseWrap === "preserve" ? r2.map((e21) => e21.length === 0 ? [] : [e21]) : r2.map((e21) => e21.length === 0 ? [] : QR(e21)).reduce((t3, n3, i2) => i2 !== 0 && r2[i2 - 1].length > 0 && n3.length > 0 && (e20 !== "quoteDouble" || !qR(qR(t3)).endsWith("\\")) ? [...t3.slice(0, -1), [...qR(t3), ...n3]] : [...t3, n3], []).map((e21) => n2.proseWrap === "never" ? [e21.join(" ")] : e21);
  },
  getLastDescendantNode: function e13(t2) {
    return UR(t2.children) ? e13(qR(t2.children)) : t2;
  },
  hasPrettierIgnore: function(e20) {
    const t2 = e20.getValue();
    if (t2.type === "documentBody") {
      const t3 = e20.getParentNode();
      return KR(t3.head) && GR(qR(t3.head.endComments));
    }
    return HR(t2) && GR(qR(t2.leadingComments));
  },
  hasLeadingComments: HR,
  hasMiddleComments: JR,
  hasIndicatorComment: XR,
  hasTrailingComment: YR,
  hasEndComments: KR
};
const { defineShortcut: e$, mapNode: t$ } = ZR;
function n$(e20) {
  switch (e20.type) {
    case "document":
      e$(e20, "head", () => e20.children[0]), e$(e20, "body", () => e20.children[1]);
      break;
    case "documentBody":
    case "sequenceItem":
    case "flowSequenceItem":
    case "mappingKey":
    case "mappingValue":
      e$(e20, "content", () => e20.children[0]);
      break;
    case "mappingItem":
    case "flowMappingItem":
      e$(e20, "key", () => e20.children[0]), e$(e20, "value", () => e20.children[1]);
  }
  return e20;
}
var r$ = function(e20) {
  return t$(e20, n$);
};
const {
  builders: { softline: i$, align: u$ }
} = eu$1, { hasEndComments: o$, isNextLineEmpty: s$, isNode: a$ } = ZR, c$ = new WeakMap();
function l$(e20) {
  return o$(e20) && !a$(e20, ["documentHead", "documentBody", "flowMapping", "flowSequence"]);
}
var p$ = {
  alignWithSpaces: function(e20, t2) {
    return u$(" ".repeat(e20), t2);
  },
  shouldPrintEndComments: l$,
  printNextEmptyLine: function(e20, t2) {
    const n2 = e20.getValue(), r2 = e20.stack[0];
    let i2;
    return c$.has(r2) ? i2 = c$.get(r2) : (i2 = new Set(), c$.set(r2, i2)), i2.has(n2.position.end.line) || (i2.add(n2.position.end.line), !s$(n2, t2) || l$(e20.getParentNode())) ? "" : i$;
  }
};
const {
  builders: {
    ifBreak: f$,
    line: d$,
    softline: h$,
    hardline: g$,
    join: m$
  }
} = eu$1, { isEmptyNode: y$, getLast: D$, hasEndComments: E$ } = ZR, { printNextEmptyLine: C$, alignWithSpaces: b$ } = p$;
function A$(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = r2.type === "flowMapping", u2 = i2 ? "{" : "[", o2 = i2 ? "}" : "]";
  let s2 = h$;
  i2 && r2.children.length > 0 && n2.bracketSpacing && (s2 = d$);
  const a2 = D$(r2.children), c2 = a2 && a2.type === "flowMappingItem" && y$(a2.key) && y$(a2.value);
  return [
    u2,
    b$(n2.tabWidth, [
      s2,
      v$(e20, t2, n2),
      n2.trailingComma === "none" ? "" : f$(","),
      E$(r2) ? [g$, m$(g$, e20.map(t2, "endComments"))] : ""
    ]),
    c2 ? "" : s2,
    o2
  ];
}
function v$(e20, t2, n2) {
  const r2 = e20.getValue();
  return e20.map((e21, i2) => [
    t2(),
    i2 === r2.children.length - 1 ? "" : [
      ",",
      d$,
      r2.children[i2].position.start.line !== r2.children[i2 + 1].position.start.line ? C$(e21, n2.originalText) : ""
    ]
  ], "children");
}
var F$ = { printFlowMapping: A$, printFlowSequence: A$ };
const {
  builders: {
    conditionalGroup: S$,
    group: x$,
    hardline: w$,
    ifBreak: T$,
    join: B$,
    line: N$
  }
} = eu$1, {
  hasLeadingComments: k$,
  hasMiddleComments: P$,
  hasTrailingComment: O$,
  hasEndComments: I$,
  isNode: L$,
  isEmptyNode: j$,
  isInlineNode: _$
} = ZR, { alignWithSpaces: M$ } = p$;
function R$(e20, t2) {
  if (!e20)
    return true;
  switch (e20.type) {
    case "plain":
    case "quoteSingle":
    case "quoteDouble":
      break;
    case "alias":
      return true;
    default:
      return false;
  }
  if (t2.proseWrap === "preserve")
    return e20.position.start.line === e20.position.end.line;
  if (/\\$/m.test(t2.originalText.slice(e20.position.start.offset, e20.position.end.offset)))
    return false;
  switch (t2.proseWrap) {
    case "never":
      return !e20.value.includes("\n");
    case "always":
      return !/[\n ]/.test(e20.value);
    default:
      return false;
  }
}
var $$ = function(e20, t2, n2, r2, i2) {
  const { key: u2, value: o2 } = e20, s2 = j$(u2), a2 = j$(o2);
  if (s2 && a2)
    return ": ";
  const c2 = r2("key"), l2 = function(e21) {
    return e21.key.content && e21.key.content.type === "alias";
  }(e20) ? " " : "";
  if (a2)
    return e20.type === "flowMappingItem" && t2.type === "flowMapping" ? c2 : e20.type !== "mappingItem" || !R$(u2.content, i2) || O$(u2.content) || t2.tag && t2.tag.value === "tag:yaml.org,2002:set" ? ["? ", M$(2, c2)] : [c2, l2, ":"];
  const p2 = r2("value");
  if (s2)
    return [": ", M$(2, p2)];
  if (k$(o2) || !_$(u2.content))
    return [
      "? ",
      M$(2, c2),
      w$,
      B$("", n2.map(r2, "value", "leadingComments").map((e21) => [e21, w$])),
      ": ",
      M$(2, p2)
    ];
  if (function(e21) {
    if (!e21)
      return true;
    switch (e21.type) {
      case "plain":
      case "quoteDouble":
      case "quoteSingle":
        return e21.position.start.line === e21.position.end.line;
      case "alias":
        return true;
      default:
        return false;
    }
  }(u2.content) && !k$(u2.content) && !P$(u2.content) && !O$(u2.content) && !I$(u2) && !k$(o2.content) && !P$(o2.content) && !I$(o2) && R$(o2.content, i2))
    return [c2, l2, ": ", p2];
  const f2 = Symbol("mappingKey"), d2 = x$([T$("? "), x$(M$(2, c2), { id: f2 })]), h2 = [w$, ": ", M$(2, p2)], g2 = [l2, ":"];
  k$(o2.content) || I$(o2) && o2.content && !L$(o2.content, ["mapping", "sequence"]) || t2.type === "mapping" && O$(u2.content) && _$(o2.content) || L$(o2.content, ["mapping", "sequence"]) && o2.content.tag === null && o2.content.anchor === null ? g2.push(w$) : o2.content && g2.push(N$), g2.push(p2);
  const m2 = M$(i2.tabWidth, g2);
  return !R$(u2.content, i2) || k$(u2.content) || P$(u2.content) || I$(u2) ? S$([[d2, T$(h2, m2, { groupId: f2 })]]) : S$([[c2, m2]]);
};
const {
  builders: {
    dedent: V$,
    dedentToRoot: W$,
    fill: q$,
    hardline: U$,
    join: z$,
    line: G$,
    literalline: H$,
    markAsRoot: J$
  },
  utils: { getDocParts: X$ }
} = eu$1, {
  getAncestorCount: Y$,
  getBlockValueLineContents: K$,
  hasIndicatorComment: Q$,
  isLastDescendantNode: Z$,
  isNode: eV
} = ZR, { alignWithSpaces: tV } = p$;
var nV = function(e20, t2, n2) {
  const r2 = e20.getValue(), i2 = Y$(e20, (e21) => eV(e21, ["sequence", "mapping"])), u2 = Z$(e20), o2 = [r2.type === "blockFolded" ? ">" : "|"];
  r2.indent !== null && o2.push(r2.indent.toString()), r2.chomping !== "clip" && o2.push(r2.chomping === "keep" ? "+" : "-"), Q$(r2) && o2.push(" ", t2("indicatorComment"));
  const s2 = K$(r2, { parentIndent: i2, isLastDescendant: u2, options: n2 }), a2 = [];
  for (const [e21, t3] of s2.entries())
    e21 === 0 && a2.push(U$), a2.push(q$(X$(z$(G$, t3)))), e21 !== s2.length - 1 ? a2.push(t3.length === 0 ? U$ : J$(H$)) : r2.chomping === "keep" && u2 && a2.push(W$(t3.length === 0 ? U$ : H$));
  return r2.indent === null ? o2.push(V$(tV(n2.tabWidth, a2))) : o2.push(W$(tV(r2.indent - 1 + i2, a2))), o2;
};
const {
  builders: {
    breakParent: rV,
    fill: iV,
    group: uV,
    hardline: oV,
    join: sV,
    line: aV,
    lineSuffix: cV,
    literalline: lV
  },
  utils: { getDocParts: pV, replaceTextEndOfLine: fV }
} = eu$1, { isPreviousLineEmpty: dV } = yi$2, { insertPragma: hV, isPragma: gV } = $R, { locStart: mV } = VR, {
  getFlowScalarLineContents: yV,
  getLastDescendantNode: DV,
  hasLeadingComments: EV,
  hasMiddleComments: CV,
  hasTrailingComment: bV,
  hasEndComments: AV,
  hasPrettierIgnore: vV,
  isLastDescendantNode: FV,
  isNode: SV,
  isInlineNode: xV
} = ZR, {
  alignWithSpaces: wV,
  printNextEmptyLine: TV,
  shouldPrintEndComments: BV
} = p$, { printFlowMapping: NV, printFlowSequence: kV } = F$;
function PV(e20, t2) {
  return bV(e20) || t2 && (t2.head.children.length > 0 || AV(t2.head));
}
function OV(e20, t2, n2) {
  const r2 = yV(e20, t2, n2);
  return sV(oV, r2.map((e21) => iV(pV(sV(aV, e21)))));
}
var IV = {
  preprocess: r$,
  embed: WR,
  print: function(e20, t2, n2) {
    const r2 = e20.getValue(), i2 = [];
    r2.type !== "mappingValue" && EV(r2) && i2.push([sV(oV, e20.map(n2, "leadingComments")), oV]);
    const { tag: u2, anchor: o2 } = r2;
    u2 && i2.push(n2("tag")), u2 && o2 && i2.push(" "), o2 && i2.push(n2("anchor"));
    let s2 = "";
    SV(r2, [
      "mapping",
      "sequence",
      "comment",
      "directive",
      "mappingItem",
      "sequenceItem"
    ]) && !FV(e20) && (s2 = TV(e20, t2.originalText)), (u2 || o2) && (SV(r2, ["sequence", "mapping"]) && !CV(r2) ? i2.push(oV) : i2.push(" ")), CV(r2) && i2.push([
      r2.middleComments.length === 1 ? "" : oV,
      sV(oV, e20.map(n2, "middleComments")),
      oV
    ]);
    const a2 = e20.getParentNode();
    return vV(e20) ? i2.push(fV(t2.originalText.slice(r2.position.start.offset, r2.position.end.offset).trimEnd(), lV)) : i2.push(uV(function(e21, t3, n3, r3, i3) {
      switch (e21.type) {
        case "root": {
          const { children: t4 } = e21, r4 = [];
          n3.each((e22, n4) => {
            const u4 = t4[n4], o3 = t4[n4 + 1];
            n4 !== 0 && r4.push(oV), r4.push(i3()), PV(u4, o3) ? (r4.push(oV, "..."), bV(u4) && r4.push(" ", i3("trailingComment"))) : o3 && !bV(o3.head) && r4.push(oV, "---");
          }, "children");
          const u3 = DV(e21);
          return SV(u3, [
            "blockLiteral",
            "blockFolded"
          ]) && u3.chomping === "keep" || r4.push(oV), r4;
        }
        case "document": {
          const u3 = [];
          return function(e22, t4, n4, r4) {
            if (n4.children[0] === e22 && /---(?:\s|$)/.test(r4.originalText.slice(mV(e22), mV(e22) + 4)) || e22.head.children.length > 0 || AV(e22.head) || bV(e22.head))
              return "head";
            if (PV(e22, t4))
              return false;
            return !!t4 && "root";
          }(e21, t3.children[n3.getName() + 1], t3, r3) === "head" && ((e21.head.children.length > 0 || e21.head.endComments.length > 0) && u3.push(i3("head")), bV(e21.head) ? u3.push([
            "---",
            " ",
            i3([
              "head",
              "trailingComment"
            ])
          ]) : u3.push("---")), function(e22) {
            return e22.body.children.length > 0 || AV(e22.body);
          }(e21) && u3.push(i3("body")), sV(oV, u3);
        }
        case "documentHead":
          return sV(oV, [
            ...n3.map(i3, "children"),
            ...n3.map(i3, "endComments")
          ]);
        case "documentBody": {
          const {
            children: t4,
            endComments: r4
          } = e21;
          let u3 = "";
          if (t4.length > 0 && r4.length > 0) {
            const t5 = DV(e21);
            SV(t5, [
              "blockFolded",
              "blockLiteral"
            ]) ? t5.chomping !== "keep" && (u3 = [oV, oV]) : u3 = oV;
          }
          return [
            sV(oV, n3.map(i3, "children")),
            u3,
            sV(oV, n3.map(i3, "endComments"))
          ];
        }
        case "directive":
          return [
            "%",
            sV(" ", [
              e21.name,
              ...e21.parameters
            ])
          ];
        case "comment":
          return ["#", e21.value];
        case "alias":
          return ["*", e21.value];
        case "tag":
          return r3.originalText.slice(e21.position.start.offset, e21.position.end.offset);
        case "anchor":
          return ["&", e21.value];
        case "plain":
          return OV(e21.type, r3.originalText.slice(e21.position.start.offset, e21.position.end.offset), r3);
        case "quoteDouble":
        case "quoteSingle": {
          const t4 = "'", n4 = '"', i4 = r3.originalText.slice(e21.position.start.offset + 1, e21.position.end.offset - 1);
          if (e21.type === "quoteSingle" && i4.includes("\\") || e21.type === "quoteDouble" && /\\[^"]/.test(i4)) {
            const u4 = e21.type === "quoteDouble" ? n4 : t4;
            return [u4, OV(e21.type, i4, r3), u4];
          }
          if (i4.includes(n4))
            return [
              t4,
              OV(e21.type, e21.type === "quoteDouble" ? i4.replace(/\\"/g, n4).replace(/'/g, t4.repeat(2)) : i4, r3),
              t4
            ];
          if (i4.includes(t4))
            return [
              n4,
              OV(e21.type, e21.type === "quoteSingle" ? i4.replace(/''/g, t4) : i4, r3),
              n4
            ];
          const u3 = r3.singleQuote ? t4 : n4;
          return [u3, OV(e21.type, i4, r3), u3];
        }
        case "blockFolded":
        case "blockLiteral":
          return nV(n3, i3, r3);
        case "mapping":
        case "sequence":
          return sV(oV, n3.map(i3, "children"));
        case "sequenceItem":
          return [
            "- ",
            wV(2, e21.content ? i3("content") : "")
          ];
        case "mappingKey":
        case "mappingValue":
          return e21.content ? i3("content") : "";
        case "mappingItem":
        case "flowMappingItem":
          return $$(e21, t3, n3, i3, r3);
        case "flowMapping":
          return NV(n3, i3, r3);
        case "flowSequence":
          return kV(n3, i3, r3);
        case "flowSequenceItem":
          return i3("content");
        default:
          throw new Error(`Unexpected node type ${e21.type}`);
      }
    }(r2, a2, e20, t2, n2))), bV(r2) && !SV(r2, ["document", "documentHead"]) && i2.push(cV([
      r2.type !== "mappingValue" || r2.content ? " " : "",
      a2.type === "mappingKey" && e20.getParentNode(2).type === "mapping" && xV(r2) ? "" : rV,
      n2("trailingComment")
    ])), BV(r2) && i2.push(wV(r2.type === "sequenceItem" ? 2 : 0, [
      oV,
      sV(oV, e20.map((e21) => [
        dV(t2.originalText, e21.getValue(), mV) ? oV : "",
        n2()
      ], "endComments"))
    ])), i2.push(s2), i2;
  },
  massageAstNode: function(e20, t2) {
    if (SV(t2))
      switch (delete t2.position, t2.type) {
        case "comment":
          if (gV(t2.value))
            return null;
          break;
        case "quoteDouble":
        case "quoteSingle":
          t2.type = "quote";
      }
  },
  insertPragma: hV
}, LV = {
  bracketSpacing: WB.bracketSpacing,
  singleQuote: WB.singleQuote,
  proseWrap: WB.proseWrap
};
var jV = [
  YB,
  nP,
  fO,
  OO,
  cL,
  RR,
  {
    languages: [
      Xd({
        name: "YAML",
        type: "data",
        color: "#cb171e",
        tmScope: "source.yaml",
        aliases: ["yml"],
        extensions: [
          ".yml",
          ".mir",
          ".reek",
          ".rviz",
          ".sublime-syntax",
          ".syntax",
          ".yaml",
          ".yaml-tmlanguage",
          ".yaml.sed",
          ".yml.mysql"
        ],
        filenames: [
          ".clang-format",
          ".clang-tidy",
          ".gemrc",
          "glide.lock",
          "yarn.lock"
        ],
        aceMode: "yaml",
        codemirrorMode: "yaml",
        codemirrorMimeType: "text/x-yaml",
        languageId: 407
      }, (e20) => ({
        since: "1.14.0",
        parsers: ["yaml"],
        vscodeLanguageIds: ["yaml", "ansible", "home-assistant"],
        filenames: [
          ...e20.filenames.filter((e21) => e21 !== "yarn.lock"),
          ".prettierrc",
          ".stylelintrc"
        ]
      }))
    ],
    printers: { yaml: IV },
    options: LV,
    parsers: void 0
  }
];
const { version: _V } = e$3, { getSupportInfo: MV } = Qr$2;
function RV(e20, t2 = 1) {
  return (...n2) => {
    const r2 = n2[t2] || {}, i2 = r2.plugins || [];
    return n2[t2] = Object.assign(Object.assign({}, r2), {}, {
      plugins: [
        ...jV,
        ...Array.isArray(i2) ? i2 : Object.values(i2)
      ]
    }), e20(...n2);
  };
}
const $V = RV(vd.formatWithCursor);
var VV = {
  formatWithCursor: $V,
  format: (e20, t2) => $V(e20, t2).formatted,
  check(e20, t2) {
    const { formatted: n2 } = $V(e20, t2);
    return n2 === e20;
  },
  doc: eu$1,
  getSupportInfo: RV(MV, 0),
  version: _V,
  util: Hd,
  __debug: {
    parse: RV(vd.parse),
    formatAST: RV(vd.formatAST),
    formatDoc: RV(vd.formatDoc),
    printToDoc: RV(vd.printToDoc),
    printDocToString: RV(vd.printDocToString)
  }
};
var e$2 = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
function t$2(e20) {
  return e20 && Object.prototype.hasOwnProperty.call(e20, "default") ? e20.default : e20;
}
function s$2(e20) {
  var t2 = { exports: {} };
  return e20(t2, t2.exports), t2.exports;
}
var r$2, i$2, a$2 = function(e20) {
  return e20 && e20.Math == Math && e20;
}, n$2 = a$2(typeof globalThis == "object" && globalThis) || a$2(typeof window == "object" && window) || a$2(typeof self == "object" && self) || a$2(typeof e$2 == "object" && e$2) || function() {
  return this;
}() || Function("return this")(), o$2 = function(e20) {
  try {
    return !!e20();
  } catch (e21) {
    return true;
  }
}, u$2 = !o$2(function() {
  return Object.defineProperty({}, 1, {
    get: function() {
      return 7;
    }
  })[1] != 7;
}), h$2 = {}.propertyIsEnumerable, c$2 = Object.getOwnPropertyDescriptor, p$2 = {
  f: c$2 && !h$2.call({ 1: 2 }, 1) ? function(e20) {
    var t2 = c$2(this, e20);
    return !!t2 && t2.enumerable;
  } : h$2
}, l$2 = function(e20, t2) {
  return {
    enumerable: !(1 & e20),
    configurable: !(2 & e20),
    writable: !(4 & e20),
    value: t2
  };
}, d$2 = {}.toString, D$2 = function(e20) {
  return d$2.call(e20).slice(8, -1);
}, m$2 = "".split, f$2 = o$2(function() {
  return !Object("z").propertyIsEnumerable(0);
}) ? function(e20) {
  return D$2(e20) == "String" ? m$2.call(e20, "") : Object(e20);
} : Object, y$2 = function(e20) {
  if (e20 == null)
    throw TypeError("Can't call method on " + e20);
  return e20;
}, A$2 = function(e20) {
  return f$2(y$2(e20));
}, E$2 = function(e20) {
  return typeof e20 == "object" ? e20 !== null : typeof e20 == "function";
}, C$2 = function(e20) {
  return typeof e20 == "function" ? e20 : void 0;
}, x$2 = function(e20, t2) {
  return arguments.length < 2 ? C$2(n$2[e20]) : n$2[e20] && n$2[e20][t2];
}, F$2 = x$2("navigator", "userAgent") || "", g$2 = n$2.process, b$2 = n$2.Deno, P$2 = g$2 && g$2.versions || b$2 && b$2.version, T$2 = P$2 && P$2.v8;
T$2 ? i$2 = (r$2 = T$2.split("."))[0] < 4 ? 1 : r$2[0] + r$2[1] : F$2 && (!(r$2 = F$2.match(/Edge\/(\d+)/)) || r$2[1] >= 74) && (r$2 = F$2.match(/Chrome\/(\d+)/)) && (i$2 = r$2[1]);
var w$2 = i$2 && +i$2, S$2 = !!Object.getOwnPropertySymbols && !o$2(function() {
  var e20 = Symbol();
  return !String(e20) || !(Object(e20) instanceof Symbol) || !Symbol.sham && w$2 && w$2 < 41;
}), B$2 = S$2 && !Symbol.sham && typeof Symbol.iterator == "symbol", N$2 = B$2 ? function(e20) {
  return typeof e20 == "symbol";
} : function(e20) {
  var t2 = x$2("Symbol");
  return typeof t2 == "function" && Object(e20) instanceof t2;
}, I$2 = function(e20, t2) {
  try {
    Object.defineProperty(n$2, e20, {
      value: t2,
      configurable: true,
      writable: true
    });
  } catch (s2) {
    n$2[e20] = t2;
  }
  return t2;
}, v$2 = n$2["__core-js_shared__"] || I$2("__core-js_shared__", {}), k$2 = s$2(function(e20) {
  (e20.exports = function(e21, t2) {
    return v$2[e21] || (v$2[e21] = t2 !== void 0 ? t2 : {});
  })("versions", []).push({
    version: "3.17.3",
    mode: "global",
    copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)"
  });
}), L$2 = function(e20) {
  return Object(y$2(e20));
}, O$2 = {}.hasOwnProperty, M$2 = Object.hasOwn || function(e20, t2) {
  return O$2.call(L$2(e20), t2);
}, R$2 = 0, j$2 = Math.random(), _$2 = function(e20) {
  return "Symbol(" + String(e20 === void 0 ? "" : e20) + ")_" + (++R$2 + j$2).toString(36);
}, U$2 = k$2("wks"), q$2 = n$2.Symbol, $$2 = B$2 ? q$2 : q$2 && q$2.withoutSetter || _$2, H$2 = function(e20) {
  return M$2(U$2, e20) && (S$2 || typeof U$2[e20] == "string") || (S$2 && M$2(q$2, e20) ? U$2[e20] = q$2[e20] : U$2[e20] = $$2("Symbol." + e20)), U$2[e20];
}, V$2 = H$2("toPrimitive"), z$2 = function(e20, t2) {
  if (!E$2(e20) || N$2(e20))
    return e20;
  var s2, r2 = e20[V$2];
  if (r2 !== void 0) {
    if (t2 === void 0 && (t2 = "default"), s2 = r2.call(e20, t2), !E$2(s2) || N$2(s2))
      return s2;
    throw TypeError("Can't convert object to primitive value");
  }
  return t2 === void 0 && (t2 = "number"), function(e21, t3) {
    var s3, r3;
    if (t3 === "string" && typeof (s3 = e21.toString) == "function" && !E$2(r3 = s3.call(e21)))
      return r3;
    if (typeof (s3 = e21.valueOf) == "function" && !E$2(r3 = s3.call(e21)))
      return r3;
    if (t3 !== "string" && typeof (s3 = e21.toString) == "function" && !E$2(r3 = s3.call(e21)))
      return r3;
    throw TypeError("Can't convert object to primitive value");
  }(e20, t2);
}, W$2 = function(e20) {
  var t2 = z$2(e20, "string");
  return N$2(t2) ? t2 : String(t2);
}, G$2 = n$2.document, K$2 = E$2(G$2) && E$2(G$2.createElement), X$2 = !u$2 && !o$2(function() {
  return Object.defineProperty((e20 = "div", K$2 ? G$2.createElement(e20) : {}), "a", {
    get: function() {
      return 7;
    }
  }).a != 7;
  var e20;
}), J$2 = Object.getOwnPropertyDescriptor, Y$2 = {
  f: u$2 ? J$2 : function(e20, t2) {
    if (e20 = A$2(e20), t2 = W$2(t2), X$2)
      try {
        return J$2(e20, t2);
      } catch (e21) {
      }
    if (M$2(e20, t2))
      return l$2(!p$2.f.call(e20, t2), e20[t2]);
  }
}, Q$2 = function(e20) {
  if (!E$2(e20))
    throw TypeError(String(e20) + " is not an object");
  return e20;
}, Z$2 = Object.defineProperty, ee$2 = {
  f: u$2 ? Z$2 : function(e20, t2, s2) {
    if (Q$2(e20), t2 = W$2(t2), Q$2(s2), X$2)
      try {
        return Z$2(e20, t2, s2);
      } catch (e21) {
      }
    if ("get" in s2 || "set" in s2)
      throw TypeError("Accessors not supported");
    return "value" in s2 && (e20[t2] = s2.value), e20;
  }
}, te$2 = u$2 ? function(e20, t2, s2) {
  return ee$2.f(e20, t2, l$2(1, s2));
} : function(e20, t2, s2) {
  return e20[t2] = s2, e20;
}, se$2 = Function.toString;
typeof v$2.inspectSource != "function" && (v$2.inspectSource = function(e20) {
  return se$2.call(e20);
});
var re$2, ie$2, ae$2, ne$2, oe$2 = v$2.inspectSource, ue$2 = n$2.WeakMap, he$2 = typeof ue$2 == "function" && /native code/.test(oe$2(ue$2)), ce$2 = k$2("keys"), pe$2 = {}, le$2 = n$2.WeakMap;
if (he$2 || v$2.state) {
  var de$2 = v$2.state || (v$2.state = new le$2()), De$2 = de$2.get, me$2 = de$2.has, fe$2 = de$2.set;
  re$2 = function(e20, t2) {
    if (me$2.call(de$2, e20))
      throw new TypeError("Object already initialized");
    return t2.facade = e20, fe$2.call(de$2, e20, t2), t2;
  }, ie$2 = function(e20) {
    return De$2.call(de$2, e20) || {};
  }, ae$2 = function(e20) {
    return me$2.call(de$2, e20);
  };
} else {
  var ye$2 = ce$2[ne$2 = "state"] || (ce$2[ne$2] = _$2(ne$2));
  pe$2[ye$2] = true, re$2 = function(e20, t2) {
    if (M$2(e20, ye$2))
      throw new TypeError("Object already initialized");
    return t2.facade = e20, te$2(e20, ye$2, t2), t2;
  }, ie$2 = function(e20) {
    return M$2(e20, ye$2) ? e20[ye$2] : {};
  }, ae$2 = function(e20) {
    return M$2(e20, ye$2);
  };
}
var Ae$2 = {
  set: re$2,
  get: ie$2,
  has: ae$2,
  enforce: function(e20) {
    return ae$2(e20) ? ie$2(e20) : re$2(e20, {});
  },
  getterFor: function(e20) {
    return function(t2) {
      var s2;
      if (!E$2(t2) || (s2 = ie$2(t2)).type !== e20)
        throw TypeError("Incompatible receiver, " + e20 + " required");
      return s2;
    };
  }
}, Ee$2 = s$2(function(e20) {
  var t2 = Ae$2.get, s2 = Ae$2.enforce, r2 = String(String).split("String");
  (e20.exports = function(e21, t3, i2, a2) {
    var o2, u2 = !!a2 && !!a2.unsafe, h2 = !!a2 && !!a2.enumerable, c2 = !!a2 && !!a2.noTargetGet;
    typeof i2 == "function" && (typeof t3 != "string" || M$2(i2, "name") || te$2(i2, "name", t3), (o2 = s2(i2)).source || (o2.source = r2.join(typeof t3 == "string" ? t3 : ""))), e21 !== n$2 ? (u2 ? !c2 && e21[t3] && (h2 = true) : delete e21[t3], h2 ? e21[t3] = i2 : te$2(e21, t3, i2)) : h2 ? e21[t3] = i2 : I$2(t3, i2);
  })(Function.prototype, "toString", function() {
    return typeof this == "function" && t2(this).source || oe$2(this);
  });
}), Ce$2 = Math.ceil, xe$2 = Math.floor, Fe$2 = function(e20) {
  return isNaN(e20 = +e20) ? 0 : (e20 > 0 ? xe$2 : Ce$2)(e20);
}, ge$2 = Math.min, be$2 = function(e20) {
  return e20 > 0 ? ge$2(Fe$2(e20), 9007199254740991) : 0;
}, Pe$2 = Math.max, Te$2 = Math.min, we$2 = function(e20) {
  return function(t2, s2, r2) {
    var i2, a2 = A$2(t2), n2 = be$2(a2.length), o2 = function(e21, t3) {
      var s3 = Fe$2(e21);
      return s3 < 0 ? Pe$2(s3 + t3, 0) : Te$2(s3, t3);
    }(r2, n2);
    if (e20 && s2 != s2) {
      for (; n2 > o2; )
        if ((i2 = a2[o2++]) != i2)
          return true;
    } else
      for (; n2 > o2; o2++)
        if ((e20 || o2 in a2) && a2[o2] === s2)
          return e20 || o2 || 0;
    return !e20 && -1;
  };
}, Se$2 = { includes: we$2(true), indexOf: we$2(false) }.indexOf, Be$2 = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf"
].concat("length", "prototype"), Ne$2 = {
  f: Object.getOwnPropertyNames || function(e20) {
    return function(e21, t2) {
      var s2, r2 = A$2(e21), i2 = 0, a2 = [];
      for (s2 in r2)
        !M$2(pe$2, s2) && M$2(r2, s2) && a2.push(s2);
      for (; t2.length > i2; )
        M$2(r2, s2 = t2[i2++]) && (~Se$2(a2, s2) || a2.push(s2));
      return a2;
    }(e20, Be$2);
  }
}, Ie$2 = { f: Object.getOwnPropertySymbols }, ve$2 = x$2("Reflect", "ownKeys") || function(e20) {
  var t2 = Ne$2.f(Q$2(e20)), s2 = Ie$2.f;
  return s2 ? t2.concat(s2(e20)) : t2;
}, ke$2 = function(e20, t2) {
  for (var s2 = ve$2(t2), r2 = ee$2.f, i2 = Y$2.f, a2 = 0; a2 < s2.length; a2++) {
    var n2 = s2[a2];
    M$2(e20, n2) || r2(e20, n2, i2(t2, n2));
  }
}, Le$2 = /#|\.prototype\./, Oe$2 = function(e20, t2) {
  var s2 = Re$2[Me$2(e20)];
  return s2 == _e$2 || s2 != je$2 && (typeof t2 == "function" ? o$2(t2) : !!t2);
}, Me$2 = Oe$2.normalize = function(e20) {
  return String(e20).replace(Le$2, ".").toLowerCase();
}, Re$2 = Oe$2.data = {}, je$2 = Oe$2.NATIVE = "N", _e$2 = Oe$2.POLYFILL = "P", Ue$2 = Oe$2, qe$2 = Y$2.f, $e$2 = function(e20, t2) {
  var s2, r2, i2, a2, o2, u2 = e20.target, h2 = e20.global, c2 = e20.stat;
  if (s2 = h2 ? n$2 : c2 ? n$2[u2] || I$2(u2, {}) : (n$2[u2] || {}).prototype)
    for (r2 in t2) {
      if (a2 = t2[r2], i2 = e20.noTargetGet ? (o2 = qe$2(s2, r2)) && o2.value : s2[r2], !Ue$2(h2 ? r2 : u2 + (c2 ? "." : "#") + r2, e20.forced) && i2 !== void 0) {
        if (typeof a2 == typeof i2)
          continue;
        ke$2(a2, i2);
      }
      (e20.sham || i2 && i2.sham) && te$2(a2, "sham", true), Ee$2(s2, r2, a2, e20);
    }
}, He$2 = Array.isArray || function(e20) {
  return D$2(e20) == "Array";
}, Ve$2 = function(e20) {
  if (typeof e20 != "function")
    throw TypeError(String(e20) + " is not a function");
  return e20;
}, ze$2 = function(e20, t2, s2) {
  if (Ve$2(e20), t2 === void 0)
    return e20;
  switch (s2) {
    case 0:
      return function() {
        return e20.call(t2);
      };
    case 1:
      return function(s3) {
        return e20.call(t2, s3);
      };
    case 2:
      return function(s3, r2) {
        return e20.call(t2, s3, r2);
      };
    case 3:
      return function(s3, r2, i2) {
        return e20.call(t2, s3, r2, i2);
      };
  }
  return function() {
    return e20.apply(t2, arguments);
  };
}, We$2 = function(e20, t2, s2, r2, i2, a2, n2, o2) {
  for (var u2, h2 = i2, c2 = 0, p2 = !!n2 && ze$2(n2, o2, 3); c2 < r2; ) {
    if (c2 in s2) {
      if (u2 = p2 ? p2(s2[c2], c2, t2) : s2[c2], a2 > 0 && He$2(u2))
        h2 = We$2(e20, t2, u2, be$2(u2.length), h2, a2 - 1) - 1;
      else {
        if (h2 >= 9007199254740991)
          throw TypeError("Exceed the acceptable array length");
        e20[h2] = u2;
      }
      h2++;
    }
    c2++;
  }
  return h2;
}, Ge$2 = We$2, Ke$2 = H$2("species"), Xe$2 = function(e20, t2) {
  return new (function(e21) {
    var t3;
    return He$2(e21) && (typeof (t3 = e21.constructor) != "function" || t3 !== Array && !He$2(t3.prototype) ? E$2(t3) && (t3 = t3[Ke$2]) === null && (t3 = void 0) : t3 = void 0), t3 === void 0 ? Array : t3;
  }(e20))(t2 === 0 ? 0 : t2);
};
$e$2({ target: "Array", proto: true }, {
  flatMap: function(e20) {
    var t2, s2 = L$2(this), r2 = be$2(s2.length);
    return Ve$2(e20), (t2 = Xe$2(s2, 0)).length = Ge$2(t2, s2, s2, r2, 0, 1, e20, arguments.length > 1 ? arguments[1] : void 0), t2;
  }
});
var Je$2 = function(...e20) {
  let t2;
  for (const [s2, r2] of e20.entries())
    try {
      return { result: r2() };
    } catch (e21) {
      s2 === 0 && (t2 = e21);
    }
  return { error: t2 };
}, Ye$2 = (e20) => typeof e20 == "string" ? e20.replace((({ onlyFirst: e21 = false } = {}) => {
  const t2 = [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
  ].join("|");
  return new RegExp(t2, e21 ? void 0 : "g");
})(), "") : e20;
const Qe$2 = (e20) => !Number.isNaN(e20) && e20 >= 4352 && (e20 <= 4447 || e20 === 9001 || e20 === 9002 || 11904 <= e20 && e20 <= 12871 && e20 !== 12351 || 12880 <= e20 && e20 <= 19903 || 19968 <= e20 && e20 <= 42182 || 43360 <= e20 && e20 <= 43388 || 44032 <= e20 && e20 <= 55203 || 63744 <= e20 && e20 <= 64255 || 65040 <= e20 && e20 <= 65049 || 65072 <= e20 && e20 <= 65131 || 65281 <= e20 && e20 <= 65376 || 65504 <= e20 && e20 <= 65510 || 110592 <= e20 && e20 <= 110593 || 127488 <= e20 && e20 <= 127569 || 131072 <= e20 && e20 <= 262141);
var Ze$2 = Qe$2, et$2 = Qe$2;
Ze$2.default = et$2;
const tt$2 = (e20) => {
  if (typeof e20 != "string" || e20.length === 0)
    return 0;
  if ((e20 = Ye$2(e20)).length === 0)
    return 0;
  e20 = e20.replace(/\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g, "  ");
  let t2 = 0;
  for (let s2 = 0; s2 < e20.length; s2++) {
    const r2 = e20.codePointAt(s2);
    r2 <= 31 || r2 >= 127 && r2 <= 159 || r2 >= 768 && r2 <= 879 || (r2 > 65535 && s2++, t2 += Ze$2(r2) ? 2 : 1);
  }
  return t2;
};
var st$2 = tt$2, rt$2 = tt$2;
st$2.default = rt$2;
var it$2 = (e20) => {
  if (typeof e20 != "string")
    throw new TypeError("Expected a string");
  return e20.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
};
var at$2 = (e20) => e20[e20.length - 1];
function nt$2(e20, t2) {
  if (e20 == null)
    return {};
  var s2, r2, i2 = function(e21, t3) {
    if (e21 == null)
      return {};
    var s3, r3, i3 = {}, a3 = Object.keys(e21);
    for (r3 = 0; r3 < a3.length; r3++)
      s3 = a3[r3], t3.indexOf(s3) >= 0 || (i3[s3] = e21[s3]);
    return i3;
  }(e20, t2);
  if (Object.getOwnPropertySymbols) {
    var a2 = Object.getOwnPropertySymbols(e20);
    for (r2 = 0; r2 < a2.length; r2++)
      s2 = a2[r2], t2.indexOf(s2) >= 0 || Object.prototype.propertyIsEnumerable.call(e20, s2) && (i2[s2] = e20[s2]);
  }
  return i2;
}
var ot$2, ut$2, ht$2 = function(e20) {
  if (N$2(e20))
    throw TypeError("Cannot convert a Symbol value to a string");
  return String(e20);
}, ct$2 = Math.floor, pt$2 = function(e20, t2) {
  var s2 = e20.length, r2 = ct$2(s2 / 2);
  return s2 < 8 ? lt$2(e20, t2) : dt$2(pt$2(e20.slice(0, r2), t2), pt$2(e20.slice(r2), t2), t2);
}, lt$2 = function(e20, t2) {
  for (var s2, r2, i2 = e20.length, a2 = 1; a2 < i2; ) {
    for (r2 = a2, s2 = e20[a2]; r2 && t2(e20[r2 - 1], s2) > 0; )
      e20[r2] = e20[--r2];
    r2 !== a2++ && (e20[r2] = s2);
  }
  return e20;
}, dt$2 = function(e20, t2, s2) {
  for (var r2 = e20.length, i2 = t2.length, a2 = 0, n2 = 0, o2 = []; a2 < r2 || n2 < i2; )
    a2 < r2 && n2 < i2 ? o2.push(s2(e20[a2], t2[n2]) <= 0 ? e20[a2++] : t2[n2++]) : o2.push(a2 < r2 ? e20[a2++] : t2[n2++]);
  return o2;
}, Dt$2 = pt$2, mt$2 = F$2.match(/firefox\/(\d+)/i), ft$2 = !!mt$2 && +mt$2[1], yt$2 = /MSIE|Trident/.test(F$2), At$2 = F$2.match(/AppleWebKit\/(\d+)\./), Et$2 = !!At$2 && +At$2[1], Ct$2 = [], xt$2 = Ct$2.sort, Ft$2 = o$2(function() {
  Ct$2.sort(void 0);
}), gt$2 = o$2(function() {
  Ct$2.sort(null);
}), bt$2 = !!(ut$2 = []["sort"]) && o$2(function() {
  ut$2.call(null, ot$2 || function() {
    throw 1;
  }, 1);
}), Pt$1 = !o$2(function() {
  if (w$2)
    return w$2 < 70;
  if (!(ft$2 && ft$2 > 3)) {
    if (yt$2)
      return true;
    if (Et$2)
      return Et$2 < 603;
    var e20, t2, s2, r2, i2 = "";
    for (e20 = 65; e20 < 76; e20++) {
      switch (t2 = String.fromCharCode(e20), e20) {
        case 66:
        case 69:
        case 70:
        case 72:
          s2 = 3;
          break;
        case 68:
        case 71:
          s2 = 4;
          break;
        default:
          s2 = 2;
      }
      for (r2 = 0; r2 < 47; r2++)
        Ct$2.push({ k: t2 + r2, v: s2 });
    }
    for (Ct$2.sort(function(e21, t3) {
      return t3.v - e21.v;
    }), r2 = 0; r2 < Ct$2.length; r2++)
      t2 = Ct$2[r2].k.charAt(0), i2.charAt(i2.length - 1) !== t2 && (i2 += t2);
    return i2 !== "DGBEFHACIJK";
  }
});
$e$2({ target: "Array", proto: true, forced: Ft$2 || !gt$2 || !bt$2 || !Pt$1 }, {
  sort: function(e20) {
    e20 !== void 0 && Ve$2(e20);
    var t2 = L$2(this);
    if (Pt$1)
      return e20 === void 0 ? xt$2.call(t2) : xt$2.call(t2, e20);
    var s2, r2, i2 = [], a2 = be$2(t2.length);
    for (r2 = 0; r2 < a2; r2++)
      r2 in t2 && i2.push(t2[r2]);
    for (s2 = (i2 = Dt$2(i2, function(e21) {
      return function(t3, s3) {
        return s3 === void 0 ? -1 : t3 === void 0 ? 1 : e21 !== void 0 ? +e21(t3, s3) || 0 : ht$2(t3) > ht$2(s3) ? 1 : -1;
      };
    }(e20))).length, r2 = 0; r2 < s2; )
      t2[r2] = i2[r2++];
    for (; r2 < a2; )
      delete t2[r2++];
    return t2;
  }
});
var Tt$1 = {}, wt$2 = H$2("iterator"), St$1 = Array.prototype, Bt$1 = {};
Bt$1[H$2("toStringTag")] = "z";
var Nt$1 = String(Bt$1) === "[object z]", It$1 = H$2("toStringTag"), vt$2 = D$2(function() {
  return arguments;
}()) == "Arguments", kt$2 = Nt$1 ? D$2 : function(e20) {
  var t2, s2, r2;
  return e20 === void 0 ? "Undefined" : e20 === null ? "Null" : typeof (s2 = function(e21, t3) {
    try {
      return e21[t3];
    } catch (e22) {
    }
  }(t2 = Object(e20), It$1)) == "string" ? s2 : vt$2 ? D$2(t2) : (r2 = D$2(t2)) == "Object" && typeof t2.callee == "function" ? "Arguments" : r2;
}, Lt$1 = H$2("iterator"), Ot$2 = function(e20) {
  if (e20 != null)
    return e20[Lt$1] || e20["@@iterator"] || Tt$1[kt$2(e20)];
}, Mt$1 = function(e20, t2, s2) {
  var r2, i2;
  Q$2(e20);
  try {
    if ((r2 = e20.return) === void 0) {
      if (t2 === "throw")
        throw s2;
      return s2;
    }
    r2 = r2.call(e20);
  } catch (e21) {
    i2 = true, r2 = e21;
  }
  if (t2 === "throw")
    throw s2;
  if (i2)
    throw r2;
  return Q$2(r2), s2;
}, Rt$1 = function(e20, t2) {
  this.stopped = e20, this.result = t2;
}, jt$1 = function(e20, t2, s2) {
  var r2, i2, a2, n2, o2, u2, h2, c2, p2 = s2 && s2.that, l2 = !(!s2 || !s2.AS_ENTRIES), d2 = !(!s2 || !s2.IS_ITERATOR), D2 = !(!s2 || !s2.INTERRUPTED), m2 = ze$2(t2, p2, 1 + l2 + D2), f2 = function(e21) {
    return r2 && Mt$1(r2, "normal", e21), new Rt$1(true, e21);
  }, y2 = function(e21) {
    return l2 ? (Q$2(e21), D2 ? m2(e21[0], e21[1], f2) : m2(e21[0], e21[1])) : D2 ? m2(e21, f2) : m2(e21);
  };
  if (d2)
    r2 = e20;
  else {
    if (typeof (i2 = Ot$2(e20)) != "function")
      throw TypeError("Target is not iterable");
    if ((c2 = i2) !== void 0 && (Tt$1.Array === c2 || St$1[wt$2] === c2)) {
      for (a2 = 0, n2 = be$2(e20.length); n2 > a2; a2++)
        if ((o2 = y2(e20[a2])) && o2 instanceof Rt$1)
          return o2;
      return new Rt$1(false);
    }
    r2 = function(e21, t3) {
      var s3 = arguments.length < 2 ? Ot$2(e21) : t3;
      if (typeof s3 != "function")
        throw TypeError(String(e21) + " is not iterable");
      return Q$2(s3.call(e21));
    }(e20, i2);
  }
  for (u2 = r2.next; !(h2 = u2.call(r2)).done; ) {
    try {
      o2 = y2(h2.value);
    } catch (e21) {
      Mt$1(r2, "throw", e21);
    }
    if (typeof o2 == "object" && o2 && o2 instanceof Rt$1)
      return o2;
  }
  return new Rt$1(false);
};
$e$2({ target: "Object", stat: true }, {
  fromEntries: function(e20) {
    var t2 = {};
    return jt$1(e20, function(e21, s2) {
      !function(e22, t3, s3) {
        var r2 = W$2(t3);
        r2 in e22 ? ee$2.f(e22, r2, l$2(0, s3)) : e22[r2] = s3;
      }(t2, e21, s2);
    }, { AS_ENTRIES: true }), t2;
  }
});
var _t$1 = _t$1 !== void 0 ? _t$1 : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {};
function Ut$1() {
  throw new Error("setTimeout has not been defined");
}
function qt$1() {
  throw new Error("clearTimeout has not been defined");
}
var $t$1 = Ut$1, Ht$1 = qt$1;
function Vt$1(e20) {
  if ($t$1 === setTimeout)
    return setTimeout(e20, 0);
  if (($t$1 === Ut$1 || !$t$1) && setTimeout)
    return $t$1 = setTimeout, setTimeout(e20, 0);
  try {
    return $t$1(e20, 0);
  } catch (t2) {
    try {
      return $t$1.call(null, e20, 0);
    } catch (t3) {
      return $t$1.call(this, e20, 0);
    }
  }
}
typeof _t$1.setTimeout == "function" && ($t$1 = setTimeout), typeof _t$1.clearTimeout == "function" && (Ht$1 = clearTimeout);
var zt$1, Wt$1 = [], Gt$1 = false, Kt$1 = -1;
function Xt$1() {
  Gt$1 && zt$1 && (Gt$1 = false, zt$1.length ? Wt$1 = zt$1.concat(Wt$1) : Kt$1 = -1, Wt$1.length && Jt$1());
}
function Jt$1() {
  if (!Gt$1) {
    var e20 = Vt$1(Xt$1);
    Gt$1 = true;
    for (var t2 = Wt$1.length; t2; ) {
      for (zt$1 = Wt$1, Wt$1 = []; ++Kt$1 < t2; )
        zt$1 && zt$1[Kt$1].run();
      Kt$1 = -1, t2 = Wt$1.length;
    }
    zt$1 = null, Gt$1 = false, function(e21) {
      if (Ht$1 === clearTimeout)
        return clearTimeout(e21);
      if ((Ht$1 === qt$1 || !Ht$1) && clearTimeout)
        return Ht$1 = clearTimeout, clearTimeout(e21);
      try {
        Ht$1(e21);
      } catch (t3) {
        try {
          return Ht$1.call(null, e21);
        } catch (t4) {
          return Ht$1.call(this, e21);
        }
      }
    }(e20);
  }
}
function Yt$1(e20, t2) {
  this.fun = e20, this.array = t2;
}
Yt$1.prototype.run = function() {
  this.fun.apply(null, this.array);
};
function Qt$1() {
}
var Zt$1 = Qt$1, es$1 = Qt$1, ts$1 = Qt$1, ss$1 = Qt$1, rs$1 = Qt$1, is$1 = Qt$1, as$1 = Qt$1;
var ns$1 = _t$1.performance || {}, os$1 = ns$1.now || ns$1.mozNow || ns$1.msNow || ns$1.oNow || ns$1.webkitNow || function() {
  return new Date().getTime();
};
var us$1 = new Date();
var hs$1 = {
  nextTick: function(e20) {
    var t2 = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var s2 = 1; s2 < arguments.length; s2++)
        t2[s2 - 1] = arguments[s2];
    Wt$1.push(new Yt$1(e20, t2)), Wt$1.length !== 1 || Gt$1 || Vt$1(Jt$1);
  },
  title: "browser",
  browser: true,
  env: {},
  argv: [],
  version: "",
  versions: {},
  on: Zt$1,
  addListener: es$1,
  once: ts$1,
  off: ss$1,
  removeListener: rs$1,
  removeAllListeners: is$1,
  emit: as$1,
  binding: function(e20) {
    throw new Error("process.binding is not supported");
  },
  cwd: function() {
    return "/";
  },
  chdir: function(e20) {
    throw new Error("process.chdir is not supported");
  },
  umask: function() {
    return 0;
  },
  hrtime: function(e20) {
    var t2 = 1e-3 * os$1.call(ns$1), s2 = Math.floor(t2), r2 = Math.floor(t2 % 1 * 1e9);
    return e20 && (s2 -= e20[0], (r2 -= e20[1]) < 0 && (s2--, r2 += 1e9)), [s2, r2];
  },
  platform: "browser",
  release: {},
  config: {},
  uptime: function() {
    return (new Date() - us$1) / 1e3;
  }
};
var cs$1 = typeof hs$1 == "object" && hs$1.env && hs$1.env.NODE_DEBUG && /\bsemver\b/i.test(hs$1.env.NODE_DEBUG) ? (...e20) => console.error("SEMVER", ...e20) : () => {
};
var ps$1 = {
  SEMVER_SPEC_VERSION: "2.0.0",
  MAX_LENGTH: 256,
  MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991,
  MAX_SAFE_COMPONENT_LENGTH: 16
}, ls$1 = s$2(function(e20, t2) {
  const { MAX_SAFE_COMPONENT_LENGTH: s2 } = ps$1, r2 = (t2 = e20.exports = {}).re = [], i2 = t2.src = [], a2 = t2.t = {};
  let n2 = 0;
  const o2 = (e21, t3, s3) => {
    const o3 = n2++;
    cs$1(o3, t3), a2[e21] = o3, i2[o3] = t3, r2[o3] = new RegExp(t3, s3 ? "g" : void 0);
  };
  o2("NUMERICIDENTIFIER", "0|[1-9]\\d*"), o2("NUMERICIDENTIFIERLOOSE", "[0-9]+"), o2("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), o2("MAINVERSION", `(${i2[a2.NUMERICIDENTIFIER]})\\.(${i2[a2.NUMERICIDENTIFIER]})\\.(${i2[a2.NUMERICIDENTIFIER]})`), o2("MAINVERSIONLOOSE", `(${i2[a2.NUMERICIDENTIFIERLOOSE]})\\.(${i2[a2.NUMERICIDENTIFIERLOOSE]})\\.(${i2[a2.NUMERICIDENTIFIERLOOSE]})`), o2("PRERELEASEIDENTIFIER", `(?:${i2[a2.NUMERICIDENTIFIER]}|${i2[a2.NONNUMERICIDENTIFIER]})`), o2("PRERELEASEIDENTIFIERLOOSE", `(?:${i2[a2.NUMERICIDENTIFIERLOOSE]}|${i2[a2.NONNUMERICIDENTIFIER]})`), o2("PRERELEASE", `(?:-(${i2[a2.PRERELEASEIDENTIFIER]}(?:\\.${i2[a2.PRERELEASEIDENTIFIER]})*))`), o2("PRERELEASELOOSE", `(?:-?(${i2[a2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${i2[a2.PRERELEASEIDENTIFIERLOOSE]})*))`), o2("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), o2("BUILD", `(?:\\+(${i2[a2.BUILDIDENTIFIER]}(?:\\.${i2[a2.BUILDIDENTIFIER]})*))`), o2("FULLPLAIN", `v?${i2[a2.MAINVERSION]}${i2[a2.PRERELEASE]}?${i2[a2.BUILD]}?`), o2("FULL", `^${i2[a2.FULLPLAIN]}$`), o2("LOOSEPLAIN", `[v=\\s]*${i2[a2.MAINVERSIONLOOSE]}${i2[a2.PRERELEASELOOSE]}?${i2[a2.BUILD]}?`), o2("LOOSE", `^${i2[a2.LOOSEPLAIN]}$`), o2("GTLT", "((?:<|>)?=?)"), o2("XRANGEIDENTIFIERLOOSE", `${i2[a2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), o2("XRANGEIDENTIFIER", `${i2[a2.NUMERICIDENTIFIER]}|x|X|\\*`), o2("XRANGEPLAIN", `[v=\\s]*(${i2[a2.XRANGEIDENTIFIER]})(?:\\.(${i2[a2.XRANGEIDENTIFIER]})(?:\\.(${i2[a2.XRANGEIDENTIFIER]})(?:${i2[a2.PRERELEASE]})?${i2[a2.BUILD]}?)?)?`), o2("XRANGEPLAINLOOSE", `[v=\\s]*(${i2[a2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i2[a2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i2[a2.XRANGEIDENTIFIERLOOSE]})(?:${i2[a2.PRERELEASELOOSE]})?${i2[a2.BUILD]}?)?)?`), o2("XRANGE", `^${i2[a2.GTLT]}\\s*${i2[a2.XRANGEPLAIN]}$`), o2("XRANGELOOSE", `^${i2[a2.GTLT]}\\s*${i2[a2.XRANGEPLAINLOOSE]}$`), o2("COERCE", `(^|[^\\d])(\\d{1,${s2}})(?:\\.(\\d{1,${s2}}))?(?:\\.(\\d{1,${s2}}))?(?:$|[^\\d])`), o2("COERCERTL", i2[a2.COERCE], true), o2("LONETILDE", "(?:~>?)"), o2("TILDETRIM", `(\\s*)${i2[a2.LONETILDE]}\\s+`, true), t2.tildeTrimReplace = "$1~", o2("TILDE", `^${i2[a2.LONETILDE]}${i2[a2.XRANGEPLAIN]}$`), o2("TILDELOOSE", `^${i2[a2.LONETILDE]}${i2[a2.XRANGEPLAINLOOSE]}$`), o2("LONECARET", "(?:\\^)"), o2("CARETTRIM", `(\\s*)${i2[a2.LONECARET]}\\s+`, true), t2.caretTrimReplace = "$1^", o2("CARET", `^${i2[a2.LONECARET]}${i2[a2.XRANGEPLAIN]}$`), o2("CARETLOOSE", `^${i2[a2.LONECARET]}${i2[a2.XRANGEPLAINLOOSE]}$`), o2("COMPARATORLOOSE", `^${i2[a2.GTLT]}\\s*(${i2[a2.LOOSEPLAIN]})$|^$`), o2("COMPARATOR", `^${i2[a2.GTLT]}\\s*(${i2[a2.FULLPLAIN]})$|^$`), o2("COMPARATORTRIM", `(\\s*)${i2[a2.GTLT]}\\s*(${i2[a2.LOOSEPLAIN]}|${i2[a2.XRANGEPLAIN]})`, true), t2.comparatorTrimReplace = "$1$2$3", o2("HYPHENRANGE", `^\\s*(${i2[a2.XRANGEPLAIN]})\\s+-\\s+(${i2[a2.XRANGEPLAIN]})\\s*$`), o2("HYPHENRANGELOOSE", `^\\s*(${i2[a2.XRANGEPLAINLOOSE]})\\s+-\\s+(${i2[a2.XRANGEPLAINLOOSE]})\\s*$`), o2("STAR", "(<|>)?=?\\s*\\*"), o2("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), o2("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
});
const ds$1 = ["includePrerelease", "loose", "rtl"];
var Ds$1 = (e20) => e20 ? typeof e20 != "object" ? { loose: true } : ds$1.filter((t2) => e20[t2]).reduce((e21, t2) => (e21[t2] = true, e21), {}) : {};
const ms$1 = /^[0-9]+$/, fs$1 = (e20, t2) => {
  const s2 = ms$1.test(e20), r2 = ms$1.test(t2);
  return s2 && r2 && (e20 = +e20, t2 = +t2), e20 === t2 ? 0 : s2 && !r2 ? -1 : r2 && !s2 ? 1 : e20 < t2 ? -1 : 1;
};
var ys$1 = {
  compareIdentifiers: fs$1,
  rcompareIdentifiers: (e20, t2) => fs$1(t2, e20)
};
const { MAX_LENGTH: As$1, MAX_SAFE_INTEGER: Es$1 } = ps$1, { re: Cs$1, t: xs$1 } = ls$1, { compareIdentifiers: Fs$1 } = ys$1;
class gs$1 {
  constructor(e20, t2) {
    if (t2 = Ds$1(t2), e20 instanceof gs$1) {
      if (e20.loose === !!t2.loose && e20.includePrerelease === !!t2.includePrerelease)
        return e20;
      e20 = e20.version;
    } else if (typeof e20 != "string")
      throw new TypeError(`Invalid Version: ${e20}`);
    if (e20.length > As$1)
      throw new TypeError(`version is longer than ${As$1} characters`);
    cs$1("SemVer", e20, t2), this.options = t2, this.loose = !!t2.loose, this.includePrerelease = !!t2.includePrerelease;
    const s2 = e20.trim().match(t2.loose ? Cs$1[xs$1.LOOSE] : Cs$1[xs$1.FULL]);
    if (!s2)
      throw new TypeError(`Invalid Version: ${e20}`);
    if (this.raw = e20, this.major = +s2[1], this.minor = +s2[2], this.patch = +s2[3], this.major > Es$1 || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > Es$1 || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > Es$1 || this.patch < 0)
      throw new TypeError("Invalid patch version");
    s2[4] ? this.prerelease = s2[4].split(".").map((e21) => {
      if (/^[0-9]+$/.test(e21)) {
        const t3 = +e21;
        if (t3 >= 0 && t3 < Es$1)
          return t3;
      }
      return e21;
    }) : this.prerelease = [], this.build = s2[5] ? s2[5].split(".") : [], this.format();
  }
  format() {
    return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
  }
  toString() {
    return this.version;
  }
  compare(e20) {
    if (cs$1("SemVer.compare", this.version, this.options, e20), !(e20 instanceof gs$1)) {
      if (typeof e20 == "string" && e20 === this.version)
        return 0;
      e20 = new gs$1(e20, this.options);
    }
    return e20.version === this.version ? 0 : this.compareMain(e20) || this.comparePre(e20);
  }
  compareMain(e20) {
    return e20 instanceof gs$1 || (e20 = new gs$1(e20, this.options)), Fs$1(this.major, e20.major) || Fs$1(this.minor, e20.minor) || Fs$1(this.patch, e20.patch);
  }
  comparePre(e20) {
    if (e20 instanceof gs$1 || (e20 = new gs$1(e20, this.options)), this.prerelease.length && !e20.prerelease.length)
      return -1;
    if (!this.prerelease.length && e20.prerelease.length)
      return 1;
    if (!this.prerelease.length && !e20.prerelease.length)
      return 0;
    let t2 = 0;
    do {
      const s2 = this.prerelease[t2], r2 = e20.prerelease[t2];
      if (cs$1("prerelease compare", t2, s2, r2), s2 === void 0 && r2 === void 0)
        return 0;
      if (r2 === void 0)
        return 1;
      if (s2 === void 0)
        return -1;
      if (s2 !== r2)
        return Fs$1(s2, r2);
    } while (++t2);
  }
  compareBuild(e20) {
    e20 instanceof gs$1 || (e20 = new gs$1(e20, this.options));
    let t2 = 0;
    do {
      const s2 = this.build[t2], r2 = e20.build[t2];
      if (cs$1("prerelease compare", t2, s2, r2), s2 === void 0 && r2 === void 0)
        return 0;
      if (r2 === void 0)
        return 1;
      if (s2 === void 0)
        return -1;
      if (s2 !== r2)
        return Fs$1(s2, r2);
    } while (++t2);
  }
  inc(e20, t2) {
    switch (e20) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t2);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t2);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", t2), this.inc("pre", t2);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", t2), this.inc("pre", t2);
        break;
      case "major":
        this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0)
          this.prerelease = [0];
        else {
          let e21 = this.prerelease.length;
          for (; --e21 >= 0; )
            typeof this.prerelease[e21] == "number" && (this.prerelease[e21]++, e21 = -2);
          e21 === -1 && this.prerelease.push(0);
        }
        t2 && (this.prerelease[0] === t2 ? isNaN(this.prerelease[1]) && (this.prerelease = [t2, 0]) : this.prerelease = [t2, 0]);
        break;
      default:
        throw new Error(`invalid increment argument: ${e20}`);
    }
    return this.format(), this.raw = this.version, this;
  }
}
var bs$1 = gs$1;
var Ps$1 = (e20, t2, s2) => new bs$1(e20, s2).compare(new bs$1(t2, s2));
var Ts$1 = (e20, t2, s2) => Ps$1(e20, t2, s2) < 0;
var ws$1 = (e20, t2, s2) => Ps$1(e20, t2, s2) >= 0, Ss$1 = s$2(function(e20, t2) {
  function s2() {
    for (var e21 = [], t3 = 0; t3 < arguments.length; t3++)
      e21[t3] = arguments[t3];
  }
  function r2() {
    return typeof WeakMap != "undefined" ? new WeakMap() : {
      add: s2,
      delete: s2,
      get: s2,
      set: s2,
      has: function(e21) {
        return false;
      }
    };
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.outdent = void 0;
  var i2 = Object.prototype.hasOwnProperty, a2 = function(e21, t3) {
    return i2.call(e21, t3);
  };
  function n2(e21, t3) {
    for (var s3 in t3)
      a2(t3, s3) && (e21[s3] = t3[s3]);
    return e21;
  }
  var o2 = /^[ \t]*(?:\r\n|\r|\n)/, u2 = /(?:\r\n|\r|\n)[ \t]*$/, h2 = /^(?:[\r\n]|$)/, c2 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, p2 = /^[ \t]*[\r\n][ \t\r\n]*$/;
  function l2(e21, t3, s3) {
    var r3 = 0, i3 = e21[0].match(c2);
    i3 && (r3 = i3[1].length);
    var a3 = new RegExp("(\\r\\n|\\r|\\n).{0," + r3 + "}", "g");
    t3 && (e21 = e21.slice(1));
    var n3 = s3.newline, h3 = s3.trimLeadingNewline, p3 = s3.trimTrailingNewline, l3 = typeof n3 == "string", d3 = e21.length;
    return e21.map(function(e22, t4) {
      return e22 = e22.replace(a3, "$1"), t4 === 0 && h3 && (e22 = e22.replace(o2, "")), t4 === d3 - 1 && p3 && (e22 = e22.replace(u2, "")), l3 && (e22 = e22.replace(/\r\n|\n|\r/g, function(e23) {
        return n3;
      })), e22;
    });
  }
  function d2(e21, t3) {
    for (var s3 = "", r3 = 0, i3 = e21.length; r3 < i3; r3++)
      s3 += e21[r3], r3 < i3 - 1 && (s3 += t3[r3]);
    return s3;
  }
  function D2(e21) {
    return a2(e21, "raw") && a2(e21, "length");
  }
  var m2 = function e21(t3) {
    var s3 = r2(), i3 = r2();
    return n2(function r3(a3) {
      for (var o3 = [], u3 = 1; u3 < arguments.length; u3++)
        o3[u3 - 1] = arguments[u3];
      if (D2(a3)) {
        var c3 = a3, f2 = (o3[0] === r3 || o3[0] === m2) && p2.test(c3[0]) && h2.test(c3[1]), y2 = f2 ? i3 : s3, A2 = y2.get(c3);
        if (A2 || (A2 = l2(c3, f2, t3), y2.set(c3, A2)), o3.length === 0)
          return A2[0];
        var E2 = d2(A2, f2 ? o3.slice(1) : o3);
        return E2;
      }
      return e21(n2(n2({}, t3), a3 || {}));
    }, {
      string: function(e22) {
        return l2([e22], false, t3)[0];
      }
    });
  }({ trimLeadingNewline: true, trimTrailingNewline: true });
  t2.outdent = m2, t2.default = m2;
  try {
    e20.exports = m2, Object.defineProperty(m2, "__esModule", { value: true }), m2.default = m2, m2.outdent = m2;
  } catch (e21) {
  }
});
const { outdent: Bs$1 } = Ss$1, Ns$1 = {
  cursorOffset: {
    since: "1.4.0",
    category: "Special",
    type: "int",
    default: -1,
    range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 },
    description: Bs$1`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `,
    cliCategory: "Editor"
  },
  endOfLine: {
    since: "1.15.0",
    category: "Global",
    type: "choice",
    default: [
      { since: "1.15.0", value: "auto" },
      { since: "2.0.0", value: "lf" }
    ],
    description: "Which end of line characters to apply.",
    choices: [
      {
        value: "lf",
        description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos"
      },
      {
        value: "crlf",
        description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows"
      },
      {
        value: "cr",
        description: "Carriage Return character only (\\r), used very rarely"
      },
      {
        value: "auto",
        description: Bs$1`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        `
      }
    ]
  },
  filepath: {
    since: "1.4.0",
    category: "Special",
    type: "path",
    description: "Specify the input filepath. This will be used to do parser inference.",
    cliName: "stdin-filepath",
    cliCategory: "Other",
    cliDescription: "Path to the file to pretend that stdin comes from."
  },
  insertPragma: {
    since: "1.8.0",
    category: "Special",
    type: "boolean",
    default: false,
    description: "Insert @format pragma into file's first docblock comment.",
    cliCategory: "Other"
  },
  parser: {
    since: "0.0.10",
    category: "Global",
    type: "choice",
    default: [
      { since: "0.0.10", value: "babylon" },
      { since: "1.13.0", value: void 0 }
    ],
    description: "Which parser to use.",
    exception: (e20) => typeof e20 == "string" || typeof e20 == "function",
    choices: [
      { value: "flow", description: "Flow" },
      { value: "babel", since: "1.16.0", description: "JavaScript" },
      { value: "babel-flow", since: "1.16.0", description: "Flow" },
      {
        value: "babel-ts",
        since: "2.0.0",
        description: "TypeScript"
      },
      {
        value: "typescript",
        since: "1.4.0",
        description: "TypeScript"
      },
      { value: "espree", since: "2.2.0", description: "JavaScript" },
      { value: "meriyah", since: "2.2.0", description: "JavaScript" },
      { value: "css", since: "1.7.1", description: "CSS" },
      { value: "less", since: "1.7.1", description: "Less" },
      { value: "scss", since: "1.7.1", description: "SCSS" },
      { value: "json", since: "1.5.0", description: "JSON" },
      { value: "json5", since: "1.13.0", description: "JSON5" },
      {
        value: "json-stringify",
        since: "1.13.0",
        description: "JSON.stringify"
      },
      { value: "graphql", since: "1.5.0", description: "GraphQL" },
      { value: "markdown", since: "1.8.0", description: "Markdown" },
      { value: "mdx", since: "1.15.0", description: "MDX" },
      { value: "vue", since: "1.10.0", description: "Vue" },
      { value: "yaml", since: "1.14.0", description: "YAML" },
      {
        value: "glimmer",
        since: "2.3.0",
        description: "Ember / Handlebars"
      },
      { value: "html", since: "1.15.0", description: "HTML" },
      { value: "angular", since: "1.15.0", description: "Angular" },
      {
        value: "lwc",
        since: "1.17.0",
        description: "Lightning Web Components"
      }
    ]
  },
  plugins: {
    since: "1.10.0",
    type: "path",
    array: true,
    default: [{ value: [] }],
    category: "Global",
    description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.",
    exception: (e20) => typeof e20 == "string" || typeof e20 == "object",
    cliName: "plugin",
    cliCategory: "Config"
  },
  pluginSearchDirs: {
    since: "1.13.0",
    type: "path",
    array: true,
    default: [{ value: [] }],
    category: "Global",
    description: Bs$1`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `,
    exception: (e20) => typeof e20 == "string" || typeof e20 == "object",
    cliName: "plugin-search-dir",
    cliCategory: "Config"
  },
  printWidth: {
    since: "0.0.0",
    category: "Global",
    type: "int",
    default: 80,
    description: "The line length where Prettier will try wrap.",
    range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }
  },
  rangeEnd: {
    since: "1.4.0",
    category: "Special",
    type: "int",
    default: Number.POSITIVE_INFINITY,
    range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 },
    description: Bs$1`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `,
    cliCategory: "Editor"
  },
  rangeStart: {
    since: "1.4.0",
    category: "Special",
    type: "int",
    default: 0,
    range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 },
    description: Bs$1`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `,
    cliCategory: "Editor"
  },
  requirePragma: {
    since: "1.7.0",
    category: "Special",
    type: "boolean",
    default: false,
    description: Bs$1`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `,
    cliCategory: "Other"
  },
  tabWidth: {
    type: "int",
    category: "Global",
    default: 2,
    description: "Number of spaces per indentation level.",
    range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }
  },
  useTabs: {
    since: "1.0.0",
    category: "Global",
    type: "boolean",
    default: false,
    description: "Indent with tabs instead of spaces."
  },
  embeddedLanguageFormatting: {
    since: "2.1.0",
    category: "Global",
    type: "choice",
    default: [{ since: "2.1.0", value: "auto" }],
    description: "Control how Prettier formats quoted code embedded in the file.",
    choices: [
      {
        value: "auto",
        description: "Format embedded code if Prettier can automatically identify it."
      },
      {
        value: "off",
        description: "Never automatically format embedded code."
      }
    ]
  }
};
const Is$1 = ["cliName", "cliCategory", "cliDescription"], vs$1 = { compare: Ps$1, lt: Ts$1, gte: ws$1 }, ks$1 = "2.4.1", Ls$1 = {
  CATEGORY_CONFIG: "Config",
  CATEGORY_EDITOR: "Editor",
  CATEGORY_FORMAT: "Format",
  CATEGORY_OTHER: "Other",
  CATEGORY_OUTPUT: "Output",
  CATEGORY_GLOBAL: "Global",
  CATEGORY_SPECIAL: "Special",
  options: Ns$1
}.options;
var Os$1 = {
  getSupportInfo: function({
    plugins: e20 = [],
    showUnreleased: t2 = false,
    showDeprecated: s2 = false,
    showInternal: r2 = false
  } = {}) {
    const i2 = ks$1.split("-", 1)[0], a2 = e20.flatMap((e21) => e21.languages || []).filter(h2), n2 = (o2 = Object.assign({}, ...e20.map(({ options: e21 }) => e21), Ls$1), u2 = "name", Object.entries(o2).map(([e21, t3]) => Object.assign({ [u2]: e21 }, t3))).filter((e21) => h2(e21) && c2(e21)).sort((e21, t3) => e21.name === t3.name ? 0 : e21.name < t3.name ? -1 : 1).map(function(e21) {
      if (r2)
        return e21;
      return nt$2(e21, Is$1);
    }).map((t3) => {
      t3 = Object.assign({}, t3), Array.isArray(t3.default) && (t3.default = t3.default.length === 1 ? t3.default[0].value : t3.default.filter(h2).sort((e21, t4) => vs$1.compare(t4.since, e21.since))[0].value), Array.isArray(t3.choices) && (t3.choices = t3.choices.filter((e21) => h2(e21) && c2(e21)), t3.name === "parser" && function(e21, t4, s4) {
        const r3 = new Set(e21.choices.map((e22) => e22.value));
        for (const i3 of t4)
          if (i3.parsers) {
            for (const t5 of i3.parsers)
              if (!r3.has(t5)) {
                r3.add(t5);
                const a3 = s4.find((e22) => e22.parsers && e22.parsers[t5]);
                let n3 = i3.name;
                a3 && a3.name && (n3 += ` (plugin: ${a3.name})`), e21.choices.push({
                  value: t5,
                  description: n3
                });
              }
          }
      }(t3, a2, e20));
      const s3 = Object.fromEntries(e20.filter((e21) => e21.defaultOptions && e21.defaultOptions[t3.name] !== void 0).map((e21) => [e21.name, e21.defaultOptions[t3.name]]));
      return Object.assign(Object.assign({}, t3), {}, { pluginDefaults: s3 });
    });
    var o2, u2;
    return { languages: a2, options: n2 };
    function h2(e21) {
      return t2 || !("since" in e21) || e21.since && vs$1.gte(i2, e21.since);
    }
    function c2(e21) {
      return s2 || !("deprecated" in e21) || e21.deprecated && vs$1.lt(i2, e21.deprecated);
    }
  }
};
const { getSupportInfo: Ms$1 } = Os$1, Rs$1 = /[^\x20-\x7F]/;
function js$1(e20) {
  return (t2, s2, r2) => {
    const i2 = r2 && r2.backwards;
    if (s2 === false)
      return false;
    const { length: a2 } = t2;
    let n2 = s2;
    for (; n2 >= 0 && n2 < a2; ) {
      const s3 = t2.charAt(n2);
      if (e20 instanceof RegExp) {
        if (!e20.test(s3))
          return n2;
      } else if (!e20.includes(s3))
        return n2;
      i2 ? n2-- : n2++;
    }
    return (n2 === -1 || n2 === a2) && n2;
  };
}
const _s$1 = js$1(/\s/), Us$1 = js$1(" 	"), qs$1 = js$1(",; 	"), $s$1 = js$1(/[^\n\r]/);
function Hs$1(e20, t2) {
  if (t2 === false)
    return false;
  if (e20.charAt(t2) === "/" && e20.charAt(t2 + 1) === "*") {
    for (let s2 = t2 + 2; s2 < e20.length; ++s2)
      if (e20.charAt(s2) === "*" && e20.charAt(s2 + 1) === "/")
        return s2 + 2;
  }
  return t2;
}
function Vs$1(e20, t2) {
  return t2 !== false && (e20.charAt(t2) === "/" && e20.charAt(t2 + 1) === "/" ? $s$1(e20, t2) : t2);
}
function zs$1(e20, t2, s2) {
  const r2 = s2 && s2.backwards;
  if (t2 === false)
    return false;
  const i2 = e20.charAt(t2);
  if (r2) {
    if (e20.charAt(t2 - 1) === "\r" && i2 === "\n")
      return t2 - 2;
    if (i2 === "\n" || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
      return t2 - 1;
  } else {
    if (i2 === "\r" && e20.charAt(t2 + 1) === "\n")
      return t2 + 2;
    if (i2 === "\n" || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
      return t2 + 1;
  }
  return t2;
}
function Ws$1(e20, t2, s2 = {}) {
  const r2 = Us$1(e20, s2.backwards ? t2 - 1 : t2, s2);
  return r2 !== zs$1(e20, r2, s2);
}
function Gs$1(e20, t2) {
  let s2 = null, r2 = t2;
  for (; r2 !== s2; )
    s2 = r2, r2 = qs$1(e20, r2), r2 = Hs$1(e20, r2), r2 = Us$1(e20, r2);
  return r2 = Vs$1(e20, r2), r2 = zs$1(e20, r2), r2 !== false && Ws$1(e20, r2);
}
function Ks$1(e20, t2) {
  let s2 = null, r2 = t2;
  for (; r2 !== s2; )
    s2 = r2, r2 = Us$1(e20, r2), r2 = Hs$1(e20, r2), r2 = Vs$1(e20, r2), r2 = zs$1(e20, r2);
  return r2;
}
function Xs$1(e20, t2, s2) {
  return Ks$1(e20, s2(t2));
}
function Js$1(e20, t2, s2 = 0) {
  let r2 = 0;
  for (let i2 = s2; i2 < e20.length; ++i2)
    e20[i2] === "	" ? r2 = r2 + t2 - r2 % t2 : r2++;
  return r2;
}
function Ys$1(e20, t2) {
  const s2 = e20.slice(1, -1), r2 = { quote: '"', regex: /"/g }, i2 = { quote: "'", regex: /'/g }, a2 = t2 === "'" ? i2 : r2, n2 = a2 === i2 ? r2 : i2;
  let o2 = a2.quote;
  if (s2.includes(a2.quote) || s2.includes(n2.quote)) {
    o2 = (s2.match(a2.regex) || []).length > (s2.match(n2.regex) || []).length ? n2.quote : a2.quote;
  }
  return o2;
}
function Qs$1(e20, t2, s2) {
  const r2 = t2 === '"' ? "'" : '"', i2 = e20.replace(/\\(.)|(["'])/gs, (e21, i3, a2) => i3 === r2 ? i3 : a2 === t2 ? "\\" + a2 : a2 || (s2 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(i3) ? i3 : "\\" + i3));
  return t2 + i2 + t2;
}
function Zs$1(e20, t2) {
  (e20.comments || (e20.comments = [])).push(t2), t2.printed = false, t2.nodeDescription = function(e21) {
    const t3 = e21.type || e21.kind || "(unknown type)";
    let s2 = String(e21.name || e21.id && (typeof e21.id == "object" ? e21.id.name : e21.id) || e21.key && (typeof e21.key == "object" ? e21.key.name : e21.key) || e21.value && (typeof e21.value == "object" ? "" : String(e21.value)) || e21.operator || "");
    s2.length > 20 && (s2 = s2.slice(0, 19) + "\u2026");
    return t3 + (s2 ? " " + s2 : "");
  }(e20);
}
var er$1, tr$1 = {
  inferParserByLanguage: function(e20, t2) {
    const { languages: s2 } = Ms$1({ plugins: t2.plugins }), r2 = s2.find(({ name: t3 }) => t3.toLowerCase() === e20) || s2.find(({ aliases: t3 }) => Array.isArray(t3) && t3.includes(e20)) || s2.find(({ extensions: t3 }) => Array.isArray(t3) && t3.includes(`.${e20}`));
    return r2 && r2.parsers[0];
  },
  getStringWidth: function(e20) {
    return e20 ? Rs$1.test(e20) ? st$2(e20) : e20.length : 0;
  },
  getMaxContinuousCount: function(e20, t2) {
    const s2 = e20.match(new RegExp(`(${it$2(t2)})+`, "g"));
    return s2 === null ? 0 : s2.reduce((e21, s3) => Math.max(e21, s3.length / t2.length), 0);
  },
  getMinNotPresentContinuousCount: function(e20, t2) {
    const s2 = e20.match(new RegExp(`(${it$2(t2)})+`, "g"));
    if (s2 === null)
      return 0;
    const r2 = new Map();
    let i2 = 0;
    for (const e21 of s2) {
      const s3 = e21.length / t2.length;
      r2.set(s3, true), s3 > i2 && (i2 = s3);
    }
    for (let e21 = 1; e21 < i2; e21++)
      if (!r2.get(e21))
        return e21;
    return i2 + 1;
  },
  getPenultimate: (e20) => e20[e20.length - 2],
  getLast: at$2,
  getNextNonSpaceNonCommentCharacterIndexWithStartIndex: Ks$1,
  getNextNonSpaceNonCommentCharacterIndex: Xs$1,
  getNextNonSpaceNonCommentCharacter: function(e20, t2, s2) {
    return e20.charAt(Xs$1(e20, t2, s2));
  },
  skip: js$1,
  skipWhitespace: _s$1,
  skipSpaces: Us$1,
  skipToLineEnd: qs$1,
  skipEverythingButNewLine: $s$1,
  skipInlineComment: Hs$1,
  skipTrailingComment: Vs$1,
  skipNewline: zs$1,
  isNextLineEmptyAfterIndex: Gs$1,
  isNextLineEmpty: function(e20, t2, s2) {
    return Gs$1(e20, s2(t2));
  },
  isPreviousLineEmpty: function(e20, t2, s2) {
    let r2 = s2(t2) - 1;
    return r2 = Us$1(e20, r2, { backwards: true }), r2 = zs$1(e20, r2, { backwards: true }), r2 = Us$1(e20, r2, { backwards: true }), r2 !== zs$1(e20, r2, { backwards: true });
  },
  hasNewline: Ws$1,
  hasNewlineInRange: function(e20, t2, s2) {
    for (let r2 = t2; r2 < s2; ++r2)
      if (e20.charAt(r2) === "\n")
        return true;
    return false;
  },
  hasSpaces: function(e20, t2, s2 = {}) {
    return Us$1(e20, s2.backwards ? t2 - 1 : t2, s2) !== t2;
  },
  getAlignmentSize: Js$1,
  getIndentSize: function(e20, t2) {
    const s2 = e20.lastIndexOf("\n");
    return s2 === -1 ? 0 : Js$1(e20.slice(s2 + 1).match(/^[\t ]*/)[0], t2);
  },
  getPreferredQuote: Ys$1,
  printString: function(e20, t2) {
    return Qs$1(e20.slice(1, -1), t2.parser === "json" || t2.parser === "json5" && t2.quoteProps === "preserve" && !t2.singleQuote ? '"' : t2.__isInHtmlAttribute ? "'" : Ys$1(e20, t2.singleQuote ? "'" : '"'), !(t2.parser === "css" || t2.parser === "less" || t2.parser === "scss" || t2.__embeddedInHtml));
  },
  printNumber: function(e20) {
    return e20.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
  },
  makeString: Qs$1,
  addLeadingComment: function(e20, t2) {
    t2.leading = true, t2.trailing = false, Zs$1(e20, t2);
  },
  addDanglingComment: function(e20, t2, s2) {
    t2.leading = false, t2.trailing = false, s2 && (t2.marker = s2), Zs$1(e20, t2);
  },
  addTrailingComment: function(e20, t2) {
    t2.leading = false, t2.trailing = true, Zs$1(e20, t2);
  },
  isFrontMatterNode: function(e20) {
    return e20 && e20.type === "front-matter";
  },
  getShebang: function(e20) {
    if (!e20.startsWith("#!"))
      return "";
    const t2 = e20.indexOf("\n");
    return t2 === -1 ? e20 : e20.slice(0, t2);
  },
  isNonEmptyArray: function(e20) {
    return Array.isArray(e20) && e20.length > 0;
  },
  createGroupIdMapper: function(e20) {
    const t2 = new WeakMap();
    return function(s2) {
      return t2.has(s2) || t2.set(s2, Symbol(e20)), t2.get(s2);
    };
  }
};
function sr$1() {
  if (er$1 === void 0) {
    var e20 = new ArrayBuffer(2), t2 = new Uint8Array(e20), s2 = new Uint16Array(e20);
    if (t2[0] = 1, t2[1] = 2, s2[0] === 258)
      er$1 = "BE";
    else {
      if (s2[0] !== 513)
        throw new Error("unable to figure out endianess");
      er$1 = "LE";
    }
  }
  return er$1;
}
function rr$1() {
  return _t$1.location !== void 0 ? _t$1.location.hostname : "";
}
function ir$1() {
  return [];
}
function ar$1() {
  return 0;
}
function nr$1() {
  return Number.MAX_VALUE;
}
function or$1() {
  return Number.MAX_VALUE;
}
function ur$1() {
  return [];
}
function hr$1() {
  return "Browser";
}
function cr$1() {
  return _t$1.navigator !== void 0 ? _t$1.navigator.appVersion : "";
}
function pr$1() {
}
function lr$1() {
}
function dr$1() {
  return "javascript";
}
function Dr$1() {
  return "browser";
}
function mr$1() {
  return "/tmp";
}
var fr$1 = mr$1, yr$1 = {
  EOL: "\n",
  arch: dr$1,
  platform: Dr$1,
  tmpdir: fr$1,
  tmpDir: mr$1,
  networkInterfaces: pr$1,
  getNetworkInterfaces: lr$1,
  release: cr$1,
  type: hr$1,
  cpus: ur$1,
  totalmem: or$1,
  freemem: nr$1,
  uptime: ar$1,
  loadavg: ir$1,
  hostname: rr$1,
  endianness: sr$1
}, Ar$1 = Object.freeze({
  __proto__: null,
  endianness: sr$1,
  hostname: rr$1,
  loadavg: ir$1,
  uptime: ar$1,
  freemem: nr$1,
  totalmem: or$1,
  cpus: ur$1,
  type: hr$1,
  release: cr$1,
  networkInterfaces: pr$1,
  getNetworkInterfaces: lr$1,
  arch: dr$1,
  platform: Dr$1,
  tmpDir: mr$1,
  tmpdir: fr$1,
  EOL: "\n",
  default: yr$1
});
const Er$1 = (e20) => {
  if (typeof e20 != "string")
    throw new TypeError("Expected a string");
  const t2 = e20.match(/(?:\r?\n)/g) || [];
  if (t2.length === 0)
    return;
  const s2 = t2.filter((e21) => e21 === "\r\n").length;
  return s2 > t2.length - s2 ? "\r\n" : "\n";
};
var Cr$1 = Er$1;
Cr$1.graceful = (e20) => typeof e20 == "string" && Er$1(e20) || "\n";
var xr$1 = t$2(Ar$1), Fr$1 = function(e20) {
  const t2 = e20.match(Ir$1);
  return t2 ? t2[0].trimLeft() : "";
}, gr$1 = function(e20) {
  const t2 = e20.match(Ir$1);
  return t2 && t2[0] ? e20.substring(t2[0].length) : e20;
}, br$1 = function(e20) {
  return jr$1(e20).pragmas;
}, Pr$1 = jr$1, Tr$1 = function({ comments: e20 = "", pragmas: t2 = {} }) {
  const s2 = (0, Sr$1().default)(e20) || wr$1().EOL, r2 = " *", i2 = Object.keys(t2), a2 = i2.map((e21) => _r$1(e21, t2[e21])).reduce((e21, t3) => e21.concat(t3), []).map((e21) => " * " + e21 + s2).join("");
  if (!e20) {
    if (i2.length === 0)
      return "";
    if (i2.length === 1 && !Array.isArray(t2[i2[0]])) {
      const e21 = t2[i2[0]];
      return `/** ${_r$1(i2[0], e21)[0]} */`;
    }
  }
  const n2 = e20.split(s2).map((e21) => ` * ${e21}`).join(s2) + s2;
  return "/**" + s2 + (e20 ? n2 : "") + (e20 && i2.length ? r2 + s2 : "") + a2 + " */";
};
function wr$1() {
  const e20 = xr$1;
  return wr$1 = function() {
    return e20;
  }, e20;
}
function Sr$1() {
  const e20 = (t2 = Cr$1) && t2.__esModule ? t2 : { default: t2 };
  var t2;
  return Sr$1 = function() {
    return e20;
  }, e20;
}
const Br$1 = /\*\/$/, Nr$1 = /^\/\*\*/, Ir$1 = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, vr$1 = /(^|\s+)\/\/([^\r\n]*)/g, kr$1 = /^(\r?\n)+/, Lr$1 = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, Or$1 = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, Mr$1 = /(\r?\n|^) *\* ?/g, Rr$1 = [];
function jr$1(e20) {
  const t2 = (0, Sr$1().default)(e20) || wr$1().EOL;
  e20 = e20.replace(Nr$1, "").replace(Br$1, "").replace(Mr$1, "$1");
  let s2 = "";
  for (; s2 !== e20; )
    s2 = e20, e20 = e20.replace(Lr$1, `${t2}$1 $2${t2}`);
  e20 = e20.replace(kr$1, "").trimRight();
  const r2 = Object.create(null), i2 = e20.replace(Or$1, "").replace(kr$1, "").trimRight();
  let a2;
  for (; a2 = Or$1.exec(e20); ) {
    const e21 = a2[2].replace(vr$1, "");
    typeof r2[a2[1]] == "string" || Array.isArray(r2[a2[1]]) ? r2[a2[1]] = Rr$1.concat(r2[a2[1]], e21) : r2[a2[1]] = e21;
  }
  return { comments: i2, pragmas: r2 };
}
function _r$1(e20, t2) {
  return Rr$1.concat(t2).map((t3) => `@${e20} ${t3}`.trim());
}
var Ur$1 = Object.defineProperty({
  extract: Fr$1,
  strip: gr$1,
  parse: br$1,
  parseWithComments: Pr$1,
  print: Tr$1
}, "__esModule", { value: true });
var qr$1 = {
  guessEndOfLine: function(e20) {
    const t2 = e20.indexOf("\r");
    return t2 >= 0 ? e20.charAt(t2 + 1) === "\n" ? "crlf" : "cr" : "lf";
  },
  convertEndOfLineToChars: function(e20) {
    switch (e20) {
      case "cr":
        return "\r";
      case "crlf":
        return "\r\n";
      default:
        return "\n";
    }
  },
  countEndOfLineChars: function(e20, t2) {
    let s2;
    if (t2 === "\n")
      s2 = /\n/g;
    else if (t2 === "\r")
      s2 = /\r/g;
    else {
      if (t2 !== "\r\n")
        throw new Error(`Unexpected "eol" ${JSON.stringify(t2)}.`);
      s2 = /\r\n/g;
    }
    const r2 = e20.match(s2);
    return r2 ? r2.length : 0;
  },
  normalizeEndOfLine: function(e20) {
    return e20.replace(/\r\n?/g, "\n");
  }
};
const {
  parseWithComments: $r$1,
  strip: Hr$1,
  extract: Vr$1,
  print: zr$1
} = Ur$1, { getShebang: Wr$1 } = tr$1, { normalizeEndOfLine: Gr$1 } = qr$1;
function Kr$1(e20) {
  const t2 = Wr$1(e20);
  t2 && (e20 = e20.slice(t2.length + 1));
  const s2 = Vr$1(e20), { pragmas: r2, comments: i2 } = $r$1(s2);
  return { shebang: t2, text: e20, pragmas: r2, comments: i2 };
}
var Xr$1 = {
  hasPragma: function(e20) {
    const t2 = Object.keys(Kr$1(e20).pragmas);
    return t2.includes("prettier") || t2.includes("format");
  },
  insertPragma: function(e20) {
    const { shebang: t2, text: s2, pragmas: r2, comments: i2 } = Kr$1(e20), a2 = Hr$1(s2), n2 = zr$1({
      pragmas: Object.assign({ format: "" }, r2),
      comments: i2.trimStart()
    });
    return (t2 ? `${t2}
` : "") + Gr$1(n2) + (a2.startsWith("\n") ? "\n" : "\n\n") + a2;
  }
};
const { isNonEmptyArray: Jr$1 } = tr$1;
function Yr$1(e20, t2) {
  const { ignoreDecorators: s2 } = t2 || {};
  if (!s2) {
    const t3 = e20.declaration && e20.declaration.decorators || e20.decorators;
    if (Jr$1(t3))
      return Yr$1(t3[0]);
  }
  return e20.range ? e20.range[0] : e20.start;
}
function Qr$1(e20) {
  return e20.range ? e20.range[1] : e20.end;
}
function Zr$1(e20, t2) {
  return Yr$1(e20) === Yr$1(t2);
}
var ei$1 = {
  locStart: Yr$1,
  locEnd: Qr$1,
  hasSameLocStart: Zr$1,
  hasSameLoc: function(e20, t2) {
    return Zr$1(e20, t2) && function(e21, t3) {
      return Qr$1(e21) === Qr$1(t3);
    }(e20, t2);
  }
};
const { hasPragma: ti$1 } = Xr$1, { locStart: si$1, locEnd: ri$1 } = ei$1;
var ii$1 = function(e20) {
  return e20 = typeof e20 == "function" ? { parse: e20 } : e20, Object.assign({
    astFormat: "estree",
    hasPragma: ti$1,
    locStart: si$1,
    locEnd: ri$1
  }, e20);
};
var ai$1 = function(e20, t2) {
  const s2 = new SyntaxError(e20 + " (" + t2.start.line + ":" + t2.start.column + ")");
  return s2.loc = t2, s2;
};
var ni$1 = function(e20) {
  const { message: t2, loc: s2 } = e20;
  return ai$1(t2.replace(/ \(.*\)/, ""), {
    start: { line: s2 ? s2.line : 0, column: s2 ? s2.column + 1 : 0 }
  });
}, oi$1 = s$2(function(e20) {
  !function() {
    function t2(e21) {
      if (e21 == null)
        return false;
      switch (e21.type) {
        case "BlockStatement":
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "ForInStatement":
        case "ForStatement":
        case "IfStatement":
        case "LabeledStatement":
        case "ReturnStatement":
        case "SwitchStatement":
        case "ThrowStatement":
        case "TryStatement":
        case "VariableDeclaration":
        case "WhileStatement":
        case "WithStatement":
          return true;
      }
      return false;
    }
    function s2(e21) {
      switch (e21.type) {
        case "IfStatement":
          return e21.alternate != null ? e21.alternate : e21.consequent;
        case "LabeledStatement":
        case "ForStatement":
        case "ForInStatement":
        case "WhileStatement":
        case "WithStatement":
          return e21.body;
      }
      return null;
    }
    e20.exports = {
      isExpression: function(e21) {
        if (e21 == null)
          return false;
        switch (e21.type) {
          case "ArrayExpression":
          case "AssignmentExpression":
          case "BinaryExpression":
          case "CallExpression":
          case "ConditionalExpression":
          case "FunctionExpression":
          case "Identifier":
          case "Literal":
          case "LogicalExpression":
          case "MemberExpression":
          case "NewExpression":
          case "ObjectExpression":
          case "SequenceExpression":
          case "ThisExpression":
          case "UnaryExpression":
          case "UpdateExpression":
            return true;
        }
        return false;
      },
      isStatement: t2,
      isIterationStatement: function(e21) {
        if (e21 == null)
          return false;
        switch (e21.type) {
          case "DoWhileStatement":
          case "ForInStatement":
          case "ForStatement":
          case "WhileStatement":
            return true;
        }
        return false;
      },
      isSourceElement: function(e21) {
        return t2(e21) || e21 != null && e21.type === "FunctionDeclaration";
      },
      isProblematicIfStatement: function(e21) {
        var t3;
        if (e21.type !== "IfStatement")
          return false;
        if (e21.alternate == null)
          return false;
        t3 = e21.consequent;
        do {
          if (t3.type === "IfStatement" && t3.alternate == null)
            return true;
          t3 = s2(t3);
        } while (t3);
        return false;
      },
      trailingStatement: s2
    };
  }();
}), ui$1 = s$2(function(e20) {
  !function() {
    var t2, s2, r2, i2, a2, n2;
    function o2(e21) {
      return e21 <= 65535 ? String.fromCharCode(e21) : String.fromCharCode(Math.floor((e21 - 65536) / 1024) + 55296) + String.fromCharCode((e21 - 65536) % 1024 + 56320);
    }
    for (s2 = {
      NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
      NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
    }, t2 = {
      NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
      NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
    }, r2 = [
      5760,
      8192,
      8193,
      8194,
      8195,
      8196,
      8197,
      8198,
      8199,
      8200,
      8201,
      8202,
      8239,
      8287,
      12288,
      65279
    ], i2 = new Array(128), n2 = 0; n2 < 128; ++n2)
      i2[n2] = n2 >= 97 && n2 <= 122 || n2 >= 65 && n2 <= 90 || n2 === 36 || n2 === 95;
    for (a2 = new Array(128), n2 = 0; n2 < 128; ++n2)
      a2[n2] = n2 >= 97 && n2 <= 122 || n2 >= 65 && n2 <= 90 || n2 >= 48 && n2 <= 57 || n2 === 36 || n2 === 95;
    e20.exports = {
      isDecimalDigit: function(e21) {
        return 48 <= e21 && e21 <= 57;
      },
      isHexDigit: function(e21) {
        return 48 <= e21 && e21 <= 57 || 97 <= e21 && e21 <= 102 || 65 <= e21 && e21 <= 70;
      },
      isOctalDigit: function(e21) {
        return e21 >= 48 && e21 <= 55;
      },
      isWhiteSpace: function(e21) {
        return e21 === 32 || e21 === 9 || e21 === 11 || e21 === 12 || e21 === 160 || e21 >= 5760 && r2.indexOf(e21) >= 0;
      },
      isLineTerminator: function(e21) {
        return e21 === 10 || e21 === 13 || e21 === 8232 || e21 === 8233;
      },
      isIdentifierStartES5: function(e21) {
        return e21 < 128 ? i2[e21] : s2.NonAsciiIdentifierStart.test(o2(e21));
      },
      isIdentifierPartES5: function(e21) {
        return e21 < 128 ? a2[e21] : s2.NonAsciiIdentifierPart.test(o2(e21));
      },
      isIdentifierStartES6: function(e21) {
        return e21 < 128 ? i2[e21] : t2.NonAsciiIdentifierStart.test(o2(e21));
      },
      isIdentifierPartES6: function(e21) {
        return e21 < 128 ? a2[e21] : t2.NonAsciiIdentifierPart.test(o2(e21));
      }
    };
  }();
}), hi$1 = s$2(function(e20) {
  !function() {
    var t2 = ui$1;
    function s2(e21, t3) {
      return !(!t3 && e21 === "yield") && r2(e21, t3);
    }
    function r2(e21, t3) {
      if (t3 && function(e22) {
        switch (e22) {
          case "implements":
          case "interface":
          case "package":
          case "private":
          case "protected":
          case "public":
          case "static":
          case "let":
            return true;
          default:
            return false;
        }
      }(e21))
        return true;
      switch (e21.length) {
        case 2:
          return e21 === "if" || e21 === "in" || e21 === "do";
        case 3:
          return e21 === "var" || e21 === "for" || e21 === "new" || e21 === "try";
        case 4:
          return e21 === "this" || e21 === "else" || e21 === "case" || e21 === "void" || e21 === "with" || e21 === "enum";
        case 5:
          return e21 === "while" || e21 === "break" || e21 === "catch" || e21 === "throw" || e21 === "const" || e21 === "yield" || e21 === "class" || e21 === "super";
        case 6:
          return e21 === "return" || e21 === "typeof" || e21 === "delete" || e21 === "switch" || e21 === "export" || e21 === "import";
        case 7:
          return e21 === "default" || e21 === "finally" || e21 === "extends";
        case 8:
          return e21 === "function" || e21 === "continue" || e21 === "debugger";
        case 10:
          return e21 === "instanceof";
        default:
          return false;
      }
    }
    function i2(e21, t3) {
      return e21 === "null" || e21 === "true" || e21 === "false" || s2(e21, t3);
    }
    function a2(e21, t3) {
      return e21 === "null" || e21 === "true" || e21 === "false" || r2(e21, t3);
    }
    function n2(e21) {
      var s3, r3, i3;
      if (e21.length === 0)
        return false;
      if (i3 = e21.charCodeAt(0), !t2.isIdentifierStartES5(i3))
        return false;
      for (s3 = 1, r3 = e21.length; s3 < r3; ++s3)
        if (i3 = e21.charCodeAt(s3), !t2.isIdentifierPartES5(i3))
          return false;
      return true;
    }
    function o2(e21) {
      var s3, r3, i3, a3, n3;
      if (e21.length === 0)
        return false;
      for (n3 = t2.isIdentifierStartES6, s3 = 0, r3 = e21.length; s3 < r3; ++s3) {
        if (55296 <= (i3 = e21.charCodeAt(s3)) && i3 <= 56319) {
          if (++s3 >= r3)
            return false;
          if (!(56320 <= (a3 = e21.charCodeAt(s3)) && a3 <= 57343))
            return false;
          i3 = 1024 * (i3 - 55296) + (a3 - 56320) + 65536;
        }
        if (!n3(i3))
          return false;
        n3 = t2.isIdentifierPartES6;
      }
      return true;
    }
    e20.exports = {
      isKeywordES5: s2,
      isKeywordES6: r2,
      isReservedWordES5: i2,
      isReservedWordES6: a2,
      isRestrictedWord: function(e21) {
        return e21 === "eval" || e21 === "arguments";
      },
      isIdentifierNameES5: n2,
      isIdentifierNameES6: o2,
      isIdentifierES5: function(e21, t3) {
        return n2(e21) && !i2(e21, t3);
      },
      isIdentifierES6: function(e21, t3) {
        return o2(e21) && !a2(e21, t3);
      }
    };
  }();
});
const ci$1 = s$2(function(e20, t2) {
  t2.ast = oi$1, t2.code = ui$1, t2.keyword = hi$1;
}).keyword.isIdentifierNameES5, {
  getLast: pi$1,
  hasNewline: li$1,
  skipWhitespace: di$1,
  isNonEmptyArray: Di$1,
  isNextLineEmptyAfterIndex: mi$1,
  getStringWidth: fi$1
} = tr$1, { locStart: yi$1, locEnd: Ai$1, hasSameLocStart: Ei$1 } = ei$1, Ci$1 = new RegExp("^(?:(?=.)\\s)*:"), xi$1 = new RegExp("^(?:(?=.)\\s)*::");
function Fi$1(e20) {
  return e20.type === "Block" || e20.type === "CommentBlock" || e20.type === "MultiLine";
}
function gi$1(e20) {
  return e20.type === "Line" || e20.type === "CommentLine" || e20.type === "SingleLine" || e20.type === "HashbangComment" || e20.type === "HTMLOpen" || e20.type === "HTMLClose";
}
const bi$1 = new Set([
  "ExportDefaultDeclaration",
  "ExportDefaultSpecifier",
  "DeclareExportDeclaration",
  "ExportNamedDeclaration",
  "ExportAllDeclaration"
]);
function Pi$1(e20) {
  return e20 && bi$1.has(e20.type);
}
function Ti$1(e20) {
  return e20.type === "NumericLiteral" || e20.type === "Literal" && typeof e20.value == "number";
}
function wi$1(e20) {
  return e20.type === "StringLiteral" || e20.type === "Literal" && typeof e20.value == "string";
}
function Si$1(e20) {
  return e20.type === "FunctionExpression" || e20.type === "ArrowFunctionExpression";
}
function Bi$1(e20) {
  return Mi$1(e20) && e20.callee.type === "Identifier" && (e20.callee.name === "async" || e20.callee.name === "inject" || e20.callee.name === "fakeAsync");
}
function Ni$1(e20) {
  return e20.type === "JSXElement" || e20.type === "JSXFragment";
}
function Ii$1(e20) {
  return e20.kind === "get" || e20.kind === "set";
}
function vi$1(e20) {
  return Ii$1(e20) || Ei$1(e20, e20.value);
}
const ki$1 = new Set([
  "BinaryExpression",
  "LogicalExpression",
  "NGPipeExpression"
]);
const Li$1 = new Set([
  "AnyTypeAnnotation",
  "TSAnyKeyword",
  "NullLiteralTypeAnnotation",
  "TSNullKeyword",
  "ThisTypeAnnotation",
  "TSThisType",
  "NumberTypeAnnotation",
  "TSNumberKeyword",
  "VoidTypeAnnotation",
  "TSVoidKeyword",
  "BooleanTypeAnnotation",
  "TSBooleanKeyword",
  "BigIntTypeAnnotation",
  "TSBigIntKeyword",
  "SymbolTypeAnnotation",
  "TSSymbolKeyword",
  "StringTypeAnnotation",
  "TSStringKeyword",
  "BooleanLiteralTypeAnnotation",
  "StringLiteralTypeAnnotation",
  "BigIntLiteralTypeAnnotation",
  "NumberLiteralTypeAnnotation",
  "TSLiteralType",
  "TSTemplateLiteralType",
  "EmptyTypeAnnotation",
  "MixedTypeAnnotation",
  "TSNeverKeyword",
  "TSObjectKeyword",
  "TSUndefinedKeyword",
  "TSUnknownKeyword"
]);
const Oi$1 = /^(?:skip|[fx]?(?:it|describe|test))$/;
function Mi$1(e20) {
  return e20 && (e20.type === "CallExpression" || e20.type === "OptionalCallExpression");
}
function Ri$1(e20) {
  return e20 && (e20.type === "MemberExpression" || e20.type === "OptionalMemberExpression");
}
function ji$1(e20) {
  return /^(?:\d+|\d+\.\d+)$/.test(e20);
}
function _i$1(e20) {
  return e20.quasis.some((e21) => e21.value.raw.includes("\n"));
}
function Ui$1(e20) {
  return e20.extra ? e20.extra.raw : e20.raw;
}
const qi$1 = { "==": true, "!=": true, "===": true, "!==": true }, $i$1 = { "*": true, "/": true, "%": true }, Hi$1 = { ">>": true, ">>>": true, "<<": true };
const Vi$1 = {};
for (const [e20, t2] of [
  ["|>"],
  ["??"],
  ["||"],
  ["&&"],
  ["|"],
  ["^"],
  ["&"],
  ["==", "===", "!=", "!=="],
  ["<", ">", "<=", ">=", "in", "instanceof"],
  [">>", "<<", ">>>"],
  ["+", "-"],
  ["*", "/", "%"],
  ["**"]
].entries())
  for (const s2 of t2)
    Vi$1[s2] = e20;
function zi$1(e20) {
  return Vi$1[e20];
}
const Wi$1 = new WeakMap();
function Gi$1(e20) {
  if (Wi$1.has(e20))
    return Wi$1.get(e20);
  const t2 = [];
  return e20.this && t2.push(e20.this), Array.isArray(e20.parameters) ? t2.push(...e20.parameters) : Array.isArray(e20.params) && t2.push(...e20.params), e20.rest && t2.push(e20.rest), Wi$1.set(e20, t2), t2;
}
const Ki$1 = new WeakMap();
function Xi$1(e20) {
  if (Ki$1.has(e20))
    return Ki$1.get(e20);
  let t2 = e20.arguments;
  return e20.type === "ImportExpression" && (t2 = [e20.source], e20.attributes && t2.push(e20.attributes)), Ki$1.set(e20, t2), t2;
}
function Ji$1(e20) {
  return e20.value.trim() === "prettier-ignore" && !e20.unignore;
}
function Yi$1(e20) {
  return e20 && (e20.prettierIgnore || ea(e20, Qi$1.PrettierIgnore));
}
const Qi$1 = {
  Leading: 2,
  Trailing: 4,
  Dangling: 8,
  Block: 16,
  Line: 32,
  PrettierIgnore: 64,
  First: 128,
  Last: 256
}, Zi$1 = (e20, t2) => {
  if (typeof e20 == "function" && (t2 = e20, e20 = 0), e20 || t2)
    return (s2, r2, i2) => !(e20 & Qi$1.Leading && !s2.leading || e20 & Qi$1.Trailing && !s2.trailing || e20 & Qi$1.Dangling && (s2.leading || s2.trailing) || e20 & Qi$1.Block && !Fi$1(s2) || e20 & Qi$1.Line && !gi$1(s2) || e20 & Qi$1.First && r2 !== 0 || e20 & Qi$1.Last && r2 !== i2.length - 1 || e20 & Qi$1.PrettierIgnore && !Ji$1(s2) || t2 && !t2(s2));
};
function ea(e20, t2, s2) {
  if (!e20 || !Di$1(e20.comments))
    return false;
  const r2 = Zi$1(t2, s2);
  return !r2 || e20.comments.some(r2);
}
function ta(e20, t2, s2) {
  if (!e20 || !Array.isArray(e20.comments))
    return [];
  const r2 = Zi$1(t2, s2);
  return r2 ? e20.comments.filter(r2) : e20.comments;
}
function sa(e20) {
  return Mi$1(e20) || e20.type === "NewExpression" || e20.type === "ImportExpression";
}
var ra = {
  getFunctionParameters: Gi$1,
  iterateFunctionParametersPath: function(e20, t2) {
    const s2 = e20.getValue();
    let r2 = 0;
    const i2 = (e21) => t2(e21, r2++);
    s2.this && e20.call(i2, "this"), Array.isArray(s2.parameters) ? e20.each(i2, "parameters") : Array.isArray(s2.params) && e20.each(i2, "params"), s2.rest && e20.call(i2, "rest");
  },
  getCallArguments: Xi$1,
  iterateCallArgumentsPath: function(e20, t2) {
    const s2 = e20.getValue();
    s2.type === "ImportExpression" ? (e20.call((e21) => t2(e21, 0), "source"), s2.attributes && e20.call((e21) => t2(e21, 1), "attributes")) : e20.each(t2, "arguments");
  },
  hasRestParameter: function(e20) {
    if (e20.rest)
      return true;
    const t2 = Gi$1(e20);
    return t2.length > 0 && pi$1(t2).type === "RestElement";
  },
  getLeftSide: function(e20) {
    return e20.expressions ? e20.expressions[0] : e20.left || e20.test || e20.callee || e20.object || e20.tag || e20.argument || e20.expression;
  },
  getLeftSidePathName: function(e20, t2) {
    if (t2.expressions)
      return ["expressions", 0];
    if (t2.left)
      return ["left"];
    if (t2.test)
      return ["test"];
    if (t2.object)
      return ["object"];
    if (t2.callee)
      return ["callee"];
    if (t2.tag)
      return ["tag"];
    if (t2.argument)
      return ["argument"];
    if (t2.expression)
      return ["expression"];
    throw new Error("Unexpected node has no left side.");
  },
  getParentExportDeclaration: function(e20) {
    const t2 = e20.getParentNode();
    return e20.getName() === "declaration" && Pi$1(t2) ? t2 : null;
  },
  getTypeScriptMappedTypeModifier: function(e20, t2) {
    return e20 === "+" ? "+" + t2 : e20 === "-" ? "-" + t2 : t2;
  },
  hasFlowAnnotationComment: function(e20) {
    return Di$1(e20) && Fi$1(e20[0]) && xi$1.test(e20[0].value);
  },
  hasFlowShorthandAnnotationComment: function(e20) {
    return e20.extra && e20.extra.parenthesized && Di$1(e20.trailingComments) && Fi$1(e20.trailingComments[0]) && Ci$1.test(e20.trailingComments[0].value);
  },
  hasLeadingOwnLineComment: function(e20, t2) {
    return Ni$1(t2) ? Yi$1(t2) : ea(t2, Qi$1.Leading, (t3) => li$1(e20, Ai$1(t3)));
  },
  hasNakedLeftSide: function(e20) {
    return e20.type === "AssignmentExpression" || e20.type === "BinaryExpression" || e20.type === "LogicalExpression" || e20.type === "NGPipeExpression" || e20.type === "ConditionalExpression" || Mi$1(e20) || Ri$1(e20) || e20.type === "SequenceExpression" || e20.type === "TaggedTemplateExpression" || e20.type === "BindExpression" || e20.type === "UpdateExpression" && !e20.prefix || e20.type === "TSAsExpression" || e20.type === "TSNonNullExpression";
  },
  hasNode: function e14(t2, s2) {
    if (!t2 || typeof t2 != "object")
      return false;
    if (Array.isArray(t2))
      return t2.some((t3) => e14(t3, s2));
    const r2 = s2(t2);
    return typeof r2 == "boolean" ? r2 : Object.values(t2).some((t3) => e14(t3, s2));
  },
  hasIgnoreComment: function(e20) {
    return Yi$1(e20.getValue());
  },
  hasNodeIgnoreComment: Yi$1,
  identity: function(e20) {
    return e20;
  },
  isBinaryish: function(e20) {
    return ki$1.has(e20.type);
  },
  isBlockComment: Fi$1,
  isCallLikeExpression: sa,
  isLineComment: gi$1,
  isPrettierIgnoreComment: Ji$1,
  isCallExpression: Mi$1,
  isMemberExpression: Ri$1,
  isExportDeclaration: Pi$1,
  isFlowAnnotationComment: function(e20, t2) {
    const s2 = yi$1(t2), r2 = di$1(e20, Ai$1(t2));
    return r2 !== false && e20.slice(s2, s2 + 2) === "/*" && e20.slice(r2, r2 + 2) === "*/";
  },
  isFunctionCompositionArgs: function(e20) {
    if (e20.length <= 1)
      return false;
    let t2 = 0;
    for (const s2 of e20)
      if (Si$1(s2)) {
        if (t2 += 1, t2 > 1)
          return true;
      } else if (Mi$1(s2)) {
        for (const e21 of s2.arguments)
          if (Si$1(e21))
            return true;
      }
    return false;
  },
  isFunctionNotation: vi$1,
  isFunctionOrArrowExpression: Si$1,
  isGetterOrSetter: Ii$1,
  isJestEachTemplateLiteral: function(e20, t2) {
    const s2 = /^[fx]?(?:describe|it|test)$/;
    return t2.type === "TaggedTemplateExpression" && t2.quasi === e20 && t2.tag.type === "MemberExpression" && t2.tag.property.type === "Identifier" && t2.tag.property.name === "each" && (t2.tag.object.type === "Identifier" && s2.test(t2.tag.object.name) || t2.tag.object.type === "MemberExpression" && t2.tag.object.property.type === "Identifier" && (t2.tag.object.property.name === "only" || t2.tag.object.property.name === "skip") && t2.tag.object.object.type === "Identifier" && s2.test(t2.tag.object.object.name));
  },
  isJsxNode: Ni$1,
  isLiteral: function(e20) {
    return e20.type === "BooleanLiteral" || e20.type === "DirectiveLiteral" || e20.type === "Literal" || e20.type === "NullLiteral" || e20.type === "NumericLiteral" || e20.type === "BigIntLiteral" || e20.type === "DecimalLiteral" || e20.type === "RegExpLiteral" || e20.type === "StringLiteral" || e20.type === "TemplateLiteral" || e20.type === "TSTypeLiteral" || e20.type === "JSXText";
  },
  isLongCurriedCallExpression: function(e20) {
    const t2 = e20.getValue(), s2 = e20.getParentNode();
    return Mi$1(t2) && Mi$1(s2) && s2.callee === t2 && t2.arguments.length > s2.arguments.length && s2.arguments.length > 0;
  },
  isSimpleCallArgument: function e15(t2, s2) {
    if (s2 >= 2)
      return false;
    const r2 = (t3) => e15(t3, s2 + 1), i2 = t2.type === "Literal" && "regex" in t2 && t2.regex.pattern || t2.type === "RegExpLiteral" && t2.pattern;
    return !(i2 && fi$1(i2) > 5) && (t2.type === "Literal" || t2.type === "BigIntLiteral" || t2.type === "DecimalLiteral" || t2.type === "BooleanLiteral" || t2.type === "NullLiteral" || t2.type === "NumericLiteral" || t2.type === "RegExpLiteral" || t2.type === "StringLiteral" || t2.type === "Identifier" || t2.type === "ThisExpression" || t2.type === "Super" || t2.type === "PrivateName" || t2.type === "PrivateIdentifier" || t2.type === "ArgumentPlaceholder" || t2.type === "Import" || (t2.type === "TemplateLiteral" ? t2.quasis.every((e20) => !e20.value.raw.includes("\n")) && t2.expressions.every(r2) : t2.type === "ObjectExpression" ? t2.properties.every((e20) => !e20.computed && (e20.shorthand || e20.value && r2(e20.value))) : t2.type === "ArrayExpression" ? t2.elements.every((e20) => e20 === null || r2(e20)) : sa(t2) ? (t2.type === "ImportExpression" || e15(t2.callee, s2)) && Xi$1(t2).every(r2) : Ri$1(t2) ? e15(t2.object, s2) && e15(t2.property, s2) : t2.type !== "UnaryExpression" || t2.operator !== "!" && t2.operator !== "-" ? t2.type === "TSNonNullExpression" && e15(t2.expression, s2) : e15(t2.argument, s2)));
  },
  isMemberish: function(e20) {
    return Ri$1(e20) || e20.type === "BindExpression" && Boolean(e20.object);
  },
  isNumericLiteral: Ti$1,
  isSignedNumericLiteral: function(e20) {
    return e20.type === "UnaryExpression" && (e20.operator === "+" || e20.operator === "-") && Ti$1(e20.argument);
  },
  isObjectProperty: function(e20) {
    return e20 && (e20.type === "ObjectProperty" || e20.type === "Property" && !e20.method && e20.kind === "init");
  },
  isObjectType: function(e20) {
    return e20.type === "ObjectTypeAnnotation" || e20.type === "TSTypeLiteral" || e20.type === "TSMappedType";
  },
  isObjectTypePropertyAFunction: function(e20) {
    return !(e20.type !== "ObjectTypeProperty" && e20.type !== "ObjectTypeInternalSlot" || e20.value.type !== "FunctionTypeAnnotation" || e20.static || vi$1(e20));
  },
  isSimpleType: function(e20) {
    return !!e20 && (!(e20.type !== "GenericTypeAnnotation" && e20.type !== "TSTypeReference" || e20.typeParameters) || !!Li$1.has(e20.type));
  },
  isSimpleNumber: ji$1,
  isSimpleTemplateLiteral: function(e20) {
    let t2 = "expressions";
    e20.type === "TSTemplateLiteralType" && (t2 = "types");
    const s2 = e20[t2];
    return s2.length !== 0 && s2.every((e21) => {
      if (ea(e21))
        return false;
      if (e21.type === "Identifier" || e21.type === "ThisExpression")
        return true;
      if (Ri$1(e21)) {
        let t3 = e21;
        for (; Ri$1(t3); ) {
          if (t3.property.type !== "Identifier" && t3.property.type !== "Literal" && t3.property.type !== "StringLiteral" && t3.property.type !== "NumericLiteral")
            return false;
          if (t3 = t3.object, ea(t3))
            return false;
        }
        return t3.type === "Identifier" || t3.type === "ThisExpression";
      }
      return false;
    });
  },
  isStringLiteral: wi$1,
  isStringPropSafeToUnquote: function(e20, t2) {
    return t2.parser !== "json" && wi$1(e20.key) && Ui$1(e20.key).slice(1, -1) === e20.key.value && (ci$1(e20.key.value) && !((t2.parser === "typescript" || t2.parser === "babel-ts") && e20.type === "ClassProperty") || ji$1(e20.key.value) && String(Number(e20.key.value)) === e20.key.value && (t2.parser === "babel" || t2.parser === "espree" || t2.parser === "meriyah" || t2.parser === "__babel_estree"));
  },
  isTemplateOnItsOwnLine: function(e20, t2) {
    return (e20.type === "TemplateLiteral" && _i$1(e20) || e20.type === "TaggedTemplateExpression" && _i$1(e20.quasi)) && !li$1(t2, yi$1(e20), { backwards: true });
  },
  isTestCall: function e16(t2, s2) {
    if (t2.type !== "CallExpression")
      return false;
    if (t2.arguments.length === 1) {
      if (Bi$1(t2) && s2 && e16(s2))
        return Si$1(t2.arguments[0]);
      if (function(e20) {
        return e20.callee.type === "Identifier" && /^(?:before|after)(?:Each|All)$/.test(e20.callee.name) && e20.arguments.length === 1;
      }(t2))
        return Bi$1(t2.arguments[0]);
    } else if ((t2.arguments.length === 2 || t2.arguments.length === 3) && (t2.callee.type === "Identifier" && Oi$1.test(t2.callee.name) || function(e20) {
      return Ri$1(e20.callee) && e20.callee.object.type === "Identifier" && e20.callee.property.type === "Identifier" && Oi$1.test(e20.callee.object.name) && (e20.callee.property.name === "only" || e20.callee.property.name === "skip");
    }(t2)) && (function(e20) {
      return e20.type === "TemplateLiteral";
    }(t2.arguments[0]) || wi$1(t2.arguments[0])))
      return !(t2.arguments[2] && !Ti$1(t2.arguments[2])) && ((t2.arguments.length === 2 ? Si$1(t2.arguments[1]) : function(e20) {
        return e20.type === "FunctionExpression" || e20.type === "ArrowFunctionExpression" && e20.body.type === "BlockStatement";
      }(t2.arguments[1]) && Gi$1(t2.arguments[1]).length <= 1) || Bi$1(t2.arguments[1]));
    return false;
  },
  isTheOnlyJsxElementInMarkdown: function(e20, t2) {
    if (e20.parentParser !== "markdown" && e20.parentParser !== "mdx")
      return false;
    const s2 = t2.getNode();
    if (!s2.expression || !Ni$1(s2.expression))
      return false;
    const r2 = t2.getParentNode();
    return r2.type === "Program" && r2.body.length === 1;
  },
  isTSXFile: function(e20) {
    return e20.filepath && /\.tsx$/i.test(e20.filepath);
  },
  isTypeAnnotationAFunction: function(e20) {
    return !(e20.type !== "TypeAnnotation" && e20.type !== "TSTypeAnnotation" || e20.typeAnnotation.type !== "FunctionTypeAnnotation" || e20.static || Ei$1(e20, e20.typeAnnotation));
  },
  isNextLineEmpty: (e20, { originalText: t2 }) => mi$1(t2, Ai$1(e20)),
  needsHardlineAfterDanglingComment: function(e20) {
    if (!ea(e20))
      return false;
    const t2 = pi$1(ta(e20, Qi$1.Dangling));
    return t2 && !Fi$1(t2);
  },
  rawText: Ui$1,
  shouldPrintComma: function(e20, t2 = "es5") {
    return e20.trailingComma === "es5" && t2 === "es5" || e20.trailingComma === "all" && (t2 === "all" || t2 === "es5");
  },
  isBitwiseOperator: function(e20) {
    return Boolean(Hi$1[e20]) || e20 === "|" || e20 === "^" || e20 === "&";
  },
  shouldFlatten: function(e20, t2) {
    return zi$1(t2) === zi$1(e20) && e20 !== "**" && (!qi$1[e20] || !qi$1[t2]) && !(t2 === "%" && $i$1[e20] || e20 === "%" && $i$1[t2]) && (t2 === e20 || !$i$1[t2] || !$i$1[e20]) && (!Hi$1[e20] || !Hi$1[t2]);
  },
  startsWithNoLookaheadToken: function e17(t2, s2) {
    switch ((t2 = function(e20) {
      for (; e20.left; )
        e20 = e20.left;
      return e20;
    }(t2)).type) {
      case "FunctionExpression":
      case "ClassExpression":
      case "DoExpression":
        return s2;
      case "ObjectExpression":
        return true;
      case "MemberExpression":
      case "OptionalMemberExpression":
        return e17(t2.object, s2);
      case "TaggedTemplateExpression":
        return t2.tag.type !== "FunctionExpression" && e17(t2.tag, s2);
      case "CallExpression":
      case "OptionalCallExpression":
        return t2.callee.type !== "FunctionExpression" && e17(t2.callee, s2);
      case "ConditionalExpression":
        return e17(t2.test, s2);
      case "UpdateExpression":
        return !t2.prefix && e17(t2.argument, s2);
      case "BindExpression":
        return t2.object && e17(t2.object, s2);
      case "SequenceExpression":
        return e17(t2.expressions[0], s2);
      case "TSAsExpression":
      case "TSNonNullExpression":
        return e17(t2.expression, s2);
      default:
        return false;
    }
  },
  getPrecedence: zi$1,
  hasComment: ea,
  getComments: ta,
  CommentCheckFlags: Qi$1
};
const {
  getLast: ia,
  hasNewline: aa,
  getNextNonSpaceNonCommentCharacterIndexWithStartIndex: na,
  getNextNonSpaceNonCommentCharacter: oa,
  hasNewlineInRange: ua,
  addLeadingComment: ha,
  addTrailingComment: ca,
  addDanglingComment: pa,
  getNextNonSpaceNonCommentCharacterIndex: la,
  isNonEmptyArray: da
} = tr$1, {
  isBlockComment: Da,
  getFunctionParameters: ma,
  isPrettierIgnoreComment: fa,
  isJsxNode: ya,
  hasFlowShorthandAnnotationComment: Aa,
  hasFlowAnnotationComment: Ea,
  hasIgnoreComment: Ca,
  isCallLikeExpression: xa,
  getCallArguments: Fa,
  isCallExpression: ga,
  isMemberExpression: ba,
  isObjectProperty: Pa,
  getComments: Ta,
  CommentCheckFlags: wa
} = ra, { locStart: Sa, locEnd: Ba } = ei$1;
function Na(e20, t2) {
  const s2 = (e20.body || e20.properties).find(({ type: e21 }) => e21 !== "EmptyStatement");
  s2 ? ha(s2, t2) : pa(e20, t2);
}
function Ia(e20, t2) {
  e20.type === "BlockStatement" ? Na(e20, t2) : ha(e20, t2);
}
function va({ comment: e20, followingNode: t2 }) {
  return !(!t2 || !un$1(e20)) && (ha(t2, e20), true);
}
function ka({
  comment: e20,
  precedingNode: t2,
  enclosingNode: s2,
  followingNode: r2,
  text: i2
}) {
  if (!s2 || s2.type !== "IfStatement" || !r2)
    return false;
  return oa(i2, e20, Ba) === ")" ? (ca(t2, e20), true) : t2 === s2.consequent && r2 === s2.alternate ? (t2.type === "BlockStatement" ? ca(t2, e20) : pa(s2, e20), true) : r2.type === "BlockStatement" ? (Na(r2, e20), true) : r2.type === "IfStatement" ? (Ia(r2.consequent, e20), true) : s2.consequent === r2 && (ha(r2, e20), true);
}
function La({
  comment: e20,
  precedingNode: t2,
  enclosingNode: s2,
  followingNode: r2,
  text: i2
}) {
  if (!s2 || s2.type !== "WhileStatement" || !r2)
    return false;
  return oa(i2, e20, Ba) === ")" ? (ca(t2, e20), true) : r2.type === "BlockStatement" ? (Na(r2, e20), true) : s2.body === r2 && (ha(r2, e20), true);
}
function Oa({
  comment: e20,
  precedingNode: t2,
  enclosingNode: s2,
  followingNode: r2
}) {
  return !(!s2 || s2.type !== "TryStatement" && s2.type !== "CatchClause" || !r2) && (s2.type === "CatchClause" && t2 ? (ca(t2, e20), true) : r2.type === "BlockStatement" ? (Na(r2, e20), true) : r2.type === "TryStatement" ? (Ia(r2.finalizer, e20), true) : r2.type === "CatchClause" && (Ia(r2.body, e20), true));
}
function Ma({ comment: e20, enclosingNode: t2, followingNode: s2 }) {
  return !(!ba(t2) || !s2 || s2.type !== "Identifier") && (ha(t2, e20), true);
}
function Ra({
  comment: e20,
  precedingNode: t2,
  enclosingNode: s2,
  followingNode: r2,
  text: i2
}) {
  const a2 = t2 && !ua(i2, Ba(t2), Sa(e20));
  return !(t2 && a2 || !s2 || s2.type !== "ConditionalExpression" && s2.type !== "TSConditionalType" || !r2) && (ha(r2, e20), true);
}
function ja({ comment: e20, precedingNode: t2, enclosingNode: s2 }) {
  return !(!Pa(s2) || !s2.shorthand || s2.key !== t2 || s2.value.type !== "AssignmentPattern") && (ca(s2.value.left, e20), true);
}
function _a$3({
  comment: e20,
  precedingNode: t2,
  enclosingNode: s2,
  followingNode: r2
}) {
  if (s2 && (s2.type === "ClassDeclaration" || s2.type === "ClassExpression" || s2.type === "DeclareClass" || s2.type === "DeclareInterface" || s2.type === "InterfaceDeclaration" || s2.type === "TSInterfaceDeclaration")) {
    if (da(s2.decorators) && (!r2 || r2.type !== "Decorator"))
      return ca(ia(s2.decorators), e20), true;
    if (s2.body && r2 === s2.body)
      return Na(s2.body, e20), true;
    if (r2) {
      for (const i2 of ["implements", "extends", "mixins"])
        if (s2[i2] && r2 === s2[i2][0])
          return !t2 || t2 !== s2.id && t2 !== s2.typeParameters && t2 !== s2.superClass ? pa(s2, e20, i2) : ca(t2, e20), true;
    }
  }
  return false;
}
function Ua({ comment: e20, precedingNode: t2, enclosingNode: s2, text: r2 }) {
  return (s2 && t2 && (s2.type === "Property" || s2.type === "TSDeclareMethod" || s2.type === "TSAbstractMethodDefinition") && t2.type === "Identifier" && s2.key === t2 && oa(r2, t2, Ba) !== ":" || !(!t2 || !s2 || t2.type !== "Decorator" || s2.type !== "ClassMethod" && s2.type !== "ClassProperty" && s2.type !== "PropertyDefinition" && s2.type !== "TSAbstractClassProperty" && s2.type !== "TSAbstractMethodDefinition" && s2.type !== "TSDeclareMethod" && s2.type !== "MethodDefinition")) && (ca(t2, e20), true);
}
function qa({ comment: e20, precedingNode: t2, enclosingNode: s2, text: r2 }) {
  return oa(r2, e20, Ba) === "(" && !(!t2 || !s2 || s2.type !== "FunctionDeclaration" && s2.type !== "FunctionExpression" && s2.type !== "ClassMethod" && s2.type !== "MethodDefinition" && s2.type !== "ObjectMethod") && (ca(t2, e20), true);
}
function $a({ comment: e20, enclosingNode: t2, text: s2 }) {
  if (!t2 || t2.type !== "ArrowFunctionExpression")
    return false;
  const r2 = la(s2, e20, Ba);
  return r2 !== false && s2.slice(r2, r2 + 2) === "=>" && (pa(t2, e20), true);
}
function Ha({ comment: e20, enclosingNode: t2, text: s2 }) {
  return oa(s2, e20, Ba) === ")" && (t2 && (on$1(t2) && ma(t2).length === 0 || xa(t2) && Fa(t2).length === 0) ? (pa(t2, e20), true) : !(!t2 || t2.type !== "MethodDefinition" && t2.type !== "TSAbstractMethodDefinition" || ma(t2.value).length !== 0) && (pa(t2.value, e20), true));
}
function Va({
  comment: e20,
  precedingNode: t2,
  enclosingNode: s2,
  followingNode: r2,
  text: i2
}) {
  if (t2 && t2.type === "FunctionTypeParam" && s2 && s2.type === "FunctionTypeAnnotation" && r2 && r2.type !== "FunctionTypeParam")
    return ca(t2, e20), true;
  if (t2 && (t2.type === "Identifier" || t2.type === "AssignmentPattern") && s2 && on$1(s2) && oa(i2, e20, Ba) === ")")
    return ca(t2, e20), true;
  if (s2 && s2.type === "FunctionDeclaration" && r2 && r2.type === "BlockStatement") {
    const t3 = (() => {
      const e21 = ma(s2);
      if (e21.length > 0)
        return na(i2, Ba(ia(e21)));
      const t4 = na(i2, Ba(s2.id));
      return t4 !== false && na(i2, t4 + 1);
    })();
    if (Sa(e20) > t3)
      return Na(r2, e20), true;
  }
  return false;
}
function za({ comment: e20, enclosingNode: t2 }) {
  return !(!t2 || t2.type !== "ImportSpecifier") && (ha(t2, e20), true);
}
function Wa({ comment: e20, enclosingNode: t2 }) {
  return !(!t2 || t2.type !== "LabeledStatement") && (ha(t2, e20), true);
}
function Ga({ comment: e20, enclosingNode: t2 }) {
  return !(!t2 || t2.type !== "ContinueStatement" && t2.type !== "BreakStatement" || t2.label) && (ca(t2, e20), true);
}
function Ka({ comment: e20, precedingNode: t2, enclosingNode: s2 }) {
  return !!(ga(s2) && t2 && s2.callee === t2 && s2.arguments.length > 0) && (ha(s2.arguments[0], e20), true);
}
function Xa({
  comment: e20,
  precedingNode: t2,
  enclosingNode: s2,
  followingNode: r2
}) {
  return !s2 || s2.type !== "UnionTypeAnnotation" && s2.type !== "TSUnionType" ? (r2 && (r2.type === "UnionTypeAnnotation" || r2.type === "TSUnionType") && fa(e20) && (r2.types[0].prettierIgnore = true, e20.unignore = true), false) : (fa(e20) && (r2.prettierIgnore = true, e20.unignore = true), !!t2 && (ca(t2, e20), true));
}
function Ja({ comment: e20, enclosingNode: t2 }) {
  return !!Pa(t2) && (ha(t2, e20), true);
}
function Ya({
  comment: e20,
  enclosingNode: t2,
  followingNode: s2,
  ast: r2,
  isLastComment: i2
}) {
  return r2 && r2.body && r2.body.length === 0 ? (i2 ? pa(r2, e20) : ha(r2, e20), true) : t2 && t2.type === "Program" && t2.body.length === 0 && !da(t2.directives) ? (i2 ? pa(t2, e20) : ha(t2, e20), true) : !(!s2 || s2.type !== "Program" || s2.body.length !== 0 || !t2 || t2.type !== "ModuleExpression") && (pa(s2, e20), true);
}
function Qa({ comment: e20, enclosingNode: t2 }) {
  return !(!t2 || t2.type !== "ForInStatement" && t2.type !== "ForOfStatement") && (ha(t2, e20), true);
}
function Za({ comment: e20, precedingNode: t2, enclosingNode: s2, text: r2 }) {
  return !!(t2 && t2.type === "ImportSpecifier" && s2 && s2.type === "ImportDeclaration" && aa(r2, Ba(e20))) && (ca(t2, e20), true);
}
function en$1({ comment: e20, enclosingNode: t2 }) {
  return !(!t2 || t2.type !== "AssignmentPattern") && (ha(t2, e20), true);
}
function tn$1({ comment: e20, enclosingNode: t2 }) {
  return !(!t2 || t2.type !== "TypeAlias") && (ha(t2, e20), true);
}
function sn$1({ comment: e20, enclosingNode: t2, followingNode: s2 }) {
  return !(!t2 || t2.type !== "VariableDeclarator" && t2.type !== "AssignmentExpression" || !s2 || s2.type !== "ObjectExpression" && s2.type !== "ArrayExpression" && s2.type !== "TemplateLiteral" && s2.type !== "TaggedTemplateExpression" && !Da(e20)) && (ha(s2, e20), true);
}
function rn$1({ comment: e20, enclosingNode: t2, followingNode: s2, text: r2 }) {
  return !(s2 || !t2 || t2.type !== "TSMethodSignature" && t2.type !== "TSDeclareFunction" && t2.type !== "TSAbstractMethodDefinition" || oa(r2, e20, Ba) !== ";") && (ca(t2, e20), true);
}
function an$1({ comment: e20, enclosingNode: t2, followingNode: s2 }) {
  if (fa(e20) && t2 && t2.type === "TSMappedType" && s2 && s2.type === "TSTypeParameter" && s2.constraint)
    return t2.prettierIgnore = true, e20.unignore = true, true;
}
function nn$1({
  comment: e20,
  precedingNode: t2,
  enclosingNode: s2,
  followingNode: r2
}) {
  return !(!s2 || s2.type !== "TSMappedType") && (r2 && r2.type === "TSTypeParameter" && r2.name ? (ha(r2.name, e20), true) : !(!t2 || t2.type !== "TSTypeParameter" || !t2.constraint) && (ca(t2.constraint, e20), true));
}
function on$1(e20) {
  return e20.type === "ArrowFunctionExpression" || e20.type === "FunctionExpression" || e20.type === "FunctionDeclaration" || e20.type === "ObjectMethod" || e20.type === "ClassMethod" || e20.type === "TSDeclareFunction" || e20.type === "TSCallSignatureDeclaration" || e20.type === "TSConstructSignatureDeclaration" || e20.type === "TSMethodSignature" || e20.type === "TSConstructorType" || e20.type === "TSFunctionType" || e20.type === "TSDeclareMethod";
}
function un$1(e20) {
  return Da(e20) && e20.value[0] === "*" && /@type\b/.test(e20.value);
}
var hn$1 = {
  handleOwnLineComment: function(e20) {
    return [
      an$1,
      Va,
      Ma,
      ka,
      La,
      Oa,
      _a$3,
      za,
      Qa,
      Xa,
      Ya,
      Za,
      en$1,
      Ua,
      Wa
    ].some((t2) => t2(e20));
  },
  handleEndOfLineComment: function(e20) {
    return [
      va,
      Va,
      Ra,
      za,
      ka,
      La,
      Oa,
      _a$3,
      Wa,
      Ka,
      Ja,
      Ya,
      tn$1,
      sn$1
    ].some((t2) => t2(e20));
  },
  handleRemainingComment: function(e20) {
    return [an$1, ka, La, ja, Ha, Ua, Ya, $a, qa, nn$1, Ga, rn$1].some((t2) => t2(e20));
  },
  isTypeCastComment: un$1,
  getCommentChildNodes: function(e20, t2) {
    if ((t2.parser === "typescript" || t2.parser === "flow" || t2.parser === "espree" || t2.parser === "meriyah" || t2.parser === "__babel_estree") && e20.type === "MethodDefinition" && e20.value && e20.value.type === "FunctionExpression" && ma(e20.value).length === 0 && !e20.value.returnType && !da(e20.value.typeParameters) && e20.value.body)
      return [...e20.decorators || [], e20.key, e20.value.body];
  },
  willPrintOwnComments: function(e20) {
    const t2 = e20.getValue(), s2 = e20.getParentNode();
    return (t2 && (ya(t2) || Aa(t2) || ga(s2) && ((e21) => Ea(Ta(e21, wa.Leading)) || Ea(Ta(e21, wa.Trailing)))(t2)) || s2 && (s2.type === "JSXSpreadAttribute" || s2.type === "JSXSpreadChild" || s2.type === "UnionTypeAnnotation" || s2.type === "TSUnionType" || (s2.type === "ClassDeclaration" || s2.type === "ClassExpression") && s2.superClass === t2)) && (!Ca(e20) || s2.type === "UnionTypeAnnotation" || s2.type === "TSUnionType");
  }
};
const { getLast: cn$1, getNextNonSpaceNonCommentCharacter: pn$1 } = tr$1, { locStart: ln$1, locEnd: dn$1 } = ei$1, { isTypeCastComment: Dn$1 } = hn$1;
function mn$1(e20) {
  return e20.type === "CallExpression" ? (e20.type = "OptionalCallExpression", e20.callee = mn$1(e20.callee)) : e20.type === "MemberExpression" ? (e20.type = "OptionalMemberExpression", e20.object = mn$1(e20.object)) : e20.type === "TSNonNullExpression" && (e20.expression = mn$1(e20.expression)), e20;
}
function fn$1(e20, t2) {
  let s2;
  if (Array.isArray(e20))
    s2 = e20.entries();
  else {
    if (!e20 || typeof e20 != "object" || typeof e20.type != "string")
      return e20;
    s2 = Object.entries(e20);
  }
  for (const [r2, i2] of s2)
    e20[r2] = fn$1(i2, t2);
  return Array.isArray(e20) ? e20 : t2(e20) || e20;
}
function yn$1(e20) {
  return e20.type === "LogicalExpression" && e20.right.type === "LogicalExpression" && e20.operator === e20.right.operator;
}
function An$1(e20) {
  return yn$1(e20) ? An$1({
    type: "LogicalExpression",
    operator: e20.operator,
    left: An$1({
      type: "LogicalExpression",
      operator: e20.operator,
      left: e20.left,
      right: e20.right.left,
      range: [ln$1(e20.left), dn$1(e20.right.left)]
    }),
    right: e20.right.right,
    range: [ln$1(e20), dn$1(e20)]
  }) : e20;
}
var En$1 = function(e20, t2) {
  if (t2.parser === "typescript" && t2.originalText.includes("@")) {
    const { esTreeNodeToTSNodeMap: s2, tsNodeToESTreeNodeMap: r2 } = t2.tsParseResult;
    e20 = fn$1(e20, (e21) => {
      const t3 = s2.get(e21);
      if (!t3)
        return;
      const i2 = t3.decorators;
      if (!Array.isArray(i2))
        return;
      const a2 = r2.get(t3);
      if (a2 !== e21)
        return;
      const n2 = a2.decorators;
      if (!Array.isArray(n2) || n2.length !== i2.length || i2.some((e22) => {
        const t4 = r2.get(e22);
        return !t4 || !n2.includes(t4);
      })) {
        const { start: e22, end: t4 } = a2.loc;
        throw ai$1("Leading decorators must be attached to a class declaration", {
          start: { line: e22.line, column: e22.column + 1 },
          end: { line: t4.line, column: t4.column + 1 }
        });
      }
    });
  }
  if (t2.parser !== "typescript" && t2.parser !== "flow" && t2.parser !== "espree" && t2.parser !== "meriyah") {
    const t3 = new Set();
    e20 = fn$1(e20, (e21) => {
      e21.leadingComments && e21.leadingComments.some(Dn$1) && t3.add(ln$1(e21));
    }), e20 = fn$1(e20, (e21) => {
      if (e21.type === "ParenthesizedExpression") {
        const { expression: s2 } = e21;
        if (s2.type === "TypeCastExpression")
          return s2.range = e21.range, s2;
        const r2 = ln$1(e21);
        if (!t3.has(r2))
          return s2.extra = Object.assign(Object.assign({}, s2.extra), {}, { parenthesized: true }), s2;
      }
    });
  }
  return e20 = fn$1(e20, (e21) => {
    switch (e21.type) {
      case "ChainExpression":
        return mn$1(e21.expression);
      case "LogicalExpression":
        if (yn$1(e21))
          return An$1(e21);
        break;
      case "VariableDeclaration": {
        const s2 = cn$1(e21.declarations);
        s2 && s2.init && function(e22, s3) {
          if (t2.originalText[dn$1(s3)] === ";")
            return;
          e22.range = [ln$1(e22), dn$1(s3)];
        }(e21, s2);
        break;
      }
      case "TSParenthesizedType":
        return e21.typeAnnotation.range = [ln$1(e21), dn$1(e21)], e21.typeAnnotation;
      case "TSTypeParameter":
        if (typeof e21.name == "string") {
          const t3 = ln$1(e21);
          e21.name = {
            type: "Identifier",
            name: e21.name,
            range: [t3, t3 + e21.name.length]
          };
        }
        break;
      case "SequenceExpression": {
        const t3 = cn$1(e21.expressions);
        e21.range = [ln$1(e21), Math.min(dn$1(t3), dn$1(e21))];
        break;
      }
      case "ClassProperty":
        e21.key && e21.key.type === "TSPrivateIdentifier" && pn$1(t2.originalText, e21.key, dn$1) === "?" && (e21.optional = true);
    }
  });
};
class Cn$1 {
  constructor(e20, t2 = {}) {
    this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.updateContext = void 0, this.label = e20, this.keyword = t2.keyword, this.beforeExpr = !!t2.beforeExpr, this.startsExpr = !!t2.startsExpr, this.rightAssociative = !!t2.rightAssociative, this.isLoop = !!t2.isLoop, this.isAssign = !!t2.isAssign, this.prefix = !!t2.prefix, this.postfix = !!t2.postfix, this.binop = t2.binop != null ? t2.binop : null, this.updateContext = null;
  }
}
const xn$1 = new Map();
function Fn$1(e20, t2 = {}) {
  t2.keyword = e20;
  const s2 = new Cn$1(e20, t2);
  return xn$1.set(e20, s2), s2;
}
function gn$1(e20, t2) {
  return new Cn$1(e20, { beforeExpr: true, binop: t2 });
}
const bn$1 = {
  num: new Cn$1("num", { startsExpr: true }),
  bigint: new Cn$1("bigint", { startsExpr: true }),
  decimal: new Cn$1("decimal", { startsExpr: true }),
  regexp: new Cn$1("regexp", { startsExpr: true }),
  string: new Cn$1("string", { startsExpr: true }),
  name: new Cn$1("name", { startsExpr: true }),
  privateName: new Cn$1("#name", { startsExpr: true }),
  eof: new Cn$1("eof"),
  bracketL: new Cn$1("[", { beforeExpr: true, startsExpr: true }),
  bracketHashL: new Cn$1("#[", { beforeExpr: true, startsExpr: true }),
  bracketBarL: new Cn$1("[|", { beforeExpr: true, startsExpr: true }),
  bracketR: new Cn$1("]"),
  bracketBarR: new Cn$1("|]"),
  braceL: new Cn$1("{", { beforeExpr: true, startsExpr: true }),
  braceBarL: new Cn$1("{|", { beforeExpr: true, startsExpr: true }),
  braceHashL: new Cn$1("#{", { beforeExpr: true, startsExpr: true }),
  braceR: new Cn$1("}", { beforeExpr: true }),
  braceBarR: new Cn$1("|}"),
  parenL: new Cn$1("(", { beforeExpr: true, startsExpr: true }),
  parenR: new Cn$1(")"),
  comma: new Cn$1(",", { beforeExpr: true }),
  semi: new Cn$1(";", { beforeExpr: true }),
  colon: new Cn$1(":", { beforeExpr: true }),
  doubleColon: new Cn$1("::", { beforeExpr: true }),
  dot: new Cn$1("."),
  question: new Cn$1("?", { beforeExpr: true }),
  questionDot: new Cn$1("?."),
  arrow: new Cn$1("=>", { beforeExpr: true }),
  template: new Cn$1("template"),
  ellipsis: new Cn$1("...", { beforeExpr: true }),
  backQuote: new Cn$1("`", { startsExpr: true }),
  dollarBraceL: new Cn$1("${", { beforeExpr: true, startsExpr: true }),
  at: new Cn$1("@"),
  hash: new Cn$1("#", { startsExpr: true }),
  interpreterDirective: new Cn$1("#!..."),
  eq: new Cn$1("=", { beforeExpr: true, isAssign: true }),
  assign: new Cn$1("_=", { beforeExpr: true, isAssign: true }),
  slashAssign: new Cn$1("_=", { beforeExpr: true, isAssign: true }),
  moduloAssign: new Cn$1("_=", { beforeExpr: true, isAssign: true }),
  incDec: new Cn$1("++/--", {
    prefix: true,
    postfix: true,
    startsExpr: true
  }),
  bang: new Cn$1("!", {
    beforeExpr: true,
    prefix: true,
    startsExpr: true
  }),
  tilde: new Cn$1("~", {
    beforeExpr: true,
    prefix: true,
    startsExpr: true
  }),
  pipeline: gn$1("|>", 0),
  nullishCoalescing: gn$1("??", 1),
  logicalOR: gn$1("||", 1),
  logicalAND: gn$1("&&", 2),
  bitwiseOR: gn$1("|", 3),
  bitwiseXOR: gn$1("^", 4),
  bitwiseAND: gn$1("&", 5),
  equality: gn$1("==/!=/===/!==", 6),
  relational: gn$1("</>/<=/>=", 7),
  bitShift: gn$1("<</>>/>>>", 8),
  plusMin: new Cn$1("+/-", {
    beforeExpr: true,
    binop: 9,
    prefix: true,
    startsExpr: true
  }),
  modulo: new Cn$1("%", { binop: 10, startsExpr: true }),
  star: new Cn$1("*", { binop: 10 }),
  slash: gn$1("/", 10),
  exponent: new Cn$1("**", {
    beforeExpr: true,
    binop: 11,
    rightAssociative: true
  }),
  _break: Fn$1("break"),
  _case: Fn$1("case", { beforeExpr: true }),
  _catch: Fn$1("catch"),
  _continue: Fn$1("continue"),
  _debugger: Fn$1("debugger"),
  _default: Fn$1("default", { beforeExpr: true }),
  _do: Fn$1("do", { isLoop: true, beforeExpr: true }),
  _else: Fn$1("else", { beforeExpr: true }),
  _finally: Fn$1("finally"),
  _for: Fn$1("for", { isLoop: true }),
  _function: Fn$1("function", { startsExpr: true }),
  _if: Fn$1("if"),
  _return: Fn$1("return", { beforeExpr: true }),
  _switch: Fn$1("switch"),
  _throw: Fn$1("throw", {
    beforeExpr: true,
    prefix: true,
    startsExpr: true
  }),
  _try: Fn$1("try"),
  _var: Fn$1("var"),
  _const: Fn$1("const"),
  _while: Fn$1("while", { isLoop: true }),
  _with: Fn$1("with"),
  _new: Fn$1("new", { beforeExpr: true, startsExpr: true }),
  _this: Fn$1("this", { startsExpr: true }),
  _super: Fn$1("super", { startsExpr: true }),
  _class: Fn$1("class", { startsExpr: true }),
  _extends: Fn$1("extends", { beforeExpr: true }),
  _export: Fn$1("export"),
  _import: Fn$1("import", { startsExpr: true }),
  _null: Fn$1("null", { startsExpr: true }),
  _true: Fn$1("true", { startsExpr: true }),
  _false: Fn$1("false", { startsExpr: true }),
  _in: Fn$1("in", { beforeExpr: true, binop: 7 }),
  _instanceof: Fn$1("instanceof", { beforeExpr: true, binop: 7 }),
  _typeof: Fn$1("typeof", {
    beforeExpr: true,
    prefix: true,
    startsExpr: true
  }),
  _void: Fn$1("void", {
    beforeExpr: true,
    prefix: true,
    startsExpr: true
  }),
  _delete: Fn$1("delete", {
    beforeExpr: true,
    prefix: true,
    startsExpr: true
  })
}, Pn$1 = /\r\n?|[\n\u2028\u2029]/, Tn$1 = new RegExp(Pn$1.source, "g");
function wn$1(e20) {
  switch (e20) {
    case 10:
    case 13:
    case 8232:
    case 8233:
      return true;
    default:
      return false;
  }
}
const Sn$1 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Bn$1 = new RegExp("(?=(" + /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
function Nn$1(e20) {
  switch (e20) {
    case 9:
    case 11:
    case 12:
    case 32:
    case 160:
    case 5760:
    case 8192:
    case 8193:
    case 8194:
    case 8195:
    case 8196:
    case 8197:
    case 8198:
    case 8199:
    case 8200:
    case 8201:
    case 8202:
    case 8239:
    case 8287:
    case 12288:
    case 65279:
      return true;
    default:
      return false;
  }
}
class In$1 {
  constructor(e20, t2) {
    this.line = void 0, this.column = void 0, this.line = e20, this.column = t2;
  }
}
class vn$1 {
  constructor(e20, t2) {
    this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = e20, this.end = t2;
  }
}
function kn$1(e20, t2) {
  e20.trailingComments === void 0 ? e20.trailingComments = t2 : e20.trailingComments.unshift(...t2);
}
function Ln$1(e20, t2) {
  e20.innerComments === void 0 ? e20.innerComments = t2 : t2 !== void 0 && e20.innerComments.unshift(...t2);
}
function On$1(e20, t2, s2) {
  let r2 = null, i2 = t2.length;
  for (; r2 === null && i2 > 0; )
    r2 = t2[--i2];
  r2 === null || r2.start > s2.start ? Ln$1(e20, s2.comments) : kn$1(r2, s2.comments);
}
const Mn$1 = Object.freeze({
  SyntaxError: "BABEL_PARSER_SYNTAX_ERROR",
  SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
}), Rn$1 = Un$1({
  AccessorIsGenerator: "A %0ter cannot be a generator.",
  ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
  AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
  AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
  AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
  AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
  AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
  AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
  BadGetterArity: "A 'get' accesor must not have any formal parameters.",
  BadSetterArity: "A 'set' accesor must have exactly one formal parameter.",
  BadSetterRestParameter: "A 'set' accesor function argument must not be a rest parameter.",
  ConstructorClassField: "Classes may not have a field named 'constructor'.",
  ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
  ConstructorIsAccessor: "Class constructor may not be an accessor.",
  ConstructorIsAsync: "Constructor can't be an async function.",
  ConstructorIsGenerator: "Constructor can't be a generator.",
  DeclarationMissingInitializer: "'%0' require an initialization value.",
  DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.",
  DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
  DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.",
  DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
  DecoratorStaticBlock: "Decorators can't be used with a static block.",
  DeletePrivateField: "Deleting a private field is not allowed.",
  DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
  DuplicateConstructor: "Duplicate constructor in the same class.",
  DuplicateDefaultExport: "Only one default export allowed per module.",
  DuplicateExport: "`%0` has already been exported. Exported identifiers must be unique.",
  DuplicateProto: "Redefinition of __proto__ property.",
  DuplicateRegExpFlags: "Duplicate regular expression flag.",
  ElementAfterRest: "Rest element must be last element.",
  EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
  ExportBindingIsString: "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { '%0' as '%1' } from 'some-module'`?",
  ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
  ForInOfLoopInitializer: "'%0' loop variable declaration may not have an initializer.",
  ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
  ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
  GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
  IllegalBreakContinue: "Unsyntactic %0.",
  IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
  IllegalReturn: "'return' outside of function.",
  ImportBindingIsString: 'A string literal cannot be used as an imported binding.\n- Did you mean `import { "%0" as foo }`?',
  ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
  ImportCallArity: "`import()` requires exactly %0.",
  ImportCallNotNewExpression: "Cannot use new with import(...).",
  ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
  InvalidBigIntLiteral: "Invalid BigIntLiteral.",
  InvalidCodePoint: "Code point out of bounds.",
  InvalidDecimal: "Invalid decimal.",
  InvalidDigit: "Expected number in radix %0.",
  InvalidEscapeSequence: "Bad character escape sequence.",
  InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
  InvalidEscapedReservedWord: "Escape sequence in keyword %0.",
  InvalidIdentifier: "Invalid identifier %0.",
  InvalidLhs: "Invalid left-hand side in %0.",
  InvalidLhsBinding: "Binding invalid left-hand side in %0.",
  InvalidNumber: "Invalid number.",
  InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
  InvalidOrUnexpectedToken: "Unexpected character '%0'.",
  InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
  InvalidPrivateFieldResolution: "Private name #%0 is not defined.",
  InvalidPropertyBindingPattern: "Binding member expression.",
  InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
  InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
  LabelRedeclaration: "Label '%0' is already declared.",
  LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
  LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
  MalformedRegExpFlags: "Invalid regular expression flag.",
  MissingClassName: "A class name is required.",
  MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
  MissingSemicolon: "Missing semicolon.",
  MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
  MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
  ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
  ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
  ModuleAttributesWithDuplicateKeys: 'Duplicate key "%0" is not allowed in module attributes.',
  ModuleExportNameHasLoneSurrogate: "An export name cannot include a lone surrogate, found '\\u%0'.",
  ModuleExportUndefined: "Export '%0' is not defined.",
  MultipleDefaultsInSwitch: "Multiple default clauses.",
  NewlineAfterThrow: "Illegal newline after throw.",
  NoCatchOrFinally: "Missing catch or finally clause.",
  NumberIdentifier: "Identifier directly after number.",
  NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
  ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
  OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
  OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
  OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
  ParamDupe: "Argument name clash.",
  PatternHasAccessor: "Object pattern can't contain getter or setter.",
  PatternHasMethod: "Object pattern can't contain methods.",
  PipeBodyIsTighter: "Unexpected %0 after pipeline body; any %0 expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
  PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
  PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
  PipeTopicUnconfiguredToken: 'Invalid topic token %0. In order to use %0 as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "%0" }.',
  PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
  PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
  PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
  PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
  PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
  PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
  PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
  PrivateInExpectedIn: "Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`).",
  PrivateNameRedeclaration: "Duplicate private name #%0.",
  RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
  RecordNoProto: "'__proto__' is not allowed in Record expressions.",
  RestTrailingComma: "Unexpected trailing comma after rest element.",
  SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
  StaticPrototype: "Classes may not have static property named prototype.",
  StrictDelete: "Deleting local variable in strict mode.",
  StrictEvalArguments: "Assigning to '%0' in strict mode.",
  StrictEvalArgumentsBinding: "Binding '%0' in strict mode.",
  StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
  StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
  StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
  StrictWith: "'with' in strict mode.",
  SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
  SuperPrivateField: "Private fields can't be accessed on super.",
  TrailingDecorator: "Decorators must be attached to a class element.",
  TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
  UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
  UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
  UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
  UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
  UnexpectedKeyword: "Unexpected keyword '%0'.",
  UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
  UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
  UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
  UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
  UnexpectedPrivateField: "Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\n or a property of member expression (i.e. this.#p).",
  UnexpectedReservedWord: "Unexpected reserved word '%0'.",
  UnexpectedSuper: "'super' is only allowed in object methods and classes.",
  UnexpectedToken: "Unexpected token '%0'.",
  UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
  UnsupportedBind: "Binding should be performed on object property.",
  UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
  UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
  UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
  UnsupportedMetaProperty: "The only valid meta property for %0 is %0.%1.",
  UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
  UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
  UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
  UnterminatedComment: "Unterminated comment.",
  UnterminatedRegExp: "Unterminated regular expression.",
  UnterminatedString: "Unterminated string constant.",
  UnterminatedTemplate: "Unterminated template.",
  VarRedeclaration: "Identifier '%0' has already been declared.",
  YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
  YieldInParameter: "Yield expression is not allowed in formal parameters.",
  ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
}, Mn$1.SyntaxError), jn$1 = Un$1({
  ImportMetaOutsideModule: `import.meta may appear only with 'sourceType: "module"'`,
  ImportOutsideModule: `'import' and 'export' may appear only with 'sourceType: "module"'`
}, Mn$1.SourceTypeModuleError);
function _n$1(e20, t2) {
  return t2 === "flow" && e20 === "PatternIsOptional" ? "OptionalBindingPattern" : e20;
}
function Un$1(e20, t2, s2) {
  const r2 = {};
  return Object.keys(e20).forEach((i2) => {
    r2[i2] = Object.freeze({
      code: t2,
      reasonCode: _n$1(i2, s2),
      template: e20[i2]
    });
  }), Object.freeze(r2);
}
class qn$1 {
  constructor(e20, t2) {
    this.token = void 0, this.preserveSpace = void 0, this.token = e20, this.preserveSpace = !!t2;
  }
}
const $n$1 = { brace: new qn$1("{"), template: new qn$1("`", true) };
bn$1.braceR.updateContext = (e20) => {
  e20.pop();
}, bn$1.braceL.updateContext = bn$1.braceHashL.updateContext = bn$1.dollarBraceL.updateContext = (e20) => {
  e20.push($n$1.brace);
}, bn$1.backQuote.updateContext = (e20) => {
  e20[e20.length - 1] === $n$1.template ? e20.pop() : e20.push($n$1.template);
};
let Hn$1 = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", Vn$1 = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
const zn$1 = new RegExp("[" + Hn$1 + "]"), Wn$1 = new RegExp("[" + Hn$1 + Vn$1 + "]");
Hn$1 = Vn$1 = null;
const Gn$1 = [
  0,
  11,
  2,
  25,
  2,
  18,
  2,
  1,
  2,
  14,
  3,
  13,
  35,
  122,
  70,
  52,
  268,
  28,
  4,
  48,
  48,
  31,
  14,
  29,
  6,
  37,
  11,
  29,
  3,
  35,
  5,
  7,
  2,
  4,
  43,
  157,
  19,
  35,
  5,
  35,
  5,
  39,
  9,
  51,
  157,
  310,
  10,
  21,
  11,
  7,
  153,
  5,
  3,
  0,
  2,
  43,
  2,
  1,
  4,
  0,
  3,
  22,
  11,
  22,
  10,
  30,
  66,
  18,
  2,
  1,
  11,
  21,
  11,
  25,
  71,
  55,
  7,
  1,
  65,
  0,
  16,
  3,
  2,
  2,
  2,
  28,
  43,
  28,
  4,
  28,
  36,
  7,
  2,
  27,
  28,
  53,
  11,
  21,
  11,
  18,
  14,
  17,
  111,
  72,
  56,
  50,
  14,
  50,
  14,
  35,
  349,
  41,
  7,
  1,
  79,
  28,
  11,
  0,
  9,
  21,
  107,
  20,
  28,
  22,
  13,
  52,
  76,
  44,
  33,
  24,
  27,
  35,
  30,
  0,
  3,
  0,
  9,
  34,
  4,
  0,
  13,
  47,
  15,
  3,
  22,
  0,
  2,
  0,
  36,
  17,
  2,
  24,
  85,
  6,
  2,
  0,
  2,
  3,
  2,
  14,
  2,
  9,
  8,
  46,
  39,
  7,
  3,
  1,
  3,
  21,
  2,
  6,
  2,
  1,
  2,
  4,
  4,
  0,
  19,
  0,
  13,
  4,
  159,
  52,
  19,
  3,
  21,
  2,
  31,
  47,
  21,
  1,
  2,
  0,
  185,
  46,
  42,
  3,
  37,
  47,
  21,
  0,
  60,
  42,
  14,
  0,
  72,
  26,
  230,
  43,
  117,
  63,
  32,
  7,
  3,
  0,
  3,
  7,
  2,
  1,
  2,
  23,
  16,
  0,
  2,
  0,
  95,
  7,
  3,
  38,
  17,
  0,
  2,
  0,
  29,
  0,
  11,
  39,
  8,
  0,
  22,
  0,
  12,
  45,
  20,
  0,
  35,
  56,
  264,
  8,
  2,
  36,
  18,
  0,
  50,
  29,
  113,
  6,
  2,
  1,
  2,
  37,
  22,
  0,
  26,
  5,
  2,
  1,
  2,
  31,
  15,
  0,
  328,
  18,
  190,
  0,
  80,
  921,
  103,
  110,
  18,
  195,
  2749,
  1070,
  4050,
  582,
  8634,
  568,
  8,
  30,
  114,
  29,
  19,
  47,
  17,
  3,
  32,
  20,
  6,
  18,
  689,
  63,
  129,
  74,
  6,
  0,
  67,
  12,
  65,
  1,
  2,
  0,
  29,
  6135,
  9,
  1237,
  43,
  8,
  8952,
  286,
  50,
  2,
  18,
  3,
  9,
  395,
  2309,
  106,
  6,
  12,
  4,
  8,
  8,
  9,
  5991,
  84,
  2,
  70,
  2,
  1,
  3,
  0,
  3,
  1,
  3,
  3,
  2,
  11,
  2,
  0,
  2,
  6,
  2,
  64,
  2,
  3,
  3,
  7,
  2,
  6,
  2,
  27,
  2,
  3,
  2,
  4,
  2,
  0,
  4,
  6,
  2,
  339,
  3,
  24,
  2,
  24,
  2,
  30,
  2,
  24,
  2,
  30,
  2,
  24,
  2,
  30,
  2,
  24,
  2,
  30,
  2,
  24,
  2,
  7,
  2357,
  44,
  11,
  6,
  17,
  0,
  370,
  43,
  1301,
  196,
  60,
  67,
  8,
  0,
  1205,
  3,
  2,
  26,
  2,
  1,
  2,
  0,
  3,
  0,
  2,
  9,
  2,
  3,
  2,
  0,
  2,
  0,
  7,
  0,
  5,
  0,
  2,
  0,
  2,
  0,
  2,
  2,
  2,
  1,
  2,
  0,
  3,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  1,
  2,
  0,
  3,
  3,
  2,
  6,
  2,
  3,
  2,
  3,
  2,
  0,
  2,
  9,
  2,
  16,
  6,
  2,
  2,
  4,
  2,
  16,
  4421,
  42717,
  35,
  4148,
  12,
  221,
  3,
  5761,
  15,
  7472,
  3104,
  541,
  1507,
  4938
], Kn$1 = [
  509,
  0,
  227,
  0,
  150,
  4,
  294,
  9,
  1368,
  2,
  2,
  1,
  6,
  3,
  41,
  2,
  5,
  0,
  166,
  1,
  574,
  3,
  9,
  9,
  370,
  1,
  154,
  10,
  176,
  2,
  54,
  14,
  32,
  9,
  16,
  3,
  46,
  10,
  54,
  9,
  7,
  2,
  37,
  13,
  2,
  9,
  6,
  1,
  45,
  0,
  13,
  2,
  49,
  13,
  9,
  3,
  2,
  11,
  83,
  11,
  7,
  0,
  161,
  11,
  6,
  9,
  7,
  3,
  56,
  1,
  2,
  6,
  3,
  1,
  3,
  2,
  10,
  0,
  11,
  1,
  3,
  6,
  4,
  4,
  193,
  17,
  10,
  9,
  5,
  0,
  82,
  19,
  13,
  9,
  214,
  6,
  3,
  8,
  28,
  1,
  83,
  16,
  16,
  9,
  82,
  12,
  9,
  9,
  84,
  14,
  5,
  9,
  243,
  14,
  166,
  9,
  71,
  5,
  2,
  1,
  3,
  3,
  2,
  0,
  2,
  1,
  13,
  9,
  120,
  6,
  3,
  6,
  4,
  0,
  29,
  9,
  41,
  6,
  2,
  3,
  9,
  0,
  10,
  10,
  47,
  15,
  406,
  7,
  2,
  7,
  17,
  9,
  57,
  21,
  2,
  13,
  123,
  5,
  4,
  0,
  2,
  1,
  2,
  6,
  2,
  0,
  9,
  9,
  49,
  4,
  2,
  1,
  2,
  4,
  9,
  9,
  330,
  3,
  19306,
  9,
  135,
  4,
  60,
  6,
  26,
  9,
  1014,
  0,
  2,
  54,
  8,
  3,
  82,
  0,
  12,
  1,
  19628,
  1,
  5319,
  4,
  4,
  5,
  9,
  7,
  3,
  6,
  31,
  3,
  149,
  2,
  1418,
  49,
  513,
  54,
  5,
  49,
  9,
  0,
  15,
  0,
  23,
  4,
  2,
  14,
  1361,
  6,
  2,
  16,
  3,
  6,
  2,
  1,
  2,
  4,
  262,
  6,
  10,
  9,
  419,
  13,
  1495,
  6,
  110,
  6,
  6,
  9,
  4759,
  9,
  787719,
  239
];
function Xn$1(e20, t2) {
  let s2 = 65536;
  for (let r2 = 0, i2 = t2.length; r2 < i2; r2 += 2) {
    if (s2 += t2[r2], s2 > e20)
      return false;
    if (s2 += t2[r2 + 1], s2 >= e20)
      return true;
  }
  return false;
}
function Jn$1(e20) {
  return e20 < 65 ? e20 === 36 : e20 <= 90 || (e20 < 97 ? e20 === 95 : e20 <= 122 || (e20 <= 65535 ? e20 >= 170 && zn$1.test(String.fromCharCode(e20)) : Xn$1(e20, Gn$1)));
}
function Yn$1(e20) {
  return e20 < 48 ? e20 === 36 : e20 < 58 || !(e20 < 65) && (e20 <= 90 || (e20 < 97 ? e20 === 95 : e20 <= 122 || (e20 <= 65535 ? e20 >= 170 && Wn$1.test(String.fromCharCode(e20)) : Xn$1(e20, Gn$1) || Xn$1(e20, Kn$1))));
}
const Qn$1 = [
  "implements",
  "interface",
  "let",
  "package",
  "private",
  "protected",
  "public",
  "static",
  "yield"
], Zn$1 = ["eval", "arguments"], eo$1 = new Set([
  "break",
  "case",
  "catch",
  "continue",
  "debugger",
  "default",
  "do",
  "else",
  "finally",
  "for",
  "function",
  "if",
  "return",
  "switch",
  "throw",
  "try",
  "var",
  "const",
  "while",
  "with",
  "new",
  "this",
  "super",
  "class",
  "extends",
  "export",
  "import",
  "null",
  "true",
  "false",
  "in",
  "instanceof",
  "typeof",
  "void",
  "delete"
]), to$1 = new Set(Qn$1), so$1 = new Set(Zn$1);
function ro$1(e20, t2) {
  return t2 && e20 === "await" || e20 === "enum";
}
function io$1(e20, t2) {
  return ro$1(e20, t2) || to$1.has(e20);
}
function ao$1(e20) {
  return so$1.has(e20);
}
function no$1(e20, t2) {
  return io$1(e20, t2) || ao$1(e20);
}
function oo$1(e20) {
  return eo$1.has(e20);
}
const uo$1 = new Set([
  "break",
  "case",
  "catch",
  "continue",
  "debugger",
  "default",
  "do",
  "else",
  "finally",
  "for",
  "function",
  "if",
  "return",
  "switch",
  "throw",
  "try",
  "var",
  "const",
  "while",
  "with",
  "new",
  "this",
  "super",
  "class",
  "extends",
  "export",
  "import",
  "null",
  "true",
  "false",
  "in",
  "instanceof",
  "typeof",
  "void",
  "delete",
  "implements",
  "interface",
  "let",
  "package",
  "private",
  "protected",
  "public",
  "static",
  "yield",
  "eval",
  "arguments",
  "enum",
  "await"
]);
class ho$1 {
  constructor(e20) {
    this.var = new Set(), this.lexical = new Set(), this.functions = new Set(), this.flags = e20;
  }
}
class co$1 {
  constructor(e20, t2) {
    this.scopeStack = [], this.undefinedExports = new Map(), this.undefinedPrivateNames = new Map(), this.raise = e20, this.inModule = t2;
  }
  get inFunction() {
    return (2 & this.currentVarScopeFlags()) > 0;
  }
  get allowSuper() {
    return (16 & this.currentThisScopeFlags()) > 0;
  }
  get allowDirectSuper() {
    return (32 & this.currentThisScopeFlags()) > 0;
  }
  get inClass() {
    return (64 & this.currentThisScopeFlags()) > 0;
  }
  get inClassAndNotInNonArrowFunction() {
    const e20 = this.currentThisScopeFlags();
    return (64 & e20) > 0 && (2 & e20) == 0;
  }
  get inStaticBlock() {
    for (let e20 = this.scopeStack.length - 1; ; e20--) {
      const { flags: t2 } = this.scopeStack[e20];
      if (128 & t2)
        return true;
      if (323 & t2)
        return false;
    }
  }
  get inNonArrowFunction() {
    return (2 & this.currentThisScopeFlags()) > 0;
  }
  get treatFunctionsAsVar() {
    return this.treatFunctionsAsVarInScope(this.currentScope());
  }
  createScope(e20) {
    return new ho$1(e20);
  }
  enter(e20) {
    this.scopeStack.push(this.createScope(e20));
  }
  exit() {
    this.scopeStack.pop();
  }
  treatFunctionsAsVarInScope(e20) {
    return !!(2 & e20.flags || !this.inModule && 1 & e20.flags);
  }
  declareName(e20, t2, s2) {
    let r2 = this.currentScope();
    if (8 & t2 || 16 & t2)
      this.checkRedeclarationInScope(r2, e20, t2, s2), 16 & t2 ? r2.functions.add(e20) : r2.lexical.add(e20), 8 & t2 && this.maybeExportDefined(r2, e20);
    else if (4 & t2)
      for (let i2 = this.scopeStack.length - 1; i2 >= 0 && (r2 = this.scopeStack[i2], this.checkRedeclarationInScope(r2, e20, t2, s2), r2.var.add(e20), this.maybeExportDefined(r2, e20), !(259 & r2.flags)); --i2)
        ;
    this.inModule && 1 & r2.flags && this.undefinedExports.delete(e20);
  }
  maybeExportDefined(e20, t2) {
    this.inModule && 1 & e20.flags && this.undefinedExports.delete(t2);
  }
  checkRedeclarationInScope(e20, t2, s2, r2) {
    this.isRedeclaredInScope(e20, t2, s2) && this.raise(r2, Rn$1.VarRedeclaration, t2);
  }
  isRedeclaredInScope(e20, t2, s2) {
    return !!(1 & s2) && (8 & s2 ? e20.lexical.has(t2) || e20.functions.has(t2) || e20.var.has(t2) : 16 & s2 ? e20.lexical.has(t2) || !this.treatFunctionsAsVarInScope(e20) && e20.var.has(t2) : e20.lexical.has(t2) && !(8 & e20.flags && e20.lexical.values().next().value === t2) || !this.treatFunctionsAsVarInScope(e20) && e20.functions.has(t2));
  }
  checkLocalExport(e20) {
    const { name: t2 } = e20, s2 = this.scopeStack[0];
    s2.lexical.has(t2) || s2.var.has(t2) || s2.functions.has(t2) || this.undefinedExports.set(t2, e20.start);
  }
  currentScope() {
    return this.scopeStack[this.scopeStack.length - 1];
  }
  currentVarScopeFlags() {
    for (let e20 = this.scopeStack.length - 1; ; e20--) {
      const { flags: t2 } = this.scopeStack[e20];
      if (259 & t2)
        return t2;
    }
  }
  currentThisScopeFlags() {
    for (let e20 = this.scopeStack.length - 1; ; e20--) {
      const { flags: t2 } = this.scopeStack[e20];
      if (323 & t2 && !(4 & t2))
        return t2;
    }
  }
}
class po$1 extends ho$1 {
  constructor(...e20) {
    super(...e20), this.declareFunctions = new Set();
  }
}
class lo$1 extends co$1 {
  createScope(e20) {
    return new po$1(e20);
  }
  declareName(e20, t2, s2) {
    const r2 = this.currentScope();
    if (2048 & t2)
      return this.checkRedeclarationInScope(r2, e20, t2, s2), this.maybeExportDefined(r2, e20), void r2.declareFunctions.add(e20);
    super.declareName(...arguments);
  }
  isRedeclaredInScope(e20, t2, s2) {
    return !!super.isRedeclaredInScope(...arguments) || !!(2048 & s2) && !e20.declareFunctions.has(t2) && (e20.lexical.has(t2) || e20.functions.has(t2));
  }
  checkLocalExport(e20) {
    this.scopeStack[0].declareFunctions.has(e20.name) || super.checkLocalExport(e20);
  }
}
class Do$1 {
  constructor() {
    this.strict = void 0, this.curLine = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.maybeInArrowParameters = false, this.inType = false, this.noAnonFunctionType = false, this.inPropertyName = false, this.hasFlowComment = false, this.isAmbientContext = false, this.inAbstractClass = false, this.topicContext = {
      maxNumOfResolvableTopics: 0,
      maxTopicIndex: null
    }, this.soloAwait = false, this.inFSharpPipelineDirectBody = false, this.labels = [], this.decoratorStack = [[]], this.comments = [], this.commentStack = [], this.pos = 0, this.lineStart = 0, this.type = bn$1.eof, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.lastTokStart = 0, this.lastTokEnd = 0, this.context = [$n$1.brace], this.exprAllowed = true, this.containsEsc = false, this.strictErrors = new Map(), this.tokensLength = 0;
  }
  init(e20) {
    this.strict = e20.strictMode !== false && (e20.strictMode === true || e20.sourceType === "module"), this.curLine = e20.startLine, this.startLoc = this.endLoc = this.curPosition();
  }
  curPosition() {
    return new In$1(this.curLine, this.pos - this.lineStart);
  }
  clone(e20) {
    const t2 = new Do$1(), s2 = Object.keys(this);
    for (let r2 = 0, i2 = s2.length; r2 < i2; r2++) {
      const i3 = s2[r2];
      let a2 = this[i3];
      !e20 && Array.isArray(a2) && (a2 = a2.slice()), t2[i3] = a2;
    }
    return t2;
  }
}
var mo$1 = function(e20) {
  return e20 >= 48 && e20 <= 57;
};
const fo$1 = new Set([103, 109, 115, 105, 121, 117, 100]), yo$1 = {
  decBinOct: [46, 66, 69, 79, 95, 98, 101, 111],
  hex: [46, 88, 95, 120]
}, Ao$1 = { bin: [48, 49] };
Ao$1.oct = [...Ao$1.bin, 50, 51, 52, 53, 54, 55], Ao$1.dec = [...Ao$1.oct, 56, 57], Ao$1.hex = [
  ...Ao$1.dec,
  65,
  66,
  67,
  68,
  69,
  70,
  97,
  98,
  99,
  100,
  101,
  102
];
class Eo$1 {
  constructor(e20) {
    this.type = e20.type, this.value = e20.value, this.start = e20.start, this.end = e20.end, this.loc = new vn$1(e20.startLoc, e20.endLoc);
  }
}
class Co$1 {
  constructor() {
    this.privateNames = new Set(), this.loneAccessors = new Map(), this.undefinedPrivateNames = new Map();
  }
}
class xo$1 {
  constructor(e20) {
    this.stack = [], this.undefinedPrivateNames = new Map(), this.raise = e20;
  }
  current() {
    return this.stack[this.stack.length - 1];
  }
  enter() {
    this.stack.push(new Co$1());
  }
  exit() {
    const e20 = this.stack.pop(), t2 = this.current();
    for (const [s2, r2] of Array.from(e20.undefinedPrivateNames))
      t2 ? t2.undefinedPrivateNames.has(s2) || t2.undefinedPrivateNames.set(s2, r2) : this.raise(r2, Rn$1.InvalidPrivateFieldResolution, s2);
  }
  declarePrivateName(e20, t2, s2) {
    const r2 = this.current();
    let i2 = r2.privateNames.has(e20);
    if (3 & t2) {
      const s3 = i2 && r2.loneAccessors.get(e20);
      if (s3) {
        const a2 = 4 & s3, n2 = 4 & t2;
        i2 = (3 & s3) === (3 & t2) || a2 !== n2, i2 || r2.loneAccessors.delete(e20);
      } else
        i2 || r2.loneAccessors.set(e20, t2);
    }
    i2 && this.raise(s2, Rn$1.PrivateNameRedeclaration, e20), r2.privateNames.add(e20), r2.undefinedPrivateNames.delete(e20);
  }
  usePrivateName(e20, t2) {
    let s2;
    for (s2 of this.stack)
      if (s2.privateNames.has(e20))
        return;
    s2 ? s2.undefinedPrivateNames.set(e20, t2) : this.raise(t2, Rn$1.InvalidPrivateFieldResolution, e20);
  }
}
class Fo$1 {
  constructor(e20 = 0) {
    this.type = void 0, this.type = e20;
  }
  canBeArrowParameterDeclaration() {
    return this.type === 2 || this.type === 1;
  }
  isCertainlyParameterDeclaration() {
    return this.type === 3;
  }
}
class go$1 extends Fo$1 {
  constructor(e20) {
    super(e20), this.errors = new Map();
  }
  recordDeclarationError(e20, t2) {
    this.errors.set(e20, t2);
  }
  clearDeclarationError(e20) {
    this.errors.delete(e20);
  }
  iterateErrors(e20) {
    this.errors.forEach(e20);
  }
}
class bo$1 {
  constructor(e20) {
    this.stack = [new Fo$1()], this.raise = e20;
  }
  enter(e20) {
    this.stack.push(e20);
  }
  exit() {
    this.stack.pop();
  }
  recordParameterInitializerError(e20, t2) {
    const { stack: s2 } = this;
    let r2 = s2.length - 1, i2 = s2[r2];
    for (; !i2.isCertainlyParameterDeclaration(); ) {
      if (!i2.canBeArrowParameterDeclaration())
        return;
      i2.recordDeclarationError(e20, t2), i2 = s2[--r2];
    }
    this.raise(e20, t2);
  }
  recordParenthesizedIdentifierError(e20, t2) {
    const { stack: s2 } = this, r2 = s2[s2.length - 1];
    if (r2.isCertainlyParameterDeclaration())
      this.raise(e20, t2);
    else {
      if (!r2.canBeArrowParameterDeclaration())
        return;
      r2.recordDeclarationError(e20, t2);
    }
  }
  recordAsyncArrowParametersError(e20, t2) {
    const { stack: s2 } = this;
    let r2 = s2.length - 1, i2 = s2[r2];
    for (; i2.canBeArrowParameterDeclaration(); )
      i2.type === 2 && i2.recordDeclarationError(e20, t2), i2 = s2[--r2];
  }
  validateAsPattern() {
    const { stack: e20 } = this, t2 = e20[e20.length - 1];
    t2.canBeArrowParameterDeclaration() && t2.iterateErrors((t3, s2) => {
      this.raise(s2, t3);
      let r2 = e20.length - 2, i2 = e20[r2];
      for (; i2.canBeArrowParameterDeclaration(); )
        i2.clearDeclarationError(s2), i2 = e20[--r2];
    });
  }
}
function Po$1() {
  return new Fo$1();
}
class To$1 {
  constructor() {
    this.stacks = [];
  }
  enter(e20) {
    this.stacks.push(e20);
  }
  exit() {
    this.stacks.pop();
  }
  currentFlags() {
    return this.stacks[this.stacks.length - 1];
  }
  get hasAwait() {
    return (2 & this.currentFlags()) > 0;
  }
  get hasYield() {
    return (1 & this.currentFlags()) > 0;
  }
  get hasReturn() {
    return (4 & this.currentFlags()) > 0;
  }
  get hasIn() {
    return (8 & this.currentFlags()) > 0;
  }
}
function wo$1(e20, t2) {
  return (e20 ? 2 : 0) | (t2 ? 1 : 0);
}
class So$1 {
  constructor() {
    this.shorthandAssign = -1, this.doubleProto = -1, this.optionalParameters = -1;
  }
}
class Bo$1 {
  constructor(e20, t2, s2) {
    this.type = "", this.start = t2, this.end = 0, this.loc = new vn$1(s2), e20 != null && e20.options.ranges && (this.range = [t2, 0]), e20 != null && e20.filename && (this.loc.filename = e20.filename);
  }
}
const No$1 = Bo$1.prototype;
function Io$1(e20) {
  const {
    type: t2,
    start: s2,
    end: r2,
    loc: i2,
    range: a2,
    extra: n2,
    name: o2
  } = e20, u2 = Object.create(No$1);
  return u2.type = t2, u2.start = s2, u2.end = r2, u2.loc = i2, u2.range = a2, u2.extra = n2, u2.name = o2, t2 === "Placeholder" && (u2.expectedNode = e20.expectedNode), u2;
}
function vo$1(e20) {
  const { type: t2, start: s2, end: r2, loc: i2, range: a2, extra: n2 } = e20;
  if (t2 === "Placeholder")
    return function(e21) {
      return Io$1(e21);
    }(e20);
  const o2 = Object.create(No$1);
  return o2.type = "StringLiteral", o2.start = s2, o2.end = r2, o2.loc = i2, o2.range = a2, o2.extra = n2, o2.value = e20.value, o2;
}
No$1.__clone = function() {
  const e20 = new Bo$1(), t2 = Object.keys(this);
  for (let s2 = 0, r2 = t2.length; s2 < r2; s2++) {
    const r3 = t2[s2];
    r3 !== "leadingComments" && r3 !== "trailingComments" && r3 !== "innerComments" && (e20[r3] = this[r3]);
  }
  return e20;
};
const ko$1 = new Set([
  "_",
  "any",
  "bool",
  "boolean",
  "empty",
  "extends",
  "false",
  "interface",
  "mixed",
  "null",
  "number",
  "static",
  "string",
  "true",
  "typeof",
  "void"
]), Lo$1 = Un$1({
  AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
  AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
  AssignReservedType: "Cannot overwrite reserved type %0.",
  DeclareClassElement: "The `declare` modifier can only appear on class fields.",
  DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
  DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
  EnumBooleanMemberNotInitialized: "Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.",
  EnumDuplicateMemberName: "Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.",
  EnumInconsistentMemberValues: "Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.",
  EnumInvalidExplicitType: "Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
  EnumInvalidExplicitTypeUnknownSupplied: "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
  EnumInvalidMemberInitializerPrimaryType: "Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.",
  EnumInvalidMemberInitializerSymbolType: "Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.",
  EnumInvalidMemberInitializerUnknownType: "The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.",
  EnumInvalidMemberName: "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.",
  EnumNumberMemberNotInitialized: "Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.",
  EnumStringMemberInconsistentlyInitailized: "String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.",
  GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
  ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
  InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
  InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
  InexactVariance: "Explicit inexact syntax cannot have variance.",
  InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
  MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
  NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
  NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
  PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
  SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
  SpreadVariance: "Spread properties cannot have variance.",
  ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
  ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
  ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
  ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
  ThisParamNoDefault: "The `this` parameter may not have a default value.",
  TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
  TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
  UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
  UnexpectedReservedType: "Unexpected reserved type %0.",
  UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
  UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
  UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
  UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
  UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
  UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
  UnsupportedDeclareExportKind: "`declare export %0` is not supported. Use `%1` instead.",
  UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
  UnterminatedFlowComment: "Unterminated flow-comment."
}, Mn$1.SyntaxError, "flow");
function Oo$1(e20) {
  return e20.importKind === "type" || e20.importKind === "typeof";
}
function Mo(e20) {
  return (e20.type === bn$1.name || !!e20.type.keyword) && e20.value !== "from";
}
const Ro$1 = {
  const: "declare export var",
  let: "declare export var",
  type: "export type",
  interface: "export interface"
};
const jo = /\*?\s*@((?:no)?flow)\b/;
const _o$1 = {
  quot: '"',
  amp: "&",
  apos: "'",
  lt: "<",
  gt: ">",
  nbsp: "\xA0",
  iexcl: "\xA1",
  cent: "\xA2",
  pound: "\xA3",
  curren: "\xA4",
  yen: "\xA5",
  brvbar: "\xA6",
  sect: "\xA7",
  uml: "\xA8",
  copy: "\xA9",
  ordf: "\xAA",
  laquo: "\xAB",
  not: "\xAC",
  shy: "\xAD",
  reg: "\xAE",
  macr: "\xAF",
  deg: "\xB0",
  plusmn: "\xB1",
  sup2: "\xB2",
  sup3: "\xB3",
  acute: "\xB4",
  micro: "\xB5",
  para: "\xB6",
  middot: "\xB7",
  cedil: "\xB8",
  sup1: "\xB9",
  ordm: "\xBA",
  raquo: "\xBB",
  frac14: "\xBC",
  frac12: "\xBD",
  frac34: "\xBE",
  iquest: "\xBF",
  Agrave: "\xC0",
  Aacute: "\xC1",
  Acirc: "\xC2",
  Atilde: "\xC3",
  Auml: "\xC4",
  Aring: "\xC5",
  AElig: "\xC6",
  Ccedil: "\xC7",
  Egrave: "\xC8",
  Eacute: "\xC9",
  Ecirc: "\xCA",
  Euml: "\xCB",
  Igrave: "\xCC",
  Iacute: "\xCD",
  Icirc: "\xCE",
  Iuml: "\xCF",
  ETH: "\xD0",
  Ntilde: "\xD1",
  Ograve: "\xD2",
  Oacute: "\xD3",
  Ocirc: "\xD4",
  Otilde: "\xD5",
  Ouml: "\xD6",
  times: "\xD7",
  Oslash: "\xD8",
  Ugrave: "\xD9",
  Uacute: "\xDA",
  Ucirc: "\xDB",
  Uuml: "\xDC",
  Yacute: "\xDD",
  THORN: "\xDE",
  szlig: "\xDF",
  agrave: "\xE0",
  aacute: "\xE1",
  acirc: "\xE2",
  atilde: "\xE3",
  auml: "\xE4",
  aring: "\xE5",
  aelig: "\xE6",
  ccedil: "\xE7",
  egrave: "\xE8",
  eacute: "\xE9",
  ecirc: "\xEA",
  euml: "\xEB",
  igrave: "\xEC",
  iacute: "\xED",
  icirc: "\xEE",
  iuml: "\xEF",
  eth: "\xF0",
  ntilde: "\xF1",
  ograve: "\xF2",
  oacute: "\xF3",
  ocirc: "\xF4",
  otilde: "\xF5",
  ouml: "\xF6",
  divide: "\xF7",
  oslash: "\xF8",
  ugrave: "\xF9",
  uacute: "\xFA",
  ucirc: "\xFB",
  uuml: "\xFC",
  yacute: "\xFD",
  thorn: "\xFE",
  yuml: "\xFF",
  OElig: "\u0152",
  oelig: "\u0153",
  Scaron: "\u0160",
  scaron: "\u0161",
  Yuml: "\u0178",
  fnof: "\u0192",
  circ: "\u02C6",
  tilde: "\u02DC",
  Alpha: "\u0391",
  Beta: "\u0392",
  Gamma: "\u0393",
  Delta: "\u0394",
  Epsilon: "\u0395",
  Zeta: "\u0396",
  Eta: "\u0397",
  Theta: "\u0398",
  Iota: "\u0399",
  Kappa: "\u039A",
  Lambda: "\u039B",
  Mu: "\u039C",
  Nu: "\u039D",
  Xi: "\u039E",
  Omicron: "\u039F",
  Pi: "\u03A0",
  Rho: "\u03A1",
  Sigma: "\u03A3",
  Tau: "\u03A4",
  Upsilon: "\u03A5",
  Phi: "\u03A6",
  Chi: "\u03A7",
  Psi: "\u03A8",
  Omega: "\u03A9",
  alpha: "\u03B1",
  beta: "\u03B2",
  gamma: "\u03B3",
  delta: "\u03B4",
  epsilon: "\u03B5",
  zeta: "\u03B6",
  eta: "\u03B7",
  theta: "\u03B8",
  iota: "\u03B9",
  kappa: "\u03BA",
  lambda: "\u03BB",
  mu: "\u03BC",
  nu: "\u03BD",
  xi: "\u03BE",
  omicron: "\u03BF",
  pi: "\u03C0",
  rho: "\u03C1",
  sigmaf: "\u03C2",
  sigma: "\u03C3",
  tau: "\u03C4",
  upsilon: "\u03C5",
  phi: "\u03C6",
  chi: "\u03C7",
  psi: "\u03C8",
  omega: "\u03C9",
  thetasym: "\u03D1",
  upsih: "\u03D2",
  piv: "\u03D6",
  ensp: "\u2002",
  emsp: "\u2003",
  thinsp: "\u2009",
  zwnj: "\u200C",
  zwj: "\u200D",
  lrm: "\u200E",
  rlm: "\u200F",
  ndash: "\u2013",
  mdash: "\u2014",
  lsquo: "\u2018",
  rsquo: "\u2019",
  sbquo: "\u201A",
  ldquo: "\u201C",
  rdquo: "\u201D",
  bdquo: "\u201E",
  dagger: "\u2020",
  Dagger: "\u2021",
  bull: "\u2022",
  hellip: "\u2026",
  permil: "\u2030",
  prime: "\u2032",
  Prime: "\u2033",
  lsaquo: "\u2039",
  rsaquo: "\u203A",
  oline: "\u203E",
  frasl: "\u2044",
  euro: "\u20AC",
  image: "\u2111",
  weierp: "\u2118",
  real: "\u211C",
  trade: "\u2122",
  alefsym: "\u2135",
  larr: "\u2190",
  uarr: "\u2191",
  rarr: "\u2192",
  darr: "\u2193",
  harr: "\u2194",
  crarr: "\u21B5",
  lArr: "\u21D0",
  uArr: "\u21D1",
  rArr: "\u21D2",
  dArr: "\u21D3",
  hArr: "\u21D4",
  forall: "\u2200",
  part: "\u2202",
  exist: "\u2203",
  empty: "\u2205",
  nabla: "\u2207",
  isin: "\u2208",
  notin: "\u2209",
  ni: "\u220B",
  prod: "\u220F",
  sum: "\u2211",
  minus: "\u2212",
  lowast: "\u2217",
  radic: "\u221A",
  prop: "\u221D",
  infin: "\u221E",
  ang: "\u2220",
  and: "\u2227",
  or: "\u2228",
  cap: "\u2229",
  cup: "\u222A",
  int: "\u222B",
  there4: "\u2234",
  sim: "\u223C",
  cong: "\u2245",
  asymp: "\u2248",
  ne: "\u2260",
  equiv: "\u2261",
  le: "\u2264",
  ge: "\u2265",
  sub: "\u2282",
  sup: "\u2283",
  nsub: "\u2284",
  sube: "\u2286",
  supe: "\u2287",
  oplus: "\u2295",
  otimes: "\u2297",
  perp: "\u22A5",
  sdot: "\u22C5",
  lceil: "\u2308",
  rceil: "\u2309",
  lfloor: "\u230A",
  rfloor: "\u230B",
  lang: "\u2329",
  rang: "\u232A",
  loz: "\u25CA",
  spades: "\u2660",
  clubs: "\u2663",
  hearts: "\u2665",
  diams: "\u2666"
}, Uo = /^[\da-fA-F]+$/, qo = /^\d+$/, $o = Un$1({
  AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
  MissingClosingTagElement: "Expected corresponding JSX closing tag for <%0>.",
  MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
  UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
  UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
  UnterminatedJsxContent: "Unterminated JSX contents.",
  UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
}, Mn$1.SyntaxError, "jsx");
function Ho(e20) {
  return !!e20 && (e20.type === "JSXOpeningFragment" || e20.type === "JSXClosingFragment");
}
function Vo(e20) {
  if (e20.type === "JSXIdentifier")
    return e20.name;
  if (e20.type === "JSXNamespacedName")
    return e20.namespace.name + ":" + e20.name.name;
  if (e20.type === "JSXMemberExpression")
    return Vo(e20.object) + "." + Vo(e20.property);
  throw new Error("Node had unexpected type: " + e20.type);
}
$n$1.j_oTag = new qn$1("<tag"), $n$1.j_cTag = new qn$1("</tag"), $n$1.j_expr = new qn$1("<tag>...</tag>", true), bn$1.jsxName = new Cn$1("jsxName"), bn$1.jsxText = new Cn$1("jsxText", { beforeExpr: true }), bn$1.jsxTagStart = new Cn$1("jsxTagStart", { startsExpr: true }), bn$1.jsxTagEnd = new Cn$1("jsxTagEnd"), bn$1.jsxTagStart.updateContext = (e20) => {
  e20.push($n$1.j_expr, $n$1.j_oTag);
};
class zo extends ho$1 {
  constructor(...e20) {
    super(...e20), this.types = new Set(), this.enums = new Set(), this.constEnums = new Set(), this.classes = new Set(), this.exportOnlyBindings = new Set();
  }
}
class Wo extends co$1 {
  createScope(e20) {
    return new zo(e20);
  }
  declareName(e20, t2, s2) {
    const r2 = this.currentScope();
    if (1024 & t2)
      return this.maybeExportDefined(r2, e20), void r2.exportOnlyBindings.add(e20);
    super.declareName(...arguments), 2 & t2 && (1 & t2 || (this.checkRedeclarationInScope(r2, e20, t2, s2), this.maybeExportDefined(r2, e20)), r2.types.add(e20)), 256 & t2 && r2.enums.add(e20), 512 & t2 && r2.constEnums.add(e20), 128 & t2 && r2.classes.add(e20);
  }
  isRedeclaredInScope(e20, t2, s2) {
    if (e20.enums.has(t2)) {
      if (256 & s2) {
        return !!(512 & s2) !== e20.constEnums.has(t2);
      }
      return true;
    }
    return 128 & s2 && e20.classes.has(t2) ? !!e20.lexical.has(t2) && !!(1 & s2) : !!(2 & s2 && e20.types.has(t2)) || super.isRedeclaredInScope(...arguments);
  }
  checkLocalExport(e20) {
    const t2 = this.scopeStack[0], { name: s2 } = e20;
    t2.types.has(s2) || t2.exportOnlyBindings.has(s2) || super.checkLocalExport(e20);
  }
}
function Go(e20) {
  if (e20 == null)
    throw new Error(`Unexpected ${e20} value.`);
  return e20;
}
function Ko(e20) {
  if (!e20)
    throw new Error("Assert fail");
}
const Xo = Un$1({
  AbstractMethodHasImplementation: "Method '%0' cannot have an implementation because it is marked abstract.",
  AbstractPropertyHasInitializer: "Property '%0' cannot have an initializer because it is marked abstract.",
  AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
  AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
  ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
  ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
  ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
  DeclareAccessor: "'declare' is not allowed in %0ters.",
  DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
  DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
  DuplicateAccessibilityModifier: "Accessibility modifier already seen.",
  DuplicateModifier: "Duplicate modifier: '%0'.",
  EmptyHeritageClauseType: "'%0' list cannot be empty.",
  EmptyTypeArguments: "Type argument list cannot be empty.",
  EmptyTypeParameters: "Type parameter list cannot be empty.",
  ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
  ImportAliasHasImportType: "An import alias can not use 'import type'.",
  IncompatibleModifiers: "'%0' modifier cannot be used with '%1' modifier.",
  IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
  IndexSignatureHasAccessibility: "Index signatures cannot have an accessibility modifier ('%0').",
  IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
  IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
  IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
  InvalidModifierOnTypeMember: "'%0' modifier cannot appear on a type member.",
  InvalidModifiersOrder: "'%0' modifier must precede '%1' modifier.",
  InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
  MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
  MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.",
  NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
  NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
  OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
  OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
  PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
  PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
  PrivateElementHasAccessibility: "Private elements cannot have an accessibility modifier ('%0').",
  ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
  SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
  SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
  SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
  StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
  TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
  TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
  UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
  UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
  UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
  UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
  UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
  UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
  UnsupportedSignatureParameterKind: "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0."
}, Mn$1.SyntaxError, "typescript");
function Jo(e20) {
  return e20 === "private" || e20 === "public" || e20 === "protected";
}
bn$1.placeholder = new Cn$1("%%", { startsExpr: true });
const Yo = Un$1({ ClassNameIsRequired: "A class name is required." }, Mn$1.SyntaxError);
function Qo(e20, t2) {
  return e20.some((e21) => Array.isArray(e21) ? e21[0] === t2 : e21 === t2);
}
function Zo(e20, t2, s2) {
  const r2 = e20.find((e21) => Array.isArray(e21) ? e21[0] === t2 : e21 === t2);
  return r2 && Array.isArray(r2) ? r2[1][s2] : null;
}
const eu = ["minimal", "fsharp", "hack", "smart"], tu = ["%", "#"], su = ["hash", "bar"];
const ru = {
  estree: (e20) => class extends e20 {
    parseRegExpLiteral({ pattern: e21, flags: t2 }) {
      let s2 = null;
      try {
        s2 = new RegExp(e21, t2);
      } catch (e22) {
      }
      const r2 = this.estreeParseLiteral(s2);
      return r2.regex = { pattern: e21, flags: t2 }, r2;
    }
    parseBigIntLiteral(e21) {
      let t2;
      try {
        t2 = BigInt(e21);
      } catch (e22) {
        t2 = null;
      }
      const s2 = this.estreeParseLiteral(t2);
      return s2.bigint = String(s2.value || e21), s2;
    }
    parseDecimalLiteral(e21) {
      const t2 = this.estreeParseLiteral(null);
      return t2.decimal = String(t2.value || e21), t2;
    }
    estreeParseLiteral(e21) {
      return this.parseLiteral(e21, "Literal");
    }
    parseStringLiteral(e21) {
      return this.estreeParseLiteral(e21);
    }
    parseNumericLiteral(e21) {
      return this.estreeParseLiteral(e21);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(e21) {
      return this.estreeParseLiteral(e21);
    }
    directiveToStmt(e21) {
      const t2 = e21.value, s2 = this.startNodeAt(e21.start, e21.loc.start), r2 = this.startNodeAt(t2.start, t2.loc.start);
      return r2.value = t2.extra.expressionValue, r2.raw = t2.extra.raw, s2.expression = this.finishNodeAt(r2, "Literal", t2.end, t2.loc.end), s2.directive = t2.extra.raw.slice(1, -1), this.finishNodeAt(s2, "ExpressionStatement", e21.end, e21.loc.end);
    }
    initFunction(e21, t2) {
      super.initFunction(e21, t2), e21.expression = false;
    }
    checkDeclaration(e21) {
      e21 != null && this.isObjectProperty(e21) ? this.checkDeclaration(e21.value) : super.checkDeclaration(e21);
    }
    getObjectOrClassMethodParams(e21) {
      return e21.value.params;
    }
    isValidDirective(e21) {
      var t2;
      return e21.type === "ExpressionStatement" && e21.expression.type === "Literal" && typeof e21.expression.value == "string" && !((t2 = e21.expression.extra) != null && t2.parenthesized);
    }
    stmtToDirective(e21) {
      const t2 = e21.expression.value, s2 = super.stmtToDirective(e21);
      return this.addExtra(s2.value, "expressionValue", t2), s2;
    }
    parseBlockBody(e21, ...t2) {
      super.parseBlockBody(e21, ...t2);
      const s2 = e21.directives.map((e22) => this.directiveToStmt(e22));
      e21.body = s2.concat(e21.body), delete e21.directives;
    }
    pushClassMethod(e21, t2, s2, r2, i2, a2) {
      this.parseMethod(t2, s2, r2, i2, a2, "ClassMethod", true), t2.typeParameters && (t2.value.typeParameters = t2.typeParameters, delete t2.typeParameters), e21.body.push(t2);
    }
    parseMaybePrivateName(...e21) {
      const t2 = super.parseMaybePrivateName(...e21);
      return t2.type === "PrivateName" && this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(t2) : t2;
    }
    convertPrivateNameToPrivateIdentifier(e21) {
      const t2 = super.getPrivateNameSV(e21);
      return delete (e21 = e21).id, e21.name = t2, e21.type = "PrivateIdentifier", e21;
    }
    isPrivateName(e21) {
      return this.getPluginOption("estree", "classFeatures") ? e21.type === "PrivateIdentifier" : super.isPrivateName(e21);
    }
    getPrivateNameSV(e21) {
      return this.getPluginOption("estree", "classFeatures") ? e21.name : super.getPrivateNameSV(e21);
    }
    parseLiteral(e21, t2) {
      const s2 = super.parseLiteral(e21, t2);
      return s2.raw = s2.extra.raw, delete s2.extra, s2;
    }
    parseFunctionBody(e21, t2, s2 = false) {
      super.parseFunctionBody(e21, t2, s2), e21.expression = e21.body.type !== "BlockStatement";
    }
    parseMethod(e21, t2, s2, r2, i2, a2, n2 = false) {
      let o2 = this.startNode();
      return o2.kind = e21.kind, o2 = super.parseMethod(o2, t2, s2, r2, i2, a2, n2), o2.type = "FunctionExpression", delete o2.kind, e21.value = o2, a2 === "ClassPrivateMethod" && (e21.computed = false), a2 = "MethodDefinition", this.finishNode(e21, a2);
    }
    parseClassProperty(...e21) {
      const t2 = super.parseClassProperty(...e21);
      return this.getPluginOption("estree", "classFeatures") && (t2.type = "PropertyDefinition"), t2;
    }
    parseClassPrivateProperty(...e21) {
      const t2 = super.parseClassPrivateProperty(...e21);
      return this.getPluginOption("estree", "classFeatures") && (t2.type = "PropertyDefinition", t2.computed = false), t2;
    }
    parseObjectMethod(e21, t2, s2, r2, i2) {
      const a2 = super.parseObjectMethod(e21, t2, s2, r2, i2);
      return a2 && (a2.type = "Property", a2.kind === "method" && (a2.kind = "init"), a2.shorthand = false), a2;
    }
    parseObjectProperty(e21, t2, s2, r2, i2) {
      const a2 = super.parseObjectProperty(e21, t2, s2, r2, i2);
      return a2 && (a2.kind = "init", a2.type = "Property"), a2;
    }
    isAssignable(e21, t2) {
      return e21 != null && this.isObjectProperty(e21) ? this.isAssignable(e21.value, t2) : super.isAssignable(e21, t2);
    }
    toAssignable(e21, t2 = false) {
      return e21 != null && this.isObjectProperty(e21) ? (this.toAssignable(e21.value, t2), e21) : super.toAssignable(e21, t2);
    }
    toAssignableObjectExpressionProp(e21, ...t2) {
      e21.kind === "get" || e21.kind === "set" ? this.raise(e21.key.start, Rn$1.PatternHasAccessor) : e21.method ? this.raise(e21.key.start, Rn$1.PatternHasMethod) : super.toAssignableObjectExpressionProp(e21, ...t2);
    }
    finishCallExpression(e21, t2) {
      if (super.finishCallExpression(e21, t2), e21.callee.type === "Import") {
        var s2;
        if (e21.type = "ImportExpression", e21.source = e21.arguments[0], this.hasPlugin("importAssertions"))
          e21.attributes = (s2 = e21.arguments[1]) != null ? s2 : null;
        delete e21.arguments, delete e21.callee;
      }
      return e21;
    }
    toReferencedArguments(e21) {
      e21.type !== "ImportExpression" && super.toReferencedArguments(e21);
    }
    parseExport(e21) {
      switch (super.parseExport(e21), e21.type) {
        case "ExportAllDeclaration":
          e21.exported = null;
          break;
        case "ExportNamedDeclaration":
          e21.specifiers.length === 1 && e21.specifiers[0].type === "ExportNamespaceSpecifier" && (e21.type = "ExportAllDeclaration", e21.exported = e21.specifiers[0].exported, delete e21.specifiers);
      }
      return e21;
    }
    parseSubscript(e21, t2, s2, r2, i2) {
      const a2 = super.parseSubscript(e21, t2, s2, r2, i2);
      if (i2.optionalChainMember) {
        if (a2.type !== "OptionalMemberExpression" && a2.type !== "OptionalCallExpression" || (a2.type = a2.type.substring(8)), i2.stop) {
          const e22 = this.startNodeAtNode(a2);
          return e22.expression = a2, this.finishNode(e22, "ChainExpression");
        }
      } else
        a2.type !== "MemberExpression" && a2.type !== "CallExpression" || (a2.optional = false);
      return a2;
    }
    hasPropertyAsPrivateName(e21) {
      return e21.type === "ChainExpression" && (e21 = e21.expression), super.hasPropertyAsPrivateName(e21);
    }
    isOptionalChain(e21) {
      return e21.type === "ChainExpression";
    }
    isObjectProperty(e21) {
      return e21.type === "Property" && e21.kind === "init" && !e21.method;
    }
    isObjectMethod(e21) {
      return e21.method || e21.kind === "get" || e21.kind === "set";
    }
  },
  jsx: (e20) => class extends e20 {
    jsxReadToken() {
      let e21 = "", t2 = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(this.state.start, $o.UnterminatedJsxContent);
        const s2 = this.input.charCodeAt(this.state.pos);
        switch (s2) {
          case 60:
          case 123:
            return this.state.pos === this.state.start ? s2 === 60 && this.state.exprAllowed ? (++this.state.pos, this.finishToken(bn$1.jsxTagStart)) : super.getTokenFromCode(s2) : (e21 += this.input.slice(t2, this.state.pos), this.finishToken(bn$1.jsxText, e21));
          case 38:
            e21 += this.input.slice(t2, this.state.pos), e21 += this.jsxReadEntity(), t2 = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            wn$1(s2) ? (e21 += this.input.slice(t2, this.state.pos), e21 += this.jsxReadNewLine(true), t2 = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(e21) {
      const t2 = this.input.charCodeAt(this.state.pos);
      let s2;
      return ++this.state.pos, t2 === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, s2 = e21 ? "\n" : "\r\n") : s2 = String.fromCharCode(t2), ++this.state.curLine, this.state.lineStart = this.state.pos, s2;
    }
    jsxReadString(e21) {
      let t2 = "", s2 = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(this.state.start, Rn$1.UnterminatedString);
        const r2 = this.input.charCodeAt(this.state.pos);
        if (r2 === e21)
          break;
        r2 === 38 ? (t2 += this.input.slice(s2, this.state.pos), t2 += this.jsxReadEntity(), s2 = this.state.pos) : wn$1(r2) ? (t2 += this.input.slice(s2, this.state.pos), t2 += this.jsxReadNewLine(false), s2 = this.state.pos) : ++this.state.pos;
      }
      return t2 += this.input.slice(s2, this.state.pos++), this.finishToken(bn$1.string, t2);
    }
    jsxReadEntity() {
      let e21, t2 = "", s2 = 0, r2 = this.input[this.state.pos];
      const i2 = ++this.state.pos;
      for (; this.state.pos < this.length && s2++ < 10; ) {
        if (r2 = this.input[this.state.pos++], r2 === ";") {
          t2[0] === "#" ? t2[1] === "x" ? (t2 = t2.substr(2), Uo.test(t2) && (e21 = String.fromCodePoint(parseInt(t2, 16)))) : (t2 = t2.substr(1), qo.test(t2) && (e21 = String.fromCodePoint(parseInt(t2, 10)))) : e21 = _o$1[t2];
          break;
        }
        t2 += r2;
      }
      return e21 || (this.state.pos = i2, "&");
    }
    jsxReadWord() {
      let e21;
      const t2 = this.state.pos;
      do {
        e21 = this.input.charCodeAt(++this.state.pos);
      } while (Yn$1(e21) || e21 === 45);
      return this.finishToken(bn$1.jsxName, this.input.slice(t2, this.state.pos));
    }
    jsxParseIdentifier() {
      const e21 = this.startNode();
      return this.match(bn$1.jsxName) ? e21.name = this.state.value : this.state.type.keyword ? e21.name = this.state.type.keyword : this.unexpected(), this.next(), this.finishNode(e21, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      const e21 = this.state.start, t2 = this.state.startLoc, s2 = this.jsxParseIdentifier();
      if (!this.eat(bn$1.colon))
        return s2;
      const r2 = this.startNodeAt(e21, t2);
      return r2.namespace = s2, r2.name = this.jsxParseIdentifier(), this.finishNode(r2, "JSXNamespacedName");
    }
    jsxParseElementName() {
      const e21 = this.state.start, t2 = this.state.startLoc;
      let s2 = this.jsxParseNamespacedName();
      if (s2.type === "JSXNamespacedName")
        return s2;
      for (; this.eat(bn$1.dot); ) {
        const r2 = this.startNodeAt(e21, t2);
        r2.object = s2, r2.property = this.jsxParseIdentifier(), s2 = this.finishNode(r2, "JSXMemberExpression");
      }
      return s2;
    }
    jsxParseAttributeValue() {
      let e21;
      switch (this.state.type) {
        case bn$1.braceL:
          return e21 = this.startNode(), this.next(), e21 = this.jsxParseExpressionContainer(e21), e21.expression.type === "JSXEmptyExpression" && this.raise(e21.start, $o.AttributeIsEmpty), e21;
        case bn$1.jsxTagStart:
        case bn$1.string:
          return this.parseExprAtom();
        default:
          throw this.raise(this.state.start, $o.UnsupportedJsxValue);
      }
    }
    jsxParseEmptyExpression() {
      const e21 = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
      return this.finishNodeAt(e21, "JSXEmptyExpression", this.state.start, this.state.startLoc);
    }
    jsxParseSpreadChild(e21) {
      return this.next(), e21.expression = this.parseExpression(), this.expect(bn$1.braceR), this.finishNode(e21, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(e21) {
      if (this.match(bn$1.braceR))
        e21.expression = this.jsxParseEmptyExpression();
      else {
        const t2 = this.parseExpression();
        e21.expression = t2;
      }
      return this.expect(bn$1.braceR), this.finishNode(e21, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      const e21 = this.startNode();
      return this.eat(bn$1.braceL) ? (this.expect(bn$1.ellipsis), e21.argument = this.parseMaybeAssignAllowIn(), this.expect(bn$1.braceR), this.finishNode(e21, "JSXSpreadAttribute")) : (e21.name = this.jsxParseNamespacedName(), e21.value = this.eat(bn$1.eq) ? this.jsxParseAttributeValue() : null, this.finishNode(e21, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(e21, t2) {
      const s2 = this.startNodeAt(e21, t2);
      return this.match(bn$1.jsxTagEnd) ? (this.expect(bn$1.jsxTagEnd), this.finishNode(s2, "JSXOpeningFragment")) : (s2.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(s2));
    }
    jsxParseOpeningElementAfterName(e21) {
      const t2 = [];
      for (; !this.match(bn$1.slash) && !this.match(bn$1.jsxTagEnd); )
        t2.push(this.jsxParseAttribute());
      return e21.attributes = t2, e21.selfClosing = this.eat(bn$1.slash), this.expect(bn$1.jsxTagEnd), this.finishNode(e21, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(e21, t2) {
      const s2 = this.startNodeAt(e21, t2);
      return this.match(bn$1.jsxTagEnd) ? (this.expect(bn$1.jsxTagEnd), this.finishNode(s2, "JSXClosingFragment")) : (s2.name = this.jsxParseElementName(), this.expect(bn$1.jsxTagEnd), this.finishNode(s2, "JSXClosingElement"));
    }
    jsxParseElementAt(e21, t2) {
      const s2 = this.startNodeAt(e21, t2), r2 = [], i2 = this.jsxParseOpeningElementAt(e21, t2);
      let a2 = null;
      if (!i2.selfClosing) {
        e:
          for (; ; )
            switch (this.state.type) {
              case bn$1.jsxTagStart:
                if (e21 = this.state.start, t2 = this.state.startLoc, this.next(), this.eat(bn$1.slash)) {
                  a2 = this.jsxParseClosingElementAt(e21, t2);
                  break e;
                }
                r2.push(this.jsxParseElementAt(e21, t2));
                break;
              case bn$1.jsxText:
                r2.push(this.parseExprAtom());
                break;
              case bn$1.braceL: {
                const e22 = this.startNode();
                this.next(), this.match(bn$1.ellipsis) ? r2.push(this.jsxParseSpreadChild(e22)) : r2.push(this.jsxParseExpressionContainer(e22));
                break;
              }
              default:
                throw this.unexpected();
            }
        Ho(i2) && !Ho(a2) ? this.raise(a2.start, $o.MissingClosingTagFragment) : !Ho(i2) && Ho(a2) ? this.raise(a2.start, $o.MissingClosingTagElement, Vo(i2.name)) : Ho(i2) || Ho(a2) || Vo(a2.name) !== Vo(i2.name) && this.raise(a2.start, $o.MissingClosingTagElement, Vo(i2.name));
      }
      if (Ho(i2) ? (s2.openingFragment = i2, s2.closingFragment = a2) : (s2.openingElement = i2, s2.closingElement = a2), s2.children = r2, this.isRelational("<"))
        throw this.raise(this.state.start, $o.UnwrappedAdjacentJSXElements);
      return Ho(i2) ? this.finishNode(s2, "JSXFragment") : this.finishNode(s2, "JSXElement");
    }
    jsxParseElement() {
      const e21 = this.state.start, t2 = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(e21, t2);
    }
    parseExprAtom(e21) {
      return this.match(bn$1.jsxText) ? this.parseLiteral(this.state.value, "JSXText") : this.match(bn$1.jsxTagStart) ? this.jsxParseElement() : this.isRelational("<") && this.input.charCodeAt(this.state.pos) !== 33 ? (this.finishToken(bn$1.jsxTagStart), this.jsxParseElement()) : super.parseExprAtom(e21);
    }
    createLookaheadState(e21) {
      const t2 = super.createLookaheadState(e21);
      return t2.inPropertyName = e21.inPropertyName, t2;
    }
    getTokenFromCode(e21) {
      if (this.state.inPropertyName)
        return super.getTokenFromCode(e21);
      const t2 = this.curContext();
      if (t2 === $n$1.j_expr)
        return this.jsxReadToken();
      if (t2 === $n$1.j_oTag || t2 === $n$1.j_cTag) {
        if (Jn$1(e21))
          return this.jsxReadWord();
        if (e21 === 62)
          return ++this.state.pos, this.finishToken(bn$1.jsxTagEnd);
        if ((e21 === 34 || e21 === 39) && t2 === $n$1.j_oTag)
          return this.jsxReadString(e21);
      }
      return e21 === 60 && this.state.exprAllowed && this.input.charCodeAt(this.state.pos + 1) !== 33 ? (++this.state.pos, this.finishToken(bn$1.jsxTagStart)) : super.getTokenFromCode(e21);
    }
    updateContext(e21) {
      super.updateContext(e21);
      const { context: t2, type: s2 } = this.state;
      if (s2 === bn$1.slash && e21 === bn$1.jsxTagStart)
        t2.splice(-2, 2, $n$1.j_cTag), this.state.exprAllowed = false;
      else if (s2 === bn$1.jsxTagEnd) {
        const s3 = t2.pop();
        s3 === $n$1.j_oTag && e21 === bn$1.slash || s3 === $n$1.j_cTag ? (t2.pop(), this.state.exprAllowed = t2[t2.length - 1] === $n$1.j_expr) : this.state.exprAllowed = true;
      } else
        !s2.keyword || e21 !== bn$1.dot && e21 !== bn$1.questionDot ? this.state.exprAllowed = s2.beforeExpr : this.state.exprAllowed = false;
    }
  },
  flow: (e20) => class extends e20 {
    constructor(...e21) {
      super(...e21), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return lo$1;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    shouldParseEnums() {
      return !!this.getPluginOption("flow", "enums");
    }
    finishToken(e21, t2) {
      return e21 !== bn$1.string && e21 !== bn$1.semi && e21 !== bn$1.interpreterDirective && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(e21, t2);
    }
    addComment(e21) {
      if (this.flowPragma === void 0) {
        const t2 = jo.exec(e21.value);
        if (t2)
          if (t2[1] === "flow")
            this.flowPragma = "flow";
          else {
            if (t2[1] !== "noflow")
              throw new Error("Unexpected flow pragma");
            this.flowPragma = "noflow";
          }
      }
      return super.addComment(e21);
    }
    flowParseTypeInitialiser(e21) {
      const t2 = this.state.inType;
      this.state.inType = true, this.expect(e21 || bn$1.colon);
      const s2 = this.flowParseType();
      return this.state.inType = t2, s2;
    }
    flowParsePredicate() {
      const e21 = this.startNode(), t2 = this.state.start;
      return this.next(), this.expectContextual("checks"), this.state.lastTokStart > t2 + 1 && this.raise(t2, Lo$1.UnexpectedSpaceBetweenModuloChecks), this.eat(bn$1.parenL) ? (e21.value = this.parseExpression(), this.expect(bn$1.parenR), this.finishNode(e21, "DeclaredPredicate")) : this.finishNode(e21, "InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      const e21 = this.state.inType;
      this.state.inType = true, this.expect(bn$1.colon);
      let t2 = null, s2 = null;
      return this.match(bn$1.modulo) ? (this.state.inType = e21, s2 = this.flowParsePredicate()) : (t2 = this.flowParseType(), this.state.inType = e21, this.match(bn$1.modulo) && (s2 = this.flowParsePredicate())), [t2, s2];
    }
    flowParseDeclareClass(e21) {
      return this.next(), this.flowParseInterfaceish(e21, true), this.finishNode(e21, "DeclareClass");
    }
    flowParseDeclareFunction(e21) {
      this.next();
      const t2 = e21.id = this.parseIdentifier(), s2 = this.startNode(), r2 = this.startNode();
      this.isRelational("<") ? s2.typeParameters = this.flowParseTypeParameterDeclaration() : s2.typeParameters = null, this.expect(bn$1.parenL);
      const i2 = this.flowParseFunctionTypeParams();
      return s2.params = i2.params, s2.rest = i2.rest, s2.this = i2._this, this.expect(bn$1.parenR), [s2.returnType, e21.predicate] = this.flowParseTypeAndPredicateInitialiser(), r2.typeAnnotation = this.finishNode(s2, "FunctionTypeAnnotation"), t2.typeAnnotation = this.finishNode(r2, "TypeAnnotation"), this.resetEndLocation(t2), this.semicolon(), this.scope.declareName(e21.id.name, 2048, e21.id.start), this.finishNode(e21, "DeclareFunction");
    }
    flowParseDeclare(e21, t2) {
      if (this.match(bn$1._class))
        return this.flowParseDeclareClass(e21);
      if (this.match(bn$1._function))
        return this.flowParseDeclareFunction(e21);
      if (this.match(bn$1._var))
        return this.flowParseDeclareVariable(e21);
      if (this.eatContextual("module"))
        return this.match(bn$1.dot) ? this.flowParseDeclareModuleExports(e21) : (t2 && this.raise(this.state.lastTokStart, Lo$1.NestedDeclareModule), this.flowParseDeclareModule(e21));
      if (this.isContextual("type"))
        return this.flowParseDeclareTypeAlias(e21);
      if (this.isContextual("opaque"))
        return this.flowParseDeclareOpaqueType(e21);
      if (this.isContextual("interface"))
        return this.flowParseDeclareInterface(e21);
      if (this.match(bn$1._export))
        return this.flowParseDeclareExportDeclaration(e21, t2);
      throw this.unexpected();
    }
    flowParseDeclareVariable(e21) {
      return this.next(), e21.id = this.flowParseTypeAnnotatableIdentifier(true), this.scope.declareName(e21.id.name, 5, e21.id.start), this.semicolon(), this.finishNode(e21, "DeclareVariable");
    }
    flowParseDeclareModule(e21) {
      this.scope.enter(0), this.match(bn$1.string) ? e21.id = this.parseExprAtom() : e21.id = this.parseIdentifier();
      const t2 = e21.body = this.startNode(), s2 = t2.body = [];
      for (this.expect(bn$1.braceL); !this.match(bn$1.braceR); ) {
        let e22 = this.startNode();
        this.match(bn$1._import) ? (this.next(), this.isContextual("type") || this.match(bn$1._typeof) || this.raise(this.state.lastTokStart, Lo$1.InvalidNonTypeImportInDeclareModule), this.parseImport(e22)) : (this.expectContextual("declare", Lo$1.UnsupportedStatementInDeclareModule), e22 = this.flowParseDeclare(e22, true)), s2.push(e22);
      }
      this.scope.exit(), this.expect(bn$1.braceR), this.finishNode(t2, "BlockStatement");
      let r2 = null, i2 = false;
      return s2.forEach((e22) => {
        !function(e23) {
          return e23.type === "DeclareExportAllDeclaration" || e23.type === "DeclareExportDeclaration" && (!e23.declaration || e23.declaration.type !== "TypeAlias" && e23.declaration.type !== "InterfaceDeclaration");
        }(e22) ? e22.type === "DeclareModuleExports" && (i2 && this.raise(e22.start, Lo$1.DuplicateDeclareModuleExports), r2 === "ES" && this.raise(e22.start, Lo$1.AmbiguousDeclareModuleKind), r2 = "CommonJS", i2 = true) : (r2 === "CommonJS" && this.raise(e22.start, Lo$1.AmbiguousDeclareModuleKind), r2 = "ES");
      }), e21.kind = r2 || "CommonJS", this.finishNode(e21, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(e21, t2) {
      if (this.expect(bn$1._export), this.eat(bn$1._default))
        return this.match(bn$1._function) || this.match(bn$1._class) ? e21.declaration = this.flowParseDeclare(this.startNode()) : (e21.declaration = this.flowParseType(), this.semicolon()), e21.default = true, this.finishNode(e21, "DeclareExportDeclaration");
      if (this.match(bn$1._const) || this.isLet() || (this.isContextual("type") || this.isContextual("interface")) && !t2) {
        const e22 = this.state.value, t3 = Ro$1[e22];
        throw this.raise(this.state.start, Lo$1.UnsupportedDeclareExportKind, e22, t3);
      }
      if (this.match(bn$1._var) || this.match(bn$1._function) || this.match(bn$1._class) || this.isContextual("opaque"))
        return e21.declaration = this.flowParseDeclare(this.startNode()), e21.default = false, this.finishNode(e21, "DeclareExportDeclaration");
      if (this.match(bn$1.star) || this.match(bn$1.braceL) || this.isContextual("interface") || this.isContextual("type") || this.isContextual("opaque"))
        return (e21 = this.parseExport(e21)).type === "ExportNamedDeclaration" && (e21.type = "ExportDeclaration", e21.default = false, delete e21.exportKind), e21.type = "Declare" + e21.type, e21;
      throw this.unexpected();
    }
    flowParseDeclareModuleExports(e21) {
      return this.next(), this.expectContextual("exports"), e21.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(e21, "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(e21) {
      return this.next(), this.flowParseTypeAlias(e21), e21.type = "DeclareTypeAlias", e21;
    }
    flowParseDeclareOpaqueType(e21) {
      return this.next(), this.flowParseOpaqueType(e21, true), e21.type = "DeclareOpaqueType", e21;
    }
    flowParseDeclareInterface(e21) {
      return this.next(), this.flowParseInterfaceish(e21), this.finishNode(e21, "DeclareInterface");
    }
    flowParseInterfaceish(e21, t2 = false) {
      if (e21.id = this.flowParseRestrictedIdentifier(!t2, true), this.scope.declareName(e21.id.name, t2 ? 17 : 9, e21.id.start), this.isRelational("<") ? e21.typeParameters = this.flowParseTypeParameterDeclaration() : e21.typeParameters = null, e21.extends = [], e21.implements = [], e21.mixins = [], this.eat(bn$1._extends))
        do {
          e21.extends.push(this.flowParseInterfaceExtends());
        } while (!t2 && this.eat(bn$1.comma));
      if (this.isContextual("mixins")) {
        this.next();
        do {
          e21.mixins.push(this.flowParseInterfaceExtends());
        } while (this.eat(bn$1.comma));
      }
      if (this.isContextual("implements")) {
        this.next();
        do {
          e21.implements.push(this.flowParseInterfaceExtends());
        } while (this.eat(bn$1.comma));
      }
      e21.body = this.flowParseObjectType({
        allowStatic: t2,
        allowExact: false,
        allowSpread: false,
        allowProto: t2,
        allowInexact: false
      });
    }
    flowParseInterfaceExtends() {
      const e21 = this.startNode();
      return e21.id = this.flowParseQualifiedTypeIdentifier(), this.isRelational("<") ? e21.typeParameters = this.flowParseTypeParameterInstantiation() : e21.typeParameters = null, this.finishNode(e21, "InterfaceExtends");
    }
    flowParseInterface(e21) {
      return this.flowParseInterfaceish(e21), this.finishNode(e21, "InterfaceDeclaration");
    }
    checkNotUnderscore(e21) {
      e21 === "_" && this.raise(this.state.start, Lo$1.UnexpectedReservedUnderscore);
    }
    checkReservedType(e21, t2, s2) {
      ko$1.has(e21) && this.raise(t2, s2 ? Lo$1.AssignReservedType : Lo$1.UnexpectedReservedType, e21);
    }
    flowParseRestrictedIdentifier(e21, t2) {
      return this.checkReservedType(this.state.value, this.state.start, t2), this.parseIdentifier(e21);
    }
    flowParseTypeAlias(e21) {
      return e21.id = this.flowParseRestrictedIdentifier(false, true), this.scope.declareName(e21.id.name, 9, e21.id.start), this.isRelational("<") ? e21.typeParameters = this.flowParseTypeParameterDeclaration() : e21.typeParameters = null, e21.right = this.flowParseTypeInitialiser(bn$1.eq), this.semicolon(), this.finishNode(e21, "TypeAlias");
    }
    flowParseOpaqueType(e21, t2) {
      return this.expectContextual("type"), e21.id = this.flowParseRestrictedIdentifier(true, true), this.scope.declareName(e21.id.name, 9, e21.id.start), this.isRelational("<") ? e21.typeParameters = this.flowParseTypeParameterDeclaration() : e21.typeParameters = null, e21.supertype = null, this.match(bn$1.colon) && (e21.supertype = this.flowParseTypeInitialiser(bn$1.colon)), e21.impltype = null, t2 || (e21.impltype = this.flowParseTypeInitialiser(bn$1.eq)), this.semicolon(), this.finishNode(e21, "OpaqueType");
    }
    flowParseTypeParameter(e21 = false) {
      const t2 = this.state.start, s2 = this.startNode(), r2 = this.flowParseVariance(), i2 = this.flowParseTypeAnnotatableIdentifier();
      return s2.name = i2.name, s2.variance = r2, s2.bound = i2.typeAnnotation, this.match(bn$1.eq) ? (this.eat(bn$1.eq), s2.default = this.flowParseType()) : e21 && this.raise(t2, Lo$1.MissingTypeParamDefault), this.finishNode(s2, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      const e21 = this.state.inType, t2 = this.startNode();
      t2.params = [], this.state.inType = true, this.isRelational("<") || this.match(bn$1.jsxTagStart) ? this.next() : this.unexpected();
      let s2 = false;
      do {
        const e22 = this.flowParseTypeParameter(s2);
        t2.params.push(e22), e22.default && (s2 = true), this.isRelational(">") || this.expect(bn$1.comma);
      } while (!this.isRelational(">"));
      return this.expectRelational(">"), this.state.inType = e21, this.finishNode(t2, "TypeParameterDeclaration");
    }
    flowParseTypeParameterInstantiation() {
      const e21 = this.startNode(), t2 = this.state.inType;
      e21.params = [], this.state.inType = true, this.expectRelational("<");
      const s2 = this.state.noAnonFunctionType;
      for (this.state.noAnonFunctionType = false; !this.isRelational(">"); )
        e21.params.push(this.flowParseType()), this.isRelational(">") || this.expect(bn$1.comma);
      return this.state.noAnonFunctionType = s2, this.expectRelational(">"), this.state.inType = t2, this.finishNode(e21, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      const e21 = this.startNode(), t2 = this.state.inType;
      for (e21.params = [], this.state.inType = true, this.expectRelational("<"); !this.isRelational(">"); )
        e21.params.push(this.flowParseTypeOrImplicitInstantiation()), this.isRelational(">") || this.expect(bn$1.comma);
      return this.expectRelational(">"), this.state.inType = t2, this.finishNode(e21, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      const e21 = this.startNode();
      if (this.expectContextual("interface"), e21.extends = [], this.eat(bn$1._extends))
        do {
          e21.extends.push(this.flowParseInterfaceExtends());
        } while (this.eat(bn$1.comma));
      return e21.body = this.flowParseObjectType({
        allowStatic: false,
        allowExact: false,
        allowSpread: false,
        allowProto: false,
        allowInexact: false
      }), this.finishNode(e21, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(bn$1.num) || this.match(bn$1.string) ? this.parseExprAtom() : this.parseIdentifier(true);
    }
    flowParseObjectTypeIndexer(e21, t2, s2) {
      return e21.static = t2, this.lookahead().type === bn$1.colon ? (e21.id = this.flowParseObjectPropertyKey(), e21.key = this.flowParseTypeInitialiser()) : (e21.id = null, e21.key = this.flowParseType()), this.expect(bn$1.bracketR), e21.value = this.flowParseTypeInitialiser(), e21.variance = s2, this.finishNode(e21, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(e21, t2) {
      return e21.static = t2, e21.id = this.flowParseObjectPropertyKey(), this.expect(bn$1.bracketR), this.expect(bn$1.bracketR), this.isRelational("<") || this.match(bn$1.parenL) ? (e21.method = true, e21.optional = false, e21.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e21.start, e21.loc.start))) : (e21.method = false, this.eat(bn$1.question) && (e21.optional = true), e21.value = this.flowParseTypeInitialiser()), this.finishNode(e21, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(e21) {
      for (e21.params = [], e21.rest = null, e21.typeParameters = null, e21.this = null, this.isRelational("<") && (e21.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(bn$1.parenL), this.match(bn$1._this) && (e21.this = this.flowParseFunctionTypeParam(true), e21.this.name = null, this.match(bn$1.parenR) || this.expect(bn$1.comma)); !this.match(bn$1.parenR) && !this.match(bn$1.ellipsis); )
        e21.params.push(this.flowParseFunctionTypeParam(false)), this.match(bn$1.parenR) || this.expect(bn$1.comma);
      return this.eat(bn$1.ellipsis) && (e21.rest = this.flowParseFunctionTypeParam(false)), this.expect(bn$1.parenR), e21.returnType = this.flowParseTypeInitialiser(), this.finishNode(e21, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(e21, t2) {
      const s2 = this.startNode();
      return e21.static = t2, e21.value = this.flowParseObjectTypeMethodish(s2), this.finishNode(e21, "ObjectTypeCallProperty");
    }
    flowParseObjectType({
      allowStatic: e21,
      allowExact: t2,
      allowSpread: s2,
      allowProto: r2,
      allowInexact: i2
    }) {
      const a2 = this.state.inType;
      this.state.inType = true;
      const n2 = this.startNode();
      let o2, u2;
      n2.callProperties = [], n2.properties = [], n2.indexers = [], n2.internalSlots = [];
      let h2 = false;
      for (t2 && this.match(bn$1.braceBarL) ? (this.expect(bn$1.braceBarL), o2 = bn$1.braceBarR, u2 = true) : (this.expect(bn$1.braceL), o2 = bn$1.braceR, u2 = false), n2.exact = u2; !this.match(o2); ) {
        let t3 = false, a3 = null, o3 = null;
        const c3 = this.startNode();
        if (r2 && this.isContextual("proto")) {
          const t4 = this.lookahead();
          t4.type !== bn$1.colon && t4.type !== bn$1.question && (this.next(), a3 = this.state.start, e21 = false);
        }
        if (e21 && this.isContextual("static")) {
          const e22 = this.lookahead();
          e22.type !== bn$1.colon && e22.type !== bn$1.question && (this.next(), t3 = true);
        }
        const p2 = this.flowParseVariance();
        if (this.eat(bn$1.bracketL))
          a3 != null && this.unexpected(a3), this.eat(bn$1.bracketL) ? (p2 && this.unexpected(p2.start), n2.internalSlots.push(this.flowParseObjectTypeInternalSlot(c3, t3))) : n2.indexers.push(this.flowParseObjectTypeIndexer(c3, t3, p2));
        else if (this.match(bn$1.parenL) || this.isRelational("<"))
          a3 != null && this.unexpected(a3), p2 && this.unexpected(p2.start), n2.callProperties.push(this.flowParseObjectTypeCallProperty(c3, t3));
        else {
          let e22 = "init";
          if (this.isContextual("get") || this.isContextual("set")) {
            const t4 = this.lookahead();
            t4.type !== bn$1.name && t4.type !== bn$1.string && t4.type !== bn$1.num || (e22 = this.state.value, this.next());
          }
          const r3 = this.flowParseObjectTypeProperty(c3, t3, a3, p2, e22, s2, i2 != null ? i2 : !u2);
          r3 === null ? (h2 = true, o3 = this.state.lastTokStart) : n2.properties.push(r3);
        }
        this.flowObjectTypeSemicolon(), !o3 || this.match(bn$1.braceR) || this.match(bn$1.braceBarR) || this.raise(o3, Lo$1.UnexpectedExplicitInexactInObject);
      }
      this.expect(o2), s2 && (n2.inexact = h2);
      const c2 = this.finishNode(n2, "ObjectTypeAnnotation");
      return this.state.inType = a2, c2;
    }
    flowParseObjectTypeProperty(e21, t2, s2, r2, i2, a2, n2) {
      if (this.eat(bn$1.ellipsis)) {
        return this.match(bn$1.comma) || this.match(bn$1.semi) || this.match(bn$1.braceR) || this.match(bn$1.braceBarR) ? (a2 ? n2 || this.raise(this.state.lastTokStart, Lo$1.InexactInsideExact) : this.raise(this.state.lastTokStart, Lo$1.InexactInsideNonObject), r2 && this.raise(r2.start, Lo$1.InexactVariance), null) : (a2 || this.raise(this.state.lastTokStart, Lo$1.UnexpectedSpreadType), s2 != null && this.unexpected(s2), r2 && this.raise(r2.start, Lo$1.SpreadVariance), e21.argument = this.flowParseType(), this.finishNode(e21, "ObjectTypeSpreadProperty"));
      }
      {
        e21.key = this.flowParseObjectPropertyKey(), e21.static = t2, e21.proto = s2 != null, e21.kind = i2;
        let n3 = false;
        return this.isRelational("<") || this.match(bn$1.parenL) ? (e21.method = true, s2 != null && this.unexpected(s2), r2 && this.unexpected(r2.start), e21.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e21.start, e21.loc.start)), i2 !== "get" && i2 !== "set" || this.flowCheckGetterSetterParams(e21), !a2 && e21.key.name === "constructor" && e21.value.this && this.raise(e21.value.this.start, Lo$1.ThisParamBannedInConstructor)) : (i2 !== "init" && this.unexpected(), e21.method = false, this.eat(bn$1.question) && (n3 = true), e21.value = this.flowParseTypeInitialiser(), e21.variance = r2), e21.optional = n3, this.finishNode(e21, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(e21) {
      const t2 = e21.kind === "get" ? 0 : 1, s2 = e21.start, r2 = e21.value.params.length + (e21.value.rest ? 1 : 0);
      e21.value.this && this.raise(e21.value.this.start, e21.kind === "get" ? Lo$1.GetterMayNotHaveThisParam : Lo$1.SetterMayNotHaveThisParam), r2 !== t2 && (e21.kind === "get" ? this.raise(s2, Rn$1.BadGetterArity) : this.raise(s2, Rn$1.BadSetterArity)), e21.kind === "set" && e21.value.rest && this.raise(s2, Rn$1.BadSetterRestParameter);
    }
    flowObjectTypeSemicolon() {
      this.eat(bn$1.semi) || this.eat(bn$1.comma) || this.match(bn$1.braceR) || this.match(bn$1.braceBarR) || this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(e21, t2, s2) {
      e21 = e21 || this.state.start, t2 = t2 || this.state.startLoc;
      let r2 = s2 || this.flowParseRestrictedIdentifier(true);
      for (; this.eat(bn$1.dot); ) {
        const s3 = this.startNodeAt(e21, t2);
        s3.qualification = r2, s3.id = this.flowParseRestrictedIdentifier(true), r2 = this.finishNode(s3, "QualifiedTypeIdentifier");
      }
      return r2;
    }
    flowParseGenericType(e21, t2, s2) {
      const r2 = this.startNodeAt(e21, t2);
      return r2.typeParameters = null, r2.id = this.flowParseQualifiedTypeIdentifier(e21, t2, s2), this.isRelational("<") && (r2.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(r2, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      const e21 = this.startNode();
      return this.expect(bn$1._typeof), e21.argument = this.flowParsePrimaryType(), this.finishNode(e21, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      const e21 = this.startNode();
      for (e21.types = [], this.expect(bn$1.bracketL); this.state.pos < this.length && !this.match(bn$1.bracketR) && (e21.types.push(this.flowParseType()), !this.match(bn$1.bracketR)); )
        this.expect(bn$1.comma);
      return this.expect(bn$1.bracketR), this.finishNode(e21, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(e21) {
      let t2 = null, s2 = false, r2 = null;
      const i2 = this.startNode(), a2 = this.lookahead(), n2 = this.state.type === bn$1._this;
      return a2.type === bn$1.colon || a2.type === bn$1.question ? (n2 && !e21 && this.raise(i2.start, Lo$1.ThisParamMustBeFirst), t2 = this.parseIdentifier(n2), this.eat(bn$1.question) && (s2 = true, n2 && this.raise(i2.start, Lo$1.ThisParamMayNotBeOptional)), r2 = this.flowParseTypeInitialiser()) : r2 = this.flowParseType(), i2.name = t2, i2.optional = s2, i2.typeAnnotation = r2, this.finishNode(i2, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(e21) {
      const t2 = this.startNodeAt(e21.start, e21.loc.start);
      return t2.name = null, t2.optional = false, t2.typeAnnotation = e21, this.finishNode(t2, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(e21 = []) {
      let t2 = null, s2 = null;
      for (this.match(bn$1._this) && (s2 = this.flowParseFunctionTypeParam(true), s2.name = null, this.match(bn$1.parenR) || this.expect(bn$1.comma)); !this.match(bn$1.parenR) && !this.match(bn$1.ellipsis); )
        e21.push(this.flowParseFunctionTypeParam(false)), this.match(bn$1.parenR) || this.expect(bn$1.comma);
      return this.eat(bn$1.ellipsis) && (t2 = this.flowParseFunctionTypeParam(false)), { params: e21, rest: t2, _this: s2 };
    }
    flowIdentToTypeAnnotation(e21, t2, s2, r2) {
      switch (r2.name) {
        case "any":
          return this.finishNode(s2, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(s2, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(s2, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(s2, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(s2, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(s2, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(s2, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(r2.name), this.flowParseGenericType(e21, t2, r2);
      }
    }
    flowParsePrimaryType() {
      const e21 = this.state.start, t2 = this.state.startLoc, s2 = this.startNode();
      let r2, i2, a2 = false;
      const n2 = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case bn$1.name:
          return this.isContextual("interface") ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(e21, t2, s2, this.parseIdentifier());
        case bn$1.braceL:
          return this.flowParseObjectType({
            allowStatic: false,
            allowExact: false,
            allowSpread: true,
            allowProto: false,
            allowInexact: true
          });
        case bn$1.braceBarL:
          return this.flowParseObjectType({
            allowStatic: false,
            allowExact: true,
            allowSpread: true,
            allowProto: false,
            allowInexact: false
          });
        case bn$1.bracketL:
          return this.state.noAnonFunctionType = false, i2 = this.flowParseTupleType(), this.state.noAnonFunctionType = n2, i2;
        case bn$1.relational:
          if (this.state.value === "<")
            return s2.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(bn$1.parenL), r2 = this.flowParseFunctionTypeParams(), s2.params = r2.params, s2.rest = r2.rest, s2.this = r2._this, this.expect(bn$1.parenR), this.expect(bn$1.arrow), s2.returnType = this.flowParseType(), this.finishNode(s2, "FunctionTypeAnnotation");
          break;
        case bn$1.parenL:
          if (this.next(), !this.match(bn$1.parenR) && !this.match(bn$1.ellipsis))
            if (this.match(bn$1.name) || this.match(bn$1._this)) {
              const e22 = this.lookahead().type;
              a2 = e22 !== bn$1.question && e22 !== bn$1.colon;
            } else
              a2 = true;
          if (a2) {
            if (this.state.noAnonFunctionType = false, i2 = this.flowParseType(), this.state.noAnonFunctionType = n2, this.state.noAnonFunctionType || !(this.match(bn$1.comma) || this.match(bn$1.parenR) && this.lookahead().type === bn$1.arrow))
              return this.expect(bn$1.parenR), i2;
            this.eat(bn$1.comma);
          }
          return r2 = i2 ? this.flowParseFunctionTypeParams([
            this.reinterpretTypeAsFunctionTypeParam(i2)
          ]) : this.flowParseFunctionTypeParams(), s2.params = r2.params, s2.rest = r2.rest, s2.this = r2._this, this.expect(bn$1.parenR), this.expect(bn$1.arrow), s2.returnType = this.flowParseType(), s2.typeParameters = null, this.finishNode(s2, "FunctionTypeAnnotation");
        case bn$1.string:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case bn$1._true:
        case bn$1._false:
          return s2.value = this.match(bn$1._true), this.next(), this.finishNode(s2, "BooleanLiteralTypeAnnotation");
        case bn$1.plusMin:
          if (this.state.value === "-") {
            if (this.next(), this.match(bn$1.num))
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", s2);
            if (this.match(bn$1.bigint))
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", s2);
            throw this.raise(this.state.start, Lo$1.UnexpectedSubtractionOperand);
          }
          throw this.unexpected();
        case bn$1.num:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case bn$1.bigint:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case bn$1._void:
          return this.next(), this.finishNode(s2, "VoidTypeAnnotation");
        case bn$1._null:
          return this.next(), this.finishNode(s2, "NullLiteralTypeAnnotation");
        case bn$1._this:
          return this.next(), this.finishNode(s2, "ThisTypeAnnotation");
        case bn$1.star:
          return this.next(), this.finishNode(s2, "ExistsTypeAnnotation");
        default:
          if (this.state.type.keyword === "typeof")
            return this.flowParseTypeofType();
          if (this.state.type.keyword) {
            const e22 = this.state.type.label;
            return this.next(), super.createIdentifier(s2, e22);
          }
      }
      throw this.unexpected();
    }
    flowParsePostfixType() {
      const e21 = this.state.start, t2 = this.state.startLoc;
      let s2 = this.flowParsePrimaryType(), r2 = false;
      for (; (this.match(bn$1.bracketL) || this.match(bn$1.questionDot)) && !this.canInsertSemicolon(); ) {
        const i2 = this.startNodeAt(e21, t2), a2 = this.eat(bn$1.questionDot);
        r2 = r2 || a2, this.expect(bn$1.bracketL), !a2 && this.match(bn$1.bracketR) ? (i2.elementType = s2, this.next(), s2 = this.finishNode(i2, "ArrayTypeAnnotation")) : (i2.objectType = s2, i2.indexType = this.flowParseType(), this.expect(bn$1.bracketR), r2 ? (i2.optional = a2, s2 = this.finishNode(i2, "OptionalIndexedAccessType")) : s2 = this.finishNode(i2, "IndexedAccessType"));
      }
      return s2;
    }
    flowParsePrefixType() {
      const e21 = this.startNode();
      return this.eat(bn$1.question) ? (e21.typeAnnotation = this.flowParsePrefixType(), this.finishNode(e21, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      const e21 = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(bn$1.arrow)) {
        const t2 = this.startNodeAt(e21.start, e21.loc.start);
        return t2.params = [
          this.reinterpretTypeAsFunctionTypeParam(e21)
        ], t2.rest = null, t2.this = null, t2.returnType = this.flowParseType(), t2.typeParameters = null, this.finishNode(t2, "FunctionTypeAnnotation");
      }
      return e21;
    }
    flowParseIntersectionType() {
      const e21 = this.startNode();
      this.eat(bn$1.bitwiseAND);
      const t2 = this.flowParseAnonFunctionWithoutParens();
      for (e21.types = [t2]; this.eat(bn$1.bitwiseAND); )
        e21.types.push(this.flowParseAnonFunctionWithoutParens());
      return e21.types.length === 1 ? t2 : this.finishNode(e21, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      const e21 = this.startNode();
      this.eat(bn$1.bitwiseOR);
      const t2 = this.flowParseIntersectionType();
      for (e21.types = [t2]; this.eat(bn$1.bitwiseOR); )
        e21.types.push(this.flowParseIntersectionType());
      return e21.types.length === 1 ? t2 : this.finishNode(e21, "UnionTypeAnnotation");
    }
    flowParseType() {
      const e21 = this.state.inType;
      this.state.inType = true;
      const t2 = this.flowParseUnionType();
      return this.state.inType = e21, t2;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === bn$1.name && this.state.value === "_") {
        const e21 = this.state.start, t2 = this.state.startLoc, s2 = this.parseIdentifier();
        return this.flowParseGenericType(e21, t2, s2);
      }
      return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      const e21 = this.startNode();
      return e21.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(e21, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(e21) {
      const t2 = e21 ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(bn$1.colon) && (t2.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(t2)), t2;
    }
    typeCastToParameter(e21) {
      return e21.expression.typeAnnotation = e21.typeAnnotation, this.resetEndLocation(e21.expression, e21.typeAnnotation.end, e21.typeAnnotation.loc.end), e21.expression;
    }
    flowParseVariance() {
      let e21 = null;
      return this.match(bn$1.plusMin) && (e21 = this.startNode(), this.state.value === "+" ? e21.kind = "plus" : e21.kind = "minus", this.next(), this.finishNode(e21, "Variance")), e21;
    }
    parseFunctionBody(e21, t2, s2 = false) {
      return t2 ? this.forwardNoArrowParamsConversionAt(e21, () => super.parseFunctionBody(e21, true, s2)) : super.parseFunctionBody(e21, false, s2);
    }
    parseFunctionBodyAndFinish(e21, t2, s2 = false) {
      if (this.match(bn$1.colon)) {
        const t3 = this.startNode();
        [t3.typeAnnotation, e21.predicate] = this.flowParseTypeAndPredicateInitialiser(), e21.returnType = t3.typeAnnotation ? this.finishNode(t3, "TypeAnnotation") : null;
      }
      super.parseFunctionBodyAndFinish(e21, t2, s2);
    }
    parseStatement(e21, t2) {
      if (this.state.strict && this.match(bn$1.name) && this.state.value === "interface") {
        const e22 = this.lookahead();
        if (e22.type === bn$1.name || oo$1(e22.value)) {
          const e23 = this.startNode();
          return this.next(), this.flowParseInterface(e23);
        }
      } else if (this.shouldParseEnums() && this.isContextual("enum")) {
        const e22 = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(e22);
      }
      const s2 = super.parseStatement(e21, t2);
      return this.flowPragma !== void 0 || this.isValidDirective(s2) || (this.flowPragma = null), s2;
    }
    parseExpressionStatement(e21, t2) {
      if (t2.type === "Identifier") {
        if (t2.name === "declare") {
          if (this.match(bn$1._class) || this.match(bn$1.name) || this.match(bn$1._function) || this.match(bn$1._var) || this.match(bn$1._export))
            return this.flowParseDeclare(e21);
        } else if (this.match(bn$1.name)) {
          if (t2.name === "interface")
            return this.flowParseInterface(e21);
          if (t2.name === "type")
            return this.flowParseTypeAlias(e21);
          if (t2.name === "opaque")
            return this.flowParseOpaqueType(e21, false);
        }
      }
      return super.parseExpressionStatement(e21, t2);
    }
    shouldParseExportDeclaration() {
      return this.isContextual("type") || this.isContextual("interface") || this.isContextual("opaque") || this.shouldParseEnums() && this.isContextual("enum") || super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      return (!this.match(bn$1.name) || !(this.state.value === "type" || this.state.value === "interface" || this.state.value === "opaque" || this.shouldParseEnums() && this.state.value === "enum")) && super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.shouldParseEnums() && this.isContextual("enum")) {
        const e21 = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(e21);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(e21, t2, s2, r2) {
      if (!this.match(bn$1.question))
        return e21;
      if (this.state.maybeInArrowParameters) {
        const t3 = this.lookaheadCharCode();
        if (t3 === 44 || t3 === 61 || t3 === 58 || t3 === 41)
          return this.setOptionalParametersError(r2), e21;
      }
      this.expect(bn$1.question);
      const i2 = this.state.clone(), a2 = this.state.noArrowAt, n2 = this.startNodeAt(t2, s2);
      let { consequent: o2, failed: u2 } = this.tryParseConditionalConsequent(), [h2, c2] = this.getArrowLikeExpressions(o2);
      if (u2 || c2.length > 0) {
        const e22 = [...a2];
        if (c2.length > 0) {
          this.state = i2, this.state.noArrowAt = e22;
          for (let t3 = 0; t3 < c2.length; t3++)
            e22.push(c2[t3].start);
          ({ consequent: o2, failed: u2 } = this.tryParseConditionalConsequent()), [h2, c2] = this.getArrowLikeExpressions(o2);
        }
        u2 && h2.length > 1 && this.raise(i2.start, Lo$1.AmbiguousConditionalArrow), u2 && h2.length === 1 && (this.state = i2, e22.push(h2[0].start), this.state.noArrowAt = e22, { consequent: o2, failed: u2 } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(o2, true), this.state.noArrowAt = a2, this.expect(bn$1.colon), n2.test = e21, n2.consequent = o2, n2.alternate = this.forwardNoArrowParamsConversionAt(n2, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(n2, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      const e21 = this.parseMaybeAssignAllowIn(), t2 = !this.match(bn$1.colon);
      return this.state.noArrowParamsConversionAt.pop(), { consequent: e21, failed: t2 };
    }
    getArrowLikeExpressions(e21, t2) {
      const s2 = [e21], r2 = [];
      for (; s2.length !== 0; ) {
        const e22 = s2.pop();
        e22.type === "ArrowFunctionExpression" ? (e22.typeParameters || !e22.returnType ? this.finishArrowValidation(e22) : r2.push(e22), s2.push(e22.body)) : e22.type === "ConditionalExpression" && (s2.push(e22.consequent), s2.push(e22.alternate));
      }
      return t2 ? (r2.forEach((e22) => this.finishArrowValidation(e22)), [r2, []]) : function(e22, t3) {
        const s3 = [], r3 = [];
        for (let i2 = 0; i2 < e22.length; i2++)
          (t3(e22[i2], i2, e22) ? s3 : r3).push(e22[i2]);
        return [s3, r3];
      }(r2, (e22) => e22.params.every((e23) => this.isAssignable(e23, true)));
    }
    finishArrowValidation(e21) {
      var t2;
      this.toAssignableList(e21.params, (t2 = e21.extra) == null ? void 0 : t2.trailingComma, false), this.scope.enter(6), super.checkParams(e21, false, true), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(e21, t2) {
      let s2;
      return this.state.noArrowParamsConversionAt.indexOf(e21.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), s2 = t2(), this.state.noArrowParamsConversionAt.pop()) : s2 = t2(), s2;
    }
    parseParenItem(e21, t2, s2) {
      if (e21 = super.parseParenItem(e21, t2, s2), this.eat(bn$1.question) && (e21.optional = true, this.resetEndLocation(e21)), this.match(bn$1.colon)) {
        const r2 = this.startNodeAt(t2, s2);
        return r2.expression = e21, r2.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(r2, "TypeCastExpression");
      }
      return e21;
    }
    assertModuleNodeAllowed(e21) {
      e21.type === "ImportDeclaration" && (e21.importKind === "type" || e21.importKind === "typeof") || e21.type === "ExportNamedDeclaration" && e21.exportKind === "type" || e21.type === "ExportAllDeclaration" && e21.exportKind === "type" || super.assertModuleNodeAllowed(e21);
    }
    parseExport(e21) {
      const t2 = super.parseExport(e21);
      return t2.type !== "ExportNamedDeclaration" && t2.type !== "ExportAllDeclaration" || (t2.exportKind = t2.exportKind || "value"), t2;
    }
    parseExportDeclaration(e21) {
      if (this.isContextual("type")) {
        e21.exportKind = "type";
        const t2 = this.startNode();
        return this.next(), this.match(bn$1.braceL) ? (e21.specifiers = this.parseExportSpecifiers(), this.parseExportFrom(e21), null) : this.flowParseTypeAlias(t2);
      }
      if (this.isContextual("opaque")) {
        e21.exportKind = "type";
        const t2 = this.startNode();
        return this.next(), this.flowParseOpaqueType(t2, false);
      }
      if (this.isContextual("interface")) {
        e21.exportKind = "type";
        const t2 = this.startNode();
        return this.next(), this.flowParseInterface(t2);
      }
      if (this.shouldParseEnums() && this.isContextual("enum")) {
        e21.exportKind = "value";
        const t2 = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(t2);
      }
      return super.parseExportDeclaration(e21);
    }
    eatExportStar(e21) {
      return !!super.eatExportStar(...arguments) || !(!this.isContextual("type") || this.lookahead().type !== bn$1.star) && (e21.exportKind = "type", this.next(), this.next(), true);
    }
    maybeParseExportNamespaceSpecifier(e21) {
      const t2 = this.state.start, s2 = super.maybeParseExportNamespaceSpecifier(e21);
      return s2 && e21.exportKind === "type" && this.unexpected(t2), s2;
    }
    parseClassId(e21, t2, s2) {
      super.parseClassId(e21, t2, s2), this.isRelational("<") && (e21.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(e21, t2, s2) {
      const r2 = this.state.start;
      if (this.isContextual("declare")) {
        if (this.parseClassMemberFromModifier(e21, t2))
          return;
        t2.declare = true;
      }
      super.parseClassMember(e21, t2, s2), t2.declare && (t2.type !== "ClassProperty" && t2.type !== "ClassPrivateProperty" && t2.type !== "PropertyDefinition" ? this.raise(r2, Lo$1.DeclareClassElement) : t2.value && this.raise(t2.value.start, Lo$1.DeclareClassFieldInitializer));
    }
    isIterator(e21) {
      return e21 === "iterator" || e21 === "asyncIterator";
    }
    readIterator() {
      const e21 = super.readWord1(), t2 = "@@" + e21;
      this.isIterator(e21) && this.state.inType || this.raise(this.state.pos, Rn$1.InvalidIdentifier, t2), this.finishToken(bn$1.name, t2);
    }
    getTokenFromCode(e21) {
      const t2 = this.input.charCodeAt(this.state.pos + 1);
      return e21 === 123 && t2 === 124 ? this.finishOp(bn$1.braceBarL, 2) : !this.state.inType || e21 !== 62 && e21 !== 60 ? this.state.inType && e21 === 63 ? t2 === 46 ? this.finishOp(bn$1.questionDot, 2) : this.finishOp(bn$1.question, 1) : function(e22, t3) {
        return e22 === 64 && t3 === 64;
      }(e21, t2) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(e21) : this.finishOp(bn$1.relational, 1);
    }
    isAssignable(e21, t2) {
      return e21.type === "TypeCastExpression" ? this.isAssignable(e21.expression, t2) : super.isAssignable(e21, t2);
    }
    toAssignable(e21, t2 = false) {
      return e21.type === "TypeCastExpression" ? super.toAssignable(this.typeCastToParameter(e21), t2) : super.toAssignable(e21, t2);
    }
    toAssignableList(e21, t2, s2) {
      for (let t3 = 0; t3 < e21.length; t3++) {
        const s3 = e21[t3];
        (s3 == null ? void 0 : s3.type) === "TypeCastExpression" && (e21[t3] = this.typeCastToParameter(s3));
      }
      return super.toAssignableList(e21, t2, s2);
    }
    toReferencedList(e21, t2) {
      for (let r2 = 0; r2 < e21.length; r2++) {
        var s2;
        const i2 = e21[r2];
        !i2 || i2.type !== "TypeCastExpression" || (s2 = i2.extra) != null && s2.parenthesized || !(e21.length > 1) && t2 || this.raise(i2.typeAnnotation.start, Lo$1.TypeCastInPattern);
      }
      return e21;
    }
    parseArrayLike(e21, t2, s2, r2) {
      const i2 = super.parseArrayLike(e21, t2, s2, r2);
      return t2 && !this.state.maybeInArrowParameters && this.toReferencedList(i2.elements), i2;
    }
    checkLVal(e21, ...t2) {
      if (e21.type !== "TypeCastExpression")
        return super.checkLVal(e21, ...t2);
    }
    parseClassProperty(e21) {
      return this.match(bn$1.colon) && (e21.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(e21);
    }
    parseClassPrivateProperty(e21) {
      return this.match(bn$1.colon) && (e21.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(e21);
    }
    isClassMethod() {
      return this.isRelational("<") || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(bn$1.colon) || super.isClassProperty();
    }
    isNonstaticConstructor(e21) {
      return !this.match(bn$1.colon) && super.isNonstaticConstructor(e21);
    }
    pushClassMethod(e21, t2, s2, r2, i2, a2) {
      if (t2.variance && this.unexpected(t2.variance.start), delete t2.variance, this.isRelational("<") && (t2.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(e21, t2, s2, r2, i2, a2), t2.params && i2) {
        const e22 = t2.params;
        e22.length > 0 && this.isThisParam(e22[0]) && this.raise(t2.start, Lo$1.ThisParamBannedInConstructor);
      } else if (t2.type === "MethodDefinition" && i2 && t2.value.params) {
        const e22 = t2.value.params;
        e22.length > 0 && this.isThisParam(e22[0]) && this.raise(t2.start, Lo$1.ThisParamBannedInConstructor);
      }
    }
    pushClassPrivateMethod(e21, t2, s2, r2) {
      t2.variance && this.unexpected(t2.variance.start), delete t2.variance, this.isRelational("<") && (t2.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(e21, t2, s2, r2);
    }
    parseClassSuper(e21) {
      if (super.parseClassSuper(e21), e21.superClass && this.isRelational("<") && (e21.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual("implements")) {
        this.next();
        const t2 = e21.implements = [];
        do {
          const e22 = this.startNode();
          e22.id = this.flowParseRestrictedIdentifier(true), this.isRelational("<") ? e22.typeParameters = this.flowParseTypeParameterInstantiation() : e22.typeParameters = null, t2.push(this.finishNode(e22, "ClassImplements"));
        } while (this.eat(bn$1.comma));
      }
    }
    checkGetterSetterParams(e21) {
      super.checkGetterSetterParams(e21);
      const t2 = this.getObjectOrClassMethodParams(e21);
      if (t2.length > 0) {
        const s2 = t2[0];
        this.isThisParam(s2) && e21.kind === "get" ? this.raise(s2.start, Lo$1.GetterMayNotHaveThisParam) : this.isThisParam(s2) && this.raise(s2.start, Lo$1.SetterMayNotHaveThisParam);
      }
    }
    parsePropertyName(e21, t2) {
      const s2 = this.flowParseVariance(), r2 = super.parsePropertyName(e21, t2);
      return e21.variance = s2, r2;
    }
    parseObjPropValue(e21, t2, s2, r2, i2, a2, n2, o2) {
      let u2;
      e21.variance && this.unexpected(e21.variance.start), delete e21.variance, this.isRelational("<") && !n2 && (u2 = this.flowParseTypeParameterDeclaration(), this.match(bn$1.parenL) || this.unexpected()), super.parseObjPropValue(e21, t2, s2, r2, i2, a2, n2, o2), u2 && ((e21.value || e21).typeParameters = u2);
    }
    parseAssignableListItemTypes(e21) {
      return this.eat(bn$1.question) && (e21.type !== "Identifier" && this.raise(e21.start, Lo$1.PatternIsOptional), this.isThisParam(e21) && this.raise(e21.start, Lo$1.ThisParamMayNotBeOptional), e21.optional = true), this.match(bn$1.colon) ? e21.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(e21) && this.raise(e21.start, Lo$1.ThisParamAnnotationRequired), this.match(bn$1.eq) && this.isThisParam(e21) && this.raise(e21.start, Lo$1.ThisParamNoDefault), this.resetEndLocation(e21), e21;
    }
    parseMaybeDefault(e21, t2, s2) {
      const r2 = super.parseMaybeDefault(e21, t2, s2);
      return r2.type === "AssignmentPattern" && r2.typeAnnotation && r2.right.start < r2.typeAnnotation.start && this.raise(r2.typeAnnotation.start, Lo$1.TypeBeforeInitializer), r2;
    }
    shouldParseDefaultImport(e21) {
      return Oo$1(e21) ? Mo(this.state) : super.shouldParseDefaultImport(e21);
    }
    parseImportSpecifierLocal(e21, t2, s2, r2) {
      t2.local = Oo$1(e21) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier(), this.checkLVal(t2.local, r2, 9), e21.specifiers.push(this.finishNode(t2, s2));
    }
    maybeParseDefaultImportSpecifier(e21) {
      e21.importKind = "value";
      let t2 = null;
      if (this.match(bn$1._typeof) ? t2 = "typeof" : this.isContextual("type") && (t2 = "type"), t2) {
        const s2 = this.lookahead();
        t2 === "type" && s2.type === bn$1.star && this.unexpected(s2.start), (Mo(s2) || s2.type === bn$1.braceL || s2.type === bn$1.star) && (this.next(), e21.importKind = t2);
      }
      return super.maybeParseDefaultImportSpecifier(e21);
    }
    parseImportSpecifier(e21) {
      const t2 = this.startNode(), s2 = this.match(bn$1.string), r2 = this.parseModuleExportName();
      let i2 = null;
      r2.type === "Identifier" && (r2.name === "type" ? i2 = "type" : r2.name === "typeof" && (i2 = "typeof"));
      let a2 = false;
      if (this.isContextual("as") && !this.isLookaheadContextual("as")) {
        const e22 = this.parseIdentifier(true);
        i2 === null || this.match(bn$1.name) || this.state.type.keyword ? (t2.imported = r2, t2.importKind = null, t2.local = this.parseIdentifier()) : (t2.imported = e22, t2.importKind = i2, t2.local = Io$1(e22));
      } else {
        if (i2 !== null && (this.match(bn$1.name) || this.state.type.keyword))
          t2.imported = this.parseIdentifier(true), t2.importKind = i2;
        else {
          if (s2)
            throw this.raise(t2.start, Rn$1.ImportBindingIsString, r2.value);
          t2.imported = r2, t2.importKind = null;
        }
        this.eatContextual("as") ? t2.local = this.parseIdentifier() : (a2 = true, t2.local = Io$1(t2.imported));
      }
      const n2 = Oo$1(e21), o2 = Oo$1(t2);
      n2 && o2 && this.raise(t2.start, Lo$1.ImportTypeShorthandOnlyInPureImport), (n2 || o2) && this.checkReservedType(t2.local.name, t2.local.start, true), !a2 || n2 || o2 || this.checkReservedWord(t2.local.name, t2.start, true, true), this.checkLVal(t2.local, "import specifier", 9), e21.specifiers.push(this.finishNode(t2, "ImportSpecifier"));
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case bn$1._this:
          return this.parseIdentifier(true);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(e21, t2) {
      const s2 = e21.kind;
      s2 !== "get" && s2 !== "set" && this.isRelational("<") && (e21.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(e21, t2);
    }
    parseVarId(e21, t2) {
      super.parseVarId(e21, t2), this.match(bn$1.colon) && (e21.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e21.id));
    }
    parseAsyncArrowFromCallExpression(e21, t2) {
      if (this.match(bn$1.colon)) {
        const t3 = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = true, e21.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = t3;
      }
      return super.parseAsyncArrowFromCallExpression(e21, t2);
    }
    shouldParseAsyncArrow() {
      return this.match(bn$1.colon) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(e21, t2) {
      var s2;
      let r2, i2 = null;
      if (this.hasPlugin("jsx") && (this.match(bn$1.jsxTagStart) || this.isRelational("<"))) {
        if (i2 = this.state.clone(), r2 = this.tryParse(() => super.parseMaybeAssign(e21, t2), i2), !r2.error)
          return r2.node;
        const { context: s3 } = this.state, a3 = s3[s3.length - 1];
        a3 === $n$1.j_oTag ? s3.length -= 2 : a3 === $n$1.j_expr && (s3.length -= 1);
      }
      if ((s2 = r2) != null && s2.error || this.isRelational("<")) {
        var a2, n2;
        let s3;
        i2 = i2 || this.state.clone();
        const o2 = this.tryParse((r3) => {
          var i3;
          s3 = this.flowParseTypeParameterDeclaration();
          const a3 = this.forwardNoArrowParamsConversionAt(s3, () => {
            const r4 = super.parseMaybeAssign(e21, t2);
            return this.resetStartLocationFromNode(r4, s3), r4;
          });
          (i3 = a3.extra) != null && i3.parenthesized && r3();
          const n3 = this.maybeUnwrapTypeCastExpression(a3);
          return n3.type !== "ArrowFunctionExpression" && r3(), n3.typeParameters = s3, this.resetStartLocationFromNode(n3, s3), a3;
        }, i2);
        let u2 = null;
        if (o2.node && this.maybeUnwrapTypeCastExpression(o2.node).type === "ArrowFunctionExpression") {
          if (!o2.error && !o2.aborted)
            return o2.node.async && this.raise(s3.start, Lo$1.UnexpectedTypeParameterBeforeAsyncArrowFunction), o2.node;
          u2 = o2.node;
        }
        if ((a2 = r2) != null && a2.node)
          return this.state = r2.failState, r2.node;
        if (u2)
          return this.state = o2.failState, u2;
        if ((n2 = r2) != null && n2.thrown)
          throw r2.error;
        if (o2.thrown)
          throw o2.error;
        throw this.raise(s3.start, Lo$1.UnexpectedTokenAfterTypeParameter);
      }
      return super.parseMaybeAssign(e21, t2);
    }
    parseArrow(e21) {
      if (this.match(bn$1.colon)) {
        const t2 = this.tryParse(() => {
          const t3 = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          const s2 = this.startNode();
          return [s2.typeAnnotation, e21.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = t3, this.canInsertSemicolon() && this.unexpected(), this.match(bn$1.arrow) || this.unexpected(), s2;
        });
        if (t2.thrown)
          return null;
        t2.error && (this.state = t2.failState), e21.returnType = t2.node.typeAnnotation ? this.finishNode(t2.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(e21);
    }
    shouldParseArrow(e21) {
      return this.match(bn$1.colon) || super.shouldParseArrow(e21);
    }
    setArrowFunctionParameters(e21, t2) {
      this.state.noArrowParamsConversionAt.indexOf(e21.start) !== -1 ? e21.params = t2 : super.setArrowFunctionParameters(e21, t2);
    }
    checkParams(e21, t2, s2) {
      if (!s2 || this.state.noArrowParamsConversionAt.indexOf(e21.start) === -1) {
        for (let t3 = 0; t3 < e21.params.length; t3++)
          this.isThisParam(e21.params[t3]) && t3 > 0 && this.raise(e21.params[t3].start, Lo$1.ThisParamMustBeFirst);
        return super.checkParams(...arguments);
      }
    }
    parseParenAndDistinguishExpression(e21) {
      return super.parseParenAndDistinguishExpression(e21 && this.state.noArrowAt.indexOf(this.state.start) === -1);
    }
    parseSubscripts(e21, t2, s2, r2) {
      if (e21.type === "Identifier" && e21.name === "async" && this.state.noArrowAt.indexOf(t2) !== -1) {
        this.next();
        const r3 = this.startNodeAt(t2, s2);
        r3.callee = e21, r3.arguments = this.parseCallExpressionArguments(bn$1.parenR, false), e21 = this.finishNode(r3, "CallExpression");
      } else if (e21.type === "Identifier" && e21.name === "async" && this.isRelational("<")) {
        const i2 = this.state.clone(), a2 = this.tryParse((e22) => this.parseAsyncArrowWithTypeParameters(t2, s2) || e22(), i2);
        if (!a2.error && !a2.aborted)
          return a2.node;
        const n2 = this.tryParse(() => super.parseSubscripts(e21, t2, s2, r2), i2);
        if (n2.node && !n2.error)
          return n2.node;
        if (a2.node)
          return this.state = a2.failState, a2.node;
        if (n2.node)
          return this.state = n2.failState, n2.node;
        throw a2.error || n2.error;
      }
      return super.parseSubscripts(e21, t2, s2, r2);
    }
    parseSubscript(e21, t2, s2, r2, i2) {
      if (this.match(bn$1.questionDot) && this.isLookaheadToken_lt()) {
        if (i2.optionalChainMember = true, r2)
          return i2.stop = true, e21;
        this.next();
        const a2 = this.startNodeAt(t2, s2);
        return a2.callee = e21, a2.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(bn$1.parenL), a2.arguments = this.parseCallExpressionArguments(bn$1.parenR, false), a2.optional = true, this.finishCallExpression(a2, true);
      }
      if (!r2 && this.shouldParseTypes() && this.isRelational("<")) {
        const r3 = this.startNodeAt(t2, s2);
        r3.callee = e21;
        const a2 = this.tryParse(() => (r3.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(bn$1.parenL), r3.arguments = this.parseCallExpressionArguments(bn$1.parenR, false), i2.optionalChainMember && (r3.optional = false), this.finishCallExpression(r3, i2.optionalChainMember)));
        if (a2.node)
          return a2.error && (this.state = a2.failState), a2.node;
      }
      return super.parseSubscript(e21, t2, s2, r2, i2);
    }
    parseNewArguments(e21) {
      let t2 = null;
      this.shouldParseTypes() && this.isRelational("<") && (t2 = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), e21.typeArguments = t2, super.parseNewArguments(e21);
    }
    parseAsyncArrowWithTypeParameters(e21, t2) {
      const s2 = this.startNodeAt(e21, t2);
      if (this.parseFunctionParams(s2), this.parseArrow(s2))
        return this.parseArrowExpression(s2, void 0, true);
    }
    readToken_mult_modulo(e21) {
      const t2 = this.input.charCodeAt(this.state.pos + 1);
      if (e21 === 42 && t2 === 47 && this.state.hasFlowComment)
        return this.state.hasFlowComment = false, this.state.pos += 2, void this.nextToken();
      super.readToken_mult_modulo(e21);
    }
    readToken_pipe_amp(e21) {
      const t2 = this.input.charCodeAt(this.state.pos + 1);
      e21 !== 124 || t2 !== 125 ? super.readToken_pipe_amp(e21) : this.finishOp(bn$1.braceBarR, 2);
    }
    parseTopLevel(e21, t2) {
      const s2 = super.parseTopLevel(e21, t2);
      return this.state.hasFlowComment && this.raise(this.state.pos, Lo$1.UnterminatedFlowComment), s2;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment())
        return this.state.hasFlowComment && this.unexpected(null, Lo$1.NestedFlowComment), this.hasFlowCommentCompletion(), this.state.pos += this.skipFlowComment(), void (this.state.hasFlowComment = true);
      if (!this.state.hasFlowComment)
        return super.skipBlockComment();
      {
        const e21 = this.input.indexOf("*-/", this.state.pos += 2);
        if (e21 === -1)
          throw this.raise(this.state.pos - 2, Rn$1.UnterminatedComment);
        this.state.pos = e21 + 3;
      }
    }
    skipFlowComment() {
      const { pos: e21 } = this.state;
      let t2 = 2;
      for (; [32, 9].includes(this.input.charCodeAt(e21 + t2)); )
        t2++;
      const s2 = this.input.charCodeAt(t2 + e21), r2 = this.input.charCodeAt(t2 + e21 + 1);
      return s2 === 58 && r2 === 58 ? t2 + 2 : this.input.slice(t2 + e21, t2 + e21 + 12) === "flow-include" ? t2 + 12 : s2 === 58 && r2 !== 58 && t2;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1)
        throw this.raise(this.state.pos, Rn$1.UnterminatedComment);
    }
    flowEnumErrorBooleanMemberNotInitialized(e21, { enumName: t2, memberName: s2 }) {
      this.raise(e21, Lo$1.EnumBooleanMemberNotInitialized, s2, t2);
    }
    flowEnumErrorInvalidMemberName(e21, { enumName: t2, memberName: s2 }) {
      const r2 = s2[0].toUpperCase() + s2.slice(1);
      this.raise(e21, Lo$1.EnumInvalidMemberName, s2, r2, t2);
    }
    flowEnumErrorDuplicateMemberName(e21, { enumName: t2, memberName: s2 }) {
      this.raise(e21, Lo$1.EnumDuplicateMemberName, s2, t2);
    }
    flowEnumErrorInconsistentMemberValues(e21, { enumName: t2 }) {
      this.raise(e21, Lo$1.EnumInconsistentMemberValues, t2);
    }
    flowEnumErrorInvalidExplicitType(e21, { enumName: t2, suppliedType: s2 }) {
      return this.raise(e21, s2 === null ? Lo$1.EnumInvalidExplicitTypeUnknownSupplied : Lo$1.EnumInvalidExplicitType, t2, s2);
    }
    flowEnumErrorInvalidMemberInitializer(e21, { enumName: t2, explicitType: s2, memberName: r2 }) {
      let i2 = null;
      switch (s2) {
        case "boolean":
        case "number":
        case "string":
          i2 = Lo$1.EnumInvalidMemberInitializerPrimaryType;
          break;
        case "symbol":
          i2 = Lo$1.EnumInvalidMemberInitializerSymbolType;
          break;
        default:
          i2 = Lo$1.EnumInvalidMemberInitializerUnknownType;
      }
      return this.raise(e21, i2, t2, r2, s2);
    }
    flowEnumErrorNumberMemberNotInitialized(e21, { enumName: t2, memberName: s2 }) {
      this.raise(e21, Lo$1.EnumNumberMemberNotInitialized, t2, s2);
    }
    flowEnumErrorStringMemberInconsistentlyInitailized(e21, { enumName: t2 }) {
      this.raise(e21, Lo$1.EnumStringMemberInconsistentlyInitailized, t2);
    }
    flowEnumMemberInit() {
      const e21 = this.state.start, t2 = () => this.match(bn$1.comma) || this.match(bn$1.braceR);
      switch (this.state.type) {
        case bn$1.num: {
          const s2 = this.parseNumericLiteral(this.state.value);
          return t2() ? { type: "number", pos: s2.start, value: s2 } : { type: "invalid", pos: e21 };
        }
        case bn$1.string: {
          const s2 = this.parseStringLiteral(this.state.value);
          return t2() ? { type: "string", pos: s2.start, value: s2 } : { type: "invalid", pos: e21 };
        }
        case bn$1._true:
        case bn$1._false: {
          const s2 = this.parseBooleanLiteral(this.match(bn$1._true));
          return t2() ? { type: "boolean", pos: s2.start, value: s2 } : { type: "invalid", pos: e21 };
        }
        default:
          return { type: "invalid", pos: e21 };
      }
    }
    flowEnumMemberRaw() {
      const e21 = this.state.start;
      return {
        id: this.parseIdentifier(true),
        init: this.eat(bn$1.eq) ? this.flowEnumMemberInit() : { type: "none", pos: e21 }
      };
    }
    flowEnumCheckExplicitTypeMismatch(e21, t2, s2) {
      const { explicitType: r2 } = t2;
      r2 !== null && r2 !== s2 && this.flowEnumErrorInvalidMemberInitializer(e21, t2);
    }
    flowEnumMembers({ enumName: e21, explicitType: t2 }) {
      const s2 = new Set(), r2 = {
        booleanMembers: [],
        numberMembers: [],
        stringMembers: [],
        defaultedMembers: []
      };
      let i2 = false;
      for (; !this.match(bn$1.braceR); ) {
        if (this.eat(bn$1.ellipsis)) {
          i2 = true;
          break;
        }
        const a2 = this.startNode(), { id: n2, init: o2 } = this.flowEnumMemberRaw(), u2 = n2.name;
        if (u2 === "")
          continue;
        /^[a-z]/.test(u2) && this.flowEnumErrorInvalidMemberName(n2.start, {
          enumName: e21,
          memberName: u2
        }), s2.has(u2) && this.flowEnumErrorDuplicateMemberName(n2.start, {
          enumName: e21,
          memberName: u2
        }), s2.add(u2);
        const h2 = {
          enumName: e21,
          explicitType: t2,
          memberName: u2
        };
        switch (a2.id = n2, o2.type) {
          case "boolean":
            this.flowEnumCheckExplicitTypeMismatch(o2.pos, h2, "boolean"), a2.init = o2.value, r2.booleanMembers.push(this.finishNode(a2, "EnumBooleanMember"));
            break;
          case "number":
            this.flowEnumCheckExplicitTypeMismatch(o2.pos, h2, "number"), a2.init = o2.value, r2.numberMembers.push(this.finishNode(a2, "EnumNumberMember"));
            break;
          case "string":
            this.flowEnumCheckExplicitTypeMismatch(o2.pos, h2, "string"), a2.init = o2.value, r2.stringMembers.push(this.finishNode(a2, "EnumStringMember"));
            break;
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(o2.pos, h2);
          case "none":
            switch (t2) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(o2.pos, h2);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(o2.pos, h2);
                break;
              default:
                r2.defaultedMembers.push(this.finishNode(a2, "EnumDefaultedMember"));
            }
        }
        this.match(bn$1.braceR) || this.expect(bn$1.comma);
      }
      return { members: r2, hasUnknownMembers: i2 };
    }
    flowEnumStringMembers(e21, t2, { enumName: s2 }) {
      if (e21.length === 0)
        return t2;
      if (t2.length === 0)
        return e21;
      if (t2.length > e21.length) {
        for (const t3 of e21)
          this.flowEnumErrorStringMemberInconsistentlyInitailized(t3.start, { enumName: s2 });
        return t2;
      }
      for (const e22 of t2)
        this.flowEnumErrorStringMemberInconsistentlyInitailized(e22.start, { enumName: s2 });
      return e21;
    }
    flowEnumParseExplicitType({ enumName: e21 }) {
      if (this.eatContextual("of")) {
        if (!this.match(bn$1.name))
          throw this.flowEnumErrorInvalidExplicitType(this.state.start, { enumName: e21, suppliedType: null });
        const { value: t2 } = this.state;
        return this.next(), t2 !== "boolean" && t2 !== "number" && t2 !== "string" && t2 !== "symbol" && this.flowEnumErrorInvalidExplicitType(this.state.start, { enumName: e21, suppliedType: t2 }), t2;
      }
      return null;
    }
    flowEnumBody(e21, { enumName: t2, nameLoc: s2 }) {
      const r2 = this.flowEnumParseExplicitType({ enumName: t2 });
      this.expect(bn$1.braceL);
      const { members: i2, hasUnknownMembers: a2 } = this.flowEnumMembers({ enumName: t2, explicitType: r2 });
      switch (e21.hasUnknownMembers = a2, r2) {
        case "boolean":
          return e21.explicitType = true, e21.members = i2.booleanMembers, this.expect(bn$1.braceR), this.finishNode(e21, "EnumBooleanBody");
        case "number":
          return e21.explicitType = true, e21.members = i2.numberMembers, this.expect(bn$1.braceR), this.finishNode(e21, "EnumNumberBody");
        case "string":
          return e21.explicitType = true, e21.members = this.flowEnumStringMembers(i2.stringMembers, i2.defaultedMembers, { enumName: t2 }), this.expect(bn$1.braceR), this.finishNode(e21, "EnumStringBody");
        case "symbol":
          return e21.members = i2.defaultedMembers, this.expect(bn$1.braceR), this.finishNode(e21, "EnumSymbolBody");
        default: {
          const r3 = () => (e21.members = [], this.expect(bn$1.braceR), this.finishNode(e21, "EnumStringBody"));
          e21.explicitType = false;
          const a3 = i2.booleanMembers.length, n2 = i2.numberMembers.length, o2 = i2.stringMembers.length, u2 = i2.defaultedMembers.length;
          if (a3 || n2 || o2 || u2) {
            if (a3 || n2) {
              if (!n2 && !o2 && a3 >= u2) {
                for (const e22 of i2.defaultedMembers)
                  this.flowEnumErrorBooleanMemberNotInitialized(e22.start, {
                    enumName: t2,
                    memberName: e22.id.name
                  });
                return e21.members = i2.booleanMembers, this.expect(bn$1.braceR), this.finishNode(e21, "EnumBooleanBody");
              }
              if (!a3 && !o2 && n2 >= u2) {
                for (const e22 of i2.defaultedMembers)
                  this.flowEnumErrorNumberMemberNotInitialized(e22.start, {
                    enumName: t2,
                    memberName: e22.id.name
                  });
                return e21.members = i2.numberMembers, this.expect(bn$1.braceR), this.finishNode(e21, "EnumNumberBody");
              }
              return this.flowEnumErrorInconsistentMemberValues(s2, { enumName: t2 }), r3();
            }
            return e21.members = this.flowEnumStringMembers(i2.stringMembers, i2.defaultedMembers, { enumName: t2 }), this.expect(bn$1.braceR), this.finishNode(e21, "EnumStringBody");
          }
          return r3();
        }
      }
    }
    flowParseEnumDeclaration(e21) {
      const t2 = this.parseIdentifier();
      return e21.id = t2, e21.body = this.flowEnumBody(this.startNode(), {
        enumName: t2.name,
        nameLoc: t2.start
      }), this.finishNode(e21, "EnumDeclaration");
    }
    isLookaheadToken_lt() {
      const e21 = this.nextTokenStart();
      if (this.input.charCodeAt(e21) === 60) {
        const t2 = this.input.charCodeAt(e21 + 1);
        return t2 !== 60 && t2 !== 61;
      }
      return false;
    }
    maybeUnwrapTypeCastExpression(e21) {
      return e21.type === "TypeCastExpression" ? e21.expression : e21;
    }
  },
  typescript: (e20) => class extends e20 {
    getScopeHandler() {
      return Wo;
    }
    tsIsIdentifier() {
      return this.match(bn$1.name);
    }
    tsTokenCanFollowModifier() {
      return (this.match(bn$1.bracketL) || this.match(bn$1.braceL) || this.match(bn$1.star) || this.match(bn$1.ellipsis) || this.match(bn$1.privateName) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
    }
    tsNextTokenCanFollowModifier() {
      return this.next(), this.tsTokenCanFollowModifier();
    }
    tsParseModifier(e21, t2) {
      if (!this.match(bn$1.name))
        return;
      const s2 = this.state.value;
      if (e21.indexOf(s2) !== -1) {
        if (t2 && this.tsIsStartOfStaticBlocks())
          return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
          return s2;
      }
    }
    tsParseModifiers(e21, t2, s2, r2, i2) {
      const a2 = (t3, s3, r3, i3) => {
        s3 === r3 && e21[i3] && this.raise(t3, Xo.InvalidModifiersOrder, r3, i3);
      }, n2 = (t3, s3, r3, i3) => {
        (e21[r3] && s3 === i3 || e21[i3] && s3 === r3) && this.raise(t3, Xo.IncompatibleModifiers, r3, i3);
      };
      for (; ; ) {
        const o2 = this.state.start, u2 = this.tsParseModifier(t2.concat(s2 != null ? s2 : []), i2);
        if (!u2)
          break;
        Jo(u2) ? e21.accessibility ? this.raise(o2, Xo.DuplicateAccessibilityModifier) : (a2(o2, u2, u2, "override"), a2(o2, u2, u2, "static"), a2(o2, u2, u2, "readonly"), e21.accessibility = u2) : (Object.hasOwnProperty.call(e21, u2) ? this.raise(o2, Xo.DuplicateModifier, u2) : (a2(o2, u2, "static", "readonly"), a2(o2, u2, "static", "override"), a2(o2, u2, "override", "readonly"), a2(o2, u2, "abstract", "override"), n2(o2, u2, "declare", "override"), n2(o2, u2, "static", "abstract")), e21[u2] = true), s2 != null && s2.includes(u2) && this.raise(o2, r2, u2);
      }
    }
    tsIsListTerminator(e21) {
      switch (e21) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(bn$1.braceR);
        case "HeritageClauseElement":
          return this.match(bn$1.braceL);
        case "TupleElementTypes":
          return this.match(bn$1.bracketR);
        case "TypeParametersOrArguments":
          return this.isRelational(">");
      }
      throw new Error("Unreachable");
    }
    tsParseList(e21, t2) {
      const s2 = [];
      for (; !this.tsIsListTerminator(e21); )
        s2.push(t2());
      return s2;
    }
    tsParseDelimitedList(e21, t2) {
      return Go(this.tsParseDelimitedListWorker(e21, t2, true));
    }
    tsParseDelimitedListWorker(e21, t2, s2) {
      const r2 = [];
      for (; !this.tsIsListTerminator(e21); ) {
        const i2 = t2();
        if (i2 == null)
          return;
        if (r2.push(i2), !this.eat(bn$1.comma)) {
          if (this.tsIsListTerminator(e21))
            break;
          return void (s2 && this.expect(bn$1.comma));
        }
      }
      return r2;
    }
    tsParseBracketedList(e21, t2, s2, r2) {
      r2 || (s2 ? this.expect(bn$1.bracketL) : this.expectRelational("<"));
      const i2 = this.tsParseDelimitedList(e21, t2);
      return s2 ? this.expect(bn$1.bracketR) : this.expectRelational(">"), i2;
    }
    tsParseImportType() {
      const e21 = this.startNode();
      return this.expect(bn$1._import), this.expect(bn$1.parenL), this.match(bn$1.string) || this.raise(this.state.start, Xo.UnsupportedImportTypeArgument), e21.argument = this.parseExprAtom(), this.expect(bn$1.parenR), this.eat(bn$1.dot) && (e21.qualifier = this.tsParseEntityName(true)), this.isRelational("<") && (e21.typeParameters = this.tsParseTypeArguments()), this.finishNode(e21, "TSImportType");
    }
    tsParseEntityName(e21) {
      let t2 = this.parseIdentifier();
      for (; this.eat(bn$1.dot); ) {
        const s2 = this.startNodeAtNode(t2);
        s2.left = t2, s2.right = this.parseIdentifier(e21), t2 = this.finishNode(s2, "TSQualifiedName");
      }
      return t2;
    }
    tsParseTypeReference() {
      const e21 = this.startNode();
      return e21.typeName = this.tsParseEntityName(false), !this.hasPrecedingLineBreak() && this.isRelational("<") && (e21.typeParameters = this.tsParseTypeArguments()), this.finishNode(e21, "TSTypeReference");
    }
    tsParseThisTypePredicate(e21) {
      this.next();
      const t2 = this.startNodeAtNode(e21);
      return t2.parameterName = e21, t2.typeAnnotation = this.tsParseTypeAnnotation(false), t2.asserts = false, this.finishNode(t2, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      const e21 = this.startNode();
      return this.next(), this.finishNode(e21, "TSThisType");
    }
    tsParseTypeQuery() {
      const e21 = this.startNode();
      return this.expect(bn$1._typeof), this.match(bn$1._import) ? e21.exprName = this.tsParseImportType() : e21.exprName = this.tsParseEntityName(true), this.finishNode(e21, "TSTypeQuery");
    }
    tsParseTypeParameter() {
      const e21 = this.startNode();
      return e21.name = this.tsParseTypeParameterName(), e21.constraint = this.tsEatThenParseType(bn$1._extends), e21.default = this.tsEatThenParseType(bn$1.eq), this.finishNode(e21, "TSTypeParameter");
    }
    tsTryParseTypeParameters() {
      if (this.isRelational("<"))
        return this.tsParseTypeParameters();
    }
    tsParseTypeParameters() {
      const e21 = this.startNode();
      return this.isRelational("<") || this.match(bn$1.jsxTagStart) ? this.next() : this.unexpected(), e21.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), false, true), e21.params.length === 0 && this.raise(e21.start, Xo.EmptyTypeParameters), this.finishNode(e21, "TSTypeParameterDeclaration");
    }
    tsTryNextParseConstantContext() {
      return this.lookahead().type === bn$1._const ? (this.next(), this.tsParseTypeReference()) : null;
    }
    tsFillSignature(e21, t2) {
      const s2 = e21 === bn$1.arrow;
      t2.typeParameters = this.tsTryParseTypeParameters(), this.expect(bn$1.parenL), t2.parameters = this.tsParseBindingListForSignature(), (s2 || this.match(e21)) && (t2.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(e21));
    }
    tsParseBindingListForSignature() {
      return this.parseBindingList(bn$1.parenR, 41).map((e21) => (e21.type !== "Identifier" && e21.type !== "RestElement" && e21.type !== "ObjectPattern" && e21.type !== "ArrayPattern" && this.raise(e21.start, Xo.UnsupportedSignatureParameterKind, e21.type), e21));
    }
    tsParseTypeMemberSemicolon() {
      this.eat(bn$1.comma) || this.isLineTerminator() || this.expect(bn$1.semi);
    }
    tsParseSignatureMember(e21, t2) {
      return this.tsFillSignature(bn$1.colon, t2), this.tsParseTypeMemberSemicolon(), this.finishNode(t2, e21);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), this.eat(bn$1.name) && this.match(bn$1.colon);
    }
    tsTryParseIndexSignature(e21) {
      if (!this.match(bn$1.bracketL) || !this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))
        return;
      this.expect(bn$1.bracketL);
      const t2 = this.parseIdentifier();
      t2.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(t2), this.expect(bn$1.bracketR), e21.parameters = [t2];
      const s2 = this.tsTryParseTypeAnnotation();
      return s2 && (e21.typeAnnotation = s2), this.tsParseTypeMemberSemicolon(), this.finishNode(e21, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(e21, t2) {
      this.eat(bn$1.question) && (e21.optional = true);
      const s2 = e21;
      if (this.match(bn$1.parenL) || this.isRelational("<")) {
        t2 && this.raise(e21.start, Xo.ReadonlyForMethodSignature);
        const r2 = s2;
        if (r2.kind && this.isRelational("<") && this.raise(this.state.pos, Xo.AccesorCannotHaveTypeParameters), this.tsFillSignature(bn$1.colon, r2), this.tsParseTypeMemberSemicolon(), r2.kind === "get")
          r2.parameters.length > 0 && (this.raise(this.state.pos, Rn$1.BadGetterArity), this.isThisParam(r2.parameters[0]) && this.raise(this.state.pos, Xo.AccesorCannotDeclareThisParameter));
        else if (r2.kind === "set") {
          if (r2.parameters.length !== 1)
            this.raise(this.state.pos, Rn$1.BadSetterArity);
          else {
            const e22 = r2.parameters[0];
            this.isThisParam(e22) && this.raise(this.state.pos, Xo.AccesorCannotDeclareThisParameter), e22.type === "Identifier" && e22.optional && this.raise(this.state.pos, Xo.SetAccesorCannotHaveOptionalParameter), e22.type === "RestElement" && this.raise(this.state.pos, Xo.SetAccesorCannotHaveRestParameter);
          }
          r2.typeAnnotation && this.raise(r2.typeAnnotation.start, Xo.SetAccesorCannotHaveReturnType);
        } else
          r2.kind = "method";
        return this.finishNode(r2, "TSMethodSignature");
      }
      {
        const e22 = s2;
        t2 && (e22.readonly = true);
        const r2 = this.tsTryParseTypeAnnotation();
        return r2 && (e22.typeAnnotation = r2), this.tsParseTypeMemberSemicolon(), this.finishNode(e22, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      const e21 = this.startNode();
      if (this.match(bn$1.parenL) || this.isRelational("<"))
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", e21);
      if (this.match(bn$1._new)) {
        const t3 = this.startNode();
        return this.next(), this.match(bn$1.parenL) || this.isRelational("<") ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", e21) : (e21.key = this.createIdentifier(t3, "new"), this.tsParsePropertyOrMethodSignature(e21, false));
      }
      this.tsParseModifiers(e21, ["readonly"], [
        "declare",
        "abstract",
        "private",
        "protected",
        "public",
        "static",
        "override"
      ], Xo.InvalidModifierOnTypeMember);
      const t2 = this.tsTryParseIndexSignature(e21);
      return t2 || (this.parsePropertyName(e21, false), e21.computed || e21.key.type !== "Identifier" || e21.key.name !== "get" && e21.key.name !== "set" || !this.tsTokenCanFollowModifier() || (e21.kind = e21.key.name, this.parsePropertyName(e21, false)), this.tsParsePropertyOrMethodSignature(e21, !!e21.readonly));
    }
    tsParseTypeLiteral() {
      const e21 = this.startNode();
      return e21.members = this.tsParseObjectTypeMembers(), this.finishNode(e21, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(bn$1.braceL);
      const e21 = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(bn$1.braceR), e21;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(bn$1.plusMin) ? this.isContextual("readonly") : (this.isContextual("readonly") && this.next(), !!this.match(bn$1.bracketL) && (this.next(), !!this.tsIsIdentifier() && (this.next(), this.match(bn$1._in))));
    }
    tsParseMappedTypeParameter() {
      const e21 = this.startNode();
      return e21.name = this.tsParseTypeParameterName(), e21.constraint = this.tsExpectThenParseType(bn$1._in), this.finishNode(e21, "TSTypeParameter");
    }
    tsParseMappedType() {
      const e21 = this.startNode();
      return this.expect(bn$1.braceL), this.match(bn$1.plusMin) ? (e21.readonly = this.state.value, this.next(), this.expectContextual("readonly")) : this.eatContextual("readonly") && (e21.readonly = true), this.expect(bn$1.bracketL), e21.typeParameter = this.tsParseMappedTypeParameter(), e21.nameType = this.eatContextual("as") ? this.tsParseType() : null, this.expect(bn$1.bracketR), this.match(bn$1.plusMin) ? (e21.optional = this.state.value, this.next(), this.expect(bn$1.question)) : this.eat(bn$1.question) && (e21.optional = true), e21.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(bn$1.braceR), this.finishNode(e21, "TSMappedType");
    }
    tsParseTupleType() {
      const e21 = this.startNode();
      e21.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
      let t2 = false, s2 = null;
      return e21.elementTypes.forEach((e22) => {
        var r2;
        let { type: i2 } = e22;
        !t2 || i2 === "TSRestType" || i2 === "TSOptionalType" || i2 === "TSNamedTupleMember" && e22.optional || this.raise(e22.start, Xo.OptionalTypeBeforeRequired), t2 = t2 || i2 === "TSNamedTupleMember" && e22.optional || i2 === "TSOptionalType", i2 === "TSRestType" && (i2 = (e22 = e22.typeAnnotation).type);
        const a2 = i2 === "TSNamedTupleMember";
        s2 = (r2 = s2) != null ? r2 : a2, s2 !== a2 && this.raise(e22.start, Xo.MixedLabeledAndUnlabeledElements);
      }), this.finishNode(e21, "TSTupleType");
    }
    tsParseTupleElementType() {
      const { start: e21, startLoc: t2 } = this.state, s2 = this.eat(bn$1.ellipsis);
      let r2 = this.tsParseType();
      const i2 = this.eat(bn$1.question);
      if (this.eat(bn$1.colon)) {
        const e22 = this.startNodeAtNode(r2);
        e22.optional = i2, r2.type !== "TSTypeReference" || r2.typeParameters || r2.typeName.type !== "Identifier" ? (this.raise(r2.start, Xo.InvalidTupleMemberLabel), e22.label = r2) : e22.label = r2.typeName, e22.elementType = this.tsParseType(), r2 = this.finishNode(e22, "TSNamedTupleMember");
      } else if (i2) {
        const e22 = this.startNodeAtNode(r2);
        e22.typeAnnotation = r2, r2 = this.finishNode(e22, "TSOptionalType");
      }
      if (s2) {
        const s3 = this.startNodeAt(e21, t2);
        s3.typeAnnotation = r2, r2 = this.finishNode(s3, "TSRestType");
      }
      return r2;
    }
    tsParseParenthesizedType() {
      const e21 = this.startNode();
      return this.expect(bn$1.parenL), e21.typeAnnotation = this.tsParseType(), this.expect(bn$1.parenR), this.finishNode(e21, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(e21, t2) {
      const s2 = this.startNode();
      return e21 === "TSConstructorType" && (s2.abstract = !!t2, t2 && this.next(), this.next()), this.tsFillSignature(bn$1.arrow, s2), this.finishNode(s2, e21);
    }
    tsParseLiteralTypeNode() {
      const e21 = this.startNode();
      return e21.literal = (() => {
        switch (this.state.type) {
          case bn$1.num:
          case bn$1.bigint:
          case bn$1.string:
          case bn$1._true:
          case bn$1._false:
            return this.parseExprAtom();
          default:
            throw this.unexpected();
        }
      })(), this.finishNode(e21, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      const e21 = this.startNode();
      return e21.literal = this.parseTemplate(false), this.finishNode(e21, "TSLiteralType");
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      const e21 = this.tsParseThisTypeNode();
      return this.isContextual("is") && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e21) : e21;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case bn$1.name:
        case bn$1._void:
        case bn$1._null: {
          const e21 = this.match(bn$1._void) ? "TSVoidKeyword" : this.match(bn$1._null) ? "TSNullKeyword" : function(e22) {
            switch (e22) {
              case "any":
                return "TSAnyKeyword";
              case "boolean":
                return "TSBooleanKeyword";
              case "bigint":
                return "TSBigIntKeyword";
              case "never":
                return "TSNeverKeyword";
              case "number":
                return "TSNumberKeyword";
              case "object":
                return "TSObjectKeyword";
              case "string":
                return "TSStringKeyword";
              case "symbol":
                return "TSSymbolKeyword";
              case "undefined":
                return "TSUndefinedKeyword";
              case "unknown":
                return "TSUnknownKeyword";
              default:
                return;
            }
          }(this.state.value);
          if (e21 !== void 0 && this.lookaheadCharCode() !== 46) {
            const t2 = this.startNode();
            return this.next(), this.finishNode(t2, e21);
          }
          return this.tsParseTypeReference();
        }
        case bn$1.string:
        case bn$1.num:
        case bn$1.bigint:
        case bn$1._true:
        case bn$1._false:
          return this.tsParseLiteralTypeNode();
        case bn$1.plusMin:
          if (this.state.value === "-") {
            const e21 = this.startNode(), t2 = this.lookahead();
            if (t2.type !== bn$1.num && t2.type !== bn$1.bigint)
              throw this.unexpected();
            return e21.literal = this.parseMaybeUnary(), this.finishNode(e21, "TSLiteralType");
          }
          break;
        case bn$1._this:
          return this.tsParseThisTypeOrThisTypePredicate();
        case bn$1._typeof:
          return this.tsParseTypeQuery();
        case bn$1._import:
          return this.tsParseImportType();
        case bn$1.braceL:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case bn$1.bracketL:
          return this.tsParseTupleType();
        case bn$1.parenL:
          return this.tsParseParenthesizedType();
        case bn$1.backQuote:
          return this.tsParseTemplateLiteralType();
      }
      throw this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let e21 = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(bn$1.bracketL); )
        if (this.match(bn$1.bracketR)) {
          const t2 = this.startNodeAtNode(e21);
          t2.elementType = e21, this.expect(bn$1.bracketR), e21 = this.finishNode(t2, "TSArrayType");
        } else {
          const t2 = this.startNodeAtNode(e21);
          t2.objectType = e21, t2.indexType = this.tsParseType(), this.expect(bn$1.bracketR), e21 = this.finishNode(t2, "TSIndexedAccessType");
        }
      return e21;
    }
    tsParseTypeOperator(e21) {
      const t2 = this.startNode();
      return this.expectContextual(e21), t2.operator = e21, t2.typeAnnotation = this.tsParseTypeOperatorOrHigher(), e21 === "readonly" && this.tsCheckTypeAnnotationForReadOnly(t2), this.finishNode(t2, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(e21) {
      switch (e21.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(e21.start, Xo.UnexpectedReadonly);
      }
    }
    tsParseInferType() {
      const e21 = this.startNode();
      this.expectContextual("infer");
      const t2 = this.startNode();
      return t2.name = this.tsParseTypeParameterName(), e21.typeParameter = this.finishNode(t2, "TSTypeParameter"), this.finishNode(e21, "TSInferType");
    }
    tsParseTypeOperatorOrHigher() {
      const e21 = ["keyof", "unique", "readonly"].find((e22) => this.isContextual(e22));
      return e21 ? this.tsParseTypeOperator(e21) : this.isContextual("infer") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();
    }
    tsParseUnionOrIntersectionType(e21, t2, s2) {
      const r2 = this.startNode(), i2 = this.eat(s2), a2 = [];
      do {
        a2.push(t2());
      } while (this.eat(s2));
      return a2.length !== 1 || i2 ? (r2.types = a2, this.finishNode(r2, e21)) : a2[0];
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), bn$1.bitwiseAND);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), bn$1.bitwiseOR);
    }
    tsIsStartOfFunctionType() {
      return !!this.isRelational("<") || this.match(bn$1.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (this.match(bn$1.name) || this.match(bn$1._this))
        return this.next(), true;
      if (this.match(bn$1.braceL)) {
        let e21 = 1;
        for (this.next(); e21 > 0; )
          this.match(bn$1.braceL) ? ++e21 : this.match(bn$1.braceR) && --e21, this.next();
        return true;
      }
      if (this.match(bn$1.bracketL)) {
        let e21 = 1;
        for (this.next(); e21 > 0; )
          this.match(bn$1.bracketL) ? ++e21 : this.match(bn$1.bracketR) && --e21, this.next();
        return true;
      }
      return false;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      if (this.next(), this.match(bn$1.parenR) || this.match(bn$1.ellipsis))
        return true;
      if (this.tsSkipParameterStart()) {
        if (this.match(bn$1.colon) || this.match(bn$1.comma) || this.match(bn$1.question) || this.match(bn$1.eq))
          return true;
        if (this.match(bn$1.parenR) && (this.next(), this.match(bn$1.arrow)))
          return true;
      }
      return false;
    }
    tsParseTypeOrTypePredicateAnnotation(e21) {
      return this.tsInType(() => {
        const t2 = this.startNode();
        this.expect(e21);
        const s2 = this.startNode(), r2 = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (r2 && this.match(bn$1._this)) {
          let e22 = this.tsParseThisTypeOrThisTypePredicate();
          return e22.type === "TSThisType" ? (s2.parameterName = e22, s2.asserts = true, s2.typeAnnotation = null, e22 = this.finishNode(s2, "TSTypePredicate")) : (this.resetStartLocationFromNode(e22, s2), e22.asserts = true), t2.typeAnnotation = e22, this.finishNode(t2, "TSTypeAnnotation");
        }
        const i2 = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!i2)
          return r2 ? (s2.parameterName = this.parseIdentifier(), s2.asserts = r2, s2.typeAnnotation = null, t2.typeAnnotation = this.finishNode(s2, "TSTypePredicate"), this.finishNode(t2, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(false, t2);
        const a2 = this.tsParseTypeAnnotation(false);
        return s2.parameterName = i2, s2.typeAnnotation = a2, s2.asserts = r2, t2.typeAnnotation = this.finishNode(s2, "TSTypePredicate"), this.finishNode(t2, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      return this.match(bn$1.colon) ? this.tsParseTypeOrTypePredicateAnnotation(bn$1.colon) : void 0;
    }
    tsTryParseTypeAnnotation() {
      return this.match(bn$1.colon) ? this.tsParseTypeAnnotation() : void 0;
    }
    tsTryParseType() {
      return this.tsEatThenParseType(bn$1.colon);
    }
    tsParseTypePredicatePrefix() {
      const e21 = this.parseIdentifier();
      if (this.isContextual("is") && !this.hasPrecedingLineBreak())
        return this.next(), e21;
    }
    tsParseTypePredicateAsserts() {
      if (!this.match(bn$1.name) || this.state.value !== "asserts" || this.hasPrecedingLineBreak())
        return false;
      const e21 = this.state.containsEsc;
      return this.next(), !(!this.match(bn$1.name) && !this.match(bn$1._this)) && (e21 && this.raise(this.state.lastTokStart, Rn$1.InvalidEscapedReservedWord, "asserts"), true);
    }
    tsParseTypeAnnotation(e21 = true, t2 = this.startNode()) {
      return this.tsInType(() => {
        e21 && this.expect(bn$1.colon), t2.typeAnnotation = this.tsParseType();
      }), this.finishNode(t2, "TSTypeAnnotation");
    }
    tsParseType() {
      Ko(this.state.inType);
      const e21 = this.tsParseNonConditionalType();
      if (this.hasPrecedingLineBreak() || !this.eat(bn$1._extends))
        return e21;
      const t2 = this.startNodeAtNode(e21);
      return t2.checkType = e21, t2.extendsType = this.tsParseNonConditionalType(), this.expect(bn$1.question), t2.trueType = this.tsParseType(), this.expect(bn$1.colon), t2.falseType = this.tsParseType(), this.finishNode(t2, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual("abstract") && this.lookahead().type === bn$1._new;
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(bn$1._new) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", true) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      const e21 = this.startNode(), t2 = this.tsTryNextParseConstantContext();
      return e21.typeAnnotation = t2 || this.tsNextThenParseType(), this.expectRelational(">"), e21.expression = this.parseMaybeUnary(), this.finishNode(e21, "TSTypeAssertion");
    }
    tsParseHeritageClause(e21) {
      const t2 = this.state.start, s2 = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));
      return s2.length || this.raise(t2, Xo.EmptyHeritageClauseType, e21), s2;
    }
    tsParseExpressionWithTypeArguments() {
      const e21 = this.startNode();
      return e21.expression = this.tsParseEntityName(false), this.isRelational("<") && (e21.typeParameters = this.tsParseTypeArguments()), this.finishNode(e21, "TSExpressionWithTypeArguments");
    }
    tsParseInterfaceDeclaration(e21) {
      this.match(bn$1.name) ? (e21.id = this.parseIdentifier(), this.checkLVal(e21.id, "typescript interface declaration", 130)) : (e21.id = null, this.raise(this.state.start, Xo.MissingInterfaceName)), e21.typeParameters = this.tsTryParseTypeParameters(), this.eat(bn$1._extends) && (e21.extends = this.tsParseHeritageClause("extends"));
      const t2 = this.startNode();
      return t2.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), e21.body = this.finishNode(t2, "TSInterfaceBody"), this.finishNode(e21, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(e21) {
      return e21.id = this.parseIdentifier(), this.checkLVal(e21.id, "typescript type alias", 2), e21.typeParameters = this.tsTryParseTypeParameters(), e21.typeAnnotation = this.tsInType(() => {
        if (this.expect(bn$1.eq), this.isContextual("intrinsic") && this.lookahead().type !== bn$1.dot) {
          const e22 = this.startNode();
          return this.next(), this.finishNode(e22, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(e21, "TSTypeAliasDeclaration");
    }
    tsInNoContext(e21) {
      const t2 = this.state.context;
      this.state.context = [t2[0]];
      try {
        return e21();
      } finally {
        this.state.context = t2;
      }
    }
    tsInType(e21) {
      const t2 = this.state.inType;
      this.state.inType = true;
      try {
        return e21();
      } finally {
        this.state.inType = t2;
      }
    }
    tsEatThenParseType(e21) {
      return this.match(e21) ? this.tsNextThenParseType() : void 0;
    }
    tsExpectThenParseType(e21) {
      return this.tsDoThenParseType(() => this.expect(e21));
    }
    tsNextThenParseType() {
      return this.tsDoThenParseType(() => this.next());
    }
    tsDoThenParseType(e21) {
      return this.tsInType(() => (e21(), this.tsParseType()));
    }
    tsParseEnumMember() {
      const e21 = this.startNode();
      return e21.id = this.match(bn$1.string) ? this.parseExprAtom() : this.parseIdentifier(true), this.eat(bn$1.eq) && (e21.initializer = this.parseMaybeAssignAllowIn()), this.finishNode(e21, "TSEnumMember");
    }
    tsParseEnumDeclaration(e21, t2) {
      return t2 && (e21.const = true), e21.id = this.parseIdentifier(), this.checkLVal(e21.id, "typescript enum declaration", t2 ? 779 : 267), this.expect(bn$1.braceL), e21.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(bn$1.braceR), this.finishNode(e21, "TSEnumDeclaration");
    }
    tsParseModuleBlock() {
      const e21 = this.startNode();
      return this.scope.enter(0), this.expect(bn$1.braceL), this.parseBlockOrModuleBlockBody(e21.body = [], void 0, true, bn$1.braceR), this.scope.exit(), this.finishNode(e21, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(e21, t2 = false) {
      if (e21.id = this.parseIdentifier(), t2 || this.checkLVal(e21.id, "module or namespace declaration", 1024), this.eat(bn$1.dot)) {
        const t3 = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(t3, true), e21.body = t3;
      } else
        this.scope.enter(256), this.prodParam.enter(0), e21.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(e21, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(e21) {
      return this.isContextual("global") ? (e21.global = true, e21.id = this.parseIdentifier()) : this.match(bn$1.string) ? e21.id = this.parseExprAtom() : this.unexpected(), this.match(bn$1.braceL) ? (this.scope.enter(256), this.prodParam.enter(0), e21.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(e21, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(e21, t2) {
      e21.isExport = t2 || false, e21.id = this.parseIdentifier(), this.checkLVal(e21.id, "import equals declaration", 9), this.expect(bn$1.eq);
      const s2 = this.tsParseModuleReference();
      return e21.importKind === "type" && s2.type !== "TSExternalModuleReference" && this.raise(s2.start, Xo.ImportAliasHasImportType), e21.moduleReference = s2, this.semicolon(), this.finishNode(e21, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual("require") && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
    }
    tsParseExternalModuleReference() {
      const e21 = this.startNode();
      if (this.expectContextual("require"), this.expect(bn$1.parenL), !this.match(bn$1.string))
        throw this.unexpected();
      return e21.expression = this.parseExprAtom(), this.expect(bn$1.parenR), this.finishNode(e21, "TSExternalModuleReference");
    }
    tsLookAhead(e21) {
      const t2 = this.state.clone(), s2 = e21();
      return this.state = t2, s2;
    }
    tsTryParseAndCatch(e21) {
      const t2 = this.tryParse((t3) => e21() || t3());
      if (!t2.aborted && t2.node)
        return t2.error && (this.state = t2.failState), t2.node;
    }
    tsTryParse(e21) {
      const t2 = this.state.clone(), s2 = e21();
      return s2 !== void 0 && s2 !== false ? s2 : void (this.state = t2);
    }
    tsTryParseDeclare(e21) {
      if (this.isLineTerminator())
        return;
      let t2, s2 = this.state.type;
      return this.isContextual("let") && (s2 = bn$1._var, t2 = "let"), this.tsInAmbientContext(() => {
        switch (s2) {
          case bn$1._function:
            return e21.declare = true, this.parseFunctionStatement(e21, false, true);
          case bn$1._class:
            return e21.declare = true, this.parseClass(e21, true, false);
          case bn$1._const:
            if (this.match(bn$1._const) && this.isLookaheadContextual("enum"))
              return this.expect(bn$1._const), this.expectContextual("enum"), this.tsParseEnumDeclaration(e21, true);
          case bn$1._var:
            return t2 = t2 || this.state.value, this.parseVarStatement(e21, t2);
          case bn$1.name: {
            const t3 = this.state.value;
            return t3 === "global" ? this.tsParseAmbientExternalModuleDeclaration(e21) : this.tsParseDeclaration(e21, t3, true);
          }
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, true);
    }
    tsParseExpressionStatement(e21, t2) {
      switch (t2.name) {
        case "declare": {
          const t3 = this.tsTryParseDeclare(e21);
          if (t3)
            return t3.declare = true, t3;
          break;
        }
        case "global":
          if (this.match(bn$1.braceL)) {
            this.scope.enter(256), this.prodParam.enter(0);
            const s2 = e21;
            return s2.global = true, s2.id = t2, s2.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(s2, "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(e21, t2.name, false);
      }
    }
    tsParseDeclaration(e21, t2, s2) {
      switch (t2) {
        case "abstract":
          if (this.tsCheckLineTerminator(s2) && (this.match(bn$1._class) || this.match(bn$1.name)))
            return this.tsParseAbstractDeclaration(e21);
          break;
        case "enum":
          if (s2 || this.match(bn$1.name))
            return s2 && this.next(), this.tsParseEnumDeclaration(e21, false);
          break;
        case "interface":
          if (this.tsCheckLineTerminator(s2) && this.match(bn$1.name))
            return this.tsParseInterfaceDeclaration(e21);
          break;
        case "module":
          if (this.tsCheckLineTerminator(s2)) {
            if (this.match(bn$1.string))
              return this.tsParseAmbientExternalModuleDeclaration(e21);
            if (this.match(bn$1.name))
              return this.tsParseModuleOrNamespaceDeclaration(e21);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(s2) && this.match(bn$1.name))
            return this.tsParseModuleOrNamespaceDeclaration(e21);
          break;
        case "type":
          if (this.tsCheckLineTerminator(s2) && this.match(bn$1.name))
            return this.tsParseTypeAliasDeclaration(e21);
      }
    }
    tsCheckLineTerminator(e21) {
      return e21 ? !this.hasFollowingLineBreak() && (this.next(), true) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(e21, t2) {
      if (!this.isRelational("<"))
        return;
      const s2 = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = true;
      const r2 = this.tsTryParseAndCatch(() => {
        const s3 = this.startNodeAt(e21, t2);
        return s3.typeParameters = this.tsParseTypeParameters(), super.parseFunctionParams(s3), s3.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(bn$1.arrow), s3;
      });
      return this.state.maybeInArrowParameters = s2, r2 ? this.parseArrowExpression(r2, null, true) : void 0;
    }
    tsParseTypeArguments() {
      const e21 = this.startNode();
      return e21.params = this.tsInType(() => this.tsInNoContext(() => (this.expectRelational("<"), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), e21.params.length === 0 && this.raise(e21.start, Xo.EmptyTypeArguments), this.expectRelational(">"), this.finishNode(e21, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      if (this.match(bn$1.name))
        switch (this.state.value) {
          case "abstract":
          case "declare":
          case "enum":
          case "interface":
          case "module":
          case "namespace":
          case "type":
            return true;
        }
      return false;
    }
    isExportDefaultSpecifier() {
      return !this.tsIsDeclarationStart() && super.isExportDefaultSpecifier();
    }
    parseAssignableListItem(e21, t2) {
      const s2 = this.state.start, r2 = this.state.startLoc;
      let i2, a2 = false, n2 = false;
      if (e21 !== void 0) {
        const t3 = {};
        this.tsParseModifiers(t3, [
          "public",
          "private",
          "protected",
          "override",
          "readonly"
        ]), i2 = t3.accessibility, n2 = t3.override, a2 = t3.readonly, e21 === false && (i2 || a2 || n2) && this.raise(s2, Xo.UnexpectedParameterModifier);
      }
      const o2 = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(o2);
      const u2 = this.parseMaybeDefault(o2.start, o2.loc.start, o2);
      if (i2 || a2 || n2) {
        const e22 = this.startNodeAt(s2, r2);
        return t2.length && (e22.decorators = t2), i2 && (e22.accessibility = i2), a2 && (e22.readonly = a2), n2 && (e22.override = n2), u2.type !== "Identifier" && u2.type !== "AssignmentPattern" && this.raise(e22.start, Xo.UnsupportedParameterPropertyKind), e22.parameter = u2, this.finishNode(e22, "TSParameterProperty");
      }
      return t2.length && (o2.decorators = t2), u2;
    }
    parseFunctionBodyAndFinish(e21, t2, s2 = false) {
      this.match(bn$1.colon) && (e21.returnType = this.tsParseTypeOrTypePredicateAnnotation(bn$1.colon));
      const r2 = t2 === "FunctionDeclaration" ? "TSDeclareFunction" : t2 === "ClassMethod" ? "TSDeclareMethod" : void 0;
      r2 && !this.match(bn$1.braceL) && this.isLineTerminator() ? this.finishNode(e21, r2) : r2 === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(e21.start, Xo.DeclareFunctionHasImplementation), e21.declare) ? super.parseFunctionBodyAndFinish(e21, r2, s2) : super.parseFunctionBodyAndFinish(e21, t2, s2);
    }
    registerFunctionStatementId(e21) {
      !e21.body && e21.id ? this.checkLVal(e21.id, "function name", 1024) : super.registerFunctionStatementId(...arguments);
    }
    tsCheckForInvalidTypeCasts(e21) {
      e21.forEach((e22) => {
        (e22 == null ? void 0 : e22.type) === "TSTypeCastExpression" && this.raise(e22.typeAnnotation.start, Xo.UnexpectedTypeAnnotation);
      });
    }
    toReferencedList(e21, t2) {
      return this.tsCheckForInvalidTypeCasts(e21), e21;
    }
    parseArrayLike(...e21) {
      const t2 = super.parseArrayLike(...e21);
      return t2.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(t2.elements), t2;
    }
    parseSubscript(e21, t2, s2, r2, i2) {
      if (!this.hasPrecedingLineBreak() && this.match(bn$1.bang)) {
        this.state.exprAllowed = false, this.next();
        const r3 = this.startNodeAt(t2, s2);
        return r3.expression = e21, this.finishNode(r3, "TSNonNullExpression");
      }
      let a2 = false;
      if (this.match(bn$1.questionDot) && this.lookaheadCharCode() === 60) {
        if (r2)
          return i2.stop = true, e21;
        i2.optionalChainMember = a2 = true, this.next();
      }
      if (this.isRelational("<")) {
        let n2;
        const o2 = this.tsTryParseAndCatch(() => {
          if (!r2 && this.atPossibleAsyncArrow(e21)) {
            const e22 = this.tsTryParseGenericAsyncArrowFunction(t2, s2);
            if (e22)
              return e22;
          }
          const o3 = this.startNodeAt(t2, s2);
          o3.callee = e21;
          const u2 = this.tsParseTypeArguments();
          if (u2) {
            if (a2 && !this.match(bn$1.parenL) && (n2 = this.state.pos, this.unexpected()), !r2 && this.eat(bn$1.parenL))
              return o3.arguments = this.parseCallExpressionArguments(bn$1.parenR, false), this.tsCheckForInvalidTypeCasts(o3.arguments), o3.typeParameters = u2, i2.optionalChainMember && (o3.optional = a2), this.finishCallExpression(o3, i2.optionalChainMember);
            if (this.match(bn$1.backQuote)) {
              const r3 = this.parseTaggedTemplateExpression(e21, t2, s2, i2);
              return r3.typeParameters = u2, r3;
            }
          }
          this.unexpected();
        });
        if (n2 && this.unexpected(n2, bn$1.parenL), o2)
          return o2;
      }
      return super.parseSubscript(e21, t2, s2, r2, i2);
    }
    parseNewArguments(e21) {
      if (this.isRelational("<")) {
        const t2 = this.tsTryParseAndCatch(() => {
          const e22 = this.tsParseTypeArguments();
          return this.match(bn$1.parenL) || this.unexpected(), e22;
        });
        t2 && (e21.typeParameters = t2);
      }
      super.parseNewArguments(e21);
    }
    parseExprOp(e21, t2, s2, r2) {
      if (Go(bn$1._in.binop) > r2 && !this.hasPrecedingLineBreak() && this.isContextual("as")) {
        const i2 = this.startNodeAt(t2, s2);
        i2.expression = e21;
        const a2 = this.tsTryNextParseConstantContext();
        return i2.typeAnnotation = a2 || this.tsNextThenParseType(), this.finishNode(i2, "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(i2, t2, s2, r2);
      }
      return super.parseExprOp(e21, t2, s2, r2);
    }
    checkReservedWord(e21, t2, s2, r2) {
    }
    checkDuplicateExports() {
    }
    parseImport(e21) {
      if (e21.importKind = "value", this.match(bn$1.name) || this.match(bn$1.star) || this.match(bn$1.braceL)) {
        let t3 = this.lookahead();
        if (!this.isContextual("type") || t3.type === bn$1.comma || t3.type === bn$1.name && t3.value === "from" || t3.type === bn$1.eq || (e21.importKind = "type", this.next(), t3 = this.lookahead()), this.match(bn$1.name) && t3.type === bn$1.eq)
          return this.tsParseImportEqualsDeclaration(e21);
      }
      const t2 = super.parseImport(e21);
      return t2.importKind === "type" && t2.specifiers.length > 1 && t2.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(t2.start, Xo.TypeImportCannotSpecifyDefaultAndNamed), t2;
    }
    parseExport(e21) {
      if (this.match(bn$1._import))
        return this.next(), this.isContextual("type") && this.lookaheadCharCode() !== 61 ? (e21.importKind = "type", this.next()) : e21.importKind = "value", this.tsParseImportEqualsDeclaration(e21, true);
      if (this.eat(bn$1.eq)) {
        const t2 = e21;
        return t2.expression = this.parseExpression(), this.semicolon(), this.finishNode(t2, "TSExportAssignment");
      }
      if (this.eatContextual("as")) {
        const t2 = e21;
        return this.expectContextual("namespace"), t2.id = this.parseIdentifier(), this.semicolon(), this.finishNode(t2, "TSNamespaceExportDeclaration");
      }
      return this.isContextual("type") && this.lookahead().type === bn$1.braceL ? (this.next(), e21.exportKind = "type") : e21.exportKind = "value", super.parseExport(e21);
    }
    isAbstractClass() {
      return this.isContextual("abstract") && this.lookahead().type === bn$1._class;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        const e21 = this.startNode();
        return this.next(), e21.abstract = true, this.parseClass(e21, true, true), e21;
      }
      if (this.state.value === "interface") {
        const e21 = this.startNode();
        this.next();
        const t2 = this.tsParseInterfaceDeclaration(e21);
        if (t2)
          return t2;
      }
      return super.parseExportDefaultExpression();
    }
    parseStatementContent(e21, t2) {
      if (this.state.type === bn$1._const) {
        const e22 = this.lookahead();
        if (e22.type === bn$1.name && e22.value === "enum") {
          const e23 = this.startNode();
          return this.expect(bn$1._const), this.expectContextual("enum"), this.tsParseEnumDeclaration(e23, true);
        }
      }
      return super.parseStatementContent(e21, t2);
    }
    parseAccessModifier() {
      return this.tsParseModifier([
        "public",
        "protected",
        "private"
      ]);
    }
    tsHasSomeModifiers(e21, t2) {
      return t2.some((t3) => Jo(t3) ? e21.accessibility === t3 : !!e21[t3]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual("static") && this.lookaheadCharCode() === 123;
    }
    parseClassMember(e21, t2, s2) {
      const r2 = [
        "declare",
        "private",
        "public",
        "protected",
        "override",
        "abstract",
        "readonly",
        "static"
      ];
      this.tsParseModifiers(t2, r2, void 0, void 0, true);
      const i2 = () => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(t2, r2) && this.raise(this.state.pos, Xo.StaticBlockCannotHaveModifier), this.parseClassStaticBlock(e21, t2)) : this.parseClassMemberWithIsStatic(e21, t2, s2, !!t2.static);
      };
      t2.declare ? this.tsInAmbientContext(i2) : i2();
    }
    parseClassMemberWithIsStatic(e21, t2, s2, r2) {
      const i2 = this.tsTryParseIndexSignature(t2);
      if (i2)
        return e21.body.push(i2), t2.abstract && this.raise(t2.start, Xo.IndexSignatureHasAbstract), t2.accessibility && this.raise(t2.start, Xo.IndexSignatureHasAccessibility, t2.accessibility), t2.declare && this.raise(t2.start, Xo.IndexSignatureHasDeclare), void (t2.override && this.raise(t2.start, Xo.IndexSignatureHasOverride));
      !this.state.inAbstractClass && t2.abstract && this.raise(t2.start, Xo.NonAbstractClassHasAbstractMethod), t2.override && (s2.hadSuperClass || this.raise(t2.start, Xo.OverrideNotInSubClass)), super.parseClassMemberWithIsStatic(e21, t2, s2, r2);
    }
    parsePostMemberNameModifiers(e21) {
      this.eat(bn$1.question) && (e21.optional = true), e21.readonly && this.match(bn$1.parenL) && this.raise(e21.start, Xo.ClassMethodHasReadonly), e21.declare && this.match(bn$1.parenL) && this.raise(e21.start, Xo.ClassMethodHasDeclare);
    }
    parseExpressionStatement(e21, t2) {
      return (t2.type === "Identifier" ? this.tsParseExpressionStatement(e21, t2) : void 0) || super.parseExpressionStatement(e21, t2);
    }
    shouldParseExportDeclaration() {
      return !!this.tsIsDeclarationStart() || super.shouldParseExportDeclaration();
    }
    parseConditional(e21, t2, s2, r2) {
      if (!this.state.maybeInArrowParameters || !this.match(bn$1.question))
        return super.parseConditional(e21, t2, s2, r2);
      const i2 = this.tryParse(() => super.parseConditional(e21, t2, s2));
      return i2.node ? (i2.error && (this.state = i2.failState), i2.node) : (i2.error && super.setOptionalParametersError(r2, i2.error), e21);
    }
    parseParenItem(e21, t2, s2) {
      if (e21 = super.parseParenItem(e21, t2, s2), this.eat(bn$1.question) && (e21.optional = true, this.resetEndLocation(e21)), this.match(bn$1.colon)) {
        const r2 = this.startNodeAt(t2, s2);
        return r2.expression = e21, r2.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(r2, "TSTypeCastExpression");
      }
      return e21;
    }
    parseExportDeclaration(e21) {
      const t2 = this.state.start, s2 = this.state.startLoc, r2 = this.eatContextual("declare");
      if (r2 && (this.isContextual("declare") || !this.shouldParseExportDeclaration()))
        throw this.raise(this.state.start, Xo.ExpectedAmbientAfterExportDeclare);
      let i2;
      return this.match(bn$1.name) && (i2 = this.tsTryParseExportDeclaration()), i2 || (i2 = super.parseExportDeclaration(e21)), i2 && (i2.type === "TSInterfaceDeclaration" || i2.type === "TSTypeAliasDeclaration" || r2) && (e21.exportKind = "type"), i2 && r2 && (this.resetStartLocation(i2, t2, s2), i2.declare = true), i2;
    }
    parseClassId(e21, t2, s2) {
      if ((!t2 || s2) && this.isContextual("implements"))
        return;
      super.parseClassId(e21, t2, s2, e21.declare ? 1024 : 139);
      const r2 = this.tsTryParseTypeParameters();
      r2 && (e21.typeParameters = r2);
    }
    parseClassPropertyAnnotation(e21) {
      !e21.optional && this.eat(bn$1.bang) && (e21.definite = true);
      const t2 = this.tsTryParseTypeAnnotation();
      t2 && (e21.typeAnnotation = t2);
    }
    parseClassProperty(e21) {
      if (this.parseClassPropertyAnnotation(e21), this.state.isAmbientContext && this.match(bn$1.eq) && this.raise(this.state.start, Xo.DeclareClassFieldHasInitializer), e21.abstract && this.match(bn$1.eq)) {
        const { key: t2 } = e21;
        this.raise(this.state.start, Xo.AbstractPropertyHasInitializer, t2.type !== "Identifier" || e21.computed ? `[${this.input.slice(t2.start, t2.end)}]` : t2.name);
      }
      return super.parseClassProperty(e21);
    }
    parseClassPrivateProperty(e21) {
      return e21.abstract && this.raise(e21.start, Xo.PrivateElementHasAbstract), e21.accessibility && this.raise(e21.start, Xo.PrivateElementHasAccessibility, e21.accessibility), this.parseClassPropertyAnnotation(e21), super.parseClassPrivateProperty(e21);
    }
    pushClassMethod(e21, t2, s2, r2, i2, a2) {
      const n2 = this.tsTryParseTypeParameters();
      n2 && i2 && this.raise(n2.start, Xo.ConstructorHasTypeParameters), !t2.declare || t2.kind !== "get" && t2.kind !== "set" || this.raise(t2.start, Xo.DeclareAccessor, t2.kind), n2 && (t2.typeParameters = n2), super.pushClassMethod(e21, t2, s2, r2, i2, a2);
    }
    pushClassPrivateMethod(e21, t2, s2, r2) {
      const i2 = this.tsTryParseTypeParameters();
      i2 && (t2.typeParameters = i2), super.pushClassPrivateMethod(e21, t2, s2, r2);
    }
    parseClassSuper(e21) {
      super.parseClassSuper(e21), e21.superClass && this.isRelational("<") && (e21.superTypeParameters = this.tsParseTypeArguments()), this.eatContextual("implements") && (e21.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(e21, ...t2) {
      const s2 = this.tsTryParseTypeParameters();
      s2 && (e21.typeParameters = s2), super.parseObjPropValue(e21, ...t2);
    }
    parseFunctionParams(e21, t2) {
      const s2 = this.tsTryParseTypeParameters();
      s2 && (e21.typeParameters = s2), super.parseFunctionParams(e21, t2);
    }
    parseVarId(e21, t2) {
      super.parseVarId(e21, t2), e21.id.type === "Identifier" && this.eat(bn$1.bang) && (e21.definite = true);
      const s2 = this.tsTryParseTypeAnnotation();
      s2 && (e21.id.typeAnnotation = s2, this.resetEndLocation(e21.id));
    }
    parseAsyncArrowFromCallExpression(e21, t2) {
      return this.match(bn$1.colon) && (e21.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(e21, t2);
    }
    parseMaybeAssign(...e21) {
      var t2, s2, r2, i2, a2, n2, o2;
      let u2, h2, c2, p2;
      if (this.hasPlugin("jsx") && (this.match(bn$1.jsxTagStart) || this.isRelational("<"))) {
        if (u2 = this.state.clone(), h2 = this.tryParse(() => super.parseMaybeAssign(...e21), u2), !h2.error)
          return h2.node;
        const { context: t3 } = this.state;
        t3[t3.length - 1] === $n$1.j_oTag ? t3.length -= 2 : t3[t3.length - 1] === $n$1.j_expr && (t3.length -= 1);
      }
      if (!((t2 = h2) != null && t2.error || this.isRelational("<")))
        return super.parseMaybeAssign(...e21);
      u2 = u2 || this.state.clone();
      const l2 = this.tryParse((t3) => {
        var s3, r3;
        p2 = this.tsParseTypeParameters();
        const i3 = super.parseMaybeAssign(...e21);
        return (i3.type !== "ArrowFunctionExpression" || (s3 = i3.extra) != null && s3.parenthesized) && t3(), ((r3 = p2) == null ? void 0 : r3.params.length) !== 0 && this.resetStartLocationFromNode(i3, p2), i3.typeParameters = p2, i3;
      }, u2);
      if (!l2.error && !l2.aborted)
        return l2.node;
      if (!h2 && (Ko(!this.hasPlugin("jsx")), c2 = this.tryParse(() => super.parseMaybeAssign(...e21), u2), !c2.error))
        return c2.node;
      if ((s2 = h2) != null && s2.node)
        return this.state = h2.failState, h2.node;
      if (l2.node)
        return this.state = l2.failState, l2.node;
      if ((r2 = c2) != null && r2.node)
        return this.state = c2.failState, c2.node;
      if ((i2 = h2) != null && i2.thrown)
        throw h2.error;
      if (l2.thrown)
        throw l2.error;
      if ((a2 = c2) != null && a2.thrown)
        throw c2.error;
      throw ((n2 = h2) == null ? void 0 : n2.error) || l2.error || ((o2 = c2) == null ? void 0 : o2.error);
    }
    parseMaybeUnary(e21) {
      return !this.hasPlugin("jsx") && this.isRelational("<") ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e21);
    }
    parseArrow(e21) {
      if (this.match(bn$1.colon)) {
        const t2 = this.tryParse((e22) => {
          const t3 = this.tsParseTypeOrTypePredicateAnnotation(bn$1.colon);
          return !this.canInsertSemicolon() && this.match(bn$1.arrow) || e22(), t3;
        });
        if (t2.aborted)
          return;
        t2.thrown || (t2.error && (this.state = t2.failState), e21.returnType = t2.node);
      }
      return super.parseArrow(e21);
    }
    parseAssignableListItemTypes(e21) {
      this.eat(bn$1.question) && (e21.type === "Identifier" || this.state.isAmbientContext || this.state.inType || this.raise(e21.start, Xo.PatternIsOptional), e21.optional = true);
      const t2 = this.tsTryParseTypeAnnotation();
      return t2 && (e21.typeAnnotation = t2), this.resetEndLocation(e21), e21;
    }
    isAssignable(e21, t2) {
      switch (e21.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(e21.expression, t2);
        case "TSParameterProperty":
          return true;
        default:
          return super.isAssignable(e21, t2);
      }
    }
    toAssignable(e21, t2 = false) {
      switch (e21.type) {
        case "TSTypeCastExpression":
          return super.toAssignable(this.typeCastToParameter(e21), t2);
        case "TSParameterProperty":
          return super.toAssignable(e21, t2);
        case "ParenthesizedExpression":
          return this.toAssignableParenthesizedExpression(e21, t2);
        case "TSAsExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          return e21.expression = this.toAssignable(e21.expression, t2), e21;
        default:
          return super.toAssignable(e21, t2);
      }
    }
    toAssignableParenthesizedExpression(e21, t2) {
      switch (e21.expression.type) {
        case "TSAsExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          return e21.expression = this.toAssignable(e21.expression, t2), e21;
        default:
          return super.toAssignable(e21, t2);
      }
    }
    checkLVal(e21, t2, ...s2) {
      var r2;
      switch (e21.type) {
        case "TSTypeCastExpression":
          return;
        case "TSParameterProperty":
          return void this.checkLVal(e21.parameter, "parameter property", ...s2);
        case "TSAsExpression":
        case "TSTypeAssertion":
          if (!(s2[0] || t2 === "parenthesized expression" || (r2 = e21.extra) != null && r2.parenthesized)) {
            this.raise(e21.start, Rn$1.InvalidLhs, t2);
            break;
          }
          return void this.checkLVal(e21.expression, "parenthesized expression", ...s2);
        case "TSNonNullExpression":
          return void this.checkLVal(e21.expression, t2, ...s2);
        default:
          return void super.checkLVal(e21, t2, ...s2);
      }
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case bn$1._this:
          return this.parseIdentifier(true);
        default:
          return super.parseBindingAtom();
      }
    }
    parseMaybeDecoratorArguments(e21) {
      if (this.isRelational("<")) {
        const t2 = this.tsParseTypeArguments();
        if (this.match(bn$1.parenL)) {
          const s2 = super.parseMaybeDecoratorArguments(e21);
          return s2.typeParameters = t2, s2;
        }
        this.unexpected(this.state.start, bn$1.parenL);
      }
      return super.parseMaybeDecoratorArguments(e21);
    }
    checkCommaAfterRest(e21) {
      this.state.isAmbientContext && this.match(bn$1.comma) && this.lookaheadCharCode() === e21 ? this.next() : super.checkCommaAfterRest(e21);
    }
    isClassMethod() {
      return this.isRelational("<") || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(bn$1.bang) || this.match(bn$1.colon) || super.isClassProperty();
    }
    parseMaybeDefault(...e21) {
      const t2 = super.parseMaybeDefault(...e21);
      return t2.type === "AssignmentPattern" && t2.typeAnnotation && t2.right.start < t2.typeAnnotation.start && this.raise(t2.typeAnnotation.start, Xo.TypeAnnotationAfterAssign), t2;
    }
    getTokenFromCode(e21) {
      return !this.state.inType || e21 !== 62 && e21 !== 60 ? super.getTokenFromCode(e21) : this.finishOp(bn$1.relational, 1);
    }
    reScan_lt_gt() {
      if (this.match(bn$1.relational)) {
        const e21 = this.input.charCodeAt(this.state.start);
        e21 !== 60 && e21 !== 62 || (this.state.pos -= 1, this.readToken_lt_gt(e21));
      }
    }
    toAssignableList(e21) {
      for (let t2 = 0; t2 < e21.length; t2++) {
        const s2 = e21[t2];
        if (s2)
          switch (s2.type) {
            case "TSTypeCastExpression":
              e21[t2] = this.typeCastToParameter(s2);
              break;
            case "TSAsExpression":
            case "TSTypeAssertion":
              this.state.maybeInArrowParameters ? this.raise(s2.start, Xo.UnexpectedTypeCastInParameter) : e21[t2] = this.typeCastToParameter(s2);
          }
      }
      return super.toAssignableList(...arguments);
    }
    typeCastToParameter(e21) {
      return e21.expression.typeAnnotation = e21.typeAnnotation, this.resetEndLocation(e21.expression, e21.typeAnnotation.end, e21.typeAnnotation.loc.end), e21.expression;
    }
    shouldParseArrow(e21) {
      return this.match(bn$1.colon) ? e21.every((e22) => this.isAssignable(e22, true)) : super.shouldParseArrow(e21);
    }
    shouldParseAsyncArrow() {
      return this.match(bn$1.colon) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(e21) {
      if (this.isRelational("<")) {
        const t2 = this.tsTryParseAndCatch(() => this.tsParseTypeArguments());
        t2 && (e21.typeParameters = t2);
      }
      return super.jsxParseOpeningElementAfterName(e21);
    }
    getGetterSetterExpectedParamCount(e21) {
      const t2 = super.getGetterSetterExpectedParamCount(e21), s2 = this.getObjectOrClassMethodParams(e21)[0];
      return s2 && this.isThisParam(s2) ? t2 + 1 : t2;
    }
    parseCatchClauseParam() {
      const e21 = super.parseCatchClauseParam(), t2 = this.tsTryParseTypeAnnotation();
      return t2 && (e21.typeAnnotation = t2, this.resetEndLocation(e21)), e21;
    }
    tsInAmbientContext(e21) {
      const t2 = this.state.isAmbientContext;
      this.state.isAmbientContext = true;
      try {
        return e21();
      } finally {
        this.state.isAmbientContext = t2;
      }
    }
    parseClass(e21, ...t2) {
      const s2 = this.state.inAbstractClass;
      this.state.inAbstractClass = !!e21.abstract;
      try {
        return super.parseClass(e21, ...t2);
      } finally {
        this.state.inAbstractClass = s2;
      }
    }
    tsParseAbstractDeclaration(e21) {
      if (this.match(bn$1._class))
        return e21.abstract = true, this.parseClass(e21, true, false);
      if (this.isContextual("interface")) {
        if (!this.hasFollowingLineBreak())
          return e21.abstract = true, this.raise(e21.start, Xo.NonClassMethodPropertyHasAbstractModifer), this.next(), this.tsParseInterfaceDeclaration(e21);
      } else
        this.unexpected(null, bn$1._class);
    }
    parseMethod(...e21) {
      const t2 = super.parseMethod(...e21);
      if (t2.abstract) {
        if (this.hasPlugin("estree") ? !!t2.value.body : !!t2.body) {
          const { key: e22 } = t2;
          this.raise(t2.start, Xo.AbstractMethodHasImplementation, e22.type !== "Identifier" || t2.computed ? `[${this.input.slice(e22.start, e22.end)}]` : e22.name);
        }
      }
      return t2;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.getExpression();
    }
  },
  v8intrinsic: (e20) => class extends e20 {
    parseV8Intrinsic() {
      if (this.match(bn$1.modulo)) {
        const e21 = this.state.start, t2 = this.startNode();
        if (this.eat(bn$1.modulo), this.match(bn$1.name)) {
          const e22 = this.parseIdentifierName(this.state.start), s2 = this.createIdentifier(t2, e22);
          if (s2.type = "V8IntrinsicIdentifier", this.match(bn$1.parenL))
            return s2;
        }
        this.unexpected(e21);
      }
    }
    parseExprAtom() {
      return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);
    }
  },
  placeholders: (e20) => class extends e20 {
    parsePlaceholder(e21) {
      if (this.match(bn$1.placeholder)) {
        const t2 = this.startNode();
        return this.next(), this.assertNoSpace("Unexpected space in placeholder."), t2.name = super.parseIdentifier(true), this.assertNoSpace("Unexpected space in placeholder."), this.expect(bn$1.placeholder), this.finishPlaceholder(t2, e21);
      }
    }
    finishPlaceholder(e21, t2) {
      const s2 = !(!e21.expectedNode || e21.type !== "Placeholder");
      return e21.expectedNode = t2, s2 ? e21 : this.finishNode(e21, "Placeholder");
    }
    getTokenFromCode(e21) {
      return e21 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(bn$1.placeholder, 2) : super.getTokenFromCode(...arguments);
    }
    parseExprAtom() {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(...arguments);
    }
    parseIdentifier() {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(...arguments);
    }
    checkReservedWord(e21) {
      e21 !== void 0 && super.checkReservedWord(...arguments);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom(...arguments);
    }
    checkLVal(e21) {
      e21.type !== "Placeholder" && super.checkLVal(...arguments);
    }
    toAssignable(e21) {
      return e21 && e21.type === "Placeholder" && e21.expectedNode === "Expression" ? (e21.expectedNode = "Pattern", e21) : super.toAssignable(...arguments);
    }
    isLet(e21) {
      if (super.isLet(e21))
        return true;
      if (!this.isContextual("let"))
        return false;
      if (e21)
        return false;
      return this.lookahead().type === bn$1.placeholder;
    }
    verifyBreakContinue(e21) {
      e21.label && e21.label.type === "Placeholder" || super.verifyBreakContinue(...arguments);
    }
    parseExpressionStatement(e21, t2) {
      if (t2.type !== "Placeholder" || t2.extra && t2.extra.parenthesized)
        return super.parseExpressionStatement(...arguments);
      if (this.match(bn$1.colon)) {
        const s2 = e21;
        return s2.label = this.finishPlaceholder(t2, "Identifier"), this.next(), s2.body = this.parseStatement("label"), this.finishNode(s2, "LabeledStatement");
      }
      return this.semicolon(), e21.name = t2.name, this.finishPlaceholder(e21, "Statement");
    }
    parseBlock() {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(...arguments);
    }
    parseFunctionId() {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(...arguments);
    }
    parseClass(e21, t2, s2) {
      const r2 = t2 ? "ClassDeclaration" : "ClassExpression";
      this.next(), this.takeDecorators(e21);
      const i2 = this.state.strict, a2 = this.parsePlaceholder("Identifier");
      if (a2)
        if (this.match(bn$1._extends) || this.match(bn$1.placeholder) || this.match(bn$1.braceL))
          e21.id = a2;
        else {
          if (s2 || !t2)
            return e21.id = null, e21.body = this.finishPlaceholder(a2, "ClassBody"), this.finishNode(e21, r2);
          this.unexpected(null, Yo.ClassNameIsRequired);
        }
      else
        this.parseClassId(e21, t2, s2);
      return this.parseClassSuper(e21), e21.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!e21.superClass, i2), this.finishNode(e21, r2);
    }
    parseExport(e21) {
      const t2 = this.parsePlaceholder("Identifier");
      if (!t2)
        return super.parseExport(...arguments);
      if (!this.isContextual("from") && !this.match(bn$1.comma))
        return e21.specifiers = [], e21.source = null, e21.declaration = this.finishPlaceholder(t2, "Declaration"), this.finishNode(e21, "ExportNamedDeclaration");
      this.expectPlugin("exportDefaultFrom");
      const s2 = this.startNode();
      return s2.exported = t2, e21.specifiers = [
        this.finishNode(s2, "ExportDefaultSpecifier")
      ], super.parseExport(e21);
    }
    isExportDefaultSpecifier() {
      if (this.match(bn$1._default)) {
        const e21 = this.nextTokenStart();
        if (this.isUnparsedContextual(e21, "from") && this.input.startsWith(bn$1.placeholder.label, this.nextTokenStartSince(e21 + 4)))
          return true;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(e21) {
      return !!(e21.specifiers && e21.specifiers.length > 0) || super.maybeParseExportDefaultSpecifier(...arguments);
    }
    checkExport(e21) {
      const { specifiers: t2 } = e21;
      t2 != null && t2.length && (e21.specifiers = t2.filter((e22) => e22.exported.type === "Placeholder")), super.checkExport(e21), e21.specifiers = t2;
    }
    parseImport(e21) {
      const t2 = this.parsePlaceholder("Identifier");
      if (!t2)
        return super.parseImport(...arguments);
      if (e21.specifiers = [], !this.isContextual("from") && !this.match(bn$1.comma))
        return e21.source = this.finishPlaceholder(t2, "StringLiteral"), this.semicolon(), this.finishNode(e21, "ImportDeclaration");
      const s2 = this.startNodeAtNode(t2);
      if (s2.local = t2, this.finishNode(s2, "ImportDefaultSpecifier"), e21.specifiers.push(s2), this.eat(bn$1.comma)) {
        this.maybeParseStarImportSpecifier(e21) || this.parseNamedImportSpecifiers(e21);
      }
      return this.expectContextual("from"), e21.source = this.parseImportSource(), this.semicolon(), this.finishNode(e21, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource(...arguments);
    }
  }
}, iu = Object.keys(ru), au = {
  sourceType: "script",
  sourceFilename: void 0,
  startLine: 1,
  allowAwaitOutsideFunction: false,
  allowReturnOutsideFunction: false,
  allowImportExportEverywhere: false,
  allowSuperOutsideMethod: false,
  allowUndeclaredExports: false,
  plugins: [],
  strictMode: null,
  ranges: false,
  tokens: false,
  createParenthesizedExpressions: false,
  errorRecovery: false,
  attachComment: true
};
const nu = (e20) => e20.type === "ParenthesizedExpression" ? nu(e20.expression) : e20;
const ou = { kind: "loop" }, uu = { kind: "switch" }, hu = /[\uD800-\uDFFF]/u, cu = /in(?:stanceof)?/y;
class pu extends class extends class extends class extends class extends class extends class extends class extends class extends class {
  constructor() {
    this.sawUnambiguousESM = false, this.ambiguousScriptDifferentAst = false;
  }
  hasPlugin(e20) {
    return this.plugins.has(e20);
  }
  getPluginOption(e20, t2) {
    if (this.hasPlugin(e20))
      return this.plugins.get(e20)[t2];
  }
} {
  addComment(e20) {
    this.filename && (e20.loc.filename = this.filename), this.state.comments.push(e20);
  }
  processComment(e20) {
    const { commentStack: t2 } = this.state, s2 = t2.length;
    if (s2 === 0)
      return;
    let r2 = s2 - 1;
    const i2 = t2[r2];
    i2.start === e20.end && (i2.leadingNode = e20, r2--);
    const { start: a2 } = e20;
    for (; r2 >= 0; r2--) {
      const s3 = t2[r2], i3 = s3.end;
      if (!(i3 > a2)) {
        i3 === a2 && (s3.trailingNode = e20);
        break;
      }
      s3.containingNode = e20, this.finalizeComment(s3), t2.splice(r2, 1);
    }
  }
  finalizeComment(e20) {
    const { comments: t2 } = e20;
    if (e20.leadingNode !== null || e20.trailingNode !== null)
      e20.leadingNode !== null && kn$1(e20.leadingNode, t2), e20.trailingNode !== null && (e20.trailingNode.leadingComments = t2);
    else {
      const { containingNode: s2, start: r2 } = e20;
      if (this.input.charCodeAt(r2 - 1) === 44)
        switch (s2.type) {
          case "ObjectExpression":
          case "ObjectPattern":
          case "RecordExpression":
            On$1(s2, s2.properties, e20);
            break;
          case "CallExpression":
          case "OptionalCallExpression":
            On$1(s2, s2.arguments, e20);
            break;
          case "FunctionDeclaration":
          case "FunctionExpression":
          case "ArrowFunctionExpression":
          case "ObjectMethod":
          case "ClassMethod":
          case "ClassPrivateMethod":
            On$1(s2, s2.params, e20);
            break;
          case "ArrayExpression":
          case "ArrayPattern":
          case "TupleExpression":
            On$1(s2, s2.elements, e20);
            break;
          case "ExportNamedDeclaration":
          case "ImportDeclaration":
            On$1(s2, s2.specifiers, e20);
            break;
          default:
            Ln$1(s2, t2);
        }
      else
        Ln$1(s2, t2);
    }
  }
  finalizeRemainingComments() {
    const { commentStack: e20 } = this.state;
    for (let t2 = e20.length - 1; t2 >= 0; t2--)
      this.finalizeComment(e20[t2]);
    this.state.commentStack = [];
  }
  resetPreviousNodeTrailingComments(e20) {
    const { commentStack: t2 } = this.state, { length: s2 } = t2;
    if (s2 === 0)
      return;
    const r2 = t2[s2 - 1];
    r2.leadingNode === e20 && (r2.leadingNode = null);
  }
} {
  getLocationForPosition(e20) {
    let t2;
    return t2 = e20 === this.state.start ? this.state.startLoc : e20 === this.state.lastTokStart ? this.state.lastTokStartLoc : e20 === this.state.end ? this.state.endLoc : e20 === this.state.lastTokEnd ? this.state.lastTokEndLoc : function(e21, t3) {
      let s2, r2 = 1, i2 = 0;
      for (Tn$1.lastIndex = 0; (s2 = Tn$1.exec(e21)) && s2.index < t3; )
        r2++, i2 = Tn$1.lastIndex;
      return new In$1(r2, t3 - i2);
    }(this.input, e20), t2;
  }
  raise(e20, { code: t2, reasonCode: s2, template: r2 }, ...i2) {
    return this.raiseWithData(e20, { code: t2, reasonCode: s2 }, r2, ...i2);
  }
  raiseOverwrite(e20, { code: t2, template: s2 }, ...r2) {
    const i2 = this.getLocationForPosition(e20), a2 = s2.replace(/%(\d+)/g, (e21, t3) => r2[t3]) + ` (${i2.line}:${i2.column})`;
    if (this.options.errorRecovery) {
      const t3 = this.state.errors;
      for (let s3 = t3.length - 1; s3 >= 0; s3--) {
        const r3 = t3[s3];
        if (r3.pos === e20)
          return Object.assign(r3, { message: a2 });
        if (r3.pos < e20)
          break;
      }
    }
    return this._raise({ code: t2, loc: i2, pos: e20 }, a2);
  }
  raiseWithData(e20, t2, s2, ...r2) {
    const i2 = this.getLocationForPosition(e20), a2 = s2.replace(/%(\d+)/g, (e21, t3) => r2[t3]) + ` (${i2.line}:${i2.column})`;
    return this._raise(Object.assign({ loc: i2, pos: e20 }, t2), a2);
  }
  _raise(e20, t2) {
    const s2 = new SyntaxError(t2);
    if (Object.assign(s2, e20), this.options.errorRecovery)
      return this.isLookahead || this.state.errors.push(s2), s2;
    throw s2;
  }
} {
  constructor(e20, t2) {
    super(), this.isLookahead = void 0, this.tokens = [], this.state = new Do$1(), this.state.init(e20), this.input = t2, this.length = t2.length, this.isLookahead = false;
  }
  pushToken(e20) {
    this.tokens.length = this.state.tokensLength, this.tokens.push(e20), ++this.state.tokensLength;
  }
  next() {
    this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new Eo$1(this.state)), this.state.lastTokEnd = this.state.end, this.state.lastTokStart = this.state.start, this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
  }
  eat(e20) {
    return !!this.match(e20) && (this.next(), true);
  }
  match(e20) {
    return this.state.type === e20;
  }
  createLookaheadState(e20) {
    return {
      pos: e20.pos,
      value: null,
      type: e20.type,
      start: e20.start,
      end: e20.end,
      lastTokEnd: e20.end,
      context: [this.curContext()],
      inType: e20.inType
    };
  }
  lookahead() {
    const e20 = this.state;
    this.state = this.createLookaheadState(e20), this.isLookahead = true, this.nextToken(), this.isLookahead = false;
    const t2 = this.state;
    return this.state = e20, t2;
  }
  nextTokenStart() {
    return this.nextTokenStartSince(this.state.pos);
  }
  nextTokenStartSince(e20) {
    return Sn$1.lastIndex = e20, Sn$1.test(this.input) ? Sn$1.lastIndex : e20;
  }
  lookaheadCharCode() {
    return this.input.charCodeAt(this.nextTokenStart());
  }
  codePointAtPos(e20) {
    let t2 = this.input.charCodeAt(e20);
    if ((64512 & t2) == 55296 && ++e20 < this.input.length) {
      const s2 = this.input.charCodeAt(e20);
      (64512 & s2) == 56320 && (t2 = 65536 + ((1023 & t2) << 10) + (1023 & s2));
    }
    return t2;
  }
  setStrict(e20) {
    this.state.strict = e20, e20 && (this.state.strictErrors.forEach((e21, t2) => this.raise(t2, e21)), this.state.strictErrors.clear());
  }
  curContext() {
    return this.state.context[this.state.context.length - 1];
  }
  nextToken() {
    const e20 = this.curContext();
    e20.preserveSpace || this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length ? this.finishToken(bn$1.eof) : e20 === $n$1.template ? this.readTmplToken() : this.getTokenFromCode(this.codePointAtPos(this.state.pos));
  }
  skipBlockComment() {
    let e20;
    this.isLookahead || (e20 = this.state.curPosition());
    const t2 = this.state.pos, s2 = this.input.indexOf("*/", t2 + 2);
    if (s2 === -1)
      throw this.raise(t2, Rn$1.UnterminatedComment);
    for (this.state.pos = s2 + 2, Tn$1.lastIndex = t2 + 2; Tn$1.test(this.input) && Tn$1.lastIndex <= s2; )
      ++this.state.curLine, this.state.lineStart = Tn$1.lastIndex;
    if (this.isLookahead)
      return;
    const r2 = {
      type: "CommentBlock",
      value: this.input.slice(t2 + 2, s2),
      start: t2,
      end: s2 + 2,
      loc: new vn$1(e20, this.state.curPosition())
    };
    return this.options.tokens && this.pushToken(r2), r2;
  }
  skipLineComment(e20) {
    const t2 = this.state.pos;
    let s2;
    this.isLookahead || (s2 = this.state.curPosition());
    let r2 = this.input.charCodeAt(this.state.pos += e20);
    if (this.state.pos < this.length)
      for (; !wn$1(r2) && ++this.state.pos < this.length; )
        r2 = this.input.charCodeAt(this.state.pos);
    if (this.isLookahead)
      return;
    const i2 = this.state.pos, a2 = {
      type: "CommentLine",
      value: this.input.slice(t2 + e20, i2),
      start: t2,
      end: i2,
      loc: new vn$1(s2, this.state.curPosition())
    };
    return this.options.tokens && this.pushToken(a2), a2;
  }
  skipSpace() {
    const e20 = this.state.pos, t2 = [];
    e:
      for (; this.state.pos < this.length; ) {
        const s2 = this.input.charCodeAt(this.state.pos);
        switch (s2) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;
          case 13:
            this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                const e21 = this.skipBlockComment();
                e21 !== void 0 && (this.addComment(e21), this.options.attachComment && t2.push(e21));
                break;
              }
              case 47: {
                const e21 = this.skipLineComment(2);
                e21 !== void 0 && (this.addComment(e21), this.options.attachComment && t2.push(e21));
                break;
              }
              default:
                break e;
            }
            break;
          default:
            if (Nn$1(s2))
              ++this.state.pos;
            else if (s2 !== 45 || this.inModule) {
              if (s2 !== 60 || this.inModule)
                break e;
              {
                const e21 = this.state.pos;
                if (this.input.charCodeAt(e21 + 1) !== 33 || this.input.charCodeAt(e21 + 2) !== 45 || this.input.charCodeAt(e21 + 3) !== 45)
                  break e;
                {
                  const e22 = this.skipLineComment(4);
                  e22 !== void 0 && (this.addComment(e22), this.options.attachComment && t2.push(e22));
                }
              }
            } else {
              const s3 = this.state.pos;
              if (this.input.charCodeAt(s3 + 1) !== 45 || this.input.charCodeAt(s3 + 2) !== 62 || !(e20 === 0 || this.state.lineStart > e20))
                break e;
              {
                const e21 = this.skipLineComment(3);
                e21 !== void 0 && (this.addComment(e21), this.options.attachComment && t2.push(e21));
              }
            }
        }
      }
    if (t2.length > 0) {
      const s2 = {
        start: e20,
        end: this.state.pos,
        comments: t2,
        leadingNode: null,
        trailingNode: null,
        containingNode: null
      };
      this.state.commentStack.push(s2);
    }
  }
  finishToken(e20, t2) {
    this.state.end = this.state.pos;
    const s2 = this.state.type;
    this.state.type = e20, this.state.value = t2, this.isLookahead || (this.state.endLoc = this.state.curPosition(), this.updateContext(s2));
  }
  readToken_numberSign() {
    if (this.state.pos === 0 && this.readToken_interpreter())
      return;
    const e20 = this.state.pos + 1, t2 = this.codePointAtPos(e20);
    if (t2 >= 48 && t2 <= 57)
      throw this.raise(this.state.pos, Rn$1.UnexpectedDigitAfterHash);
    if (t2 === 123 || t2 === 91 && this.hasPlugin("recordAndTuple")) {
      if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") !== "hash")
        throw this.raise(this.state.pos, t2 === 123 ? Rn$1.RecordExpressionHashIncorrectStartSyntaxType : Rn$1.TupleExpressionHashIncorrectStartSyntaxType);
      this.state.pos += 2, t2 === 123 ? this.finishToken(bn$1.braceHashL) : this.finishToken(bn$1.bracketHashL);
    } else
      Jn$1(t2) ? (++this.state.pos, this.finishToken(bn$1.privateName, this.readWord1(t2))) : t2 === 92 ? (++this.state.pos, this.finishToken(bn$1.privateName, this.readWord1())) : this.finishOp(bn$1.hash, 1);
  }
  readToken_dot() {
    const e20 = this.input.charCodeAt(this.state.pos + 1);
    e20 >= 48 && e20 <= 57 ? this.readNumber(true) : e20 === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(bn$1.ellipsis)) : (++this.state.pos, this.finishToken(bn$1.dot));
  }
  readToken_slash() {
    this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(bn$1.slashAssign, 2) : this.finishOp(bn$1.slash, 1);
  }
  readToken_interpreter() {
    if (this.state.pos !== 0 || this.length < 2)
      return false;
    let e20 = this.input.charCodeAt(this.state.pos + 1);
    if (e20 !== 33)
      return false;
    const t2 = this.state.pos;
    for (this.state.pos += 1; !wn$1(e20) && ++this.state.pos < this.length; )
      e20 = this.input.charCodeAt(this.state.pos);
    const s2 = this.input.slice(t2 + 2, this.state.pos);
    return this.finishToken(bn$1.interpreterDirective, s2), true;
  }
  readToken_mult_modulo(e20) {
    let t2 = e20 === 42 ? bn$1.star : bn$1.modulo, s2 = 1, r2 = this.input.charCodeAt(this.state.pos + 1);
    e20 === 42 && r2 === 42 && (s2++, r2 = this.input.charCodeAt(this.state.pos + 2), t2 = bn$1.exponent), r2 !== 61 || this.state.inType || (s2++, t2 = e20 === 37 ? bn$1.moduloAssign : bn$1.assign), this.finishOp(t2, s2);
  }
  readToken_pipe_amp(e20) {
    const t2 = this.input.charCodeAt(this.state.pos + 1);
    if (t2 !== e20) {
      if (e20 === 124) {
        if (t2 === 62)
          return void this.finishOp(bn$1.pipeline, 2);
        if (this.hasPlugin("recordAndTuple") && t2 === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(this.state.pos, Rn$1.RecordExpressionBarIncorrectEndSyntaxType);
          return this.state.pos += 2, void this.finishToken(bn$1.braceBarR);
        }
        if (this.hasPlugin("recordAndTuple") && t2 === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(this.state.pos, Rn$1.TupleExpressionBarIncorrectEndSyntaxType);
          return this.state.pos += 2, void this.finishToken(bn$1.bracketBarR);
        }
      }
      t2 !== 61 ? this.finishOp(e20 === 124 ? bn$1.bitwiseOR : bn$1.bitwiseAND, 1) : this.finishOp(bn$1.assign, 2);
    } else
      this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(bn$1.assign, 3) : this.finishOp(e20 === 124 ? bn$1.logicalOR : bn$1.logicalAND, 2);
  }
  readToken_caret() {
    this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(bn$1.assign, 2) : this.finishOp(bn$1.bitwiseXOR, 1);
  }
  readToken_plus_min(e20) {
    const t2 = this.input.charCodeAt(this.state.pos + 1);
    t2 !== e20 ? t2 === 61 ? this.finishOp(bn$1.assign, 2) : this.finishOp(bn$1.plusMin, 1) : this.finishOp(bn$1.incDec, 2);
  }
  readToken_lt_gt(e20) {
    const t2 = this.input.charCodeAt(this.state.pos + 1);
    let s2 = 1;
    if (t2 === e20)
      return s2 = e20 === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.state.pos + s2) === 61 ? void this.finishOp(bn$1.assign, s2 + 1) : void this.finishOp(bn$1.bitShift, s2);
    t2 === 61 && (s2 = 2), this.finishOp(bn$1.relational, s2);
  }
  readToken_eq_excl(e20) {
    const t2 = this.input.charCodeAt(this.state.pos + 1);
    if (t2 !== 61)
      return e20 === 61 && t2 === 62 ? (this.state.pos += 2, void this.finishToken(bn$1.arrow)) : void this.finishOp(e20 === 61 ? bn$1.eq : bn$1.bang, 1);
    this.finishOp(bn$1.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
  }
  readToken_question() {
    const e20 = this.input.charCodeAt(this.state.pos + 1), t2 = this.input.charCodeAt(this.state.pos + 2);
    e20 === 63 ? t2 === 61 ? this.finishOp(bn$1.assign, 3) : this.finishOp(bn$1.nullishCoalescing, 2) : e20 !== 46 || t2 >= 48 && t2 <= 57 ? (++this.state.pos, this.finishToken(bn$1.question)) : (this.state.pos += 2, this.finishToken(bn$1.questionDot));
  }
  getTokenFromCode(e20) {
    switch (e20) {
      case 46:
        return void this.readToken_dot();
      case 40:
        return ++this.state.pos, void this.finishToken(bn$1.parenL);
      case 41:
        return ++this.state.pos, void this.finishToken(bn$1.parenR);
      case 59:
        return ++this.state.pos, void this.finishToken(bn$1.semi);
      case 44:
        return ++this.state.pos, void this.finishToken(bn$1.comma);
      case 91:
        if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(this.state.pos, Rn$1.TupleExpressionBarIncorrectStartSyntaxType);
          this.state.pos += 2, this.finishToken(bn$1.bracketBarL);
        } else
          ++this.state.pos, this.finishToken(bn$1.bracketL);
        return;
      case 93:
        return ++this.state.pos, void this.finishToken(bn$1.bracketR);
      case 123:
        if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(this.state.pos, Rn$1.RecordExpressionBarIncorrectStartSyntaxType);
          this.state.pos += 2, this.finishToken(bn$1.braceBarL);
        } else
          ++this.state.pos, this.finishToken(bn$1.braceL);
        return;
      case 125:
        return ++this.state.pos, void this.finishToken(bn$1.braceR);
      case 58:
        return void (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(bn$1.doubleColon, 2) : (++this.state.pos, this.finishToken(bn$1.colon)));
      case 63:
        return void this.readToken_question();
      case 96:
        return ++this.state.pos, void this.finishToken(bn$1.backQuote);
      case 48: {
        const e21 = this.input.charCodeAt(this.state.pos + 1);
        if (e21 === 120 || e21 === 88)
          return void this.readRadixNumber(16);
        if (e21 === 111 || e21 === 79)
          return void this.readRadixNumber(8);
        if (e21 === 98 || e21 === 66)
          return void this.readRadixNumber(2);
      }
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return void this.readNumber(false);
      case 34:
      case 39:
        return void this.readString(e20);
      case 47:
        return void this.readToken_slash();
      case 37:
      case 42:
        return void this.readToken_mult_modulo(e20);
      case 124:
      case 38:
        return void this.readToken_pipe_amp(e20);
      case 94:
        return void this.readToken_caret();
      case 43:
      case 45:
        return void this.readToken_plus_min(e20);
      case 60:
      case 62:
        return void this.readToken_lt_gt(e20);
      case 61:
      case 33:
        return void this.readToken_eq_excl(e20);
      case 126:
        return void this.finishOp(bn$1.tilde, 1);
      case 64:
        return ++this.state.pos, void this.finishToken(bn$1.at);
      case 35:
        return void this.readToken_numberSign();
      case 92:
        return void this.readWord();
      default:
        if (Jn$1(e20))
          return void this.readWord(e20);
    }
    throw this.raise(this.state.pos, Rn$1.InvalidOrUnexpectedToken, String.fromCodePoint(e20));
  }
  finishOp(e20, t2) {
    const s2 = this.input.slice(this.state.pos, this.state.pos + t2);
    this.state.pos += t2, this.finishToken(e20, s2);
  }
  readRegexp() {
    const e20 = this.state.start + 1;
    let t2, s2, { pos: r2 } = this.state;
    for (; ; ++r2) {
      if (r2 >= this.length)
        throw this.raise(e20, Rn$1.UnterminatedRegExp);
      const i3 = this.input.charCodeAt(r2);
      if (wn$1(i3))
        throw this.raise(e20, Rn$1.UnterminatedRegExp);
      if (t2)
        t2 = false;
      else {
        if (i3 === 91)
          s2 = true;
        else if (i3 === 93 && s2)
          s2 = false;
        else if (i3 === 47 && !s2)
          break;
        t2 = i3 === 92;
      }
    }
    const i2 = this.input.slice(e20, r2);
    ++r2;
    let a2 = "";
    for (; r2 < this.length; ) {
      const e21 = this.codePointAtPos(r2), t3 = String.fromCharCode(e21);
      if (fo$1.has(e21))
        a2.includes(t3) && this.raise(r2 + 1, Rn$1.DuplicateRegExpFlags);
      else {
        if (!Yn$1(e21) && e21 !== 92)
          break;
        this.raise(r2 + 1, Rn$1.MalformedRegExpFlags);
      }
      ++r2, a2 += t3;
    }
    this.state.pos = r2, this.finishToken(bn$1.regexp, { pattern: i2, flags: a2 });
  }
  readInt(e20, t2, s2, r2 = true) {
    const i2 = this.state.pos, a2 = e20 === 16 ? yo$1.hex : yo$1.decBinOct, n2 = e20 === 16 ? Ao$1.hex : e20 === 10 ? Ao$1.dec : e20 === 8 ? Ao$1.oct : Ao$1.bin;
    let o2 = false, u2 = 0;
    for (let i3 = 0, h2 = t2 == null ? 1 / 0 : t2; i3 < h2; ++i3) {
      const t3 = this.input.charCodeAt(this.state.pos);
      let h3;
      if (t3 !== 95) {
        if (h3 = t3 >= 97 ? t3 - 97 + 10 : t3 >= 65 ? t3 - 65 + 10 : mo$1(t3) ? t3 - 48 : 1 / 0, h3 >= e20)
          if (this.options.errorRecovery && h3 <= 9)
            h3 = 0, this.raise(this.state.start + i3 + 2, Rn$1.InvalidDigit, e20);
          else {
            if (!s2)
              break;
            h3 = 0, o2 = true;
          }
        ++this.state.pos, u2 = u2 * e20 + h3;
      } else {
        const e21 = this.input.charCodeAt(this.state.pos - 1), t4 = this.input.charCodeAt(this.state.pos + 1);
        (n2.indexOf(t4) === -1 || a2.indexOf(e21) > -1 || a2.indexOf(t4) > -1 || Number.isNaN(t4)) && this.raise(this.state.pos, Rn$1.UnexpectedNumericSeparator), r2 || this.raise(this.state.pos, Rn$1.NumericSeparatorInEscapeSequence), ++this.state.pos;
      }
    }
    return this.state.pos === i2 || t2 != null && this.state.pos - i2 !== t2 || o2 ? null : u2;
  }
  readRadixNumber(e20) {
    const t2 = this.state.pos;
    let s2 = false;
    this.state.pos += 2;
    const r2 = this.readInt(e20);
    r2 == null && this.raise(this.state.start + 2, Rn$1.InvalidDigit, e20);
    const i2 = this.input.charCodeAt(this.state.pos);
    if (i2 === 110)
      ++this.state.pos, s2 = true;
    else if (i2 === 109)
      throw this.raise(t2, Rn$1.InvalidDecimal);
    if (Jn$1(this.codePointAtPos(this.state.pos)))
      throw this.raise(this.state.pos, Rn$1.NumberIdentifier);
    if (s2) {
      const e21 = this.input.slice(t2, this.state.pos).replace(/[_n]/g, "");
      this.finishToken(bn$1.bigint, e21);
    } else
      this.finishToken(bn$1.num, r2);
  }
  readNumber(e20) {
    const t2 = this.state.pos;
    let s2 = false, r2 = false, i2 = false, a2 = false, n2 = false;
    e20 || this.readInt(10) !== null || this.raise(t2, Rn$1.InvalidNumber);
    const o2 = this.state.pos - t2 >= 2 && this.input.charCodeAt(t2) === 48;
    if (o2) {
      const e21 = this.input.slice(t2, this.state.pos);
      if (this.recordStrictModeErrors(t2, Rn$1.StrictOctalLiteral), !this.state.strict) {
        const s3 = e21.indexOf("_");
        s3 > 0 && this.raise(s3 + t2, Rn$1.ZeroDigitNumericSeparator);
      }
      n2 = o2 && !/[89]/.test(e21);
    }
    let u2 = this.input.charCodeAt(this.state.pos);
    if (u2 !== 46 || n2 || (++this.state.pos, this.readInt(10), s2 = true, u2 = this.input.charCodeAt(this.state.pos)), u2 !== 69 && u2 !== 101 || n2 || (u2 = this.input.charCodeAt(++this.state.pos), u2 !== 43 && u2 !== 45 || ++this.state.pos, this.readInt(10) === null && this.raise(t2, Rn$1.InvalidOrMissingExponent), s2 = true, a2 = true, u2 = this.input.charCodeAt(this.state.pos)), u2 === 110 && ((s2 || o2) && this.raise(t2, Rn$1.InvalidBigIntLiteral), ++this.state.pos, r2 = true), u2 === 109 && (this.expectPlugin("decimal", this.state.pos), (a2 || o2) && this.raise(t2, Rn$1.InvalidDecimal), ++this.state.pos, i2 = true), Jn$1(this.codePointAtPos(this.state.pos)))
      throw this.raise(this.state.pos, Rn$1.NumberIdentifier);
    const h2 = this.input.slice(t2, this.state.pos).replace(/[_mn]/g, "");
    if (r2)
      return void this.finishToken(bn$1.bigint, h2);
    if (i2)
      return void this.finishToken(bn$1.decimal, h2);
    const c2 = n2 ? parseInt(h2, 8) : parseFloat(h2);
    this.finishToken(bn$1.num, c2);
  }
  readCodePoint(e20) {
    let t2;
    if (this.input.charCodeAt(this.state.pos) === 123) {
      const s2 = ++this.state.pos;
      if (t2 = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, true, e20), ++this.state.pos, t2 !== null && t2 > 1114111) {
        if (!e20)
          return null;
        this.raise(s2, Rn$1.InvalidCodePoint);
      }
    } else
      t2 = this.readHexChar(4, false, e20);
    return t2;
  }
  readString(e20) {
    let t2 = "", s2 = ++this.state.pos;
    for (; ; ) {
      if (this.state.pos >= this.length)
        throw this.raise(this.state.start, Rn$1.UnterminatedString);
      const r2 = this.input.charCodeAt(this.state.pos);
      if (r2 === e20)
        break;
      if (r2 === 92)
        t2 += this.input.slice(s2, this.state.pos), t2 += this.readEscapedChar(false), s2 = this.state.pos;
      else if (r2 === 8232 || r2 === 8233)
        ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
      else {
        if (wn$1(r2))
          throw this.raise(this.state.start, Rn$1.UnterminatedString);
        ++this.state.pos;
      }
    }
    t2 += this.input.slice(s2, this.state.pos++), this.finishToken(bn$1.string, t2);
  }
  readTmplToken() {
    let e20 = "", t2 = this.state.pos, s2 = false;
    for (; ; ) {
      if (this.state.pos >= this.length)
        throw this.raise(this.state.start, Rn$1.UnterminatedTemplate);
      const r2 = this.input.charCodeAt(this.state.pos);
      if (r2 === 96 || r2 === 36 && this.input.charCodeAt(this.state.pos + 1) === 123)
        return this.state.pos === this.state.start && this.match(bn$1.template) ? r2 === 36 ? (this.state.pos += 2, void this.finishToken(bn$1.dollarBraceL)) : (++this.state.pos, void this.finishToken(bn$1.backQuote)) : (e20 += this.input.slice(t2, this.state.pos), void this.finishToken(bn$1.template, s2 ? null : e20));
      if (r2 === 92) {
        e20 += this.input.slice(t2, this.state.pos);
        const r3 = this.readEscapedChar(true);
        r3 === null ? s2 = true : e20 += r3, t2 = this.state.pos;
      } else if (wn$1(r2)) {
        switch (e20 += this.input.slice(t2, this.state.pos), ++this.state.pos, r2) {
          case 13:
            this.input.charCodeAt(this.state.pos) === 10 && ++this.state.pos;
          case 10:
            e20 += "\n";
            break;
          default:
            e20 += String.fromCharCode(r2);
        }
        ++this.state.curLine, this.state.lineStart = this.state.pos, t2 = this.state.pos;
      } else
        ++this.state.pos;
    }
  }
  recordStrictModeErrors(e20, t2) {
    this.state.strict && !this.state.strictErrors.has(e20) ? this.raise(e20, t2) : this.state.strictErrors.set(e20, t2);
  }
  readEscapedChar(e20) {
    const t2 = !e20, s2 = this.input.charCodeAt(++this.state.pos);
    switch (++this.state.pos, s2) {
      case 110:
        return "\n";
      case 114:
        return "\r";
      case 120: {
        const e21 = this.readHexChar(2, false, t2);
        return e21 === null ? null : String.fromCharCode(e21);
      }
      case 117: {
        const e21 = this.readCodePoint(t2);
        return e21 === null ? null : String.fromCodePoint(e21);
      }
      case 116:
        return "	";
      case 98:
        return "\b";
      case 118:
        return "\v";
      case 102:
        return "\f";
      case 13:
        this.input.charCodeAt(this.state.pos) === 10 && ++this.state.pos;
      case 10:
        this.state.lineStart = this.state.pos, ++this.state.curLine;
      case 8232:
      case 8233:
        return "";
      case 56:
      case 57:
        if (e20)
          return null;
        this.recordStrictModeErrors(this.state.pos - 1, Rn$1.StrictNumericEscape);
      default:
        if (s2 >= 48 && s2 <= 55) {
          const t3 = this.state.pos - 1;
          let s3 = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0], r2 = parseInt(s3, 8);
          r2 > 255 && (s3 = s3.slice(0, -1), r2 = parseInt(s3, 8)), this.state.pos += s3.length - 1;
          const i2 = this.input.charCodeAt(this.state.pos);
          if (s3 !== "0" || i2 === 56 || i2 === 57) {
            if (e20)
              return null;
            this.recordStrictModeErrors(t3, Rn$1.StrictNumericEscape);
          }
          return String.fromCharCode(r2);
        }
        return String.fromCharCode(s2);
    }
  }
  readHexChar(e20, t2, s2) {
    const r2 = this.state.pos, i2 = this.readInt(16, e20, t2, false);
    return i2 === null && (s2 ? this.raise(r2, Rn$1.InvalidEscapeSequence) : this.state.pos = r2 - 1), i2;
  }
  readWord1(e20) {
    this.state.containsEsc = false;
    let t2 = "";
    const s2 = this.state.pos;
    let r2 = this.state.pos;
    for (e20 !== void 0 && (this.state.pos += e20 <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
      const e21 = this.codePointAtPos(this.state.pos);
      if (Yn$1(e21))
        this.state.pos += e21 <= 65535 ? 1 : 2;
      else {
        if (e21 !== 92)
          break;
        {
          this.state.containsEsc = true, t2 += this.input.slice(r2, this.state.pos);
          const e22 = this.state.pos, i2 = this.state.pos === s2 ? Jn$1 : Yn$1;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(this.state.pos, Rn$1.MissingUnicodeEscape), r2 = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          const a2 = this.readCodePoint(true);
          a2 !== null && (i2(a2) || this.raise(e22, Rn$1.EscapedCharNotAnIdentifier), t2 += String.fromCodePoint(a2)), r2 = this.state.pos;
        }
      }
    }
    return t2 + this.input.slice(r2, this.state.pos);
  }
  readWord(e20) {
    const t2 = this.readWord1(e20), s2 = xn$1.get(t2) || bn$1.name;
    this.finishToken(s2, t2);
  }
  checkKeywordEscapes() {
    const e20 = this.state.type.keyword;
    e20 && this.state.containsEsc && this.raise(this.state.start, Rn$1.InvalidEscapedReservedWord, e20);
  }
  updateContext(e20) {
    var t2, s2;
    (t2 = (s2 = this.state.type).updateContext) == null || t2.call(s2, this.state.context);
  }
} {
  addExtra(e20, t2, s2) {
    if (!e20)
      return;
    (e20.extra = e20.extra || {})[t2] = s2;
  }
  isRelational(e20) {
    return this.match(bn$1.relational) && this.state.value === e20;
  }
  expectRelational(e20) {
    this.isRelational(e20) ? this.next() : this.unexpected(null, bn$1.relational);
  }
  isContextual(e20) {
    return this.match(bn$1.name) && this.state.value === e20 && !this.state.containsEsc;
  }
  isUnparsedContextual(e20, t2) {
    const s2 = e20 + t2.length;
    if (this.input.slice(e20, s2) === t2) {
      const e21 = this.input.charCodeAt(s2);
      return !(Yn$1(e21) || (64512 & e21) == 55296);
    }
    return false;
  }
  isLookaheadContextual(e20) {
    const t2 = this.nextTokenStart();
    return this.isUnparsedContextual(t2, e20);
  }
  eatContextual(e20) {
    return this.isContextual(e20) && this.eat(bn$1.name);
  }
  expectContextual(e20, t2) {
    this.eatContextual(e20) || this.unexpected(null, t2);
  }
  canInsertSemicolon() {
    return this.match(bn$1.eof) || this.match(bn$1.braceR) || this.hasPrecedingLineBreak();
  }
  hasPrecedingLineBreak() {
    return Pn$1.test(this.input.slice(this.state.lastTokEnd, this.state.start));
  }
  hasFollowingLineBreak() {
    return Bn$1.lastIndex = this.state.end, Bn$1.test(this.input);
  }
  isLineTerminator() {
    return this.eat(bn$1.semi) || this.canInsertSemicolon();
  }
  semicolon(e20 = true) {
    (e20 ? this.isLineTerminator() : this.eat(bn$1.semi)) || this.raise(this.state.lastTokEnd, Rn$1.MissingSemicolon);
  }
  expect(e20, t2) {
    this.eat(e20) || this.unexpected(t2, e20);
  }
  assertNoSpace(e20 = "Unexpected space.") {
    this.state.start > this.state.lastTokEnd && this.raise(this.state.lastTokEnd, {
      code: Mn$1.SyntaxError,
      reasonCode: "UnexpectedSpace",
      template: e20
    });
  }
  unexpected(e20, t2 = {
    code: Mn$1.SyntaxError,
    reasonCode: "UnexpectedToken",
    template: "Unexpected token"
  }) {
    throw t2 instanceof Cn$1 && (t2 = {
      code: Mn$1.SyntaxError,
      reasonCode: "UnexpectedToken",
      template: `Unexpected token, expected "${t2.label}"`
    }), this.raise(e20 != null ? e20 : this.state.start, t2);
  }
  expectPlugin(e20, t2) {
    if (!this.hasPlugin(e20))
      throw this.raiseWithData(t2 != null ? t2 : this.state.start, { missingPlugin: [e20] }, `This experimental syntax requires enabling the parser plugin: '${e20}'`);
    return true;
  }
  expectOnePlugin(e20, t2) {
    if (!e20.some((e21) => this.hasPlugin(e21)))
      throw this.raiseWithData(t2 != null ? t2 : this.state.start, { missingPlugin: e20 }, `This experimental syntax requires enabling one of the following parser plugin(s): '${e20.join(", ")}'`);
  }
  tryParse(e20, t2 = this.state.clone()) {
    const s2 = { node: null };
    try {
      const r2 = e20((e21 = null) => {
        throw s2.node = e21, s2;
      });
      if (this.state.errors.length > t2.errors.length) {
        const e21 = this.state;
        return this.state = t2, this.state.tokensLength = e21.tokensLength, {
          node: r2,
          error: e21.errors[t2.errors.length],
          thrown: false,
          aborted: false,
          failState: e21
        };
      }
      return {
        node: r2,
        error: null,
        thrown: false,
        aborted: false,
        failState: null
      };
    } catch (e21) {
      const r2 = this.state;
      if (this.state = t2, e21 instanceof SyntaxError)
        return {
          node: null,
          error: e21,
          thrown: true,
          aborted: false,
          failState: r2
        };
      if (e21 === s2)
        return {
          node: s2.node,
          error: null,
          thrown: false,
          aborted: true,
          failState: r2
        };
      throw e21;
    }
  }
  checkExpressionErrors(e20, t2) {
    if (!e20)
      return false;
    const { shorthandAssign: s2, doubleProto: r2, optionalParameters: i2 } = e20;
    if (!t2)
      return s2 >= 0 || r2 >= 0 || i2 >= 0;
    s2 >= 0 && this.unexpected(s2), r2 >= 0 && this.raise(r2, Rn$1.DuplicateProto), i2 >= 0 && this.unexpected(i2);
  }
  isLiteralPropertyName() {
    return this.match(bn$1.name) || !!this.state.type.keyword || this.match(bn$1.string) || this.match(bn$1.num) || this.match(bn$1.bigint) || this.match(bn$1.decimal);
  }
  isPrivateName(e20) {
    return e20.type === "PrivateName";
  }
  getPrivateNameSV(e20) {
    return e20.id.name;
  }
  hasPropertyAsPrivateName(e20) {
    return (e20.type === "MemberExpression" || e20.type === "OptionalMemberExpression") && this.isPrivateName(e20.property);
  }
  isOptionalChain(e20) {
    return e20.type === "OptionalMemberExpression" || e20.type === "OptionalCallExpression";
  }
  isObjectProperty(e20) {
    return e20.type === "ObjectProperty";
  }
  isObjectMethod(e20) {
    return e20.type === "ObjectMethod";
  }
  initializeScopes(e20 = this.options.sourceType === "module") {
    const t2 = this.state.labels;
    this.state.labels = [];
    const s2 = this.exportedIdentifiers;
    this.exportedIdentifiers = new Set();
    const r2 = this.inModule;
    this.inModule = e20;
    const i2 = this.scope, a2 = this.getScopeHandler();
    this.scope = new a2(this.raise.bind(this), this.inModule);
    const n2 = this.prodParam;
    this.prodParam = new To$1();
    const o2 = this.classScope;
    this.classScope = new xo$1(this.raise.bind(this));
    const u2 = this.expressionScope;
    return this.expressionScope = new bo$1(this.raise.bind(this)), () => {
      this.state.labels = t2, this.exportedIdentifiers = s2, this.inModule = r2, this.scope = i2, this.prodParam = n2, this.classScope = o2, this.expressionScope = u2;
    };
  }
  enterInitialScopes() {
    let e20 = 0;
    this.inModule && (e20 |= 2), this.scope.enter(1), this.prodParam.enter(e20);
  }
} {
  startNode() {
    return new Bo$1(this, this.state.start, this.state.startLoc);
  }
  startNodeAt(e20, t2) {
    return new Bo$1(this, e20, t2);
  }
  startNodeAtNode(e20) {
    return this.startNodeAt(e20.start, e20.loc.start);
  }
  finishNode(e20, t2) {
    return this.finishNodeAt(e20, t2, this.state.lastTokEnd, this.state.lastTokEndLoc);
  }
  finishNodeAt(e20, t2, s2, r2) {
    return e20.type = t2, e20.end = s2, e20.loc.end = r2, this.options.ranges && (e20.range[1] = s2), this.options.attachComment && this.processComment(e20), e20;
  }
  resetStartLocation(e20, t2, s2) {
    e20.start = t2, e20.loc.start = s2, this.options.ranges && (e20.range[0] = t2);
  }
  resetEndLocation(e20, t2 = this.state.lastTokEnd, s2 = this.state.lastTokEndLoc) {
    e20.end = t2, e20.loc.end = s2, this.options.ranges && (e20.range[1] = t2);
  }
  resetStartLocationFromNode(e20, t2) {
    this.resetStartLocation(e20, t2.start, t2.loc.start);
  }
} {
  toAssignable(e20, t2 = false) {
    var s2, r2;
    let i2;
    switch ((e20.type === "ParenthesizedExpression" || (s2 = e20.extra) != null && s2.parenthesized) && (i2 = nu(e20), t2 ? i2.type === "Identifier" ? this.expressionScope.recordParenthesizedIdentifierError(e20.start, Rn$1.InvalidParenthesizedAssignment) : i2.type !== "MemberExpression" && this.raise(e20.start, Rn$1.InvalidParenthesizedAssignment) : this.raise(e20.start, Rn$1.InvalidParenthesizedAssignment)), e20.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        e20.type = "ObjectPattern";
        for (let s3 = 0, r3 = e20.properties.length, i3 = r3 - 1; s3 < r3; s3++) {
          var a2;
          const r4 = e20.properties[s3], n2 = s3 === i3;
          this.toAssignableObjectExpressionProp(r4, n2, t2), n2 && r4.type === "RestElement" && (a2 = e20.extra) != null && a2.trailingComma && this.raiseRestNotLast(e20.extra.trailingComma);
        }
        break;
      case "ObjectProperty":
        this.toAssignable(e20.value, t2);
        break;
      case "SpreadElement": {
        this.checkToRestConversion(e20), e20.type = "RestElement";
        const s3 = e20.argument;
        this.toAssignable(s3, t2);
        break;
      }
      case "ArrayExpression":
        e20.type = "ArrayPattern", this.toAssignableList(e20.elements, (r2 = e20.extra) == null ? void 0 : r2.trailingComma, t2);
        break;
      case "AssignmentExpression":
        e20.operator !== "=" && this.raise(e20.left.end, Rn$1.MissingEqInAssignment), e20.type = "AssignmentPattern", delete e20.operator, this.toAssignable(e20.left, t2);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(i2, t2);
    }
    return e20;
  }
  toAssignableObjectExpressionProp(e20, t2, s2) {
    if (e20.type === "ObjectMethod") {
      const t3 = e20.kind === "get" || e20.kind === "set" ? Rn$1.PatternHasAccessor : Rn$1.PatternHasMethod;
      this.raise(e20.key.start, t3);
    } else
      e20.type !== "SpreadElement" || t2 ? this.toAssignable(e20, s2) : this.raiseRestNotLast(e20.start);
  }
  toAssignableList(e20, t2, s2) {
    let r2 = e20.length;
    if (r2) {
      const i2 = e20[r2 - 1];
      if ((i2 == null ? void 0 : i2.type) === "RestElement")
        --r2;
      else if ((i2 == null ? void 0 : i2.type) === "SpreadElement") {
        i2.type = "RestElement";
        let e21 = i2.argument;
        this.toAssignable(e21, s2), e21 = nu(e21), e21.type !== "Identifier" && e21.type !== "MemberExpression" && e21.type !== "ArrayPattern" && e21.type !== "ObjectPattern" && this.unexpected(e21.start), t2 && this.raiseTrailingCommaAfterRest(t2), --r2;
      }
    }
    for (let t3 = 0; t3 < r2; t3++) {
      const r3 = e20[t3];
      r3 && (this.toAssignable(r3, s2), r3.type === "RestElement" && this.raiseRestNotLast(r3.start));
    }
    return e20;
  }
  isAssignable(e20, t2) {
    switch (e20.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        return true;
      case "ObjectExpression": {
        const t3 = e20.properties.length - 1;
        return e20.properties.every((e21, s2) => e21.type !== "ObjectMethod" && (s2 === t3 || e21.type !== "SpreadElement") && this.isAssignable(e21));
      }
      case "ObjectProperty":
        return this.isAssignable(e20.value);
      case "SpreadElement":
        return this.isAssignable(e20.argument);
      case "ArrayExpression":
        return e20.elements.every((e21) => e21 === null || this.isAssignable(e21));
      case "AssignmentExpression":
        return e20.operator === "=";
      case "ParenthesizedExpression":
        return this.isAssignable(e20.expression);
      case "MemberExpression":
      case "OptionalMemberExpression":
        return !t2;
      default:
        return false;
    }
  }
  toReferencedList(e20, t2) {
    return e20;
  }
  toReferencedListDeep(e20, t2) {
    this.toReferencedList(e20, t2);
    for (const t3 of e20)
      (t3 == null ? void 0 : t3.type) === "ArrayExpression" && this.toReferencedListDeep(t3.elements);
  }
  parseSpread(e20, t2) {
    const s2 = this.startNode();
    return this.next(), s2.argument = this.parseMaybeAssignAllowIn(e20, void 0, t2), this.finishNode(s2, "SpreadElement");
  }
  parseRestBinding() {
    const e20 = this.startNode();
    return this.next(), e20.argument = this.parseBindingAtom(), this.finishNode(e20, "RestElement");
  }
  parseBindingAtom() {
    switch (this.state.type) {
      case bn$1.bracketL: {
        const e20 = this.startNode();
        return this.next(), e20.elements = this.parseBindingList(bn$1.bracketR, 93, true), this.finishNode(e20, "ArrayPattern");
      }
      case bn$1.braceL:
        return this.parseObjectLike(bn$1.braceR, true);
    }
    return this.parseIdentifier();
  }
  parseBindingList(e20, t2, s2, r2) {
    const i2 = [];
    let a2 = true;
    for (; !this.eat(e20); )
      if (a2 ? a2 = false : this.expect(bn$1.comma), s2 && this.match(bn$1.comma))
        i2.push(null);
      else {
        if (this.eat(e20))
          break;
        if (this.match(bn$1.ellipsis)) {
          i2.push(this.parseAssignableListItemTypes(this.parseRestBinding())), this.checkCommaAfterRest(t2), this.expect(e20);
          break;
        }
        {
          const e21 = [];
          for (this.match(bn$1.at) && this.hasPlugin("decorators") && this.raise(this.state.start, Rn$1.UnsupportedParameterDecorator); this.match(bn$1.at); )
            e21.push(this.parseDecorator());
          i2.push(this.parseAssignableListItem(r2, e21));
        }
      }
    return i2;
  }
  parseAssignableListItem(e20, t2) {
    const s2 = this.parseMaybeDefault();
    this.parseAssignableListItemTypes(s2);
    const r2 = this.parseMaybeDefault(s2.start, s2.loc.start, s2);
    return t2.length && (s2.decorators = t2), r2;
  }
  parseAssignableListItemTypes(e20) {
    return e20;
  }
  parseMaybeDefault(e20, t2, s2) {
    var r2, i2, a2;
    if (t2 = (r2 = t2) != null ? r2 : this.state.startLoc, e20 = (i2 = e20) != null ? i2 : this.state.start, s2 = (a2 = s2) != null ? a2 : this.parseBindingAtom(), !this.eat(bn$1.eq))
      return s2;
    const n2 = this.startNodeAt(e20, t2);
    return n2.left = s2, n2.right = this.parseMaybeAssignAllowIn(), this.finishNode(n2, "AssignmentPattern");
  }
  checkLVal(e20, t2, s2 = 64, r2, i2, a2 = false) {
    switch (e20.type) {
      case "Identifier": {
        const { name: t3 } = e20;
        this.state.strict && (a2 ? no$1(t3, this.inModule) : ao$1(t3)) && this.raise(e20.start, s2 === 64 ? Rn$1.StrictEvalArguments : Rn$1.StrictEvalArgumentsBinding, t3), r2 && (r2.has(t3) ? this.raise(e20.start, Rn$1.ParamDupe) : r2.add(t3)), i2 && t3 === "let" && this.raise(e20.start, Rn$1.LetInLexicalBinding), 64 & s2 || this.scope.declareName(t3, s2, e20.start);
        break;
      }
      case "MemberExpression":
        s2 !== 64 && this.raise(e20.start, Rn$1.InvalidPropertyBindingPattern);
        break;
      case "ObjectPattern":
        for (let t3 of e20.properties) {
          if (this.isObjectProperty(t3))
            t3 = t3.value;
          else if (this.isObjectMethod(t3))
            continue;
          this.checkLVal(t3, "object destructuring pattern", s2, r2, i2);
        }
        break;
      case "ArrayPattern":
        for (const t3 of e20.elements)
          t3 && this.checkLVal(t3, "array destructuring pattern", s2, r2, i2);
        break;
      case "AssignmentPattern":
        this.checkLVal(e20.left, "assignment pattern", s2, r2);
        break;
      case "RestElement":
        this.checkLVal(e20.argument, "rest element", s2, r2);
        break;
      case "ParenthesizedExpression":
        this.checkLVal(e20.expression, "parenthesized expression", s2, r2);
        break;
      default:
        this.raise(e20.start, s2 === 64 ? Rn$1.InvalidLhs : Rn$1.InvalidLhsBinding, t2);
    }
  }
  checkToRestConversion(e20) {
    e20.argument.type !== "Identifier" && e20.argument.type !== "MemberExpression" && this.raise(e20.argument.start, Rn$1.InvalidRestAssignmentPattern);
  }
  checkCommaAfterRest(e20) {
    this.match(bn$1.comma) && (this.lookaheadCharCode() === e20 ? this.raiseTrailingCommaAfterRest(this.state.start) : this.raiseRestNotLast(this.state.start));
  }
  raiseRestNotLast(e20) {
    throw this.raise(e20, Rn$1.ElementAfterRest);
  }
  raiseTrailingCommaAfterRest(e20) {
    this.raise(e20, Rn$1.RestTrailingComma);
  }
} {
  checkProto(e20, t2, s2, r2) {
    if (e20.type === "SpreadElement" || this.isObjectMethod(e20) || e20.computed || e20.shorthand)
      return;
    const i2 = e20.key;
    if ((i2.type === "Identifier" ? i2.name : i2.value) === "__proto__") {
      if (t2)
        return void this.raise(i2.start, Rn$1.RecordNoProto);
      s2.used && (r2 ? r2.doubleProto === -1 && (r2.doubleProto = i2.start) : this.raise(i2.start, Rn$1.DuplicateProto)), s2.used = true;
    }
  }
  shouldExitDescending(e20, t2) {
    return e20.type === "ArrowFunctionExpression" && e20.start === t2;
  }
  getExpression() {
    this.enterInitialScopes(), this.nextToken();
    const e20 = this.parseExpression();
    return this.match(bn$1.eof) || this.unexpected(), this.finalizeRemainingComments(), e20.comments = this.state.comments, e20.errors = this.state.errors, this.options.tokens && (e20.tokens = this.tokens), e20;
  }
  parseExpression(e20, t2) {
    return e20 ? this.disallowInAnd(() => this.parseExpressionBase(t2)) : this.allowInAnd(() => this.parseExpressionBase(t2));
  }
  parseExpressionBase(e20) {
    const t2 = this.state.start, s2 = this.state.startLoc, r2 = this.parseMaybeAssign(e20);
    if (this.match(bn$1.comma)) {
      const i2 = this.startNodeAt(t2, s2);
      for (i2.expressions = [r2]; this.eat(bn$1.comma); )
        i2.expressions.push(this.parseMaybeAssign(e20));
      return this.toReferencedList(i2.expressions), this.finishNode(i2, "SequenceExpression");
    }
    return r2;
  }
  parseMaybeAssignDisallowIn(e20, t2) {
    return this.disallowInAnd(() => this.parseMaybeAssign(e20, t2));
  }
  parseMaybeAssignAllowIn(e20, t2) {
    return this.allowInAnd(() => this.parseMaybeAssign(e20, t2));
  }
  setOptionalParametersError(e20, t2) {
    var s2;
    e20.optionalParameters = (s2 = t2 == null ? void 0 : t2.pos) != null ? s2 : this.state.start;
  }
  parseMaybeAssign(e20, t2) {
    const s2 = this.state.start, r2 = this.state.startLoc;
    if (this.isContextual("yield") && this.prodParam.hasYield) {
      let e21 = this.parseYield();
      return t2 && (e21 = t2.call(this, e21, s2, r2)), e21;
    }
    let i2;
    e20 ? i2 = false : (e20 = new So$1(), i2 = true), (this.match(bn$1.parenL) || this.match(bn$1.name)) && (this.state.potentialArrowAt = this.state.start);
    let a2 = this.parseMaybeConditional(e20);
    if (t2 && (a2 = t2.call(this, a2, s2, r2)), this.state.type.isAssign) {
      const t3 = this.startNodeAt(s2, r2), i3 = this.state.value;
      t3.operator = i3;
      if (a2.type === "BinaryExpression" && a2.operator === "|>" && this.getPluginOption("pipelineOperator", "proposal") === "hack")
        throw this.raise(this.state.start, Rn$1.PipeBodyIsTighter, i3);
      return this.match(bn$1.eq) ? (t3.left = this.toAssignable(a2, true), e20.doubleProto = -1) : t3.left = a2, e20.shorthandAssign >= t3.left.start && (e20.shorthandAssign = -1), this.checkLVal(a2, "assignment expression"), this.next(), t3.right = this.parseMaybeAssign(), this.finishNode(t3, "AssignmentExpression");
    }
    return i2 && this.checkExpressionErrors(e20, true), a2;
  }
  parseMaybeConditional(e20) {
    const t2 = this.state.start, s2 = this.state.startLoc, r2 = this.state.potentialArrowAt, i2 = this.parseExprOps(e20);
    return this.shouldExitDescending(i2, r2) ? i2 : this.parseConditional(i2, t2, s2, e20);
  }
  parseConditional(e20, t2, s2, r2) {
    if (this.eat(bn$1.question)) {
      const r3 = this.startNodeAt(t2, s2);
      return r3.test = e20, r3.consequent = this.parseMaybeAssignAllowIn(), this.expect(bn$1.colon), r3.alternate = this.parseMaybeAssign(), this.finishNode(r3, "ConditionalExpression");
    }
    return e20;
  }
  parseMaybeUnaryOrPrivate(e20) {
    return this.match(bn$1.privateName) ? this.parsePrivateName() : this.parseMaybeUnary(e20);
  }
  parseExprOps(e20) {
    const t2 = this.state.start, s2 = this.state.startLoc, r2 = this.state.potentialArrowAt, i2 = this.parseMaybeUnaryOrPrivate(e20);
    return this.shouldExitDescending(i2, r2) ? i2 : this.parseExprOp(i2, t2, s2, -1);
  }
  parseExprOp(e20, t2, s2, r2) {
    if (this.isPrivateName(e20)) {
      const t3 = this.getPrivateNameSV(e20), { start: s3 } = e20;
      (r2 >= bn$1._in.binop || !this.prodParam.hasIn || !this.match(bn$1._in)) && this.raise(s3, Rn$1.PrivateInExpectedIn, t3), this.classScope.usePrivateName(t3, s3);
    }
    let i2 = this.state.type.binop;
    if (i2 != null && (this.prodParam.hasIn || !this.match(bn$1._in)) && i2 > r2) {
      const a2 = this.state.type;
      if (a2 === bn$1.pipeline) {
        if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
          return e20;
        this.checkPipelineAtInfixOperator(e20, t2);
      }
      const n2 = this.startNodeAt(t2, s2);
      n2.left = e20, n2.operator = this.state.value;
      const o2 = a2 === bn$1.logicalOR || a2 === bn$1.logicalAND, u2 = a2 === bn$1.nullishCoalescing;
      if (u2 && (i2 = bn$1.logicalAND.binop), this.next(), a2 === bn$1.pipeline && this.getPluginOption("pipelineOperator", "proposal") === "minimal" && this.match(bn$1.name) && this.state.value === "await" && this.prodParam.hasAwait)
        throw this.raise(this.state.start, Rn$1.UnexpectedAwaitAfterPipelineBody);
      n2.right = this.parseExprOpRightExpr(a2, i2), this.finishNode(n2, o2 || u2 ? "LogicalExpression" : "BinaryExpression");
      const h2 = this.state.type;
      if (u2 && (h2 === bn$1.logicalOR || h2 === bn$1.logicalAND) || o2 && h2 === bn$1.nullishCoalescing)
        throw this.raise(this.state.start, Rn$1.MixingCoalesceWithLogical);
      return this.parseExprOp(n2, t2, s2, r2);
    }
    return e20;
  }
  parseExprOpRightExpr(e20, t2) {
    const s2 = this.state.start, r2 = this.state.startLoc;
    switch (e20) {
      case bn$1.pipeline:
        switch (this.getPluginOption("pipelineOperator", "proposal")) {
          case "hack":
            return this.withTopicBindingContext(() => {
              const r3 = this.parseHackPipeBody(e20, t2);
              return this.checkHackPipeBodyEarlyErrors(s2), r3;
            });
          case "smart":
            return this.withTopicBindingContext(() => {
              const i2 = this.parseHackPipeBody(e20, t2);
              return this.parseSmartPipelineBodyInStyle(i2, s2, r2);
            });
          case "fsharp":
            return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(t2));
        }
      default:
        return this.parseExprOpBaseRightExpr(e20, t2);
    }
  }
  parseExprOpBaseRightExpr(e20, t2) {
    const s2 = this.state.start, r2 = this.state.startLoc;
    return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), s2, r2, e20.rightAssociative ? t2 - 1 : t2);
  }
  parseHackPipeBody(e20, t2) {
    if (this.prodParam.hasYield && this.isContextual("yield"))
      throw this.raise(this.state.start, Rn$1.PipeBodyIsTighter, this.state.value);
    return this.parseExprOpBaseRightExpr(e20, t2);
  }
  checkExponentialAfterUnary(e20) {
    this.match(bn$1.exponent) && this.raise(e20.argument.start, Rn$1.UnexpectedTokenUnaryExponentiation);
  }
  parseMaybeUnary(e20, t2) {
    const s2 = this.state.start, r2 = this.state.startLoc, i2 = this.isContextual("await");
    if (i2 && this.isAwaitAllowed()) {
      this.next();
      const e21 = this.parseAwait(s2, r2);
      return t2 || this.checkExponentialAfterUnary(e21), e21;
    }
    const a2 = this.match(bn$1.incDec), n2 = this.startNode();
    if (this.state.type.prefix) {
      n2.operator = this.state.value, n2.prefix = true, this.match(bn$1._throw) && this.expectPlugin("throwExpressions");
      const s3 = this.match(bn$1._delete);
      if (this.next(), n2.argument = this.parseMaybeUnary(null, true), this.checkExpressionErrors(e20, true), this.state.strict && s3) {
        const e21 = n2.argument;
        e21.type === "Identifier" ? this.raise(n2.start, Rn$1.StrictDelete) : this.hasPropertyAsPrivateName(e21) && this.raise(n2.start, Rn$1.DeletePrivateField);
      }
      if (!a2)
        return t2 || this.checkExponentialAfterUnary(n2), this.finishNode(n2, "UnaryExpression");
    }
    const o2 = this.parseUpdate(n2, a2, e20);
    if (i2) {
      if ((this.hasPlugin("v8intrinsic") ? this.state.type.startsExpr : this.state.type.startsExpr && !this.match(bn$1.modulo)) && !this.isAmbiguousAwait())
        return this.raiseOverwrite(s2, Rn$1.AwaitNotInAsyncContext), this.parseAwait(s2, r2);
    }
    return o2;
  }
  parseUpdate(e20, t2, s2) {
    if (t2)
      return this.checkLVal(e20.argument, "prefix operation"), this.finishNode(e20, "UpdateExpression");
    const r2 = this.state.start, i2 = this.state.startLoc;
    let a2 = this.parseExprSubscripts(s2);
    if (this.checkExpressionErrors(s2, false))
      return a2;
    for (; this.state.type.postfix && !this.canInsertSemicolon(); ) {
      const e21 = this.startNodeAt(r2, i2);
      e21.operator = this.state.value, e21.prefix = false, e21.argument = a2, this.checkLVal(a2, "postfix operation"), this.next(), a2 = this.finishNode(e21, "UpdateExpression");
    }
    return a2;
  }
  parseExprSubscripts(e20) {
    const t2 = this.state.start, s2 = this.state.startLoc, r2 = this.state.potentialArrowAt, i2 = this.parseExprAtom(e20);
    return this.shouldExitDescending(i2, r2) ? i2 : this.parseSubscripts(i2, t2, s2);
  }
  parseSubscripts(e20, t2, s2, r2) {
    const i2 = {
      optionalChainMember: false,
      maybeAsyncArrow: this.atPossibleAsyncArrow(e20),
      stop: false
    };
    do {
      e20 = this.parseSubscript(e20, t2, s2, r2, i2), i2.maybeAsyncArrow = false;
    } while (!i2.stop);
    return e20;
  }
  parseSubscript(e20, t2, s2, r2, i2) {
    if (!r2 && this.eat(bn$1.doubleColon))
      return this.parseBind(e20, t2, s2, r2, i2);
    if (this.match(bn$1.backQuote))
      return this.parseTaggedTemplateExpression(e20, t2, s2, i2);
    let a2 = false;
    if (this.match(bn$1.questionDot)) {
      if (r2 && this.lookaheadCharCode() === 40)
        return i2.stop = true, e20;
      i2.optionalChainMember = a2 = true, this.next();
    }
    if (!r2 && this.match(bn$1.parenL))
      return this.parseCoverCallAndAsyncArrowHead(e20, t2, s2, i2, a2);
    {
      const r3 = this.eat(bn$1.bracketL);
      return r3 || a2 || this.eat(bn$1.dot) ? this.parseMember(e20, t2, s2, i2, r3, a2) : (i2.stop = true, e20);
    }
  }
  parseMember(e20, t2, s2, r2, i2, a2) {
    const n2 = this.startNodeAt(t2, s2);
    n2.object = e20, n2.computed = i2;
    const o2 = !i2 && this.match(bn$1.privateName) && this.state.value, u2 = i2 ? this.parseExpression() : o2 ? this.parsePrivateName() : this.parseIdentifier(true);
    return o2 !== false && (n2.object.type === "Super" && this.raise(t2, Rn$1.SuperPrivateField), this.classScope.usePrivateName(o2, u2.start)), n2.property = u2, i2 && this.expect(bn$1.bracketR), r2.optionalChainMember ? (n2.optional = a2, this.finishNode(n2, "OptionalMemberExpression")) : this.finishNode(n2, "MemberExpression");
  }
  parseBind(e20, t2, s2, r2, i2) {
    const a2 = this.startNodeAt(t2, s2);
    return a2.object = e20, a2.callee = this.parseNoCallExpr(), i2.stop = true, this.parseSubscripts(this.finishNode(a2, "BindExpression"), t2, s2, r2);
  }
  parseCoverCallAndAsyncArrowHead(e20, t2, s2, r2, i2) {
    const a2 = this.state.maybeInArrowParameters;
    let n2 = null;
    this.state.maybeInArrowParameters = true, this.next();
    let o2 = this.startNodeAt(t2, s2);
    return o2.callee = e20, r2.maybeAsyncArrow && (this.expressionScope.enter(new go$1(2)), n2 = new So$1()), r2.optionalChainMember && (o2.optional = i2), o2.arguments = i2 ? this.parseCallExpressionArguments(bn$1.parenR) : this.parseCallExpressionArguments(bn$1.parenR, e20.type === "Import", e20.type !== "Super", o2, n2), this.finishCallExpression(o2, r2.optionalChainMember), r2.maybeAsyncArrow && this.shouldParseAsyncArrow() && !i2 ? (r2.stop = true, this.expressionScope.validateAsPattern(), this.expressionScope.exit(), o2 = this.parseAsyncArrowFromCallExpression(this.startNodeAt(t2, s2), o2)) : (r2.maybeAsyncArrow && (this.checkExpressionErrors(n2, true), this.expressionScope.exit()), this.toReferencedArguments(o2)), this.state.maybeInArrowParameters = a2, o2;
  }
  toReferencedArguments(e20, t2) {
    this.toReferencedListDeep(e20.arguments, t2);
  }
  parseTaggedTemplateExpression(e20, t2, s2, r2) {
    const i2 = this.startNodeAt(t2, s2);
    return i2.tag = e20, i2.quasi = this.parseTemplate(true), r2.optionalChainMember && this.raise(t2, Rn$1.OptionalChainingNoTemplate), this.finishNode(i2, "TaggedTemplateExpression");
  }
  atPossibleAsyncArrow(e20) {
    return e20.type === "Identifier" && e20.name === "async" && this.state.lastTokEnd === e20.end && !this.canInsertSemicolon() && e20.end - e20.start == 5 && e20.start === this.state.potentialArrowAt;
  }
  finishCallExpression(e20, t2) {
    if (e20.callee.type === "Import")
      if (e20.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectPlugin("importAssertions")), e20.arguments.length === 0 || e20.arguments.length > 2)
        this.raise(e20.start, Rn$1.ImportCallArity, this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? "one or two arguments" : "one argument");
      else
        for (const t3 of e20.arguments)
          t3.type === "SpreadElement" && this.raise(t3.start, Rn$1.ImportCallSpreadArgument);
    return this.finishNode(e20, t2 ? "OptionalCallExpression" : "CallExpression");
  }
  parseCallExpressionArguments(e20, t2, s2, r2, i2) {
    const a2 = [];
    let n2 = true;
    const o2 = this.state.inFSharpPipelineDirectBody;
    for (this.state.inFSharpPipelineDirectBody = false; !this.eat(e20); ) {
      if (n2)
        n2 = false;
      else if (this.expect(bn$1.comma), this.match(e20)) {
        !t2 || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") || this.raise(this.state.lastTokStart, Rn$1.ImportCallArgumentTrailingComma), r2 && this.addExtra(r2, "trailingComma", this.state.lastTokStart), this.next();
        break;
      }
      a2.push(this.parseExprListItem(false, i2, s2));
    }
    return this.state.inFSharpPipelineDirectBody = o2, a2;
  }
  shouldParseAsyncArrow() {
    return this.match(bn$1.arrow) && !this.canInsertSemicolon();
  }
  parseAsyncArrowFromCallExpression(e20, t2) {
    var s2;
    return this.resetPreviousNodeTrailingComments(t2), this.expect(bn$1.arrow), this.parseArrowExpression(e20, t2.arguments, true, (s2 = t2.extra) == null ? void 0 : s2.trailingComma), Ln$1(e20, t2.innerComments), Ln$1(e20, t2.callee.trailingComments), e20;
  }
  parseNoCallExpr() {
    const e20 = this.state.start, t2 = this.state.startLoc;
    return this.parseSubscripts(this.parseExprAtom(), e20, t2, true);
  }
  parseExprAtom(e20) {
    let t2;
    switch (this.state.type) {
      case bn$1._super:
        return this.parseSuper();
      case bn$1._import:
        return t2 = this.startNode(), this.next(), this.match(bn$1.dot) ? this.parseImportMetaProperty(t2) : (this.match(bn$1.parenL) || this.raise(this.state.lastTokStart, Rn$1.UnsupportedImport), this.finishNode(t2, "Import"));
      case bn$1._this:
        return t2 = this.startNode(), this.next(), this.finishNode(t2, "ThisExpression");
      case bn$1.name: {
        if (this.isContextual("module") && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak())
          return this.parseModuleExpression();
        const e21 = this.state.potentialArrowAt === this.state.start, t3 = this.state.containsEsc, s2 = this.parseIdentifier();
        if (!t3 && s2.name === "async" && !this.canInsertSemicolon()) {
          if (this.match(bn$1._function))
            return this.resetPreviousNodeTrailingComments(s2), this.next(), this.parseFunction(this.startNodeAtNode(s2), void 0, true);
          if (this.match(bn$1.name))
            return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(s2)) : s2;
          if (this.match(bn$1._do))
            return this.resetPreviousNodeTrailingComments(s2), this.parseDo(this.startNodeAtNode(s2), true);
        }
        return e21 && this.match(bn$1.arrow) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(s2), [s2], false)) : s2;
      }
      case bn$1._do:
        return this.parseDo(this.startNode(), false);
      case bn$1.slash:
      case bn$1.slashAssign:
        return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
      case bn$1.num:
        return this.parseNumericLiteral(this.state.value);
      case bn$1.bigint:
        return this.parseBigIntLiteral(this.state.value);
      case bn$1.decimal:
        return this.parseDecimalLiteral(this.state.value);
      case bn$1.string:
        return this.parseStringLiteral(this.state.value);
      case bn$1._null:
        return this.parseNullLiteral();
      case bn$1._true:
        return this.parseBooleanLiteral(true);
      case bn$1._false:
        return this.parseBooleanLiteral(false);
      case bn$1.parenL: {
        const e21 = this.state.potentialArrowAt === this.state.start;
        return this.parseParenAndDistinguishExpression(e21);
      }
      case bn$1.bracketBarL:
      case bn$1.bracketHashL:
        return this.parseArrayLike(this.state.type === bn$1.bracketBarL ? bn$1.bracketBarR : bn$1.bracketR, false, true, e20);
      case bn$1.bracketL:
        return this.parseArrayLike(bn$1.bracketR, true, false, e20);
      case bn$1.braceBarL:
      case bn$1.braceHashL:
        return this.parseObjectLike(this.state.type === bn$1.braceBarL ? bn$1.braceBarR : bn$1.braceR, false, true, e20);
      case bn$1.braceL:
        return this.parseObjectLike(bn$1.braceR, false, false, e20);
      case bn$1._function:
        return this.parseFunctionOrFunctionSent();
      case bn$1.at:
        this.parseDecorators();
      case bn$1._class:
        return t2 = this.startNode(), this.takeDecorators(t2), this.parseClass(t2, false);
      case bn$1._new:
        return this.parseNewOrNewTarget();
      case bn$1.backQuote:
        return this.parseTemplate(false);
      case bn$1.doubleColon: {
        t2 = this.startNode(), this.next(), t2.object = null;
        const e21 = t2.callee = this.parseNoCallExpr();
        if (e21.type === "MemberExpression")
          return this.finishNode(t2, "BindExpression");
        throw this.raise(e21.start, Rn$1.UnsupportedBind);
      }
      case bn$1.privateName:
        return this.raise(this.state.start, Rn$1.PrivateInExpectedIn, this.state.value), this.parsePrivateName();
      case bn$1.moduloAssign:
        if (this.getPluginOption("pipelineOperator", "proposal") !== "hack" || this.getPluginOption("pipelineOperator", "topicToken") !== "%")
          throw this.unexpected();
        this.state.value = "%", this.state.type = bn$1.modulo, this.state.pos--, this.state.end--, this.state.endLoc.column--;
      case bn$1.modulo:
      case bn$1.hash: {
        const e21 = this.getPluginOption("pipelineOperator", "proposal");
        if (e21) {
          t2 = this.startNode();
          const s2 = this.state.start, r2 = this.state.type;
          return this.next(), this.finishTopicReference(t2, s2, e21, r2);
        }
      }
      case bn$1.relational:
        if (this.state.value === "<") {
          const e21 = this.input.codePointAt(this.nextTokenStart());
          (Jn$1(e21) || e21 === 62) && this.expectOnePlugin(["jsx", "flow", "typescript"]);
        }
      default:
        throw this.unexpected();
    }
  }
  finishTopicReference(e20, t2, s2, r2) {
    if (this.testTopicReferenceConfiguration(s2, t2, r2)) {
      let r3;
      return r3 = s2 === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference", this.topicReferenceIsAllowedInCurrentContext() || (s2 === "smart" ? this.raise(t2, Rn$1.PrimaryTopicNotAllowed) : this.raise(t2, Rn$1.PipeTopicUnbound)), this.registerTopicReference(), this.finishNode(e20, r3);
    }
    throw this.raise(t2, Rn$1.PipeTopicUnconfiguredToken, r2.label);
  }
  testTopicReferenceConfiguration(e20, t2, s2) {
    switch (e20) {
      case "hack": {
        const e21 = this.getPluginOption("pipelineOperator", "topicToken");
        return s2.label === e21;
      }
      case "smart":
        return s2 === bn$1.hash;
      default:
        throw this.raise(t2, Rn$1.PipeTopicRequiresHackPipes);
    }
  }
  parseAsyncArrowUnaryFunction(e20) {
    this.prodParam.enter(wo$1(true, this.prodParam.hasYield));
    const t2 = [this.parseIdentifier()];
    return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(this.state.pos, Rn$1.LineTerminatorBeforeArrow), this.expect(bn$1.arrow), this.parseArrowExpression(e20, t2, true), e20;
  }
  parseDo(e20, t2) {
    this.expectPlugin("doExpressions"), t2 && this.expectPlugin("asyncDoExpressions"), e20.async = t2, this.next();
    const s2 = this.state.labels;
    return this.state.labels = [], t2 ? (this.prodParam.enter(2), e20.body = this.parseBlock(), this.prodParam.exit()) : e20.body = this.parseBlock(), this.state.labels = s2, this.finishNode(e20, "DoExpression");
  }
  parseSuper() {
    const e20 = this.startNode();
    return this.next(), !this.match(bn$1.parenL) || this.scope.allowDirectSuper || this.options.allowSuperOutsideMethod ? this.scope.allowSuper || this.options.allowSuperOutsideMethod || this.raise(e20.start, Rn$1.UnexpectedSuper) : this.raise(e20.start, Rn$1.SuperNotAllowed), this.match(bn$1.parenL) || this.match(bn$1.bracketL) || this.match(bn$1.dot) || this.raise(e20.start, Rn$1.UnsupportedSuper), this.finishNode(e20, "Super");
  }
  parseMaybePrivateName(e20) {
    return this.match(bn$1.privateName) ? (e20 || this.raise(this.state.start + 1, Rn$1.UnexpectedPrivateField), this.parsePrivateName()) : this.parseIdentifier(true);
  }
  parsePrivateName() {
    const e20 = this.startNode(), t2 = this.startNodeAt(this.state.start + 1, new In$1(this.state.curLine, this.state.start + 1 - this.state.lineStart)), s2 = this.state.value;
    return this.next(), e20.id = this.createIdentifier(t2, s2), this.finishNode(e20, "PrivateName");
  }
  parseFunctionOrFunctionSent() {
    const e20 = this.startNode();
    if (this.next(), this.prodParam.hasYield && this.match(bn$1.dot)) {
      const t2 = this.createIdentifier(this.startNodeAtNode(e20), "function");
      return this.next(), this.parseMetaProperty(e20, t2, "sent");
    }
    return this.parseFunction(e20);
  }
  parseMetaProperty(e20, t2, s2) {
    e20.meta = t2, t2.name === "function" && s2 === "sent" && (this.isContextual(s2) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected());
    const r2 = this.state.containsEsc;
    return e20.property = this.parseIdentifier(true), (e20.property.name !== s2 || r2) && this.raise(e20.property.start, Rn$1.UnsupportedMetaProperty, t2.name, s2), this.finishNode(e20, "MetaProperty");
  }
  parseImportMetaProperty(e20) {
    const t2 = this.createIdentifier(this.startNodeAtNode(e20), "import");
    return this.next(), this.isContextual("meta") && (this.inModule || this.raise(t2.start, jn$1.ImportMetaOutsideModule), this.sawUnambiguousESM = true), this.parseMetaProperty(e20, t2, "meta");
  }
  parseLiteralAtNode(e20, t2, s2) {
    return this.addExtra(s2, "rawValue", e20), this.addExtra(s2, "raw", this.input.slice(s2.start, this.state.end)), s2.value = e20, this.next(), this.finishNode(s2, t2);
  }
  parseLiteral(e20, t2) {
    const s2 = this.startNode();
    return this.parseLiteralAtNode(e20, t2, s2);
  }
  parseStringLiteral(e20) {
    return this.parseLiteral(e20, "StringLiteral");
  }
  parseNumericLiteral(e20) {
    return this.parseLiteral(e20, "NumericLiteral");
  }
  parseBigIntLiteral(e20) {
    return this.parseLiteral(e20, "BigIntLiteral");
  }
  parseDecimalLiteral(e20) {
    return this.parseLiteral(e20, "DecimalLiteral");
  }
  parseRegExpLiteral(e20) {
    const t2 = this.parseLiteral(e20.value, "RegExpLiteral");
    return t2.pattern = e20.pattern, t2.flags = e20.flags, t2;
  }
  parseBooleanLiteral(e20) {
    const t2 = this.startNode();
    return t2.value = e20, this.next(), this.finishNode(t2, "BooleanLiteral");
  }
  parseNullLiteral() {
    const e20 = this.startNode();
    return this.next(), this.finishNode(e20, "NullLiteral");
  }
  parseParenAndDistinguishExpression(e20) {
    const t2 = this.state.start, s2 = this.state.startLoc;
    let r2;
    this.next(), this.expressionScope.enter(new go$1(1));
    const i2 = this.state.maybeInArrowParameters, a2 = this.state.inFSharpPipelineDirectBody;
    this.state.maybeInArrowParameters = true, this.state.inFSharpPipelineDirectBody = false;
    const n2 = this.state.start, o2 = this.state.startLoc, u2 = [], h2 = new So$1();
    let c2, p2, l2 = true;
    for (; !this.match(bn$1.parenR); ) {
      if (l2)
        l2 = false;
      else if (this.expect(bn$1.comma, h2.optionalParameters === -1 ? null : h2.optionalParameters), this.match(bn$1.parenR)) {
        p2 = this.state.start;
        break;
      }
      if (this.match(bn$1.ellipsis)) {
        const e21 = this.state.start, t3 = this.state.startLoc;
        c2 = this.state.start, u2.push(this.parseParenItem(this.parseRestBinding(), e21, t3)), this.checkCommaAfterRest(41);
        break;
      }
      u2.push(this.parseMaybeAssignAllowIn(h2, this.parseParenItem));
    }
    const d2 = this.state.lastTokEnd, D2 = this.state.lastTokEndLoc;
    this.expect(bn$1.parenR), this.state.maybeInArrowParameters = i2, this.state.inFSharpPipelineDirectBody = a2;
    let m2 = this.startNodeAt(t2, s2);
    if (e20 && this.shouldParseArrow(u2) && (m2 = this.parseArrow(m2)))
      return this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(m2, u2, false), m2;
    if (this.expressionScope.exit(), u2.length || this.unexpected(this.state.lastTokStart), p2 && this.unexpected(p2), c2 && this.unexpected(c2), this.checkExpressionErrors(h2, true), this.toReferencedListDeep(u2, true), u2.length > 1 ? (r2 = this.startNodeAt(n2, o2), r2.expressions = u2, this.finishNode(r2, "SequenceExpression"), r2.end = d2, r2.loc.end = D2) : r2 = u2[0], !this.options.createParenthesizedExpressions)
      return this.addExtra(r2, "parenthesized", true), this.addExtra(r2, "parenStart", t2), r2;
    const f2 = this.startNodeAt(t2, s2);
    return f2.expression = r2, this.finishNode(f2, "ParenthesizedExpression"), f2;
  }
  shouldParseArrow(e20) {
    return !this.canInsertSemicolon();
  }
  parseArrow(e20) {
    if (this.eat(bn$1.arrow))
      return e20;
  }
  parseParenItem(e20, t2, s2) {
    return e20;
  }
  parseNewOrNewTarget() {
    const e20 = this.startNode();
    if (this.next(), this.match(bn$1.dot)) {
      const t2 = this.createIdentifier(this.startNodeAtNode(e20), "new");
      this.next();
      const s2 = this.parseMetaProperty(e20, t2, "target");
      return this.scope.inNonArrowFunction || this.scope.inClass || this.raise(s2.start, Rn$1.UnexpectedNewTarget), s2;
    }
    return this.parseNew(e20);
  }
  parseNew(e20) {
    return e20.callee = this.parseNoCallExpr(), e20.callee.type === "Import" ? this.raise(e20.callee.start, Rn$1.ImportCallNotNewExpression) : this.isOptionalChain(e20.callee) ? this.raise(this.state.lastTokEnd, Rn$1.OptionalChainingNoNew) : this.eat(bn$1.questionDot) && this.raise(this.state.start, Rn$1.OptionalChainingNoNew), this.parseNewArguments(e20), this.finishNode(e20, "NewExpression");
  }
  parseNewArguments(e20) {
    if (this.eat(bn$1.parenL)) {
      const t2 = this.parseExprList(bn$1.parenR);
      this.toReferencedList(t2), e20.arguments = t2;
    } else
      e20.arguments = [];
  }
  parseTemplateElement(e20) {
    const t2 = this.startNode();
    return this.state.value === null && (e20 || this.raise(this.state.start + 1, Rn$1.InvalidEscapeSequenceTemplate)), t2.value = {
      raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"),
      cooked: this.state.value
    }, this.next(), t2.tail = this.match(bn$1.backQuote), this.finishNode(t2, "TemplateElement");
  }
  parseTemplate(e20) {
    const t2 = this.startNode();
    this.next(), t2.expressions = [];
    let s2 = this.parseTemplateElement(e20);
    for (t2.quasis = [s2]; !s2.tail; )
      this.expect(bn$1.dollarBraceL), t2.expressions.push(this.parseTemplateSubstitution()), this.expect(bn$1.braceR), t2.quasis.push(s2 = this.parseTemplateElement(e20));
    return this.next(), this.finishNode(t2, "TemplateLiteral");
  }
  parseTemplateSubstitution() {
    return this.parseExpression();
  }
  parseObjectLike(e20, t2, s2, r2) {
    s2 && this.expectPlugin("recordAndTuple");
    const i2 = this.state.inFSharpPipelineDirectBody;
    this.state.inFSharpPipelineDirectBody = false;
    const a2 = Object.create(null);
    let n2 = true;
    const o2 = this.startNode();
    for (o2.properties = [], this.next(); !this.match(e20); ) {
      if (n2)
        n2 = false;
      else if (this.expect(bn$1.comma), this.match(e20)) {
        this.addExtra(o2, "trailingComma", this.state.lastTokStart);
        break;
      }
      const i3 = this.parsePropertyDefinition(t2, r2);
      t2 || this.checkProto(i3, s2, a2, r2), s2 && !this.isObjectProperty(i3) && i3.type !== "SpreadElement" && this.raise(i3.start, Rn$1.InvalidRecordProperty), i3.shorthand && this.addExtra(i3, "shorthand", true), o2.properties.push(i3);
    }
    this.next(), this.state.inFSharpPipelineDirectBody = i2;
    let u2 = "ObjectExpression";
    return t2 ? u2 = "ObjectPattern" : s2 && (u2 = "RecordExpression"), this.finishNode(o2, u2);
  }
  maybeAsyncOrAccessorProp(e20) {
    return !e20.computed && e20.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(bn$1.bracketL) || this.match(bn$1.star));
  }
  parsePropertyDefinition(e20, t2) {
    let s2 = [];
    if (this.match(bn$1.at))
      for (this.hasPlugin("decorators") && this.raise(this.state.start, Rn$1.UnsupportedPropertyDecorator); this.match(bn$1.at); )
        s2.push(this.parseDecorator());
    const r2 = this.startNode();
    let i2, a2, n2 = false, o2 = false, u2 = false;
    if (this.match(bn$1.ellipsis))
      return s2.length && this.unexpected(), e20 ? (this.next(), r2.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(r2, "RestElement")) : this.parseSpread();
    s2.length && (r2.decorators = s2, s2 = []), r2.method = false, (e20 || t2) && (i2 = this.state.start, a2 = this.state.startLoc), e20 || (n2 = this.eat(bn$1.star));
    const h2 = this.state.containsEsc, c2 = this.parsePropertyName(r2, false);
    if (!e20 && !n2 && !h2 && this.maybeAsyncOrAccessorProp(r2)) {
      const e21 = c2.name;
      e21 !== "async" || this.hasPrecedingLineBreak() || (o2 = true, this.resetPreviousNodeTrailingComments(c2), n2 = this.eat(bn$1.star), this.parsePropertyName(r2, false)), e21 !== "get" && e21 !== "set" || (u2 = true, this.resetPreviousNodeTrailingComments(c2), r2.kind = e21, this.match(bn$1.star) && (n2 = true, this.raise(this.state.pos, Rn$1.AccessorIsGenerator, e21), this.next()), this.parsePropertyName(r2, false));
    }
    return this.parseObjPropValue(r2, i2, a2, n2, o2, e20, u2, t2), r2;
  }
  getGetterSetterExpectedParamCount(e20) {
    return e20.kind === "get" ? 0 : 1;
  }
  getObjectOrClassMethodParams(e20) {
    return e20.params;
  }
  checkGetterSetterParams(e20) {
    var t2;
    const s2 = this.getGetterSetterExpectedParamCount(e20), r2 = this.getObjectOrClassMethodParams(e20), i2 = e20.start;
    r2.length !== s2 && (e20.kind === "get" ? this.raise(i2, Rn$1.BadGetterArity) : this.raise(i2, Rn$1.BadSetterArity)), e20.kind === "set" && ((t2 = r2[r2.length - 1]) == null ? void 0 : t2.type) === "RestElement" && this.raise(i2, Rn$1.BadSetterRestParameter);
  }
  parseObjectMethod(e20, t2, s2, r2, i2) {
    return i2 ? (this.parseMethod(e20, t2, false, false, false, "ObjectMethod"), this.checkGetterSetterParams(e20), e20) : s2 || t2 || this.match(bn$1.parenL) ? (r2 && this.unexpected(), e20.kind = "method", e20.method = true, this.parseMethod(e20, t2, s2, false, false, "ObjectMethod")) : void 0;
  }
  parseObjectProperty(e20, t2, s2, r2, i2) {
    return e20.shorthand = false, this.eat(bn$1.colon) ? (e20.value = r2 ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(i2), this.finishNode(e20, "ObjectProperty")) : e20.computed || e20.key.type !== "Identifier" ? void 0 : (this.checkReservedWord(e20.key.name, e20.key.start, true, false), r2 ? e20.value = this.parseMaybeDefault(t2, s2, Io$1(e20.key)) : this.match(bn$1.eq) && i2 ? (i2.shorthandAssign === -1 && (i2.shorthandAssign = this.state.start), e20.value = this.parseMaybeDefault(t2, s2, Io$1(e20.key))) : e20.value = Io$1(e20.key), e20.shorthand = true, this.finishNode(e20, "ObjectProperty"));
  }
  parseObjPropValue(e20, t2, s2, r2, i2, a2, n2, o2) {
    const u2 = this.parseObjectMethod(e20, r2, i2, a2, n2) || this.parseObjectProperty(e20, t2, s2, a2, o2);
    return u2 || this.unexpected(), u2;
  }
  parsePropertyName(e20, t2) {
    if (this.eat(bn$1.bracketL))
      e20.computed = true, e20.key = this.parseMaybeAssignAllowIn(), this.expect(bn$1.bracketR);
    else {
      const s2 = this.state.inPropertyName;
      this.state.inPropertyName = true;
      const r2 = this.state.type;
      e20.key = r2 === bn$1.num || r2 === bn$1.string || r2 === bn$1.bigint || r2 === bn$1.decimal ? this.parseExprAtom() : this.parseMaybePrivateName(t2), r2 !== bn$1.privateName && (e20.computed = false), this.state.inPropertyName = s2;
    }
    return e20.key;
  }
  initFunction(e20, t2) {
    e20.id = null, e20.generator = false, e20.async = !!t2;
  }
  parseMethod(e20, t2, s2, r2, i2, a2, n2 = false) {
    this.initFunction(e20, s2), e20.generator = !!t2;
    const o2 = r2;
    return this.scope.enter(18 | (n2 ? 64 : 0) | (i2 ? 32 : 0)), this.prodParam.enter(wo$1(s2, e20.generator)), this.parseFunctionParams(e20, o2), this.parseFunctionBodyAndFinish(e20, a2, true), this.prodParam.exit(), this.scope.exit(), e20;
  }
  parseArrayLike(e20, t2, s2, r2) {
    s2 && this.expectPlugin("recordAndTuple");
    const i2 = this.state.inFSharpPipelineDirectBody;
    this.state.inFSharpPipelineDirectBody = false;
    const a2 = this.startNode();
    return this.next(), a2.elements = this.parseExprList(e20, !s2, r2, a2), this.state.inFSharpPipelineDirectBody = i2, this.finishNode(a2, s2 ? "TupleExpression" : "ArrayExpression");
  }
  parseArrowExpression(e20, t2, s2, r2) {
    this.scope.enter(6);
    let i2 = wo$1(s2, false);
    !this.match(bn$1.bracketL) && this.prodParam.hasIn && (i2 |= 8), this.prodParam.enter(i2), this.initFunction(e20, s2);
    const a2 = this.state.maybeInArrowParameters;
    return t2 && (this.state.maybeInArrowParameters = true, this.setArrowFunctionParameters(e20, t2, r2)), this.state.maybeInArrowParameters = false, this.parseFunctionBody(e20, true), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = a2, this.finishNode(e20, "ArrowFunctionExpression");
  }
  setArrowFunctionParameters(e20, t2, s2) {
    e20.params = this.toAssignableList(t2, s2, false);
  }
  parseFunctionBodyAndFinish(e20, t2, s2 = false) {
    this.parseFunctionBody(e20, false, s2), this.finishNode(e20, t2);
  }
  parseFunctionBody(e20, t2, s2 = false) {
    const r2 = t2 && !this.match(bn$1.braceL);
    if (this.expressionScope.enter(Po$1()), r2)
      e20.body = this.parseMaybeAssign(), this.checkParams(e20, false, t2, false);
    else {
      const r3 = this.state.strict, i2 = this.state.labels;
      this.state.labels = [], this.prodParam.enter(4 | this.prodParam.currentFlags()), e20.body = this.parseBlock(true, false, (i3) => {
        const a2 = !this.isSimpleParamList(e20.params);
        if (i3 && a2) {
          const t3 = e20.kind !== "method" && e20.kind !== "constructor" || !e20.key ? e20.start : e20.key.end;
          this.raise(t3, Rn$1.IllegalLanguageModeDirective);
        }
        const n2 = !r3 && this.state.strict;
        this.checkParams(e20, !(this.state.strict || t2 || s2 || a2), t2, n2), this.state.strict && e20.id && this.checkLVal(e20.id, "function name", 65, void 0, void 0, n2);
      }), this.prodParam.exit(), this.expressionScope.exit(), this.state.labels = i2;
    }
  }
  isSimpleParamList(e20) {
    for (let t2 = 0, s2 = e20.length; t2 < s2; t2++)
      if (e20[t2].type !== "Identifier")
        return false;
    return true;
  }
  checkParams(e20, t2, s2, r2 = true) {
    const i2 = new Set();
    for (const s3 of e20.params)
      this.checkLVal(s3, "function parameter list", 5, t2 ? null : i2, void 0, r2);
  }
  parseExprList(e20, t2, s2, r2) {
    const i2 = [];
    let a2 = true;
    for (; !this.eat(e20); ) {
      if (a2)
        a2 = false;
      else if (this.expect(bn$1.comma), this.match(e20)) {
        r2 && this.addExtra(r2, "trailingComma", this.state.lastTokStart), this.next();
        break;
      }
      i2.push(this.parseExprListItem(t2, s2));
    }
    return i2;
  }
  parseExprListItem(e20, t2, s2) {
    let r2;
    if (this.match(bn$1.comma))
      e20 || this.raise(this.state.pos, Rn$1.UnexpectedToken, ","), r2 = null;
    else if (this.match(bn$1.ellipsis)) {
      const e21 = this.state.start, s3 = this.state.startLoc;
      r2 = this.parseParenItem(this.parseSpread(t2), e21, s3);
    } else if (this.match(bn$1.question)) {
      this.expectPlugin("partialApplication"), s2 || this.raise(this.state.start, Rn$1.UnexpectedArgumentPlaceholder);
      const e21 = this.startNode();
      this.next(), r2 = this.finishNode(e21, "ArgumentPlaceholder");
    } else
      r2 = this.parseMaybeAssignAllowIn(t2, this.parseParenItem);
    return r2;
  }
  parseIdentifier(e20) {
    const t2 = this.startNode(), s2 = this.parseIdentifierName(t2.start, e20);
    return this.createIdentifier(t2, s2);
  }
  createIdentifier(e20, t2) {
    return e20.name = t2, e20.loc.identifierName = t2, this.finishNode(e20, "Identifier");
  }
  parseIdentifierName(e20, t2) {
    let s2;
    const { start: r2, type: i2 } = this.state;
    if (i2 === bn$1.name)
      s2 = this.state.value;
    else {
      if (!i2.keyword)
        throw this.unexpected();
      s2 = i2.keyword;
    }
    return t2 ? this.state.type = bn$1.name : this.checkReservedWord(s2, r2, !!i2.keyword, false), this.next(), s2;
  }
  checkReservedWord(e20, t2, s2, r2) {
    if (e20.length > 10)
      return;
    if (!function(e21) {
      return uo$1.has(e21);
    }(e20))
      return;
    if (e20 === "yield") {
      if (this.prodParam.hasYield)
        return void this.raise(t2, Rn$1.YieldBindingIdentifier);
    } else if (e20 === "await") {
      if (this.prodParam.hasAwait)
        return void this.raise(t2, Rn$1.AwaitBindingIdentifier);
      if (this.scope.inStaticBlock)
        return void this.raise(t2, Rn$1.AwaitBindingIdentifierInStaticBlock);
      this.expressionScope.recordAsyncArrowParametersError(t2, Rn$1.AwaitBindingIdentifier);
    } else if (e20 === "arguments" && this.scope.inClassAndNotInNonArrowFunction)
      return void this.raise(t2, Rn$1.ArgumentsInClass);
    if (s2 && oo$1(e20))
      return void this.raise(t2, Rn$1.UnexpectedKeyword, e20);
    (this.state.strict ? r2 ? no$1 : io$1 : ro$1)(e20, this.inModule) && this.raise(t2, Rn$1.UnexpectedReservedWord, e20);
  }
  isAwaitAllowed() {
    return !!this.prodParam.hasAwait || !(!this.options.allowAwaitOutsideFunction || this.scope.inFunction);
  }
  parseAwait(e20, t2) {
    const s2 = this.startNodeAt(e20, t2);
    return this.expressionScope.recordParameterInitializerError(s2.start, Rn$1.AwaitExpressionFormalParameter), this.eat(bn$1.star) && this.raise(s2.start, Rn$1.ObsoleteAwaitStar), this.scope.inFunction || this.options.allowAwaitOutsideFunction || (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = true : this.sawUnambiguousESM = true), this.state.soloAwait || (s2.argument = this.parseMaybeUnary(null, true)), this.finishNode(s2, "AwaitExpression");
  }
  isAmbiguousAwait() {
    return this.hasPrecedingLineBreak() || this.match(bn$1.plusMin) || this.match(bn$1.parenL) || this.match(bn$1.bracketL) || this.match(bn$1.backQuote) || this.match(bn$1.regexp) || this.match(bn$1.slash) || this.hasPlugin("v8intrinsic") && this.match(bn$1.modulo);
  }
  parseYield() {
    const e20 = this.startNode();
    this.expressionScope.recordParameterInitializerError(e20.start, Rn$1.YieldInParameter), this.next();
    let t2 = false, s2 = null;
    if (!this.hasPrecedingLineBreak())
      switch (t2 = this.eat(bn$1.star), this.state.type) {
        case bn$1.semi:
        case bn$1.eof:
        case bn$1.braceR:
        case bn$1.parenR:
        case bn$1.bracketR:
        case bn$1.braceBarR:
        case bn$1.colon:
        case bn$1.comma:
          if (!t2)
            break;
        default:
          s2 = this.parseMaybeAssign();
      }
    return e20.delegate = t2, e20.argument = s2, this.finishNode(e20, "YieldExpression");
  }
  checkPipelineAtInfixOperator(e20, t2) {
    this.getPluginOption("pipelineOperator", "proposal") === "smart" && e20.type === "SequenceExpression" && this.raise(t2, Rn$1.PipelineHeadSequenceExpression);
  }
  checkHackPipeBodyEarlyErrors(e20) {
    if (this.match(bn$1.arrow))
      throw this.raise(this.state.start, Rn$1.PipeBodyIsTighter, bn$1.arrow.label);
    this.topicReferenceWasUsedInCurrentContext() || this.raise(e20, Rn$1.PipeTopicUnused);
  }
  parseSmartPipelineBodyInStyle(e20, t2, s2) {
    const r2 = this.startNodeAt(t2, s2);
    return this.isSimpleReference(e20) ? (r2.callee = e20, this.finishNode(r2, "PipelineBareFunction")) : (this.checkSmartPipeTopicBodyEarlyErrors(t2), r2.expression = e20, this.finishNode(r2, "PipelineTopicExpression"));
  }
  isSimpleReference(e20) {
    switch (e20.type) {
      case "MemberExpression":
        return !e20.computed && this.isSimpleReference(e20.object);
      case "Identifier":
        return true;
      default:
        return false;
    }
  }
  checkSmartPipeTopicBodyEarlyErrors(e20) {
    if (this.match(bn$1.arrow))
      throw this.raise(this.state.start, Rn$1.PipelineBodyNoArrow);
    this.topicReferenceWasUsedInCurrentContext() || this.raise(e20, Rn$1.PipelineTopicUnused);
  }
  withTopicBindingContext(e20) {
    const t2 = this.state.topicContext;
    this.state.topicContext = {
      maxNumOfResolvableTopics: 1,
      maxTopicIndex: null
    };
    try {
      return e20();
    } finally {
      this.state.topicContext = t2;
    }
  }
  withSmartMixTopicForbiddingContext(e20) {
    if (this.getPluginOption("pipelineOperator", "proposal") !== "smart")
      return e20();
    {
      const t2 = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      };
      try {
        return e20();
      } finally {
        this.state.topicContext = t2;
      }
    }
  }
  withSoloAwaitPermittingContext(e20) {
    const t2 = this.state.soloAwait;
    this.state.soloAwait = true;
    try {
      return e20();
    } finally {
      this.state.soloAwait = t2;
    }
  }
  allowInAnd(e20) {
    const t2 = this.prodParam.currentFlags();
    if (8 & ~t2) {
      this.prodParam.enter(8 | t2);
      try {
        return e20();
      } finally {
        this.prodParam.exit();
      }
    }
    return e20();
  }
  disallowInAnd(e20) {
    const t2 = this.prodParam.currentFlags();
    if (8 & t2) {
      this.prodParam.enter(-9 & t2);
      try {
        return e20();
      } finally {
        this.prodParam.exit();
      }
    }
    return e20();
  }
  registerTopicReference() {
    this.state.topicContext.maxTopicIndex = 0;
  }
  topicReferenceIsAllowedInCurrentContext() {
    return this.state.topicContext.maxNumOfResolvableTopics >= 1;
  }
  topicReferenceWasUsedInCurrentContext() {
    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
  }
  parseFSharpPipelineBody(e20) {
    const t2 = this.state.start, s2 = this.state.startLoc;
    this.state.potentialArrowAt = this.state.start;
    const r2 = this.state.inFSharpPipelineDirectBody;
    this.state.inFSharpPipelineDirectBody = true;
    const i2 = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), t2, s2, e20);
    return this.state.inFSharpPipelineDirectBody = r2, i2;
  }
  parseModuleExpression() {
    this.expectPlugin("moduleBlocks");
    const e20 = this.startNode();
    this.next(), this.eat(bn$1.braceL);
    const t2 = this.initializeScopes(true);
    this.enterInitialScopes();
    const s2 = this.startNode();
    try {
      e20.body = this.parseProgram(s2, bn$1.braceR, "module");
    } finally {
      t2();
    }
    return this.eat(bn$1.braceR), this.finishNode(e20, "ModuleExpression");
  }
} {
  parseTopLevel(e20, t2) {
    return e20.program = this.parseProgram(t2), e20.comments = this.state.comments, this.options.tokens && (e20.tokens = function(e21) {
      for (let t3 = 0; t3 < e21.length; t3++) {
        const s2 = e21[t3];
        if (s2.type === bn$1.privateName) {
          const { loc: r2, start: i2, value: a2, end: n2 } = s2, o2 = i2 + 1, u2 = new In$1(r2.start.line, r2.start.column + 1);
          e21.splice(t3, 1, new Eo$1({
            type: bn$1.hash,
            value: "#",
            start: i2,
            end: o2,
            startLoc: r2.start,
            endLoc: u2
          }), new Eo$1({
            type: bn$1.name,
            value: a2,
            start: o2,
            end: n2,
            startLoc: u2,
            endLoc: r2.end
          }));
        }
      }
      return e21;
    }(this.tokens)), this.finishNode(e20, "File");
  }
  parseProgram(e20, t2 = bn$1.eof, s2 = this.options.sourceType) {
    if (e20.sourceType = s2, e20.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(e20, true, true, t2), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
      for (const [e21] of Array.from(this.scope.undefinedExports)) {
        const t3 = this.scope.undefinedExports.get(e21);
        this.raise(t3, Rn$1.ModuleExportUndefined, e21);
      }
    return this.finishNode(e20, "Program");
  }
  stmtToDirective(e20) {
    const t2 = e20;
    t2.type = "Directive", t2.value = t2.expression, delete t2.expression;
    const s2 = t2.value, r2 = this.input.slice(s2.start, s2.end), i2 = s2.value = r2.slice(1, -1);
    return this.addExtra(s2, "raw", r2), this.addExtra(s2, "rawValue", i2), s2.type = "DirectiveLiteral", t2;
  }
  parseInterpreterDirective() {
    if (!this.match(bn$1.interpreterDirective))
      return null;
    const e20 = this.startNode();
    return e20.value = this.state.value, this.next(), this.finishNode(e20, "InterpreterDirective");
  }
  isLet(e20) {
    return !!this.isContextual("let") && this.isLetKeyword(e20);
  }
  isLetKeyword(e20) {
    const t2 = this.nextTokenStart(), s2 = this.codePointAtPos(t2);
    if (s2 === 92 || s2 === 91)
      return true;
    if (e20)
      return false;
    if (s2 === 123)
      return true;
    if (Jn$1(s2)) {
      if (cu.lastIndex = t2, cu.test(this.input)) {
        const e21 = this.codePointAtPos(cu.lastIndex);
        if (!Yn$1(e21) && e21 !== 92)
          return false;
      }
      return true;
    }
    return false;
  }
  parseStatement(e20, t2) {
    return this.match(bn$1.at) && this.parseDecorators(true), this.parseStatementContent(e20, t2);
  }
  parseStatementContent(e20, t2) {
    let s2 = this.state.type;
    const r2 = this.startNode();
    let i2;
    switch (this.isLet(e20) && (s2 = bn$1._var, i2 = "let"), s2) {
      case bn$1._break:
      case bn$1._continue:
        return this.parseBreakContinueStatement(r2, s2.keyword);
      case bn$1._debugger:
        return this.parseDebuggerStatement(r2);
      case bn$1._do:
        return this.parseDoStatement(r2);
      case bn$1._for:
        return this.parseForStatement(r2);
      case bn$1._function:
        if (this.lookaheadCharCode() === 46)
          break;
        return e20 && (this.state.strict ? this.raise(this.state.start, Rn$1.StrictFunction) : e20 !== "if" && e20 !== "label" && this.raise(this.state.start, Rn$1.SloppyFunction)), this.parseFunctionStatement(r2, false, !e20);
      case bn$1._class:
        return e20 && this.unexpected(), this.parseClass(r2, true);
      case bn$1._if:
        return this.parseIfStatement(r2);
      case bn$1._return:
        return this.parseReturnStatement(r2);
      case bn$1._switch:
        return this.parseSwitchStatement(r2);
      case bn$1._throw:
        return this.parseThrowStatement(r2);
      case bn$1._try:
        return this.parseTryStatement(r2);
      case bn$1._const:
      case bn$1._var:
        return i2 = i2 || this.state.value, e20 && i2 !== "var" && this.raise(this.state.start, Rn$1.UnexpectedLexicalDeclaration), this.parseVarStatement(r2, i2);
      case bn$1._while:
        return this.parseWhileStatement(r2);
      case bn$1._with:
        return this.parseWithStatement(r2);
      case bn$1.braceL:
        return this.parseBlock();
      case bn$1.semi:
        return this.parseEmptyStatement(r2);
      case bn$1._import: {
        const e21 = this.lookaheadCharCode();
        if (e21 === 40 || e21 === 46)
          break;
      }
      case bn$1._export: {
        let e21;
        return this.options.allowImportExportEverywhere || t2 || this.raise(this.state.start, Rn$1.UnexpectedImportExport), this.next(), s2 === bn$1._import ? (e21 = this.parseImport(r2), e21.type !== "ImportDeclaration" || e21.importKind && e21.importKind !== "value" || (this.sawUnambiguousESM = true)) : (e21 = this.parseExport(r2), (e21.type !== "ExportNamedDeclaration" || e21.exportKind && e21.exportKind !== "value") && (e21.type !== "ExportAllDeclaration" || e21.exportKind && e21.exportKind !== "value") && e21.type !== "ExportDefaultDeclaration" || (this.sawUnambiguousESM = true)), this.assertModuleNodeAllowed(r2), e21;
      }
      default:
        if (this.isAsyncFunction())
          return e20 && this.raise(this.state.start, Rn$1.AsyncFunctionInSingleStatementContext), this.next(), this.parseFunctionStatement(r2, true, !e20);
    }
    const a2 = this.state.value, n2 = this.parseExpression();
    return s2 === bn$1.name && n2.type === "Identifier" && this.eat(bn$1.colon) ? this.parseLabeledStatement(r2, a2, n2, e20) : this.parseExpressionStatement(r2, n2);
  }
  assertModuleNodeAllowed(e20) {
    this.options.allowImportExportEverywhere || this.inModule || this.raise(e20.start, jn$1.ImportOutsideModule);
  }
  takeDecorators(e20) {
    const t2 = this.state.decoratorStack[this.state.decoratorStack.length - 1];
    t2.length && (e20.decorators = t2, this.resetStartLocationFromNode(e20, t2[0]), this.state.decoratorStack[this.state.decoratorStack.length - 1] = []);
  }
  canHaveLeadingDecorator() {
    return this.match(bn$1._class);
  }
  parseDecorators(e20) {
    const t2 = this.state.decoratorStack[this.state.decoratorStack.length - 1];
    for (; this.match(bn$1.at); ) {
      const e21 = this.parseDecorator();
      t2.push(e21);
    }
    if (this.match(bn$1._export))
      e20 || this.unexpected(), this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(this.state.start, Rn$1.DecoratorExportClass);
    else if (!this.canHaveLeadingDecorator())
      throw this.raise(this.state.start, Rn$1.UnexpectedLeadingDecorator);
  }
  parseDecorator() {
    this.expectOnePlugin(["decorators-legacy", "decorators"]);
    const e20 = this.startNode();
    if (this.next(), this.hasPlugin("decorators")) {
      this.state.decoratorStack.push([]);
      const t2 = this.state.start, s2 = this.state.startLoc;
      let r2;
      if (this.eat(bn$1.parenL))
        r2 = this.parseExpression(), this.expect(bn$1.parenR);
      else
        for (r2 = this.parseIdentifier(false); this.eat(bn$1.dot); ) {
          const e21 = this.startNodeAt(t2, s2);
          e21.object = r2, e21.property = this.parseIdentifier(true), e21.computed = false, r2 = this.finishNode(e21, "MemberExpression");
        }
      e20.expression = this.parseMaybeDecoratorArguments(r2), this.state.decoratorStack.pop();
    } else
      e20.expression = this.parseExprSubscripts();
    return this.finishNode(e20, "Decorator");
  }
  parseMaybeDecoratorArguments(e20) {
    if (this.eat(bn$1.parenL)) {
      const t2 = this.startNodeAtNode(e20);
      return t2.callee = e20, t2.arguments = this.parseCallExpressionArguments(bn$1.parenR, false), this.toReferencedList(t2.arguments), this.finishNode(t2, "CallExpression");
    }
    return e20;
  }
  parseBreakContinueStatement(e20, t2) {
    const s2 = t2 === "break";
    return this.next(), this.isLineTerminator() ? e20.label = null : (e20.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(e20, t2), this.finishNode(e20, s2 ? "BreakStatement" : "ContinueStatement");
  }
  verifyBreakContinue(e20, t2) {
    const s2 = t2 === "break";
    let r2;
    for (r2 = 0; r2 < this.state.labels.length; ++r2) {
      const t3 = this.state.labels[r2];
      if (e20.label == null || t3.name === e20.label.name) {
        if (t3.kind != null && (s2 || t3.kind === "loop"))
          break;
        if (e20.label && s2)
          break;
      }
    }
    r2 === this.state.labels.length && this.raise(e20.start, Rn$1.IllegalBreakContinue, t2);
  }
  parseDebuggerStatement(e20) {
    return this.next(), this.semicolon(), this.finishNode(e20, "DebuggerStatement");
  }
  parseHeaderExpression() {
    this.expect(bn$1.parenL);
    const e20 = this.parseExpression();
    return this.expect(bn$1.parenR), e20;
  }
  parseDoStatement(e20) {
    return this.next(), this.state.labels.push(ou), e20.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("do")), this.state.labels.pop(), this.expect(bn$1._while), e20.test = this.parseHeaderExpression(), this.eat(bn$1.semi), this.finishNode(e20, "DoWhileStatement");
  }
  parseForStatement(e20) {
    this.next(), this.state.labels.push(ou);
    let t2 = -1;
    if (this.isAwaitAllowed() && this.eatContextual("await") && (t2 = this.state.lastTokStart), this.scope.enter(0), this.expect(bn$1.parenL), this.match(bn$1.semi))
      return t2 > -1 && this.unexpected(t2), this.parseFor(e20, null);
    const s2 = this.isContextual("let"), r2 = s2 && this.isLetKeyword();
    if (this.match(bn$1._var) || this.match(bn$1._const) || r2) {
      const s3 = this.startNode(), i3 = r2 ? "let" : this.state.value;
      return this.next(), this.parseVar(s3, true, i3), this.finishNode(s3, "VariableDeclaration"), (this.match(bn$1._in) || this.isContextual("of")) && s3.declarations.length === 1 ? this.parseForIn(e20, s3, t2) : (t2 > -1 && this.unexpected(t2), this.parseFor(e20, s3));
    }
    const i2 = this.match(bn$1.name) && !this.state.containsEsc, a2 = new So$1(), n2 = this.parseExpression(true, a2), o2 = this.isContextual("of");
    if (o2 && (s2 ? this.raise(n2.start, Rn$1.ForOfLet) : t2 === -1 && i2 && n2.type === "Identifier" && n2.name === "async" && this.raise(n2.start, Rn$1.ForOfAsync)), o2 || this.match(bn$1._in)) {
      this.toAssignable(n2, true);
      const s3 = o2 ? "for-of statement" : "for-in statement";
      return this.checkLVal(n2, s3), this.parseForIn(e20, n2, t2);
    }
    return this.checkExpressionErrors(a2, true), t2 > -1 && this.unexpected(t2), this.parseFor(e20, n2);
  }
  parseFunctionStatement(e20, t2, s2) {
    return this.next(), this.parseFunction(e20, 1 | (s2 ? 0 : 2), t2);
  }
  parseIfStatement(e20) {
    return this.next(), e20.test = this.parseHeaderExpression(), e20.consequent = this.parseStatement("if"), e20.alternate = this.eat(bn$1._else) ? this.parseStatement("if") : null, this.finishNode(e20, "IfStatement");
  }
  parseReturnStatement(e20) {
    return this.prodParam.hasReturn || this.options.allowReturnOutsideFunction || this.raise(this.state.start, Rn$1.IllegalReturn), this.next(), this.isLineTerminator() ? e20.argument = null : (e20.argument = this.parseExpression(), this.semicolon()), this.finishNode(e20, "ReturnStatement");
  }
  parseSwitchStatement(e20) {
    this.next(), e20.discriminant = this.parseHeaderExpression();
    const t2 = e20.cases = [];
    let s2, r2;
    for (this.expect(bn$1.braceL), this.state.labels.push(uu), this.scope.enter(0); !this.match(bn$1.braceR); )
      if (this.match(bn$1._case) || this.match(bn$1._default)) {
        const e21 = this.match(bn$1._case);
        s2 && this.finishNode(s2, "SwitchCase"), t2.push(s2 = this.startNode()), s2.consequent = [], this.next(), e21 ? s2.test = this.parseExpression() : (r2 && this.raise(this.state.lastTokStart, Rn$1.MultipleDefaultsInSwitch), r2 = true, s2.test = null), this.expect(bn$1.colon);
      } else
        s2 ? s2.consequent.push(this.parseStatement(null)) : this.unexpected();
    return this.scope.exit(), s2 && this.finishNode(s2, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(e20, "SwitchStatement");
  }
  parseThrowStatement(e20) {
    return this.next(), this.hasPrecedingLineBreak() && this.raise(this.state.lastTokEnd, Rn$1.NewlineAfterThrow), e20.argument = this.parseExpression(), this.semicolon(), this.finishNode(e20, "ThrowStatement");
  }
  parseCatchClauseParam() {
    const e20 = this.parseBindingAtom(), t2 = e20.type === "Identifier";
    return this.scope.enter(t2 ? 8 : 0), this.checkLVal(e20, "catch clause", 9), e20;
  }
  parseTryStatement(e20) {
    if (this.next(), e20.block = this.parseBlock(), e20.handler = null, this.match(bn$1._catch)) {
      const t2 = this.startNode();
      this.next(), this.match(bn$1.parenL) ? (this.expect(bn$1.parenL), t2.param = this.parseCatchClauseParam(), this.expect(bn$1.parenR)) : (t2.param = null, this.scope.enter(0)), t2.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false)), this.scope.exit(), e20.handler = this.finishNode(t2, "CatchClause");
    }
    return e20.finalizer = this.eat(bn$1._finally) ? this.parseBlock() : null, e20.handler || e20.finalizer || this.raise(e20.start, Rn$1.NoCatchOrFinally), this.finishNode(e20, "TryStatement");
  }
  parseVarStatement(e20, t2) {
    return this.next(), this.parseVar(e20, false, t2), this.semicolon(), this.finishNode(e20, "VariableDeclaration");
  }
  parseWhileStatement(e20) {
    return this.next(), e20.test = this.parseHeaderExpression(), this.state.labels.push(ou), e20.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("while")), this.state.labels.pop(), this.finishNode(e20, "WhileStatement");
  }
  parseWithStatement(e20) {
    return this.state.strict && this.raise(this.state.start, Rn$1.StrictWith), this.next(), e20.object = this.parseHeaderExpression(), e20.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("with")), this.finishNode(e20, "WithStatement");
  }
  parseEmptyStatement(e20) {
    return this.next(), this.finishNode(e20, "EmptyStatement");
  }
  parseLabeledStatement(e20, t2, s2, r2) {
    for (const e21 of this.state.labels)
      e21.name === t2 && this.raise(s2.start, Rn$1.LabelRedeclaration, t2);
    const i2 = this.state.type.isLoop ? "loop" : this.match(bn$1._switch) ? "switch" : null;
    for (let t3 = this.state.labels.length - 1; t3 >= 0; t3--) {
      const s3 = this.state.labels[t3];
      if (s3.statementStart !== e20.start)
        break;
      s3.statementStart = this.state.start, s3.kind = i2;
    }
    return this.state.labels.push({
      name: t2,
      kind: i2,
      statementStart: this.state.start
    }), e20.body = this.parseStatement(r2 ? r2.indexOf("label") === -1 ? r2 + "label" : r2 : "label"), this.state.labels.pop(), e20.label = s2, this.finishNode(e20, "LabeledStatement");
  }
  parseExpressionStatement(e20, t2) {
    return e20.expression = t2, this.semicolon(), this.finishNode(e20, "ExpressionStatement");
  }
  parseBlock(e20 = false, t2 = true, s2) {
    const r2 = this.startNode();
    return e20 && this.state.strictErrors.clear(), this.expect(bn$1.braceL), t2 && this.scope.enter(0), this.parseBlockBody(r2, e20, false, bn$1.braceR, s2), t2 && this.scope.exit(), this.finishNode(r2, "BlockStatement");
  }
  isValidDirective(e20) {
    return e20.type === "ExpressionStatement" && e20.expression.type === "StringLiteral" && !e20.expression.extra.parenthesized;
  }
  parseBlockBody(e20, t2, s2, r2, i2) {
    const a2 = e20.body = [], n2 = e20.directives = [];
    this.parseBlockOrModuleBlockBody(a2, t2 ? n2 : void 0, s2, r2, i2);
  }
  parseBlockOrModuleBlockBody(e20, t2, s2, r2, i2) {
    const a2 = this.state.strict;
    let n2 = false, o2 = false;
    for (; !this.match(r2); ) {
      const r3 = this.parseStatement(null, s2);
      if (t2 && !o2) {
        if (this.isValidDirective(r3)) {
          const e21 = this.stmtToDirective(r3);
          t2.push(e21), n2 || e21.value.value !== "use strict" || (n2 = true, this.setStrict(true));
          continue;
        }
        o2 = true, this.state.strictErrors.clear();
      }
      e20.push(r3);
    }
    i2 && i2.call(this, n2), a2 || this.setStrict(false), this.next();
  }
  parseFor(e20, t2) {
    return e20.init = t2, this.semicolon(false), e20.test = this.match(bn$1.semi) ? null : this.parseExpression(), this.semicolon(false), e20.update = this.match(bn$1.parenR) ? null : this.parseExpression(), this.expect(bn$1.parenR), e20.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for")), this.scope.exit(), this.state.labels.pop(), this.finishNode(e20, "ForStatement");
  }
  parseForIn(e20, t2, s2) {
    const r2 = this.match(bn$1._in);
    return this.next(), r2 ? s2 > -1 && this.unexpected(s2) : e20.await = s2 > -1, t2.type !== "VariableDeclaration" || t2.declarations[0].init == null || r2 && !this.state.strict && t2.kind === "var" && t2.declarations[0].id.type === "Identifier" ? t2.type === "AssignmentPattern" && this.raise(t2.start, Rn$1.InvalidLhs, "for-loop") : this.raise(t2.start, Rn$1.ForInOfLoopInitializer, r2 ? "for-in" : "for-of"), e20.left = t2, e20.right = r2 ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(bn$1.parenR), e20.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for")), this.scope.exit(), this.state.labels.pop(), this.finishNode(e20, r2 ? "ForInStatement" : "ForOfStatement");
  }
  parseVar(e20, t2, s2) {
    const r2 = e20.declarations = [], i2 = this.hasPlugin("typescript");
    for (e20.kind = s2; ; ) {
      const e21 = this.startNode();
      if (this.parseVarId(e21, s2), this.eat(bn$1.eq) ? e21.init = t2 ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : (s2 !== "const" || this.match(bn$1._in) || this.isContextual("of") ? e21.id.type === "Identifier" || t2 && (this.match(bn$1._in) || this.isContextual("of")) || this.raise(this.state.lastTokEnd, Rn$1.DeclarationMissingInitializer, "Complex binding patterns") : i2 || this.raise(this.state.lastTokEnd, Rn$1.DeclarationMissingInitializer, "Const declarations"), e21.init = null), r2.push(this.finishNode(e21, "VariableDeclarator")), !this.eat(bn$1.comma))
        break;
    }
    return e20;
  }
  parseVarId(e20, t2) {
    e20.id = this.parseBindingAtom(), this.checkLVal(e20.id, "variable declaration", t2 === "var" ? 5 : 9, void 0, t2 !== "var");
  }
  parseFunction(e20, t2 = 0, s2 = false) {
    const r2 = 1 & t2, i2 = 2 & t2, a2 = !(!r2 || 4 & t2);
    this.initFunction(e20, s2), this.match(bn$1.star) && i2 && this.raise(this.state.start, Rn$1.GeneratorInSingleStatementContext), e20.generator = this.eat(bn$1.star), r2 && (e20.id = this.parseFunctionId(a2));
    const n2 = this.state.maybeInArrowParameters;
    return this.state.maybeInArrowParameters = false, this.scope.enter(2), this.prodParam.enter(wo$1(s2, e20.generator)), r2 || (e20.id = this.parseFunctionId()), this.parseFunctionParams(e20, false), this.withSmartMixTopicForbiddingContext(() => {
      this.parseFunctionBodyAndFinish(e20, r2 ? "FunctionDeclaration" : "FunctionExpression");
    }), this.prodParam.exit(), this.scope.exit(), r2 && !i2 && this.registerFunctionStatementId(e20), this.state.maybeInArrowParameters = n2, e20;
  }
  parseFunctionId(e20) {
    return e20 || this.match(bn$1.name) ? this.parseIdentifier() : null;
  }
  parseFunctionParams(e20, t2) {
    this.expect(bn$1.parenL), this.expressionScope.enter(new Fo$1(3)), e20.params = this.parseBindingList(bn$1.parenR, 41, false, t2), this.expressionScope.exit();
  }
  registerFunctionStatementId(e20) {
    e20.id && this.scope.declareName(e20.id.name, this.state.strict || e20.generator || e20.async ? this.scope.treatFunctionsAsVar ? 5 : 9 : 17, e20.id.start);
  }
  parseClass(e20, t2, s2) {
    this.next(), this.takeDecorators(e20);
    const r2 = this.state.strict;
    return this.state.strict = true, this.parseClassId(e20, t2, s2), this.parseClassSuper(e20), e20.body = this.parseClassBody(!!e20.superClass, r2), this.finishNode(e20, t2 ? "ClassDeclaration" : "ClassExpression");
  }
  isClassProperty() {
    return this.match(bn$1.eq) || this.match(bn$1.semi) || this.match(bn$1.braceR);
  }
  isClassMethod() {
    return this.match(bn$1.parenL);
  }
  isNonstaticConstructor(e20) {
    return !(e20.computed || e20.static || e20.key.name !== "constructor" && e20.key.value !== "constructor");
  }
  parseClassBody(e20, t2) {
    this.classScope.enter();
    const s2 = { hadConstructor: false, hadSuperClass: e20 };
    let r2 = [];
    const i2 = this.startNode();
    if (i2.body = [], this.expect(bn$1.braceL), this.withSmartMixTopicForbiddingContext(() => {
      for (; !this.match(bn$1.braceR); ) {
        if (this.eat(bn$1.semi)) {
          if (r2.length > 0)
            throw this.raise(this.state.lastTokEnd, Rn$1.DecoratorSemicolon);
          continue;
        }
        if (this.match(bn$1.at)) {
          r2.push(this.parseDecorator());
          continue;
        }
        const e21 = this.startNode();
        r2.length && (e21.decorators = r2, this.resetStartLocationFromNode(e21, r2[0]), r2 = []), this.parseClassMember(i2, e21, s2), e21.kind === "constructor" && e21.decorators && e21.decorators.length > 0 && this.raise(e21.start, Rn$1.DecoratorConstructor);
      }
    }), this.state.strict = t2, this.next(), r2.length)
      throw this.raise(this.state.start, Rn$1.TrailingDecorator);
    return this.classScope.exit(), this.finishNode(i2, "ClassBody");
  }
  parseClassMemberFromModifier(e20, t2) {
    const s2 = this.parseIdentifier(true);
    if (this.isClassMethod()) {
      const r2 = t2;
      return r2.kind = "method", r2.computed = false, r2.key = s2, r2.static = false, this.pushClassMethod(e20, r2, false, false, false, false), true;
    }
    if (this.isClassProperty()) {
      const r2 = t2;
      return r2.computed = false, r2.key = s2, r2.static = false, e20.body.push(this.parseClassProperty(r2)), true;
    }
    return this.resetPreviousNodeTrailingComments(s2), false;
  }
  parseClassMember(e20, t2, s2) {
    const r2 = this.isContextual("static");
    if (r2) {
      if (this.parseClassMemberFromModifier(e20, t2))
        return;
      if (this.eat(bn$1.braceL))
        return void this.parseClassStaticBlock(e20, t2);
    }
    this.parseClassMemberWithIsStatic(e20, t2, s2, r2);
  }
  parseClassMemberWithIsStatic(e20, t2, s2, r2) {
    const i2 = t2, a2 = t2, n2 = t2, o2 = t2, u2 = i2, h2 = i2;
    if (t2.static = r2, this.eat(bn$1.star)) {
      u2.kind = "method";
      const t3 = this.match(bn$1.privateName);
      return this.parseClassElementName(u2), t3 ? void this.pushClassPrivateMethod(e20, a2, true, false) : (this.isNonstaticConstructor(i2) && this.raise(i2.key.start, Rn$1.ConstructorIsGenerator), void this.pushClassMethod(e20, i2, true, false, false, false));
    }
    const c2 = this.match(bn$1.name) && !this.state.containsEsc, p2 = this.match(bn$1.privateName), l2 = this.parseClassElementName(t2), d2 = this.state.start;
    if (this.parsePostMemberNameModifiers(h2), this.isClassMethod()) {
      if (u2.kind = "method", p2)
        return void this.pushClassPrivateMethod(e20, a2, false, false);
      const r3 = this.isNonstaticConstructor(i2);
      let n3 = false;
      r3 && (i2.kind = "constructor", s2.hadConstructor && !this.hasPlugin("typescript") && this.raise(l2.start, Rn$1.DuplicateConstructor), r3 && this.hasPlugin("typescript") && t2.override && this.raise(l2.start, Rn$1.OverrideOnConstructor), s2.hadConstructor = true, n3 = s2.hadSuperClass), this.pushClassMethod(e20, i2, false, false, r3, n3);
    } else if (this.isClassProperty())
      p2 ? this.pushClassPrivateProperty(e20, o2) : this.pushClassProperty(e20, n2);
    else if (c2 && l2.name === "async" && !this.isLineTerminator()) {
      this.resetPreviousNodeTrailingComments(l2);
      const t3 = this.eat(bn$1.star);
      h2.optional && this.unexpected(d2), u2.kind = "method";
      const s3 = this.match(bn$1.privateName);
      this.parseClassElementName(u2), this.parsePostMemberNameModifiers(h2), s3 ? this.pushClassPrivateMethod(e20, a2, t3, true) : (this.isNonstaticConstructor(i2) && this.raise(i2.key.start, Rn$1.ConstructorIsAsync), this.pushClassMethod(e20, i2, t3, true, false, false));
    } else if (!c2 || l2.name !== "get" && l2.name !== "set" || this.match(bn$1.star) && this.isLineTerminator())
      this.isLineTerminator() ? p2 ? this.pushClassPrivateProperty(e20, o2) : this.pushClassProperty(e20, n2) : this.unexpected();
    else {
      this.resetPreviousNodeTrailingComments(l2), u2.kind = l2.name;
      const t3 = this.match(bn$1.privateName);
      this.parseClassElementName(i2), t3 ? this.pushClassPrivateMethod(e20, a2, false, false) : (this.isNonstaticConstructor(i2) && this.raise(i2.key.start, Rn$1.ConstructorIsAccessor), this.pushClassMethod(e20, i2, false, false, false, false)), this.checkGetterSetterParams(i2);
    }
  }
  parseClassElementName(e20) {
    const { type: t2, value: s2, start: r2 } = this.state;
    return t2 !== bn$1.name && t2 !== bn$1.string || !e20.static || s2 !== "prototype" || this.raise(r2, Rn$1.StaticPrototype), t2 === bn$1.privateName && s2 === "constructor" && this.raise(r2, Rn$1.ConstructorClassPrivateField), this.parsePropertyName(e20, true);
  }
  parseClassStaticBlock(e20, t2) {
    var s2;
    this.expectPlugin("classStaticBlock", t2.start), this.scope.enter(208);
    const r2 = this.state.labels;
    this.state.labels = [], this.prodParam.enter(0);
    const i2 = t2.body = [];
    this.parseBlockOrModuleBlockBody(i2, void 0, false, bn$1.braceR), this.prodParam.exit(), this.scope.exit(), this.state.labels = r2, e20.body.push(this.finishNode(t2, "StaticBlock")), (s2 = t2.decorators) != null && s2.length && this.raise(t2.start, Rn$1.DecoratorStaticBlock);
  }
  pushClassProperty(e20, t2) {
    t2.computed || t2.key.name !== "constructor" && t2.key.value !== "constructor" || this.raise(t2.key.start, Rn$1.ConstructorClassField), e20.body.push(this.parseClassProperty(t2));
  }
  pushClassPrivateProperty(e20, t2) {
    const s2 = this.parseClassPrivateProperty(t2);
    e20.body.push(s2), this.classScope.declarePrivateName(this.getPrivateNameSV(s2.key), 0, s2.key.start);
  }
  pushClassMethod(e20, t2, s2, r2, i2, a2) {
    e20.body.push(this.parseMethod(t2, s2, r2, i2, a2, "ClassMethod", true));
  }
  pushClassPrivateMethod(e20, t2, s2, r2) {
    const i2 = this.parseMethod(t2, s2, r2, false, false, "ClassPrivateMethod", true);
    e20.body.push(i2);
    const a2 = i2.kind === "get" ? i2.static ? 6 : 2 : i2.kind === "set" ? i2.static ? 5 : 1 : 0;
    this.classScope.declarePrivateName(this.getPrivateNameSV(i2.key), a2, i2.key.start);
  }
  parsePostMemberNameModifiers(e20) {
  }
  parseClassPrivateProperty(e20) {
    return this.parseInitializer(e20), this.semicolon(), this.finishNode(e20, "ClassPrivateProperty");
  }
  parseClassProperty(e20) {
    return this.parseInitializer(e20), this.semicolon(), this.finishNode(e20, "ClassProperty");
  }
  parseInitializer(e20) {
    this.scope.enter(80), this.expressionScope.enter(Po$1()), this.prodParam.enter(0), e20.value = this.eat(bn$1.eq) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
  }
  parseClassId(e20, t2, s2, r2 = 139) {
    this.match(bn$1.name) ? (e20.id = this.parseIdentifier(), t2 && this.checkLVal(e20.id, "class name", r2)) : s2 || !t2 ? e20.id = null : this.unexpected(null, Rn$1.MissingClassName);
  }
  parseClassSuper(e20) {
    e20.superClass = this.eat(bn$1._extends) ? this.parseExprSubscripts() : null;
  }
  parseExport(e20) {
    const t2 = this.maybeParseExportDefaultSpecifier(e20), s2 = !t2 || this.eat(bn$1.comma), r2 = s2 && this.eatExportStar(e20), i2 = r2 && this.maybeParseExportNamespaceSpecifier(e20), a2 = s2 && (!i2 || this.eat(bn$1.comma)), n2 = t2 || r2;
    if (r2 && !i2)
      return t2 && this.unexpected(), this.parseExportFrom(e20, true), this.finishNode(e20, "ExportAllDeclaration");
    const o2 = this.maybeParseExportNamedSpecifiers(e20);
    if (t2 && s2 && !r2 && !o2 || i2 && a2 && !o2)
      throw this.unexpected(null, bn$1.braceL);
    let u2;
    if (n2 || o2 ? (u2 = false, this.parseExportFrom(e20, n2)) : u2 = this.maybeParseExportDeclaration(e20), n2 || o2 || u2)
      return this.checkExport(e20, true, false, !!e20.source), this.finishNode(e20, "ExportNamedDeclaration");
    if (this.eat(bn$1._default))
      return e20.declaration = this.parseExportDefaultExpression(), this.checkExport(e20, true, true), this.finishNode(e20, "ExportDefaultDeclaration");
    throw this.unexpected(null, bn$1.braceL);
  }
  eatExportStar(e20) {
    return this.eat(bn$1.star);
  }
  maybeParseExportDefaultSpecifier(e20) {
    if (this.isExportDefaultSpecifier()) {
      this.expectPlugin("exportDefaultFrom");
      const t2 = this.startNode();
      return t2.exported = this.parseIdentifier(true), e20.specifiers = [this.finishNode(t2, "ExportDefaultSpecifier")], true;
    }
    return false;
  }
  maybeParseExportNamespaceSpecifier(e20) {
    if (this.isContextual("as")) {
      e20.specifiers || (e20.specifiers = []);
      const t2 = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
      return this.next(), t2.exported = this.parseModuleExportName(), e20.specifiers.push(this.finishNode(t2, "ExportNamespaceSpecifier")), true;
    }
    return false;
  }
  maybeParseExportNamedSpecifiers(e20) {
    return !!this.match(bn$1.braceL) && (e20.specifiers || (e20.specifiers = []), e20.specifiers.push(...this.parseExportSpecifiers()), e20.source = null, e20.declaration = null, true);
  }
  maybeParseExportDeclaration(e20) {
    return !!this.shouldParseExportDeclaration() && (e20.specifiers = [], e20.source = null, e20.declaration = this.parseExportDeclaration(e20), true);
  }
  isAsyncFunction() {
    if (!this.isContextual("async"))
      return false;
    const e20 = this.nextTokenStart();
    return !Pn$1.test(this.input.slice(this.state.pos, e20)) && this.isUnparsedContextual(e20, "function");
  }
  parseExportDefaultExpression() {
    const e20 = this.startNode(), t2 = this.isAsyncFunction();
    if (this.match(bn$1._function) || t2)
      return this.next(), t2 && this.next(), this.parseFunction(e20, 5, t2);
    if (this.match(bn$1._class))
      return this.parseClass(e20, true, true);
    if (this.match(bn$1.at))
      return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(this.state.start, Rn$1.DecoratorBeforeExport), this.parseDecorators(false), this.parseClass(e20, true, true);
    if (this.match(bn$1._const) || this.match(bn$1._var) || this.isLet())
      throw this.raise(this.state.start, Rn$1.UnsupportedDefaultExport);
    {
      const e21 = this.parseMaybeAssignAllowIn();
      return this.semicolon(), e21;
    }
  }
  parseExportDeclaration(e20) {
    return this.parseStatement(null);
  }
  isExportDefaultSpecifier() {
    if (this.match(bn$1.name)) {
      const e21 = this.state.value;
      if (e21 === "async" && !this.state.containsEsc || e21 === "let")
        return false;
      if ((e21 === "type" || e21 === "interface") && !this.state.containsEsc) {
        const e22 = this.lookahead();
        if (e22.type === bn$1.name && e22.value !== "from" || e22.type === bn$1.braceL)
          return this.expectOnePlugin(["flow", "typescript"]), false;
      }
    } else if (!this.match(bn$1._default))
      return false;
    const e20 = this.nextTokenStart(), t2 = this.isUnparsedContextual(e20, "from");
    if (this.input.charCodeAt(e20) === 44 || this.match(bn$1.name) && t2)
      return true;
    if (this.match(bn$1._default) && t2) {
      const t3 = this.input.charCodeAt(this.nextTokenStartSince(e20 + 4));
      return t3 === 34 || t3 === 39;
    }
    return false;
  }
  parseExportFrom(e20, t2) {
    if (this.eatContextual("from")) {
      e20.source = this.parseImportSource(), this.checkExport(e20);
      const t3 = this.maybeParseImportAssertions();
      t3 && (e20.assertions = t3);
    } else
      t2 ? this.unexpected() : e20.source = null;
    this.semicolon();
  }
  shouldParseExportDeclaration() {
    if (this.match(bn$1.at) && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators"))) {
      if (!this.getPluginOption("decorators", "decoratorsBeforeExport"))
        return true;
      this.unexpected(this.state.start, Rn$1.DecoratorBeforeExport);
    }
    return this.state.type.keyword === "var" || this.state.type.keyword === "const" || this.state.type.keyword === "function" || this.state.type.keyword === "class" || this.isLet() || this.isAsyncFunction();
  }
  checkExport(e20, t2, s2, r2) {
    if (t2) {
      if (s2) {
        if (this.checkDuplicateExports(e20, "default"), this.hasPlugin("exportDefaultFrom")) {
          var i2;
          const t3 = e20.declaration;
          t3.type !== "Identifier" || t3.name !== "from" || t3.end - t3.start != 4 || (i2 = t3.extra) != null && i2.parenthesized || this.raise(t3.start, Rn$1.ExportDefaultFromAsIdentifier);
        }
      } else if (e20.specifiers && e20.specifiers.length)
        for (const t3 of e20.specifiers) {
          const { exported: e21 } = t3, s3 = e21.type === "Identifier" ? e21.name : e21.value;
          if (this.checkDuplicateExports(t3, s3), !r2 && t3.local) {
            const { local: e22 } = t3;
            e22.type !== "Identifier" ? this.raise(t3.start, Rn$1.ExportBindingIsString, e22.value, s3) : (this.checkReservedWord(e22.name, e22.start, true, false), this.scope.checkLocalExport(e22));
          }
        }
      else if (e20.declaration) {
        if (e20.declaration.type === "FunctionDeclaration" || e20.declaration.type === "ClassDeclaration") {
          const t3 = e20.declaration.id;
          if (!t3)
            throw new Error("Assertion failure");
          this.checkDuplicateExports(e20, t3.name);
        } else if (e20.declaration.type === "VariableDeclaration")
          for (const t3 of e20.declaration.declarations)
            this.checkDeclaration(t3.id);
      }
    }
    if (this.state.decoratorStack[this.state.decoratorStack.length - 1].length)
      throw this.raise(e20.start, Rn$1.UnsupportedDecoratorExport);
  }
  checkDeclaration(e20) {
    if (e20.type === "Identifier")
      this.checkDuplicateExports(e20, e20.name);
    else if (e20.type === "ObjectPattern")
      for (const t2 of e20.properties)
        this.checkDeclaration(t2);
    else if (e20.type === "ArrayPattern")
      for (const t2 of e20.elements)
        t2 && this.checkDeclaration(t2);
    else
      e20.type === "ObjectProperty" ? this.checkDeclaration(e20.value) : e20.type === "RestElement" ? this.checkDeclaration(e20.argument) : e20.type === "AssignmentPattern" && this.checkDeclaration(e20.left);
  }
  checkDuplicateExports(e20, t2) {
    this.exportedIdentifiers.has(t2) && this.raise(e20.start, t2 === "default" ? Rn$1.DuplicateDefaultExport : Rn$1.DuplicateExport, t2), this.exportedIdentifiers.add(t2);
  }
  parseExportSpecifiers() {
    const e20 = [];
    let t2 = true;
    for (this.expect(bn$1.braceL); !this.eat(bn$1.braceR); ) {
      if (t2)
        t2 = false;
      else if (this.expect(bn$1.comma), this.eat(bn$1.braceR))
        break;
      const s2 = this.startNode(), r2 = this.match(bn$1.string), i2 = this.parseModuleExportName();
      s2.local = i2, this.eatContextual("as") ? s2.exported = this.parseModuleExportName() : s2.exported = r2 ? vo$1(i2) : Io$1(i2), e20.push(this.finishNode(s2, "ExportSpecifier"));
    }
    return e20;
  }
  parseModuleExportName() {
    if (this.match(bn$1.string)) {
      const e20 = this.parseStringLiteral(this.state.value), t2 = e20.value.match(hu);
      return t2 && this.raise(e20.start, Rn$1.ModuleExportNameHasLoneSurrogate, t2[0].charCodeAt(0).toString(16)), e20;
    }
    return this.parseIdentifier(true);
  }
  parseImport(e20) {
    if (e20.specifiers = [], !this.match(bn$1.string)) {
      const t3 = !this.maybeParseDefaultImportSpecifier(e20) || this.eat(bn$1.comma), s2 = t3 && this.maybeParseStarImportSpecifier(e20);
      t3 && !s2 && this.parseNamedImportSpecifiers(e20), this.expectContextual("from");
    }
    e20.source = this.parseImportSource();
    const t2 = this.maybeParseImportAssertions();
    if (t2)
      e20.assertions = t2;
    else {
      const t3 = this.maybeParseModuleAttributes();
      t3 && (e20.attributes = t3);
    }
    return this.semicolon(), this.finishNode(e20, "ImportDeclaration");
  }
  parseImportSource() {
    return this.match(bn$1.string) || this.unexpected(), this.parseExprAtom();
  }
  shouldParseDefaultImport(e20) {
    return this.match(bn$1.name);
  }
  parseImportSpecifierLocal(e20, t2, s2, r2) {
    t2.local = this.parseIdentifier(), this.checkLVal(t2.local, r2, 9), e20.specifiers.push(this.finishNode(t2, s2));
  }
  parseAssertEntries() {
    const e20 = [], t2 = new Set();
    do {
      if (this.match(bn$1.braceR))
        break;
      const s2 = this.startNode(), r2 = this.state.value;
      if (t2.has(r2) && this.raise(this.state.start, Rn$1.ModuleAttributesWithDuplicateKeys, r2), t2.add(r2), this.match(bn$1.string) ? s2.key = this.parseStringLiteral(r2) : s2.key = this.parseIdentifier(true), this.expect(bn$1.colon), !this.match(bn$1.string))
        throw this.unexpected(this.state.start, Rn$1.ModuleAttributeInvalidValue);
      s2.value = this.parseStringLiteral(this.state.value), this.finishNode(s2, "ImportAttribute"), e20.push(s2);
    } while (this.eat(bn$1.comma));
    return e20;
  }
  maybeParseModuleAttributes() {
    if (!this.match(bn$1._with) || this.hasPrecedingLineBreak())
      return this.hasPlugin("moduleAttributes") ? [] : null;
    this.expectPlugin("moduleAttributes"), this.next();
    const e20 = [], t2 = new Set();
    do {
      const s2 = this.startNode();
      if (s2.key = this.parseIdentifier(true), s2.key.name !== "type" && this.raise(s2.key.start, Rn$1.ModuleAttributeDifferentFromType, s2.key.name), t2.has(s2.key.name) && this.raise(s2.key.start, Rn$1.ModuleAttributesWithDuplicateKeys, s2.key.name), t2.add(s2.key.name), this.expect(bn$1.colon), !this.match(bn$1.string))
        throw this.unexpected(this.state.start, Rn$1.ModuleAttributeInvalidValue);
      s2.value = this.parseStringLiteral(this.state.value), this.finishNode(s2, "ImportAttribute"), e20.push(s2);
    } while (this.eat(bn$1.comma));
    return e20;
  }
  maybeParseImportAssertions() {
    if (!this.isContextual("assert") || this.hasPrecedingLineBreak())
      return this.hasPlugin("importAssertions") ? [] : null;
    this.expectPlugin("importAssertions"), this.next(), this.eat(bn$1.braceL);
    const e20 = this.parseAssertEntries();
    return this.eat(bn$1.braceR), e20;
  }
  maybeParseDefaultImportSpecifier(e20) {
    return !!this.shouldParseDefaultImport(e20) && (this.parseImportSpecifierLocal(e20, this.startNode(), "ImportDefaultSpecifier", "default import specifier"), true);
  }
  maybeParseStarImportSpecifier(e20) {
    if (this.match(bn$1.star)) {
      const t2 = this.startNode();
      return this.next(), this.expectContextual("as"), this.parseImportSpecifierLocal(e20, t2, "ImportNamespaceSpecifier", "import namespace specifier"), true;
    }
    return false;
  }
  parseNamedImportSpecifiers(e20) {
    let t2 = true;
    for (this.expect(bn$1.braceL); !this.eat(bn$1.braceR); ) {
      if (t2)
        t2 = false;
      else {
        if (this.eat(bn$1.colon))
          throw this.raise(this.state.start, Rn$1.DestructureNamedImport);
        if (this.expect(bn$1.comma), this.eat(bn$1.braceR))
          break;
      }
      this.parseImportSpecifier(e20);
    }
  }
  parseImportSpecifier(e20) {
    const t2 = this.startNode(), s2 = this.match(bn$1.string);
    if (t2.imported = this.parseModuleExportName(), this.eatContextual("as"))
      t2.local = this.parseIdentifier();
    else {
      const { imported: e21 } = t2;
      if (s2)
        throw this.raise(t2.start, Rn$1.ImportBindingIsString, e21.value);
      this.checkReservedWord(e21.name, t2.start, true, true), t2.local = Io$1(e21);
    }
    this.checkLVal(t2.local, "import specifier", 9), e20.specifiers.push(this.finishNode(t2, "ImportSpecifier"));
  }
  isThisParam(e20) {
    return e20.type === "Identifier" && e20.name === "this";
  }
} {
  constructor(e20, t2) {
    super(e20 = function(e21) {
      const t3 = {};
      for (const s2 of Object.keys(au))
        t3[s2] = e21 && e21[s2] != null ? e21[s2] : au[s2];
      return t3;
    }(e20), t2), this.options = e20, this.initializeScopes(), this.plugins = function(e21) {
      const t3 = new Map();
      for (const s2 of e21) {
        const [e22, r2] = Array.isArray(s2) ? s2 : [s2, {}];
        t3.has(e22) || t3.set(e22, r2 || {});
      }
      return t3;
    }(this.options.plugins), this.filename = e20.sourceFilename;
  }
  getScopeHandler() {
    return co$1;
  }
  parse() {
    this.enterInitialScopes();
    const e20 = this.startNode(), t2 = this.startNode();
    return this.nextToken(), e20.errors = null, this.parseTopLevel(e20, t2), e20.errors = this.state.errors, e20;
  }
}
function lu(e20, t2) {
  let s2 = pu;
  return e20 != null && e20.plugins && (!function(e21) {
    if (Qo(e21, "decorators")) {
      if (Qo(e21, "decorators-legacy"))
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      const t3 = Zo(e21, "decorators", "decoratorsBeforeExport");
      if (t3 == null)
        throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.");
      if (typeof t3 != "boolean")
        throw new Error("'decoratorsBeforeExport' must be a boolean.");
    }
    if (Qo(e21, "flow") && Qo(e21, "typescript"))
      throw new Error("Cannot combine flow and typescript plugins.");
    if (Qo(e21, "placeholders") && Qo(e21, "v8intrinsic"))
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (Qo(e21, "pipelineOperator")) {
      const t3 = Zo(e21, "pipelineOperator", "proposal");
      if (!eu.includes(t3)) {
        const e22 = eu.map((e23) => `"${e23}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${e22}.`);
      }
      const s3 = Qo(e21, "recordAndTuple") && Zo(e21, "recordAndTuple", "syntaxType") === "hash";
      if (t3 === "hack") {
        if (Qo(e21, "placeholders"))
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (Qo(e21, "v8intrinsic"))
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        const t4 = Zo(e21, "pipelineOperator", "topicToken");
        if (!tu.includes(t4)) {
          const e22 = tu.map((e23) => `"${e23}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${e22}.`);
        }
        if (t4 === "#" && s3)
          throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
      } else if (t3 === "smart" && s3)
        throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
    }
    if (Qo(e21, "moduleAttributes")) {
      if (Qo(e21, "importAssertions"))
        throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
      if (Zo(e21, "moduleAttributes", "version") !== "may-2020")
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
    }
    if (Qo(e21, "recordAndTuple") && !su.includes(Zo(e21, "recordAndTuple", "syntaxType")))
      throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + su.map((e22) => `'${e22}'`).join(", "));
    if (Qo(e21, "asyncDoExpressions") && !Qo(e21, "doExpressions")) {
      const e22 = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw e22.missingPlugins = "doExpressions", e22;
    }
  }(e20.plugins), s2 = function(e21) {
    const t3 = iu.filter((t4) => Qo(e21, t4)), s3 = t3.join("/");
    let r2 = du[s3];
    if (!r2) {
      r2 = pu;
      for (const e22 of t3)
        r2 = ru[e22](r2);
      du[s3] = r2;
    }
    return r2;
  }(e20.plugins)), new s2(e20, t2);
}
const du = {};
var Du = function(e20, t2) {
  var s2;
  if (((s2 = t2) == null ? void 0 : s2.sourceType) !== "unambiguous")
    return lu(t2, e20).parse();
  t2 = Object.assign({}, t2);
  try {
    t2.sourceType = "module";
    const s3 = lu(t2, e20), r2 = s3.parse();
    if (s3.sawUnambiguousESM)
      return r2;
    if (s3.ambiguousScriptDifferentAst)
      try {
        return t2.sourceType = "script", lu(t2, e20).parse();
      } catch (e21) {
      }
    else
      r2.program.sourceType = "script";
    return r2;
  } catch (s3) {
    try {
      return t2.sourceType = "script", lu(t2, e20).parse();
    } catch (e21) {
    }
    throw s3;
  }
}, mu = function(e20, t2) {
  const s2 = lu(t2, e20);
  return s2.options.strictMode && (s2.state.strict = true), s2.getExpression();
}, fu = bn$1, yu = Object.defineProperty({ parse: Du, parseExpression: mu, tokTypes: fu }, "__esModule", { value: true });
const { isNonEmptyArray: Au } = tr$1;
function Eu(e20 = {}) {
  const { allowComments: t2 = true } = e20;
  return function(e21) {
    const { parseExpression: s2 } = yu;
    let r2;
    try {
      r2 = s2(e21, { tokens: true, ranges: true });
    } catch (e22) {
      throw ni$1(e22);
    }
    if (!t2 && Au(r2.comments))
      throw Cu(r2.comments[0], "Comment");
    return xu(r2), r2;
  };
}
function Cu(e20, t2) {
  const [s2, r2] = [e20.loc.start, e20.loc.end].map(({ line: e21, column: t3 }) => ({
    line: e21,
    column: t3 + 1
  }));
  return ai$1(`${t2} is not allowed in JSON.`, { start: s2, end: r2 });
}
function xu(e20) {
  switch (e20.type) {
    case "ArrayExpression":
      for (const t2 of e20.elements)
        t2 !== null && xu(t2);
      return;
    case "ObjectExpression":
      for (const t2 of e20.properties)
        xu(t2);
      return;
    case "ObjectProperty":
      if (e20.computed)
        throw Cu(e20.key, "Computed key");
      if (e20.shorthand)
        throw Cu(e20.key, "Shorthand property");
      return e20.key.type !== "Identifier" && xu(e20.key), void xu(e20.value);
    case "UnaryExpression": {
      const { operator: t2, argument: s2 } = e20;
      if (t2 !== "+" && t2 !== "-")
        throw Cu(e20, `Operator '${e20.operator}'`);
      if (s2.type === "NumericLiteral" || s2.type === "Identifier" && (s2.name === "Infinity" || s2.name === "NaN"))
        return;
      throw Cu(s2, `Operator '${t2}' before '${s2.type}'`);
    }
    case "Identifier":
      if (e20.name !== "Infinity" && e20.name !== "NaN" && e20.name !== "undefined")
        throw Cu(e20, `Identifier '${e20.name}'`);
      return;
    case "TemplateLiteral":
      if (Au(e20.expressions))
        throw Cu(e20.expressions[0], "'TemplateLiteral' with expression");
      for (const t2 of e20.quasis)
        xu(t2);
      return;
    case "NullLiteral":
    case "BooleanLiteral":
    case "NumericLiteral":
    case "StringLiteral":
    case "TemplateElement":
      return;
    default:
      throw Cu(e20, `'${e20.type}'`);
  }
}
const Fu = Eu();
var gu = {
  json: ii$1({ parse: Fu, hasPragma: () => true }),
  json5: ii$1(Fu),
  "json-stringify": ii$1({
    parse: Eu({ allowComments: false }),
    astFormat: "estree-json"
  })
};
const {
  getNextNonSpaceNonCommentCharacterIndexWithStartIndex: bu,
  getShebang: Pu
} = tr$1, Tu = {
  sourceType: "module",
  allowImportExportEverywhere: true,
  allowReturnOutsideFunction: true,
  allowSuperOutsideMethod: true,
  allowUndeclaredExports: true,
  errorRecovery: true,
  createParenthesizedExpressions: true,
  plugins: [
    "doExpressions",
    "exportDefaultFrom",
    "functionBind",
    "functionSent",
    "throwExpressions",
    "partialApplication",
    ["decorators", { decoratorsBeforeExport: false }],
    "importAssertions",
    "decimal",
    "classStaticBlock",
    "moduleBlocks",
    "asyncDoExpressions"
  ],
  tokens: true,
  ranges: true
}, wu = ["recordAndTuple", { syntaxType: "hash" }], Su = [
  ["pipelineOperator", { proposal: "hack", topicToken: "%" }],
  ["pipelineOperator", { proposal: "minimal" }],
  ["pipelineOperator", { proposal: "fsharp" }]
], Bu = (e20, t2 = Tu) => Object.assign(Object.assign({}, t2), {}, { plugins: [...t2.plugins, ...e20] }), Nu = /@(?:no)?flow\b/;
function Iu(e20, ...t2) {
  return (s2, r2, i2 = {}) => {
    if ((i2.parser === "babel" || i2.parser === "__babel_estree") && function(e21, t3) {
      if (t3.filepath && t3.filepath.endsWith(".js.flow"))
        return true;
      const s3 = Pu(e21);
      s3 && (e21 = e21.slice(s3.length));
      const r3 = bu(e21, 0);
      return r3 !== false && (e21 = e21.slice(0, r3)), Nu.test(e21);
    }(s2, i2))
      return i2.parser = "babel-flow", ku(s2, r2, i2);
    let a2 = t2;
    i2.__babelSourceType === "script" && (a2 = a2.map((e21) => Object.assign(Object.assign({}, e21), {}, { sourceType: "script" }))), /#[[{]/.test(s2) && (a2 = a2.map((e21) => Bu([wu], e21)));
    const n2 = /%[A-Z]/.test(s2);
    if (s2.includes("|>")) {
      const e21 = n2 ? [...Su, "v8intrinsic"] : Su;
      a2 = e21.flatMap((e22) => a2.map((t3) => Bu([e22], t3)));
    } else
      n2 && (a2 = a2.map((e21) => Bu(["v8intrinsic"], e21)));
    const { result: o2, error: u2 } = Je$2(...a2.map((t3) => () => function(e21, t4, s3) {
      const r3 = (0, yu[e21])(t4, s3), i3 = r3.errors.find((e22) => !Ru.has(e22.reasonCode));
      if (i3)
        throw i3;
      return r3;
    }(e20, s2, t3)));
    if (!o2)
      throw ni$1(u2);
    return En$1(o2, Object.assign(Object.assign({}, i2), {}, { originalText: s2 }));
  };
}
const vu = Iu("parse", Bu(["jsx", "flow"])), ku = Iu("parse", Bu(["jsx", ["flow", { all: true, enums: true }]])), Lu = Iu("parse", Bu(["jsx", "typescript"]), Bu(["typescript"])), Ou = Iu("parse", Bu(["jsx", "flow", "estree"])), Mu = Iu("parseExpression", Bu(["jsx"])), Ru = new Set([
  "StrictNumericEscape",
  "StrictWith",
  "StrictOctalLiteral",
  "EmptyTypeArguments",
  "EmptyTypeParameters",
  "ConstructorHasTypeParameters",
  "UnsupportedParameterPropertyKind",
  "UnexpectedParameterModifier",
  "MixedLabeledAndUnlabeledElements",
  "InvalidTupleMemberLabel",
  "NonClassMethodPropertyHasAbstractModifer",
  "ReadonlyForMethodSignature",
  "ClassMethodHasDeclare",
  "ClassMethodHasReadonly",
  "InvalidModifierOnTypeMember",
  "DuplicateAccessibilityModifier",
  "IndexSignatureHasDeclare",
  "DecoratorExportClass",
  "ParamDupe",
  "InvalidDecimal",
  "RestTrailingComma",
  "UnsupportedParameterDecorator",
  "UnterminatedJsxContent",
  "UnexpectedReservedWord",
  "ModuleAttributesWithDuplicateKeys",
  "LineTerminatorBeforeArrow",
  "InvalidEscapeSequenceTemplate",
  "NonAbstractClassHasAbstractMethod",
  "UnsupportedPropertyDecorator",
  "OptionalTypeBeforeRequired",
  "PatternIsOptional",
  "OptionalBindingPattern",
  "DeclareClassFieldHasInitializer",
  "TypeImportCannotSpecifyDefaultAndNamed",
  "DeclareFunctionHasImplementation",
  "ConstructorClassField",
  "VarRedeclaration",
  "InvalidPrivateFieldResolution",
  "DuplicateExport"
]), ju = ii$1(vu), _u = ii$1(Mu);
var Uu = {
  parsers: Object.assign(Object.assign({ babel: ju, "babel-flow": ii$1(ku), "babel-ts": ii$1(Lu) }, gu), {}, {
    __js_expression: _u,
    __vue_expression: _u,
    __vue_event_binding: ju,
    __babel_estree: ii$1(Ou)
  })
};
var e$1 = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
function t$1(e20) {
  var t2 = { exports: {} };
  return e20(t2, t2.exports), t2.exports;
}
var r$1 = t$1(function(e20, t2) {
  function r2(e21) {
    return t2.$0 <= e21 && e21 <= t2.$9;
  }
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  Object.defineProperty(t2, "__esModule", { value: true }), t2.$EOF = 0, t2.$BSPACE = 8, t2.$TAB = 9, t2.$LF = 10, t2.$VTAB = 11, t2.$FF = 12, t2.$CR = 13, t2.$SPACE = 32, t2.$BANG = 33, t2.$DQ = 34, t2.$HASH = 35, t2.$$ = 36, t2.$PERCENT = 37, t2.$AMPERSAND = 38, t2.$SQ = 39, t2.$LPAREN = 40, t2.$RPAREN = 41, t2.$STAR = 42, t2.$PLUS = 43, t2.$COMMA = 44, t2.$MINUS = 45, t2.$PERIOD = 46, t2.$SLASH = 47, t2.$COLON = 58, t2.$SEMICOLON = 59, t2.$LT = 60, t2.$EQ = 61, t2.$GT = 62, t2.$QUESTION = 63, t2.$0 = 48, t2.$7 = 55, t2.$9 = 57, t2.$A = 65, t2.$E = 69, t2.$F = 70, t2.$X = 88, t2.$Z = 90, t2.$LBRACKET = 91, t2.$BACKSLASH = 92, t2.$RBRACKET = 93, t2.$CARET = 94, t2.$_ = 95, t2.$a = 97, t2.$b = 98, t2.$e = 101, t2.$f = 102, t2.$n = 110, t2.$r = 114, t2.$t = 116, t2.$u = 117, t2.$v = 118, t2.$x = 120, t2.$z = 122, t2.$LBRACE = 123, t2.$BAR = 124, t2.$RBRACE = 125, t2.$NBSP = 160, t2.$PIPE = 124, t2.$TILDA = 126, t2.$AT = 64, t2.$BT = 96, t2.isWhitespace = function(e21) {
    return e21 >= t2.$TAB && e21 <= t2.$SPACE || e21 == t2.$NBSP;
  }, t2.isDigit = r2, t2.isAsciiLetter = function(e21) {
    return e21 >= t2.$a && e21 <= t2.$z || e21 >= t2.$A && e21 <= t2.$Z;
  }, t2.isAsciiHexDigit = function(e21) {
    return e21 >= t2.$a && e21 <= t2.$f || e21 >= t2.$A && e21 <= t2.$F || r2(e21);
  }, t2.isNewLine = function(e21) {
    return e21 === t2.$LF || e21 === t2.$CR;
  }, t2.isOctalDigit = function(e21) {
    return t2.$0 <= e21 && e21 <= t2.$7;
  };
});
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class n$1 {
  constructor(e20, t2, r2) {
    this.filePath = e20, this.name = t2, this.members = r2;
  }
  assertNoMembers() {
    if (this.members.length)
      throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);
  }
}
var i$1 = n$1;
var s$1 = class {
  constructor() {
    this.cache = new Map();
  }
  get(e20, t2, r2) {
    const i2 = `"${e20}".${t2}${(r2 = r2 || []).length ? `.${r2.join(".")}` : ""}`;
    let s2 = this.cache.get(i2);
    return s2 || (s2 = new n$1(e20, t2, r2), this.cache.set(i2, s2)), s2;
  }
}, o$1 = Object.defineProperty({ StaticSymbol: i$1, StaticSymbolCache: s$1 }, "__esModule", { value: true });
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const a$1$1 = /-+([a-z0-9])/g;
var u$1 = function(e20) {
  return e20.replace(a$1$1, (...e21) => e21[1].toUpperCase());
};
var c$1 = function(e20, t2) {
  return p$1(e20, ":", t2);
};
var l$1 = function(e20, t2) {
  return p$1(e20, ".", t2);
};
function p$1(e20, t2, r2) {
  const n2 = e20.indexOf(t2);
  return n2 == -1 ? r2 : [e20.slice(0, n2).trim(), e20.slice(n2 + 1).trim()];
}
function h$1(e20, t2, r2) {
  return Array.isArray(e20) ? t2.visitArray(e20, r2) : typeof (n2 = e20) == "object" && n2 !== null && Object.getPrototypeOf(n2) === v$1 ? t2.visitStringMap(e20, r2) : e20 == null || typeof e20 == "string" || typeof e20 == "number" || typeof e20 == "boolean" ? t2.visitPrimitive(e20, r2) : t2.visitOther(e20, r2);
  var n2;
}
var D$1 = h$1;
var f$1 = function(e20) {
  return e20 != null;
};
var d$1$1 = function(e20) {
  return e20 === void 0 ? null : e20;
};
var g$1 = class {
  visitArray(e20, t2) {
    return e20.map((e21) => h$1(e21, this, t2));
  }
  visitStringMap(e20, t2) {
    const r2 = {};
    return Object.keys(e20).forEach((n2) => {
      r2[n2] = h$1(e20[n2], this, t2);
    }), r2;
  }
  visitPrimitive(e20, t2) {
    return e20;
  }
  visitOther(e20, t2) {
    return e20;
  }
}, m$1 = {
  assertSync: (e20) => {
    if (k$1$1(e20))
      throw new Error("Illegal state: value cannot be a promise");
    return e20;
  },
  then: (e20, t2) => k$1$1(e20) ? e20.then(t2) : t2(e20),
  all: (e20) => e20.some(k$1$1) ? Promise.all(e20) : e20
};
var E$1 = function(e20) {
  throw new Error(`Internal Error: ${e20}`);
};
var C$1 = function(e20, t2) {
  const r2 = Error(e20);
  return r2[y$1] = true, t2 && (r2[b$1] = t2), r2;
};
const y$1 = "ngSyntaxError", b$1 = "ngParseErrors";
var S$1 = function(e20) {
  return e20[y$1];
};
var T$1 = function(e20) {
  return e20[b$1] || [];
};
var _$1 = function(e20) {
  return e20.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
};
const v$1 = Object.getPrototypeOf({});
var A$1 = function(e20) {
  let t2 = "";
  for (let r2 = 0; r2 < e20.length; r2++) {
    let n2 = e20.charCodeAt(r2);
    if (n2 >= 55296 && n2 <= 56319 && e20.length > r2 + 1) {
      const t3 = e20.charCodeAt(r2 + 1);
      t3 >= 56320 && t3 <= 57343 && (r2++, n2 = (n2 - 55296 << 10) + t3 - 56320 + 65536);
    }
    n2 <= 127 ? t2 += String.fromCharCode(n2) : n2 <= 2047 ? t2 += String.fromCharCode(n2 >> 6 & 31 | 192, 63 & n2 | 128) : n2 <= 65535 ? t2 += String.fromCharCode(n2 >> 12 | 224, n2 >> 6 & 63 | 128, 63 & n2 | 128) : n2 <= 2097151 && (t2 += String.fromCharCode(n2 >> 18 & 7 | 240, n2 >> 12 & 63 | 128, n2 >> 6 & 63 | 128, 63 & n2 | 128));
  }
  return t2;
};
var F$1 = function e18(t2) {
  if (typeof t2 == "string")
    return t2;
  if (t2 instanceof Array)
    return "[" + t2.map(e18).join(", ") + "]";
  if (t2 == null)
    return "" + t2;
  if (t2.overriddenName)
    return `${t2.overriddenName}`;
  if (t2.name)
    return `${t2.name}`;
  if (!t2.toString)
    return "object";
  const r2 = t2.toString();
  if (r2 == null)
    return "" + r2;
  const n2 = r2.indexOf("\n");
  return n2 === -1 ? r2 : r2.substring(0, n2);
};
var w$1 = function(e20) {
  return typeof e20 == "function" && e20.hasOwnProperty("__forward_ref__") ? e20() : e20;
};
function k$1$1(e20) {
  return !!e20 && typeof e20.then == "function";
}
var N$1 = k$1$1;
var O$1 = class {
  constructor(e20) {
    this.full = e20;
    const t2 = e20.split(".");
    this.major = t2[0], this.minor = t2[1], this.patch = t2.slice(2).join(".");
  }
};
const x$1 = typeof window != "undefined" && window, I$1 = typeof self != "undefined" && typeof WorkerGlobalScope != "undefined" && self instanceof WorkerGlobalScope && self;
var P$1 = e$1 !== void 0 && e$1 || x$1 || I$1, R$1 = Object.defineProperty({
  dashCaseToCamelCase: u$1,
  splitAtColon: c$1,
  splitAtPeriod: l$1,
  visitValue: D$1,
  isDefined: f$1,
  noUndefined: d$1$1,
  ValueTransformer: g$1,
  SyncAsync: m$1,
  error: E$1,
  syntaxError: C$1,
  isSyntaxError: S$1,
  getParseErrors: T$1,
  escapeRegExp: _$1,
  utf8Encode: A$1,
  stringify: F$1,
  resolveForwardRef: w$1,
  isPromise: N$1,
  Version: O$1,
  global: P$1
}, "__esModule", { value: true }), L$1 = t$1(function(e20, t2) {
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  Object.defineProperty(t2, "__esModule", { value: true });
  const r2 = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
  function n2(e21) {
    return e21.replace(/\W/g, "_");
  }
  t2.sanitizeIdentifier = n2;
  let i2 = 0;
  function s2(e21) {
    if (!e21 || !e21.reference)
      return null;
    const t3 = e21.reference;
    if (t3 instanceof o$1.StaticSymbol)
      return t3.name;
    if (t3.__anonymousType)
      return t3.__anonymousType;
    let r3 = R$1.stringify(t3);
    return r3.indexOf("(") >= 0 ? (r3 = "anonymous_" + i2++, t3.__anonymousType = r3) : r3 = n2(r3), r3;
  }
  var a2;
  t2.identifierName = s2, t2.identifierModuleUrl = function(e21) {
    const t3 = e21.reference;
    return t3 instanceof o$1.StaticSymbol ? t3.filePath : `./${R$1.stringify(t3)}`;
  }, t2.viewClassName = function(e21, t3) {
    return `View_${s2({ reference: e21 })}_${t3}`;
  }, t2.rendererTypeName = function(e21) {
    return `RenderType_${s2({ reference: e21 })}`;
  }, t2.hostViewClassName = function(e21) {
    return `HostView_${s2({ reference: e21 })}`;
  }, t2.componentFactoryName = function(e21) {
    return `${s2({ reference: e21 })}NgFactory`;
  }, function(e21) {
    e21[e21.Pipe = 0] = "Pipe", e21[e21.Directive = 1] = "Directive", e21[e21.NgModule = 2] = "NgModule", e21[e21.Injectable = 3] = "Injectable";
  }(a2 = t2.CompileSummaryKind || (t2.CompileSummaryKind = {})), t2.tokenName = function(e21) {
    return e21.value != null ? n2(e21.value) : s2(e21.identifier);
  }, t2.tokenReference = function(e21) {
    return e21.identifier != null ? e21.identifier.reference : e21.value;
  };
  t2.CompileStylesheetMetadata = class {
    constructor({ moduleUrl: e21, styles: t3, styleUrls: r3 } = {}) {
      this.moduleUrl = e21 || null, this.styles = c2(t3), this.styleUrls = c2(r3);
    }
  };
  t2.CompileTemplateMetadata = class {
    constructor({
      encapsulation: e21,
      template: t3,
      templateUrl: r3,
      htmlAst: n3,
      styles: i3,
      styleUrls: s3,
      externalStylesheets: o2,
      animations: a3,
      ngContentSelectors: u3,
      interpolation: p3,
      isInline: h2,
      preserveWhitespaces: D2
    }) {
      if (this.encapsulation = e21, this.template = t3, this.templateUrl = r3, this.htmlAst = n3, this.styles = c2(i3), this.styleUrls = c2(s3), this.externalStylesheets = c2(o2), this.animations = a3 ? l2(a3) : [], this.ngContentSelectors = u3 || [], p3 && p3.length != 2)
        throw new Error("'interpolation' should have a start and an end symbol.");
      this.interpolation = p3, this.isInline = h2, this.preserveWhitespaces = D2;
    }
    toSummary() {
      return {
        ngContentSelectors: this.ngContentSelectors,
        encapsulation: this.encapsulation,
        styles: this.styles,
        animations: this.animations
      };
    }
  };
  class u2 {
    static create({
      isHost: e21,
      type: t3,
      isComponent: n3,
      selector: i3,
      exportAs: s3,
      changeDetection: o2,
      inputs: a3,
      outputs: c3,
      host: l3,
      providers: p3,
      viewProviders: h2,
      queries: D2,
      guards: f2,
      viewQueries: d2,
      entryComponents: g2,
      template: m2,
      componentViewType: E2,
      rendererType: C2,
      componentFactory: y2
    }) {
      const b2 = {}, S2 = {}, T2 = {};
      l3 != null && Object.keys(l3).forEach((e22) => {
        const t4 = l3[e22], n4 = e22.match(r2);
        n4 === null ? T2[e22] = t4 : n4[1] != null ? S2[n4[1]] = t4 : n4[2] != null && (b2[n4[2]] = t4);
      });
      const _2 = {};
      a3 != null && a3.forEach((e22) => {
        const t4 = R$1.splitAtColon(e22, [e22, e22]);
        _2[t4[0]] = t4[1];
      });
      const v2 = {};
      return c3 != null && c3.forEach((e22) => {
        const t4 = R$1.splitAtColon(e22, [e22, e22]);
        v2[t4[0]] = t4[1];
      }), new u2({
        isHost: e21,
        type: t3,
        isComponent: !!n3,
        selector: i3,
        exportAs: s3,
        changeDetection: o2,
        inputs: _2,
        outputs: v2,
        hostListeners: b2,
        hostProperties: S2,
        hostAttributes: T2,
        providers: p3,
        viewProviders: h2,
        queries: D2,
        guards: f2,
        viewQueries: d2,
        entryComponents: g2,
        template: m2,
        componentViewType: E2,
        rendererType: C2,
        componentFactory: y2
      });
    }
    constructor({
      isHost: e21,
      type: t3,
      isComponent: r3,
      selector: n3,
      exportAs: i3,
      changeDetection: s3,
      inputs: o2,
      outputs: a3,
      hostListeners: u3,
      hostProperties: l3,
      hostAttributes: p3,
      providers: h2,
      viewProviders: D2,
      queries: f2,
      guards: d2,
      viewQueries: g2,
      entryComponents: m2,
      template: E2,
      componentViewType: C2,
      rendererType: y2,
      componentFactory: b2
    }) {
      this.isHost = !!e21, this.type = t3, this.isComponent = r3, this.selector = n3, this.exportAs = i3, this.changeDetection = s3, this.inputs = o2, this.outputs = a3, this.hostListeners = u3, this.hostProperties = l3, this.hostAttributes = p3, this.providers = c2(h2), this.viewProviders = c2(D2), this.queries = c2(f2), this.guards = d2, this.viewQueries = c2(g2), this.entryComponents = c2(m2), this.template = E2, this.componentViewType = C2, this.rendererType = y2, this.componentFactory = b2;
    }
    toSummary() {
      return {
        summaryKind: a2.Directive,
        type: this.type,
        isComponent: this.isComponent,
        selector: this.selector,
        exportAs: this.exportAs,
        inputs: this.inputs,
        outputs: this.outputs,
        hostListeners: this.hostListeners,
        hostProperties: this.hostProperties,
        hostAttributes: this.hostAttributes,
        providers: this.providers,
        viewProviders: this.viewProviders,
        queries: this.queries,
        guards: this.guards,
        viewQueries: this.viewQueries,
        entryComponents: this.entryComponents,
        changeDetection: this.changeDetection,
        template: this.template && this.template.toSummary(),
        componentViewType: this.componentViewType,
        rendererType: this.rendererType,
        componentFactory: this.componentFactory
      };
    }
  }
  t2.CompileDirectiveMetadata = u2;
  t2.CompilePipeMetadata = class {
    constructor({ type: e21, name: t3, pure: r3 }) {
      this.type = e21, this.name = t3, this.pure = !!r3;
    }
    toSummary() {
      return {
        summaryKind: a2.Pipe,
        type: this.type,
        name: this.name,
        pure: this.pure
      };
    }
  };
  t2.CompileShallowModuleMetadata = class {
  };
  t2.CompileNgModuleMetadata = class {
    constructor({
      type: e21,
      providers: t3,
      declaredDirectives: r3,
      exportedDirectives: n3,
      declaredPipes: i3,
      exportedPipes: s3,
      entryComponents: o2,
      bootstrapComponents: a3,
      importedModules: u3,
      exportedModules: l3,
      schemas: p3,
      transitiveModule: h2,
      id: D2
    }) {
      this.type = e21 || null, this.declaredDirectives = c2(r3), this.exportedDirectives = c2(n3), this.declaredPipes = c2(i3), this.exportedPipes = c2(s3), this.providers = c2(t3), this.entryComponents = c2(o2), this.bootstrapComponents = c2(a3), this.importedModules = c2(u3), this.exportedModules = c2(l3), this.schemas = c2(p3), this.id = D2 || null, this.transitiveModule = h2 || null;
    }
    toSummary() {
      const e21 = this.transitiveModule;
      return {
        summaryKind: a2.NgModule,
        type: this.type,
        entryComponents: e21.entryComponents,
        providers: e21.providers,
        modules: e21.modules,
        exportedDirectives: e21.exportedDirectives,
        exportedPipes: e21.exportedPipes
      };
    }
  };
  function c2(e21) {
    return e21 || [];
  }
  t2.TransitiveCompileNgModuleMetadata = class {
    constructor() {
      this.directivesSet = new Set(), this.directives = [], this.exportedDirectivesSet = new Set(), this.exportedDirectives = [], this.pipesSet = new Set(), this.pipes = [], this.exportedPipesSet = new Set(), this.exportedPipes = [], this.modulesSet = new Set(), this.modules = [], this.entryComponentsSet = new Set(), this.entryComponents = [], this.providers = [];
    }
    addProvider(e21, t3) {
      this.providers.push({ provider: e21, module: t3 });
    }
    addDirective(e21) {
      this.directivesSet.has(e21.reference) || (this.directivesSet.add(e21.reference), this.directives.push(e21));
    }
    addExportedDirective(e21) {
      this.exportedDirectivesSet.has(e21.reference) || (this.exportedDirectivesSet.add(e21.reference), this.exportedDirectives.push(e21));
    }
    addPipe(e21) {
      this.pipesSet.has(e21.reference) || (this.pipesSet.add(e21.reference), this.pipes.push(e21));
    }
    addExportedPipe(e21) {
      this.exportedPipesSet.has(e21.reference) || (this.exportedPipesSet.add(e21.reference), this.exportedPipes.push(e21));
    }
    addModule(e21) {
      this.modulesSet.has(e21.reference) || (this.modulesSet.add(e21.reference), this.modules.push(e21));
    }
    addEntryComponent(e21) {
      this.entryComponentsSet.has(e21.componentType) || (this.entryComponentsSet.add(e21.componentType), this.entryComponents.push(e21));
    }
  };
  function l2(e21) {
    return e21.reduce((e22, t3) => {
      const r3 = Array.isArray(t3) ? l2(t3) : t3;
      return e22.concat(r3);
    }, []);
  }
  function p2(e21) {
    return e21.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
  }
  t2.ProviderMeta = class {
    constructor(e21, {
      useClass: t3,
      useValue: r3,
      useExisting: n3,
      useFactory: i3,
      deps: s3,
      multi: o2
    }) {
      this.token = e21, this.useClass = t3 || null, this.useValue = r3, this.useExisting = n3, this.useFactory = i3 || null, this.dependencies = s3 || null, this.multi = !!o2;
    }
  }, t2.flatten = l2, t2.templateSourceUrl = function(e21, t3, r3) {
    let n3;
    return n3 = r3.isInline ? t3.type.reference instanceof o$1.StaticSymbol ? `${t3.type.reference.filePath}.${t3.type.reference.name}.html` : `${s2(e21)}/${s2(t3.type)}.html` : r3.templateUrl, t3.type.reference instanceof o$1.StaticSymbol ? n3 : p2(n3);
  }, t2.sharedStylesheetJitUrl = function(e21, t3) {
    const r3 = e21.moduleUrl.split(/\/\\/g);
    return p2(`css/${t3}${r3[r3.length - 1]}.ngstyle.js`);
  }, t2.ngModuleJitUrl = function(e21) {
    return p2(`${s2(e21.type)}/module.ngfactory.js`);
  }, t2.templateJitUrl = function(e21, t3) {
    return p2(`${s2(e21)}/${s2(t3.type)}.ngfactory.js`);
  };
}), B$1 = t$1(function(e20, t2) {
  Object.defineProperty(t2, "__esModule", { value: true });
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class n2 {
    constructor(e21, t3, r2, n3) {
      this.file = e21, this.offset = t3, this.line = r2, this.col = n3;
    }
    toString() {
      return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
    }
    moveBy(e21) {
      const t3 = this.file.content, i3 = t3.length;
      let s3 = this.offset, o3 = this.line, a2 = this.col;
      for (; s3 > 0 && e21 < 0; ) {
        s3--, e21++;
        if (t3.charCodeAt(s3) == r$1.$LF) {
          o3--;
          const e22 = t3.substr(0, s3 - 1).lastIndexOf(String.fromCharCode(r$1.$LF));
          a2 = e22 > 0 ? s3 - e22 : s3;
        } else
          a2--;
      }
      for (; s3 < i3 && e21 > 0; ) {
        const n3 = t3.charCodeAt(s3);
        s3++, e21--, n3 == r$1.$LF ? (o3++, a2 = 0) : a2++;
      }
      return new n2(this.file, s3, o3, a2);
    }
    getContext(e21, t3) {
      const r2 = this.file.content;
      let n3 = this.offset;
      if (n3 != null) {
        n3 > r2.length - 1 && (n3 = r2.length - 1);
        let i3 = n3, s3 = 0, o3 = 0;
        for (; s3 < e21 && n3 > 0 && (n3--, s3++, r2[n3] != "\n" || ++o3 != t3); )
          ;
        for (s3 = 0, o3 = 0; s3 < e21 && i3 < r2.length - 1 && (i3++, s3++, r2[i3] != "\n" || ++o3 != t3); )
          ;
        return {
          before: r2.substring(n3, this.offset),
          after: r2.substring(this.offset, i3 + 1)
        };
      }
      return null;
    }
  }
  t2.ParseLocation = n2;
  class i2 {
    constructor(e21, t3) {
      this.content = e21, this.url = t3;
    }
  }
  t2.ParseSourceFile = i2;
  class s2 {
    constructor(e21, t3, r2 = null) {
      this.start = e21, this.end = t3, this.details = r2;
    }
    toString() {
      return this.start.file.content.substring(this.start.offset, this.end.offset);
    }
  }
  var o2;
  t2.ParseSourceSpan = s2, t2.EMPTY_PARSE_LOCATION = new n2(new i2("", ""), 0, 0, 0), t2.EMPTY_SOURCE_SPAN = new s2(t2.EMPTY_PARSE_LOCATION, t2.EMPTY_PARSE_LOCATION), function(e21) {
    e21[e21.WARNING = 0] = "WARNING", e21[e21.ERROR = 1] = "ERROR";
  }(o2 = t2.ParseErrorLevel || (t2.ParseErrorLevel = {}));
  t2.ParseError = class {
    constructor(e21, t3, r2 = o2.ERROR) {
      this.span = e21, this.msg = t3, this.level = r2;
    }
    contextualMessage() {
      const e21 = this.span.start.getContext(100, 3);
      return e21 ? `${this.msg} ("${e21.before}[${o2[this.level]} ->]${e21.after}")` : this.msg;
    }
    toString() {
      const e21 = this.span.details ? `, ${this.span.details}` : "";
      return `${this.contextualMessage()}: ${this.span.start}${e21}`;
    }
  }, t2.typeSourceSpan = function(e21, t3) {
    const r2 = L$1.identifierModuleUrl(t3), o3 = r2 != null ? `in ${e21} ${L$1.identifierName(t3)} in ${r2}` : `in ${e21} ${L$1.identifierName(t3)}`, a2 = new i2("", o3);
    return new s2(new n2(a2, -1, -1, -1), new n2(a2, -1, -1, -1));
  }, t2.r3JitTypeSourceSpan = function(e21, t3, r2) {
    const o3 = new i2("", `in ${e21} ${t3} in ${r2}`);
    return new s2(new n2(o3, -1, -1, -1), new n2(o3, -1, -1, -1));
  };
});
const $$1 = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
var q$1 = function(e20) {
  const t2 = e20.match($$1);
  if (!t2)
    return { content: e20 };
  const {
    startDelimiter: r2,
    language: n2,
    value: i2 = "",
    endDelimiter: s2
  } = t2.groups;
  let o2 = n2.trim() || "yaml";
  if (r2 === "+++" && (o2 = "toml"), o2 !== "yaml" && r2 !== s2)
    return { content: e20 };
  const [a2] = t2;
  return {
    frontMatter: {
      type: "front-matter",
      lang: o2,
      value: i2,
      startDelimiter: r2,
      endDelimiter: s2,
      raw: a2.replace(/\n$/, "")
    },
    content: a2.replace(/[^\n]/g, " ") + e20.slice(a2.length)
  };
};
var M$1 = (e20) => e20[e20.length - 1];
var j$1 = function(e20, t2) {
  const r2 = new SyntaxError(e20 + " (" + t2.start.line + ":" + t2.start.column + ")");
  return r2.loc = t2, r2;
}, U$1 = (e20) => typeof e20 == "string" ? e20.replace((({ onlyFirst: e21 = false } = {}) => {
  const t2 = [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
  ].join("|");
  return new RegExp(t2, e21 ? void 0 : "g");
})(), "") : e20;
const G$1 = (e20) => !Number.isNaN(e20) && e20 >= 4352 && (e20 <= 4447 || e20 === 9001 || e20 === 9002 || 11904 <= e20 && e20 <= 12871 && e20 !== 12351 || 12880 <= e20 && e20 <= 19903 || 19968 <= e20 && e20 <= 42182 || 43360 <= e20 && e20 <= 43388 || 44032 <= e20 && e20 <= 55203 || 63744 <= e20 && e20 <= 64255 || 65040 <= e20 && e20 <= 65049 || 65072 <= e20 && e20 <= 65131 || 65281 <= e20 && e20 <= 65376 || 65504 <= e20 && e20 <= 65510 || 110592 <= e20 && e20 <= 110593 || 127488 <= e20 && e20 <= 127569 || 131072 <= e20 && e20 <= 262141);
var V$1 = G$1, H$1 = G$1;
V$1.default = H$1;
const X$1 = (e20) => {
  if (typeof e20 != "string" || e20.length === 0)
    return 0;
  if ((e20 = U$1(e20)).length === 0)
    return 0;
  e20 = e20.replace(/\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g, "  ");
  let t2 = 0;
  for (let r2 = 0; r2 < e20.length; r2++) {
    const n2 = e20.codePointAt(r2);
    n2 <= 31 || n2 >= 127 && n2 <= 159 || n2 >= 768 && n2 <= 879 || (n2 > 65535 && r2++, t2 += V$1(n2) ? 2 : 1);
  }
  return t2;
};
var z$1 = X$1, W$1 = X$1;
z$1.default = W$1;
var Y$1 = (e20) => {
  if (typeof e20 != "string")
    throw new TypeError("Expected a string");
  return e20.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
};
function Q$1(e20, t2) {
  if (e20 == null)
    return {};
  var r2, n2, i2 = function(e21, t3) {
    if (e21 == null)
      return {};
    var r3, n3, i3 = {}, s3 = Object.keys(e21);
    for (n3 = 0; n3 < s3.length; n3++)
      r3 = s3[n3], t3.indexOf(r3) >= 0 || (i3[r3] = e21[r3]);
    return i3;
  }(e20, t2);
  if (Object.getOwnPropertySymbols) {
    var s2 = Object.getOwnPropertySymbols(e20);
    for (n2 = 0; n2 < s2.length; n2++)
      r2 = s2[n2], t2.indexOf(r2) >= 0 || Object.prototype.propertyIsEnumerable.call(e20, r2) && (i2[r2] = e20[r2]);
  }
  return i2;
}
var J$1, K$1, Z$1 = function(e20) {
  return e20 && e20.Math == Math && e20;
}, ee$1 = Z$1(typeof globalThis == "object" && globalThis) || Z$1(typeof window == "object" && window) || Z$1(typeof self == "object" && self) || Z$1(typeof e$1 == "object" && e$1) || function() {
  return this;
}() || Function("return this")(), te$1 = function(e20) {
  try {
    return !!e20();
  } catch (e21) {
    return true;
  }
}, re$1 = !te$1(function() {
  return Object.defineProperty({}, 1, {
    get: function() {
      return 7;
    }
  })[1] != 7;
}), ne$1 = {}.propertyIsEnumerable, ie$1 = Object.getOwnPropertyDescriptor, se$1 = {
  f: ie$1 && !ne$1.call({ 1: 2 }, 1) ? function(e20) {
    var t2 = ie$1(this, e20);
    return !!t2 && t2.enumerable;
  } : ne$1
}, oe$1 = function(e20, t2) {
  return {
    enumerable: !(1 & e20),
    configurable: !(2 & e20),
    writable: !(4 & e20),
    value: t2
  };
}, ae$1 = {}.toString, ue$1 = function(e20) {
  return ae$1.call(e20).slice(8, -1);
}, ce$1 = "".split, le$1 = te$1(function() {
  return !Object("z").propertyIsEnumerable(0);
}) ? function(e20) {
  return ue$1(e20) == "String" ? ce$1.call(e20, "") : Object(e20);
} : Object, pe$1 = function(e20) {
  if (e20 == null)
    throw TypeError("Can't call method on " + e20);
  return e20;
}, he$1 = function(e20) {
  return le$1(pe$1(e20));
}, De$1 = function(e20) {
  return typeof e20 == "object" ? e20 !== null : typeof e20 == "function";
}, fe$1 = function(e20) {
  return typeof e20 == "function" ? e20 : void 0;
}, de$1 = function(e20, t2) {
  return arguments.length < 2 ? fe$1(ee$1[e20]) : ee$1[e20] && ee$1[e20][t2];
}, ge$1 = de$1("navigator", "userAgent") || "", me$1 = ee$1.process, Ee$1 = ee$1.Deno, Ce$1 = me$1 && me$1.versions || Ee$1 && Ee$1.version, ye$1 = Ce$1 && Ce$1.v8;
ye$1 ? K$1 = (J$1 = ye$1.split("."))[0] < 4 ? 1 : J$1[0] + J$1[1] : ge$1 && (!(J$1 = ge$1.match(/Edge\/(\d+)/)) || J$1[1] >= 74) && (J$1 = ge$1.match(/Chrome\/(\d+)/)) && (K$1 = J$1[1]);
var be$1 = K$1 && +K$1, Se$1 = !!Object.getOwnPropertySymbols && !te$1(function() {
  var e20 = Symbol();
  return !String(e20) || !(Object(e20) instanceof Symbol) || !Symbol.sham && be$1 && be$1 < 41;
}), Te$1 = Se$1 && !Symbol.sham && typeof Symbol.iterator == "symbol", _e$1 = Te$1 ? function(e20) {
  return typeof e20 == "symbol";
} : function(e20) {
  var t2 = de$1("Symbol");
  return typeof t2 == "function" && Object(e20) instanceof t2;
}, ve$1 = function(e20, t2) {
  try {
    Object.defineProperty(ee$1, e20, {
      value: t2,
      configurable: true,
      writable: true
    });
  } catch (r2) {
    ee$1[e20] = t2;
  }
  return t2;
}, Ae$1 = ee$1["__core-js_shared__"] || ve$1("__core-js_shared__", {}), Fe$1 = t$1(function(e20) {
  (e20.exports = function(e21, t2) {
    return Ae$1[e21] || (Ae$1[e21] = t2 !== void 0 ? t2 : {});
  })("versions", []).push({
    version: "3.17.3",
    mode: "global",
    copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)"
  });
}), we$1 = function(e20) {
  return Object(pe$1(e20));
}, ke$1 = {}.hasOwnProperty, Ne$1 = Object.hasOwn || function(e20, t2) {
  return ke$1.call(we$1(e20), t2);
}, Oe$1 = 0, xe$1 = Math.random(), Ie$1 = function(e20) {
  return "Symbol(" + String(e20 === void 0 ? "" : e20) + ")_" + (++Oe$1 + xe$1).toString(36);
}, Pe$1 = Fe$1("wks"), Re$1 = ee$1.Symbol, Le$1 = Te$1 ? Re$1 : Re$1 && Re$1.withoutSetter || Ie$1, Be$1 = function(e20) {
  return Ne$1(Pe$1, e20) && (Se$1 || typeof Pe$1[e20] == "string") || (Se$1 && Ne$1(Re$1, e20) ? Pe$1[e20] = Re$1[e20] : Pe$1[e20] = Le$1("Symbol." + e20)), Pe$1[e20];
}, $e$1 = Be$1("toPrimitive"), qe$1 = function(e20, t2) {
  if (!De$1(e20) || _e$1(e20))
    return e20;
  var r2, n2 = e20[$e$1];
  if (n2 !== void 0) {
    if (t2 === void 0 && (t2 = "default"), r2 = n2.call(e20, t2), !De$1(r2) || _e$1(r2))
      return r2;
    throw TypeError("Can't convert object to primitive value");
  }
  return t2 === void 0 && (t2 = "number"), function(e21, t3) {
    var r3, n3;
    if (t3 === "string" && typeof (r3 = e21.toString) == "function" && !De$1(n3 = r3.call(e21)))
      return n3;
    if (typeof (r3 = e21.valueOf) == "function" && !De$1(n3 = r3.call(e21)))
      return n3;
    if (t3 !== "string" && typeof (r3 = e21.toString) == "function" && !De$1(n3 = r3.call(e21)))
      return n3;
    throw TypeError("Can't convert object to primitive value");
  }(e20, t2);
}, Me$1 = function(e20) {
  var t2 = qe$1(e20, "string");
  return _e$1(t2) ? t2 : String(t2);
}, je$1 = ee$1.document, Ue$1 = De$1(je$1) && De$1(je$1.createElement), Ge$1 = !re$1 && !te$1(function() {
  return Object.defineProperty((e20 = "div", Ue$1 ? je$1.createElement(e20) : {}), "a", {
    get: function() {
      return 7;
    }
  }).a != 7;
  var e20;
}), Ve$1 = Object.getOwnPropertyDescriptor, He$1 = {
  f: re$1 ? Ve$1 : function(e20, t2) {
    if (e20 = he$1(e20), t2 = Me$1(t2), Ge$1)
      try {
        return Ve$1(e20, t2);
      } catch (e21) {
      }
    if (Ne$1(e20, t2))
      return oe$1(!se$1.f.call(e20, t2), e20[t2]);
  }
}, Xe$1 = function(e20) {
  if (!De$1(e20))
    throw TypeError(String(e20) + " is not an object");
  return e20;
}, ze$1 = Object.defineProperty, We$1 = {
  f: re$1 ? ze$1 : function(e20, t2, r2) {
    if (Xe$1(e20), t2 = Me$1(t2), Xe$1(r2), Ge$1)
      try {
        return ze$1(e20, t2, r2);
      } catch (e21) {
      }
    if ("get" in r2 || "set" in r2)
      throw TypeError("Accessors not supported");
    return "value" in r2 && (e20[t2] = r2.value), e20;
  }
}, Ye$1 = re$1 ? function(e20, t2, r2) {
  return We$1.f(e20, t2, oe$1(1, r2));
} : function(e20, t2, r2) {
  return e20[t2] = r2, e20;
}, Qe$1 = Function.toString;
typeof Ae$1.inspectSource != "function" && (Ae$1.inspectSource = function(e20) {
  return Qe$1.call(e20);
});
var Je$1, Ke$1, Ze$1, et$1, tt$1 = Ae$1.inspectSource, rt$1 = ee$1.WeakMap, nt$1 = typeof rt$1 == "function" && /native code/.test(tt$1(rt$1)), it$1 = Fe$1("keys"), st$1 = {}, ot$1 = ee$1.WeakMap;
if (nt$1 || Ae$1.state) {
  var at$1 = Ae$1.state || (Ae$1.state = new ot$1()), ut$1 = at$1.get, ct$1 = at$1.has, lt$1 = at$1.set;
  Je$1 = function(e20, t2) {
    if (ct$1.call(at$1, e20))
      throw new TypeError("Object already initialized");
    return t2.facade = e20, lt$1.call(at$1, e20, t2), t2;
  }, Ke$1 = function(e20) {
    return ut$1.call(at$1, e20) || {};
  }, Ze$1 = function(e20) {
    return ct$1.call(at$1, e20);
  };
} else {
  var pt$1 = it$1[et$1 = "state"] || (it$1[et$1] = Ie$1(et$1));
  st$1[pt$1] = true, Je$1 = function(e20, t2) {
    if (Ne$1(e20, pt$1))
      throw new TypeError("Object already initialized");
    return t2.facade = e20, Ye$1(e20, pt$1, t2), t2;
  }, Ke$1 = function(e20) {
    return Ne$1(e20, pt$1) ? e20[pt$1] : {};
  }, Ze$1 = function(e20) {
    return Ne$1(e20, pt$1);
  };
}
var ht$1 = {
  set: Je$1,
  get: Ke$1,
  has: Ze$1,
  enforce: function(e20) {
    return Ze$1(e20) ? Ke$1(e20) : Je$1(e20, {});
  },
  getterFor: function(e20) {
    return function(t2) {
      var r2;
      if (!De$1(t2) || (r2 = Ke$1(t2)).type !== e20)
        throw TypeError("Incompatible receiver, " + e20 + " required");
      return r2;
    };
  }
}, Dt$1 = t$1(function(e20) {
  var t2 = ht$1.get, r2 = ht$1.enforce, n2 = String(String).split("String");
  (e20.exports = function(e21, t3, i2, s2) {
    var o2, a2 = !!s2 && !!s2.unsafe, u2 = !!s2 && !!s2.enumerable, c2 = !!s2 && !!s2.noTargetGet;
    typeof i2 == "function" && (typeof t3 != "string" || Ne$1(i2, "name") || Ye$1(i2, "name", t3), (o2 = r2(i2)).source || (o2.source = n2.join(typeof t3 == "string" ? t3 : ""))), e21 !== ee$1 ? (a2 ? !c2 && e21[t3] && (u2 = true) : delete e21[t3], u2 ? e21[t3] = i2 : Ye$1(e21, t3, i2)) : u2 ? e21[t3] = i2 : ve$1(t3, i2);
  })(Function.prototype, "toString", function() {
    return typeof this == "function" && t2(this).source || tt$1(this);
  });
}), ft$1 = Math.ceil, dt$1 = Math.floor, gt$1 = function(e20) {
  return isNaN(e20 = +e20) ? 0 : (e20 > 0 ? dt$1 : ft$1)(e20);
}, mt$1 = Math.min, Et$1 = function(e20) {
  return e20 > 0 ? mt$1(gt$1(e20), 9007199254740991) : 0;
}, Ct$1 = Math.max, yt$1 = Math.min, bt$1 = function(e20) {
  return function(t2, r2, n2) {
    var i2, s2 = he$1(t2), o2 = Et$1(s2.length), a2 = function(e21, t3) {
      var r3 = gt$1(e21);
      return r3 < 0 ? Ct$1(r3 + t3, 0) : yt$1(r3, t3);
    }(n2, o2);
    if (e20 && r2 != r2) {
      for (; o2 > a2; )
        if ((i2 = s2[a2++]) != i2)
          return true;
    } else
      for (; o2 > a2; a2++)
        if ((e20 || a2 in s2) && s2[a2] === r2)
          return e20 || a2 || 0;
    return !e20 && -1;
  };
}, St = { includes: bt$1(true), indexOf: bt$1(false) }.indexOf, Tt = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf"
].concat("length", "prototype"), _t = {
  f: Object.getOwnPropertyNames || function(e20) {
    return function(e21, t2) {
      var r2, n2 = he$1(e21), i2 = 0, s2 = [];
      for (r2 in n2)
        !Ne$1(st$1, r2) && Ne$1(n2, r2) && s2.push(r2);
      for (; t2.length > i2; )
        Ne$1(n2, r2 = t2[i2++]) && (~St(s2, r2) || s2.push(r2));
      return s2;
    }(e20, Tt);
  }
}, vt$1 = { f: Object.getOwnPropertySymbols }, At$1 = de$1("Reflect", "ownKeys") || function(e20) {
  var t2 = _t.f(Xe$1(e20)), r2 = vt$1.f;
  return r2 ? t2.concat(r2(e20)) : t2;
}, Ft$1 = function(e20, t2) {
  for (var r2 = At$1(t2), n2 = We$1.f, i2 = He$1.f, s2 = 0; s2 < r2.length; s2++) {
    var o2 = r2[s2];
    Ne$1(e20, o2) || n2(e20, o2, i2(t2, o2));
  }
}, wt$1 = /#|\.prototype\./, kt$1 = function(e20, t2) {
  var r2 = Ot$1[Nt(e20)];
  return r2 == It || r2 != xt$1 && (typeof t2 == "function" ? te$1(t2) : !!t2);
}, Nt = kt$1.normalize = function(e20) {
  return String(e20).replace(wt$1, ".").toLowerCase();
}, Ot$1 = kt$1.data = {}, xt$1 = kt$1.NATIVE = "N", It = kt$1.POLYFILL = "P", Pt = kt$1, Rt = He$1.f, Lt = function(e20, t2) {
  var r2, n2, i2, s2, o2, a2 = e20.target, u2 = e20.global, c2 = e20.stat;
  if (r2 = u2 ? ee$1 : c2 ? ee$1[a2] || ve$1(a2, {}) : (ee$1[a2] || {}).prototype)
    for (n2 in t2) {
      if (s2 = t2[n2], i2 = e20.noTargetGet ? (o2 = Rt(r2, n2)) && o2.value : r2[n2], !Pt(u2 ? n2 : a2 + (c2 ? "." : "#") + n2, e20.forced) && i2 !== void 0) {
        if (typeof s2 == typeof i2)
          continue;
        Ft$1(s2, i2);
      }
      (e20.sham || i2 && i2.sham) && Ye$1(s2, "sham", true), Dt$1(r2, n2, s2, e20);
    }
}, Bt = Array.isArray || function(e20) {
  return ue$1(e20) == "Array";
}, $t = function(e20) {
  if (typeof e20 != "function")
    throw TypeError(String(e20) + " is not a function");
  return e20;
}, qt = function(e20, t2, r2) {
  if ($t(e20), t2 === void 0)
    return e20;
  switch (r2) {
    case 0:
      return function() {
        return e20.call(t2);
      };
    case 1:
      return function(r3) {
        return e20.call(t2, r3);
      };
    case 2:
      return function(r3, n2) {
        return e20.call(t2, r3, n2);
      };
    case 3:
      return function(r3, n2, i2) {
        return e20.call(t2, r3, n2, i2);
      };
  }
  return function() {
    return e20.apply(t2, arguments);
  };
}, Mt = function(e20, t2, r2, n2, i2, s2, o2, a2) {
  for (var u2, c2 = i2, l2 = 0, p2 = !!o2 && qt(o2, a2, 3); l2 < n2; ) {
    if (l2 in r2) {
      if (u2 = p2 ? p2(r2[l2], l2, t2) : r2[l2], s2 > 0 && Bt(u2))
        c2 = Mt(e20, t2, u2, Et$1(u2.length), c2, s2 - 1) - 1;
      else {
        if (c2 >= 9007199254740991)
          throw TypeError("Exceed the acceptable array length");
        e20[c2] = u2;
      }
      c2++;
    }
    l2++;
  }
  return c2;
}, jt = Mt, Ut = Be$1("species"), Gt = function(e20, t2) {
  return new (function(e21) {
    var t3;
    return Bt(e21) && (typeof (t3 = e21.constructor) != "function" || t3 !== Array && !Bt(t3.prototype) ? De$1(t3) && (t3 = t3[Ut]) === null && (t3 = void 0) : t3 = void 0), t3 === void 0 ? Array : t3;
  }(e20))(t2 === 0 ? 0 : t2);
};
Lt({ target: "Array", proto: true }, {
  flatMap: function(e20) {
    var t2, r2 = we$1(this), n2 = Et$1(r2.length);
    return $t(e20), (t2 = Gt(r2, 0)).length = jt(t2, r2, r2, n2, 0, 1, e20, arguments.length > 1 ? arguments[1] : void 0), t2;
  }
});
var Vt, Ht, Xt = function(e20) {
  if (_e$1(e20))
    throw TypeError("Cannot convert a Symbol value to a string");
  return String(e20);
}, zt = Math.floor, Wt = function(e20, t2) {
  var r2 = e20.length, n2 = zt(r2 / 2);
  return r2 < 8 ? Yt(e20, t2) : Qt(Wt(e20.slice(0, n2), t2), Wt(e20.slice(n2), t2), t2);
}, Yt = function(e20, t2) {
  for (var r2, n2, i2 = e20.length, s2 = 1; s2 < i2; ) {
    for (n2 = s2, r2 = e20[s2]; n2 && t2(e20[n2 - 1], r2) > 0; )
      e20[n2] = e20[--n2];
    n2 !== s2++ && (e20[n2] = r2);
  }
  return e20;
}, Qt = function(e20, t2, r2) {
  for (var n2 = e20.length, i2 = t2.length, s2 = 0, o2 = 0, a2 = []; s2 < n2 || o2 < i2; )
    s2 < n2 && o2 < i2 ? a2.push(r2(e20[s2], t2[o2]) <= 0 ? e20[s2++] : t2[o2++]) : a2.push(s2 < n2 ? e20[s2++] : t2[o2++]);
  return a2;
}, Jt = Wt, Kt = ge$1.match(/firefox\/(\d+)/i), Zt = !!Kt && +Kt[1], er = /MSIE|Trident/.test(ge$1), tr = ge$1.match(/AppleWebKit\/(\d+)\./), rr = !!tr && +tr[1], nr = [], ir = nr.sort, sr = te$1(function() {
  nr.sort(void 0);
}), or = te$1(function() {
  nr.sort(null);
}), ar = !!(Ht = []["sort"]) && te$1(function() {
  Ht.call(null, Vt || function() {
    throw 1;
  }, 1);
}), ur = !te$1(function() {
  if (be$1)
    return be$1 < 70;
  if (!(Zt && Zt > 3)) {
    if (er)
      return true;
    if (rr)
      return rr < 603;
    var e20, t2, r2, n2, i2 = "";
    for (e20 = 65; e20 < 76; e20++) {
      switch (t2 = String.fromCharCode(e20), e20) {
        case 66:
        case 69:
        case 70:
        case 72:
          r2 = 3;
          break;
        case 68:
        case 71:
          r2 = 4;
          break;
        default:
          r2 = 2;
      }
      for (n2 = 0; n2 < 47; n2++)
        nr.push({ k: t2 + n2, v: r2 });
    }
    for (nr.sort(function(e21, t3) {
      return t3.v - e21.v;
    }), n2 = 0; n2 < nr.length; n2++)
      t2 = nr[n2].k.charAt(0), i2.charAt(i2.length - 1) !== t2 && (i2 += t2);
    return i2 !== "DGBEFHACIJK";
  }
});
Lt({ target: "Array", proto: true, forced: sr || !or || !ar || !ur }, {
  sort: function(e20) {
    e20 !== void 0 && $t(e20);
    var t2 = we$1(this);
    if (ur)
      return e20 === void 0 ? ir.call(t2) : ir.call(t2, e20);
    var r2, n2, i2 = [], s2 = Et$1(t2.length);
    for (n2 = 0; n2 < s2; n2++)
      n2 in t2 && i2.push(t2[n2]);
    for (r2 = (i2 = Jt(i2, function(e21) {
      return function(t3, r3) {
        return r3 === void 0 ? -1 : t3 === void 0 ? 1 : e21 !== void 0 ? +e21(t3, r3) || 0 : Xt(t3) > Xt(r3) ? 1 : -1;
      };
    }(e20))).length, n2 = 0; n2 < r2; )
      t2[n2] = i2[n2++];
    for (; n2 < s2; )
      delete t2[n2++];
    return t2;
  }
});
var cr = {}, lr = Be$1("iterator"), pr = Array.prototype, hr = {};
hr[Be$1("toStringTag")] = "z";
var Dr = String(hr) === "[object z]", fr = Be$1("toStringTag"), dr = ue$1(function() {
  return arguments;
}()) == "Arguments", gr = Dr ? ue$1 : function(e20) {
  var t2, r2, n2;
  return e20 === void 0 ? "Undefined" : e20 === null ? "Null" : typeof (r2 = function(e21, t3) {
    try {
      return e21[t3];
    } catch (e22) {
    }
  }(t2 = Object(e20), fr)) == "string" ? r2 : dr ? ue$1(t2) : (n2 = ue$1(t2)) == "Object" && typeof t2.callee == "function" ? "Arguments" : n2;
}, mr = Be$1("iterator"), Er = function(e20) {
  if (e20 != null)
    return e20[mr] || e20["@@iterator"] || cr[gr(e20)];
}, Cr = function(e20, t2, r2) {
  var n2, i2;
  Xe$1(e20);
  try {
    if ((n2 = e20.return) === void 0) {
      if (t2 === "throw")
        throw r2;
      return r2;
    }
    n2 = n2.call(e20);
  } catch (e21) {
    i2 = true, n2 = e21;
  }
  if (t2 === "throw")
    throw r2;
  if (i2)
    throw n2;
  return Xe$1(n2), r2;
}, yr = function(e20, t2) {
  this.stopped = e20, this.result = t2;
}, br = function(e20, t2, r2) {
  var n2, i2, s2, o2, a2, u2, c2, l2, p2 = r2 && r2.that, h2 = !(!r2 || !r2.AS_ENTRIES), D2 = !(!r2 || !r2.IS_ITERATOR), f2 = !(!r2 || !r2.INTERRUPTED), d2 = qt(t2, p2, 1 + h2 + f2), g2 = function(e21) {
    return n2 && Cr(n2, "normal", e21), new yr(true, e21);
  }, m2 = function(e21) {
    return h2 ? (Xe$1(e21), f2 ? d2(e21[0], e21[1], g2) : d2(e21[0], e21[1])) : f2 ? d2(e21, g2) : d2(e21);
  };
  if (D2)
    n2 = e20;
  else {
    if (typeof (i2 = Er(e20)) != "function")
      throw TypeError("Target is not iterable");
    if ((l2 = i2) !== void 0 && (cr.Array === l2 || pr[lr] === l2)) {
      for (s2 = 0, o2 = Et$1(e20.length); o2 > s2; s2++)
        if ((a2 = m2(e20[s2])) && a2 instanceof yr)
          return a2;
      return new yr(false);
    }
    n2 = function(e21, t3) {
      var r3 = arguments.length < 2 ? Er(e21) : t3;
      if (typeof r3 != "function")
        throw TypeError(String(e21) + " is not iterable");
      return Xe$1(r3.call(e21));
    }(e20, i2);
  }
  for (u2 = n2.next; !(c2 = u2.call(n2)).done; ) {
    try {
      a2 = m2(c2.value);
    } catch (e21) {
      Cr(n2, "throw", e21);
    }
    if (typeof a2 == "object" && a2 && a2 instanceof yr)
      return a2;
  }
  return new yr(false);
};
Lt({ target: "Object", stat: true }, {
  fromEntries: function(e20) {
    var t2 = {};
    return br(e20, function(e21, r2) {
      !function(e22, t3, r3) {
        var n2 = Me$1(t3);
        n2 in e22 ? We$1.f(e22, n2, oe$1(0, r3)) : e22[n2] = r3;
      }(t2, e21, r2);
    }, { AS_ENTRIES: true }), t2;
  }
});
var Sr = Sr !== void 0 ? Sr : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {};
function Tr() {
  throw new Error("setTimeout has not been defined");
}
function _r() {
  throw new Error("clearTimeout has not been defined");
}
var vr = Tr, Ar = _r;
function Fr(e20) {
  if (vr === setTimeout)
    return setTimeout(e20, 0);
  if ((vr === Tr || !vr) && setTimeout)
    return vr = setTimeout, setTimeout(e20, 0);
  try {
    return vr(e20, 0);
  } catch (t2) {
    try {
      return vr.call(null, e20, 0);
    } catch (t3) {
      return vr.call(this, e20, 0);
    }
  }
}
typeof Sr.setTimeout == "function" && (vr = setTimeout), typeof Sr.clearTimeout == "function" && (Ar = clearTimeout);
var wr, kr = [], Nr = false, Or = -1;
function xr() {
  Nr && wr && (Nr = false, wr.length ? kr = wr.concat(kr) : Or = -1, kr.length && Ir());
}
function Ir() {
  if (!Nr) {
    var e20 = Fr(xr);
    Nr = true;
    for (var t2 = kr.length; t2; ) {
      for (wr = kr, kr = []; ++Or < t2; )
        wr && wr[Or].run();
      Or = -1, t2 = kr.length;
    }
    wr = null, Nr = false, function(e21) {
      if (Ar === clearTimeout)
        return clearTimeout(e21);
      if ((Ar === _r || !Ar) && clearTimeout)
        return Ar = clearTimeout, clearTimeout(e21);
      try {
        Ar(e21);
      } catch (t3) {
        try {
          return Ar.call(null, e21);
        } catch (t4) {
          return Ar.call(this, e21);
        }
      }
    }(e20);
  }
}
function Pr(e20, t2) {
  this.fun = e20, this.array = t2;
}
Pr.prototype.run = function() {
  this.fun.apply(null, this.array);
};
function Rr() {
}
var Lr = Rr, Br = Rr, $r = Rr, qr = Rr, Mr = Rr, jr = Rr, Ur = Rr;
var Gr = Sr.performance || {}, Vr = Gr.now || Gr.mozNow || Gr.msNow || Gr.oNow || Gr.webkitNow || function() {
  return new Date().getTime();
};
var Hr = new Date();
var Xr = {
  nextTick: function(e20) {
    var t2 = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var r2 = 1; r2 < arguments.length; r2++)
        t2[r2 - 1] = arguments[r2];
    kr.push(new Pr(e20, t2)), kr.length !== 1 || Nr || Fr(Ir);
  },
  title: "browser",
  browser: true,
  env: {},
  argv: [],
  version: "",
  versions: {},
  on: Lr,
  addListener: Br,
  once: $r,
  off: qr,
  removeListener: Mr,
  removeAllListeners: jr,
  emit: Ur,
  binding: function(e20) {
    throw new Error("process.binding is not supported");
  },
  cwd: function() {
    return "/";
  },
  chdir: function(e20) {
    throw new Error("process.chdir is not supported");
  },
  umask: function() {
    return 0;
  },
  hrtime: function(e20) {
    var t2 = 1e-3 * Vr.call(Gr), r2 = Math.floor(t2), n2 = Math.floor(t2 % 1 * 1e9);
    return e20 && (r2 -= e20[0], (n2 -= e20[1]) < 0 && (r2--, n2 += 1e9)), [r2, n2];
  },
  platform: "browser",
  release: {},
  config: {},
  uptime: function() {
    return (new Date() - Hr) / 1e3;
  }
};
var zr = typeof Xr == "object" && Xr.env && Xr.env.NODE_DEBUG && /\bsemver\b/i.test(Xr.env.NODE_DEBUG) ? (...e20) => console.error("SEMVER", ...e20) : () => {
};
var Wr = {
  SEMVER_SPEC_VERSION: "2.0.0",
  MAX_LENGTH: 256,
  MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991,
  MAX_SAFE_COMPONENT_LENGTH: 16
}, Yr = t$1(function(e20, t2) {
  const { MAX_SAFE_COMPONENT_LENGTH: r2 } = Wr, n2 = (t2 = e20.exports = {}).re = [], i2 = t2.src = [], s2 = t2.t = {};
  let o2 = 0;
  const a2 = (e21, t3, r3) => {
    const a3 = o2++;
    zr(a3, t3), s2[e21] = a3, i2[a3] = t3, n2[a3] = new RegExp(t3, r3 ? "g" : void 0);
  };
  a2("NUMERICIDENTIFIER", "0|[1-9]\\d*"), a2("NUMERICIDENTIFIERLOOSE", "[0-9]+"), a2("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), a2("MAINVERSION", `(${i2[s2.NUMERICIDENTIFIER]})\\.(${i2[s2.NUMERICIDENTIFIER]})\\.(${i2[s2.NUMERICIDENTIFIER]})`), a2("MAINVERSIONLOOSE", `(${i2[s2.NUMERICIDENTIFIERLOOSE]})\\.(${i2[s2.NUMERICIDENTIFIERLOOSE]})\\.(${i2[s2.NUMERICIDENTIFIERLOOSE]})`), a2("PRERELEASEIDENTIFIER", `(?:${i2[s2.NUMERICIDENTIFIER]}|${i2[s2.NONNUMERICIDENTIFIER]})`), a2("PRERELEASEIDENTIFIERLOOSE", `(?:${i2[s2.NUMERICIDENTIFIERLOOSE]}|${i2[s2.NONNUMERICIDENTIFIER]})`), a2("PRERELEASE", `(?:-(${i2[s2.PRERELEASEIDENTIFIER]}(?:\\.${i2[s2.PRERELEASEIDENTIFIER]})*))`), a2("PRERELEASELOOSE", `(?:-?(${i2[s2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${i2[s2.PRERELEASEIDENTIFIERLOOSE]})*))`), a2("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), a2("BUILD", `(?:\\+(${i2[s2.BUILDIDENTIFIER]}(?:\\.${i2[s2.BUILDIDENTIFIER]})*))`), a2("FULLPLAIN", `v?${i2[s2.MAINVERSION]}${i2[s2.PRERELEASE]}?${i2[s2.BUILD]}?`), a2("FULL", `^${i2[s2.FULLPLAIN]}$`), a2("LOOSEPLAIN", `[v=\\s]*${i2[s2.MAINVERSIONLOOSE]}${i2[s2.PRERELEASELOOSE]}?${i2[s2.BUILD]}?`), a2("LOOSE", `^${i2[s2.LOOSEPLAIN]}$`), a2("GTLT", "((?:<|>)?=?)"), a2("XRANGEIDENTIFIERLOOSE", `${i2[s2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), a2("XRANGEIDENTIFIER", `${i2[s2.NUMERICIDENTIFIER]}|x|X|\\*`), a2("XRANGEPLAIN", `[v=\\s]*(${i2[s2.XRANGEIDENTIFIER]})(?:\\.(${i2[s2.XRANGEIDENTIFIER]})(?:\\.(${i2[s2.XRANGEIDENTIFIER]})(?:${i2[s2.PRERELEASE]})?${i2[s2.BUILD]}?)?)?`), a2("XRANGEPLAINLOOSE", `[v=\\s]*(${i2[s2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i2[s2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i2[s2.XRANGEIDENTIFIERLOOSE]})(?:${i2[s2.PRERELEASELOOSE]})?${i2[s2.BUILD]}?)?)?`), a2("XRANGE", `^${i2[s2.GTLT]}\\s*${i2[s2.XRANGEPLAIN]}$`), a2("XRANGELOOSE", `^${i2[s2.GTLT]}\\s*${i2[s2.XRANGEPLAINLOOSE]}$`), a2("COERCE", `(^|[^\\d])(\\d{1,${r2}})(?:\\.(\\d{1,${r2}}))?(?:\\.(\\d{1,${r2}}))?(?:$|[^\\d])`), a2("COERCERTL", i2[s2.COERCE], true), a2("LONETILDE", "(?:~>?)"), a2("TILDETRIM", `(\\s*)${i2[s2.LONETILDE]}\\s+`, true), t2.tildeTrimReplace = "$1~", a2("TILDE", `^${i2[s2.LONETILDE]}${i2[s2.XRANGEPLAIN]}$`), a2("TILDELOOSE", `^${i2[s2.LONETILDE]}${i2[s2.XRANGEPLAINLOOSE]}$`), a2("LONECARET", "(?:\\^)"), a2("CARETTRIM", `(\\s*)${i2[s2.LONECARET]}\\s+`, true), t2.caretTrimReplace = "$1^", a2("CARET", `^${i2[s2.LONECARET]}${i2[s2.XRANGEPLAIN]}$`), a2("CARETLOOSE", `^${i2[s2.LONECARET]}${i2[s2.XRANGEPLAINLOOSE]}$`), a2("COMPARATORLOOSE", `^${i2[s2.GTLT]}\\s*(${i2[s2.LOOSEPLAIN]})$|^$`), a2("COMPARATOR", `^${i2[s2.GTLT]}\\s*(${i2[s2.FULLPLAIN]})$|^$`), a2("COMPARATORTRIM", `(\\s*)${i2[s2.GTLT]}\\s*(${i2[s2.LOOSEPLAIN]}|${i2[s2.XRANGEPLAIN]})`, true), t2.comparatorTrimReplace = "$1$2$3", a2("HYPHENRANGE", `^\\s*(${i2[s2.XRANGEPLAIN]})\\s+-\\s+(${i2[s2.XRANGEPLAIN]})\\s*$`), a2("HYPHENRANGELOOSE", `^\\s*(${i2[s2.XRANGEPLAINLOOSE]})\\s+-\\s+(${i2[s2.XRANGEPLAINLOOSE]})\\s*$`), a2("STAR", "(<|>)?=?\\s*\\*"), a2("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), a2("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
});
const Qr = ["includePrerelease", "loose", "rtl"];
var Jr = (e20) => e20 ? typeof e20 != "object" ? { loose: true } : Qr.filter((t2) => e20[t2]).reduce((e21, t2) => (e21[t2] = true, e21), {}) : {};
const Kr = /^[0-9]+$/, Zr = (e20, t2) => {
  const r2 = Kr.test(e20), n2 = Kr.test(t2);
  return r2 && n2 && (e20 = +e20, t2 = +t2), e20 === t2 ? 0 : r2 && !n2 ? -1 : n2 && !r2 ? 1 : e20 < t2 ? -1 : 1;
};
var en = { compareIdentifiers: Zr, rcompareIdentifiers: (e20, t2) => Zr(t2, e20) };
const { MAX_LENGTH: tn, MAX_SAFE_INTEGER: rn } = Wr, { re: nn, t: sn } = Yr, { compareIdentifiers: on } = en;
class an {
  constructor(e20, t2) {
    if (t2 = Jr(t2), e20 instanceof an) {
      if (e20.loose === !!t2.loose && e20.includePrerelease === !!t2.includePrerelease)
        return e20;
      e20 = e20.version;
    } else if (typeof e20 != "string")
      throw new TypeError(`Invalid Version: ${e20}`);
    if (e20.length > tn)
      throw new TypeError(`version is longer than ${tn} characters`);
    zr("SemVer", e20, t2), this.options = t2, this.loose = !!t2.loose, this.includePrerelease = !!t2.includePrerelease;
    const r2 = e20.trim().match(t2.loose ? nn[sn.LOOSE] : nn[sn.FULL]);
    if (!r2)
      throw new TypeError(`Invalid Version: ${e20}`);
    if (this.raw = e20, this.major = +r2[1], this.minor = +r2[2], this.patch = +r2[3], this.major > rn || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > rn || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > rn || this.patch < 0)
      throw new TypeError("Invalid patch version");
    r2[4] ? this.prerelease = r2[4].split(".").map((e21) => {
      if (/^[0-9]+$/.test(e21)) {
        const t3 = +e21;
        if (t3 >= 0 && t3 < rn)
          return t3;
      }
      return e21;
    }) : this.prerelease = [], this.build = r2[5] ? r2[5].split(".") : [], this.format();
  }
  format() {
    return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
  }
  toString() {
    return this.version;
  }
  compare(e20) {
    if (zr("SemVer.compare", this.version, this.options, e20), !(e20 instanceof an)) {
      if (typeof e20 == "string" && e20 === this.version)
        return 0;
      e20 = new an(e20, this.options);
    }
    return e20.version === this.version ? 0 : this.compareMain(e20) || this.comparePre(e20);
  }
  compareMain(e20) {
    return e20 instanceof an || (e20 = new an(e20, this.options)), on(this.major, e20.major) || on(this.minor, e20.minor) || on(this.patch, e20.patch);
  }
  comparePre(e20) {
    if (e20 instanceof an || (e20 = new an(e20, this.options)), this.prerelease.length && !e20.prerelease.length)
      return -1;
    if (!this.prerelease.length && e20.prerelease.length)
      return 1;
    if (!this.prerelease.length && !e20.prerelease.length)
      return 0;
    let t2 = 0;
    do {
      const r2 = this.prerelease[t2], n2 = e20.prerelease[t2];
      if (zr("prerelease compare", t2, r2, n2), r2 === void 0 && n2 === void 0)
        return 0;
      if (n2 === void 0)
        return 1;
      if (r2 === void 0)
        return -1;
      if (r2 !== n2)
        return on(r2, n2);
    } while (++t2);
  }
  compareBuild(e20) {
    e20 instanceof an || (e20 = new an(e20, this.options));
    let t2 = 0;
    do {
      const r2 = this.build[t2], n2 = e20.build[t2];
      if (zr("prerelease compare", t2, r2, n2), r2 === void 0 && n2 === void 0)
        return 0;
      if (n2 === void 0)
        return 1;
      if (r2 === void 0)
        return -1;
      if (r2 !== n2)
        return on(r2, n2);
    } while (++t2);
  }
  inc(e20, t2) {
    switch (e20) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t2);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t2);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", t2), this.inc("pre", t2);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", t2), this.inc("pre", t2);
        break;
      case "major":
        this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0)
          this.prerelease = [0];
        else {
          let e21 = this.prerelease.length;
          for (; --e21 >= 0; )
            typeof this.prerelease[e21] == "number" && (this.prerelease[e21]++, e21 = -2);
          e21 === -1 && this.prerelease.push(0);
        }
        t2 && (this.prerelease[0] === t2 ? isNaN(this.prerelease[1]) && (this.prerelease = [t2, 0]) : this.prerelease = [t2, 0]);
        break;
      default:
        throw new Error(`invalid increment argument: ${e20}`);
    }
    return this.format(), this.raw = this.version, this;
  }
}
var un = an;
var cn = (e20, t2, r2) => new un(e20, r2).compare(new un(t2, r2));
var ln = (e20, t2, r2) => cn(e20, t2, r2) < 0;
var pn = (e20, t2, r2) => cn(e20, t2, r2) >= 0, hn = t$1(function(e20, t2) {
  function r2() {
    for (var e21 = [], t3 = 0; t3 < arguments.length; t3++)
      e21[t3] = arguments[t3];
  }
  function n2() {
    return typeof WeakMap != "undefined" ? new WeakMap() : {
      add: r2,
      delete: r2,
      get: r2,
      set: r2,
      has: function(e21) {
        return false;
      }
    };
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.outdent = void 0;
  var i2 = Object.prototype.hasOwnProperty, s2 = function(e21, t3) {
    return i2.call(e21, t3);
  };
  function o2(e21, t3) {
    for (var r3 in t3)
      s2(t3, r3) && (e21[r3] = t3[r3]);
    return e21;
  }
  var a2 = /^[ \t]*(?:\r\n|\r|\n)/, u2 = /(?:\r\n|\r|\n)[ \t]*$/, c2 = /^(?:[\r\n]|$)/, l2 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, p2 = /^[ \t]*[\r\n][ \t\r\n]*$/;
  function h2(e21, t3, r3) {
    var n3 = 0, i3 = e21[0].match(l2);
    i3 && (n3 = i3[1].length);
    var s3 = new RegExp("(\\r\\n|\\r|\\n).{0," + n3 + "}", "g");
    t3 && (e21 = e21.slice(1));
    var o3 = r3.newline, c3 = r3.trimLeadingNewline, p3 = r3.trimTrailingNewline, h3 = typeof o3 == "string", D3 = e21.length;
    return e21.map(function(e22, t4) {
      return e22 = e22.replace(s3, "$1"), t4 === 0 && c3 && (e22 = e22.replace(a2, "")), t4 === D3 - 1 && p3 && (e22 = e22.replace(u2, "")), h3 && (e22 = e22.replace(/\r\n|\n|\r/g, function(e23) {
        return o3;
      })), e22;
    });
  }
  function D2(e21, t3) {
    for (var r3 = "", n3 = 0, i3 = e21.length; n3 < i3; n3++)
      r3 += e21[n3], n3 < i3 - 1 && (r3 += t3[n3]);
    return r3;
  }
  function f2(e21) {
    return s2(e21, "raw") && s2(e21, "length");
  }
  var d2 = function e21(t3) {
    var r3 = n2(), i3 = n2();
    return o2(function n3(s3) {
      for (var a3 = [], u3 = 1; u3 < arguments.length; u3++)
        a3[u3 - 1] = arguments[u3];
      if (f2(s3)) {
        var l3 = s3, g2 = (a3[0] === n3 || a3[0] === d2) && p2.test(l3[0]) && c2.test(l3[1]), m2 = g2 ? i3 : r3, E2 = m2.get(l3);
        if (E2 || (E2 = h2(l3, g2, t3), m2.set(l3, E2)), a3.length === 0)
          return E2[0];
        var C2 = D2(E2, g2 ? a3.slice(1) : a3);
        return C2;
      }
      return e21(o2(o2({}, t3), s3 || {}));
    }, {
      string: function(e22) {
        return h2([e22], false, t3)[0];
      }
    });
  }({ trimLeadingNewline: true, trimTrailingNewline: true });
  t2.outdent = d2, t2.default = d2;
  try {
    e20.exports = d2, Object.defineProperty(d2, "__esModule", { value: true }), d2.default = d2, d2.outdent = d2;
  } catch (e21) {
  }
});
const { outdent: Dn } = hn, fn = {
  cursorOffset: {
    since: "1.4.0",
    category: "Special",
    type: "int",
    default: -1,
    range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 },
    description: Dn`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `,
    cliCategory: "Editor"
  },
  endOfLine: {
    since: "1.15.0",
    category: "Global",
    type: "choice",
    default: [
      { since: "1.15.0", value: "auto" },
      { since: "2.0.0", value: "lf" }
    ],
    description: "Which end of line characters to apply.",
    choices: [
      {
        value: "lf",
        description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos"
      },
      {
        value: "crlf",
        description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows"
      },
      {
        value: "cr",
        description: "Carriage Return character only (\\r), used very rarely"
      },
      {
        value: "auto",
        description: Dn`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        `
      }
    ]
  },
  filepath: {
    since: "1.4.0",
    category: "Special",
    type: "path",
    description: "Specify the input filepath. This will be used to do parser inference.",
    cliName: "stdin-filepath",
    cliCategory: "Other",
    cliDescription: "Path to the file to pretend that stdin comes from."
  },
  insertPragma: {
    since: "1.8.0",
    category: "Special",
    type: "boolean",
    default: false,
    description: "Insert @format pragma into file's first docblock comment.",
    cliCategory: "Other"
  },
  parser: {
    since: "0.0.10",
    category: "Global",
    type: "choice",
    default: [
      { since: "0.0.10", value: "babylon" },
      { since: "1.13.0", value: void 0 }
    ],
    description: "Which parser to use.",
    exception: (e20) => typeof e20 == "string" || typeof e20 == "function",
    choices: [
      { value: "flow", description: "Flow" },
      { value: "babel", since: "1.16.0", description: "JavaScript" },
      { value: "babel-flow", since: "1.16.0", description: "Flow" },
      {
        value: "babel-ts",
        since: "2.0.0",
        description: "TypeScript"
      },
      {
        value: "typescript",
        since: "1.4.0",
        description: "TypeScript"
      },
      { value: "espree", since: "2.2.0", description: "JavaScript" },
      { value: "meriyah", since: "2.2.0", description: "JavaScript" },
      { value: "css", since: "1.7.1", description: "CSS" },
      { value: "less", since: "1.7.1", description: "Less" },
      { value: "scss", since: "1.7.1", description: "SCSS" },
      { value: "json", since: "1.5.0", description: "JSON" },
      { value: "json5", since: "1.13.0", description: "JSON5" },
      {
        value: "json-stringify",
        since: "1.13.0",
        description: "JSON.stringify"
      },
      { value: "graphql", since: "1.5.0", description: "GraphQL" },
      { value: "markdown", since: "1.8.0", description: "Markdown" },
      { value: "mdx", since: "1.15.0", description: "MDX" },
      { value: "vue", since: "1.10.0", description: "Vue" },
      { value: "yaml", since: "1.14.0", description: "YAML" },
      {
        value: "glimmer",
        since: "2.3.0",
        description: "Ember / Handlebars"
      },
      { value: "html", since: "1.15.0", description: "HTML" },
      { value: "angular", since: "1.15.0", description: "Angular" },
      {
        value: "lwc",
        since: "1.17.0",
        description: "Lightning Web Components"
      }
    ]
  },
  plugins: {
    since: "1.10.0",
    type: "path",
    array: true,
    default: [{ value: [] }],
    category: "Global",
    description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.",
    exception: (e20) => typeof e20 == "string" || typeof e20 == "object",
    cliName: "plugin",
    cliCategory: "Config"
  },
  pluginSearchDirs: {
    since: "1.13.0",
    type: "path",
    array: true,
    default: [{ value: [] }],
    category: "Global",
    description: Dn`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `,
    exception: (e20) => typeof e20 == "string" || typeof e20 == "object",
    cliName: "plugin-search-dir",
    cliCategory: "Config"
  },
  printWidth: {
    since: "0.0.0",
    category: "Global",
    type: "int",
    default: 80,
    description: "The line length where Prettier will try wrap.",
    range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }
  },
  rangeEnd: {
    since: "1.4.0",
    category: "Special",
    type: "int",
    default: Number.POSITIVE_INFINITY,
    range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 },
    description: Dn`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `,
    cliCategory: "Editor"
  },
  rangeStart: {
    since: "1.4.0",
    category: "Special",
    type: "int",
    default: 0,
    range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 },
    description: Dn`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `,
    cliCategory: "Editor"
  },
  requirePragma: {
    since: "1.7.0",
    category: "Special",
    type: "boolean",
    default: false,
    description: Dn`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `,
    cliCategory: "Other"
  },
  tabWidth: {
    type: "int",
    category: "Global",
    default: 2,
    description: "Number of spaces per indentation level.",
    range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }
  },
  useTabs: {
    since: "1.0.0",
    category: "Global",
    type: "boolean",
    default: false,
    description: "Indent with tabs instead of spaces."
  },
  embeddedLanguageFormatting: {
    since: "2.1.0",
    category: "Global",
    type: "choice",
    default: [{ since: "2.1.0", value: "auto" }],
    description: "Control how Prettier formats quoted code embedded in the file.",
    choices: [
      {
        value: "auto",
        description: "Format embedded code if Prettier can automatically identify it."
      },
      {
        value: "off",
        description: "Never automatically format embedded code."
      }
    ]
  }
};
const dn = ["cliName", "cliCategory", "cliDescription"], gn = { compare: cn, lt: ln, gte: pn }, mn = "2.4.1", En = {
  CATEGORY_CONFIG: "Config",
  CATEGORY_EDITOR: "Editor",
  CATEGORY_FORMAT: "Format",
  CATEGORY_OTHER: "Other",
  CATEGORY_OUTPUT: "Output",
  CATEGORY_GLOBAL: "Global",
  CATEGORY_SPECIAL: "Special",
  options: fn
}.options;
var Cn = {
  getSupportInfo: function({
    plugins: e20 = [],
    showUnreleased: t2 = false,
    showDeprecated: r2 = false,
    showInternal: n2 = false
  } = {}) {
    const i2 = mn.split("-", 1)[0], s2 = e20.flatMap((e21) => e21.languages || []).filter(a2), o2 = ((e21, t3) => Object.entries(e21).map(([e22, r3]) => Object.assign({ [t3]: e22 }, r3)))(Object.assign({}, ...e20.map(({ options: e21 }) => e21), En), "name").filter((e21) => a2(e21) && u2(e21)).sort((e21, t3) => e21.name === t3.name ? 0 : e21.name < t3.name ? -1 : 1).map(function(e21) {
      if (n2)
        return e21;
      return Q$1(e21, dn);
    }).map((t3) => {
      t3 = Object.assign({}, t3), Array.isArray(t3.default) && (t3.default = t3.default.length === 1 ? t3.default[0].value : t3.default.filter(a2).sort((e21, t4) => gn.compare(t4.since, e21.since))[0].value), Array.isArray(t3.choices) && (t3.choices = t3.choices.filter((e21) => a2(e21) && u2(e21)), t3.name === "parser" && function(e21, t4, r4) {
        const n3 = new Set(e21.choices.map((e22) => e22.value));
        for (const i3 of t4)
          if (i3.parsers) {
            for (const t5 of i3.parsers)
              if (!n3.has(t5)) {
                n3.add(t5);
                const s3 = r4.find((e22) => e22.parsers && e22.parsers[t5]);
                let o3 = i3.name;
                s3 && s3.name && (o3 += ` (plugin: ${s3.name})`), e21.choices.push({
                  value: t5,
                  description: o3
                });
              }
          }
      }(t3, s2, e20));
      const r3 = Object.fromEntries(e20.filter((e21) => e21.defaultOptions && e21.defaultOptions[t3.name] !== void 0).map((e21) => [e21.name, e21.defaultOptions[t3.name]]));
      return Object.assign(Object.assign({}, t3), {}, { pluginDefaults: r3 });
    });
    return { languages: s2, options: o2 };
    function a2(e21) {
      return t2 || !("since" in e21) || e21.since && gn.gte(i2, e21.since);
    }
    function u2(e21) {
      return r2 || !("deprecated" in e21) || e21.deprecated && gn.lt(i2, e21.deprecated);
    }
  }
};
const { getSupportInfo: yn } = Cn, bn = /[^\x20-\x7F]/;
function Sn(e20) {
  return (t2, r2, n2) => {
    const i2 = n2 && n2.backwards;
    if (r2 === false)
      return false;
    const { length: s2 } = t2;
    let o2 = r2;
    for (; o2 >= 0 && o2 < s2; ) {
      const r3 = t2.charAt(o2);
      if (e20 instanceof RegExp) {
        if (!e20.test(r3))
          return o2;
      } else if (!e20.includes(r3))
        return o2;
      i2 ? o2-- : o2++;
    }
    return (o2 === -1 || o2 === s2) && o2;
  };
}
const Tn = Sn(/\s/), _n = Sn(" 	"), vn = Sn(",; 	"), An = Sn(/[^\n\r]/);
function Fn(e20, t2) {
  if (t2 === false)
    return false;
  if (e20.charAt(t2) === "/" && e20.charAt(t2 + 1) === "*") {
    for (let r2 = t2 + 2; r2 < e20.length; ++r2)
      if (e20.charAt(r2) === "*" && e20.charAt(r2 + 1) === "/")
        return r2 + 2;
  }
  return t2;
}
function wn(e20, t2) {
  return t2 !== false && (e20.charAt(t2) === "/" && e20.charAt(t2 + 1) === "/" ? An(e20, t2) : t2);
}
function kn(e20, t2, r2) {
  const n2 = r2 && r2.backwards;
  if (t2 === false)
    return false;
  const i2 = e20.charAt(t2);
  if (n2) {
    if (e20.charAt(t2 - 1) === "\r" && i2 === "\n")
      return t2 - 2;
    if (i2 === "\n" || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
      return t2 - 1;
  } else {
    if (i2 === "\r" && e20.charAt(t2 + 1) === "\n")
      return t2 + 2;
    if (i2 === "\n" || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
      return t2 + 1;
  }
  return t2;
}
function Nn(e20, t2, r2 = {}) {
  const n2 = _n(e20, r2.backwards ? t2 - 1 : t2, r2);
  return n2 !== kn(e20, n2, r2);
}
function On(e20, t2) {
  let r2 = null, n2 = t2;
  for (; n2 !== r2; )
    r2 = n2, n2 = vn(e20, n2), n2 = Fn(e20, n2), n2 = _n(e20, n2);
  return n2 = wn(e20, n2), n2 = kn(e20, n2), n2 !== false && Nn(e20, n2);
}
function xn(e20, t2) {
  let r2 = null, n2 = t2;
  for (; n2 !== r2; )
    r2 = n2, n2 = _n(e20, n2), n2 = Fn(e20, n2), n2 = wn(e20, n2), n2 = kn(e20, n2);
  return n2;
}
function In(e20, t2, r2) {
  return xn(e20, r2(t2));
}
function Pn(e20, t2, r2 = 0) {
  let n2 = 0;
  for (let i2 = r2; i2 < e20.length; ++i2)
    e20[i2] === "	" ? n2 = n2 + t2 - n2 % t2 : n2++;
  return n2;
}
function Rn(e20, t2) {
  const r2 = e20.slice(1, -1), n2 = { quote: '"', regex: /"/g }, i2 = { quote: "'", regex: /'/g }, s2 = t2 === "'" ? i2 : n2, o2 = s2 === i2 ? n2 : i2;
  let a2 = s2.quote;
  if (r2.includes(s2.quote) || r2.includes(o2.quote)) {
    a2 = (r2.match(s2.regex) || []).length > (r2.match(o2.regex) || []).length ? o2.quote : s2.quote;
  }
  return a2;
}
function Ln(e20, t2, r2) {
  const n2 = t2 === '"' ? "'" : '"', i2 = e20.replace(/\\(.)|(["'])/gs, (e21, i3, s2) => i3 === n2 ? i3 : s2 === t2 ? "\\" + s2 : s2 || (r2 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(i3) ? i3 : "\\" + i3));
  return t2 + i2 + t2;
}
function Bn(e20, t2) {
  (e20.comments || (e20.comments = [])).push(t2), t2.printed = false, t2.nodeDescription = function(e21) {
    const t3 = e21.type || e21.kind || "(unknown type)";
    let r2 = String(e21.name || e21.id && (typeof e21.id == "object" ? e21.id.name : e21.id) || e21.key && (typeof e21.key == "object" ? e21.key.name : e21.key) || e21.value && (typeof e21.value == "object" ? "" : String(e21.value)) || e21.operator || "");
    r2.length > 20 && (r2 = r2.slice(0, 19) + "\u2026");
    return t3 + (r2 ? " " + r2 : "");
  }(e20);
}
var $n = {
  inferParserByLanguage: function(e20, t2) {
    const { languages: r2 } = yn({ plugins: t2.plugins }), n2 = r2.find(({ name: t3 }) => t3.toLowerCase() === e20) || r2.find(({ aliases: t3 }) => Array.isArray(t3) && t3.includes(e20)) || r2.find(({ extensions: t3 }) => Array.isArray(t3) && t3.includes(`.${e20}`));
    return n2 && n2.parsers[0];
  },
  getStringWidth: function(e20) {
    return e20 ? bn.test(e20) ? z$1(e20) : e20.length : 0;
  },
  getMaxContinuousCount: function(e20, t2) {
    const r2 = e20.match(new RegExp(`(${Y$1(t2)})+`, "g"));
    return r2 === null ? 0 : r2.reduce((e21, r3) => Math.max(e21, r3.length / t2.length), 0);
  },
  getMinNotPresentContinuousCount: function(e20, t2) {
    const r2 = e20.match(new RegExp(`(${Y$1(t2)})+`, "g"));
    if (r2 === null)
      return 0;
    const n2 = new Map();
    let i2 = 0;
    for (const e21 of r2) {
      const r3 = e21.length / t2.length;
      n2.set(r3, true), r3 > i2 && (i2 = r3);
    }
    for (let e21 = 1; e21 < i2; e21++)
      if (!n2.get(e21))
        return e21;
    return i2 + 1;
  },
  getPenultimate: (e20) => e20[e20.length - 2],
  getLast: M$1,
  getNextNonSpaceNonCommentCharacterIndexWithStartIndex: xn,
  getNextNonSpaceNonCommentCharacterIndex: In,
  getNextNonSpaceNonCommentCharacter: function(e20, t2, r2) {
    return e20.charAt(In(e20, t2, r2));
  },
  skip: Sn,
  skipWhitespace: Tn,
  skipSpaces: _n,
  skipToLineEnd: vn,
  skipEverythingButNewLine: An,
  skipInlineComment: Fn,
  skipTrailingComment: wn,
  skipNewline: kn,
  isNextLineEmptyAfterIndex: On,
  isNextLineEmpty: function(e20, t2, r2) {
    return On(e20, r2(t2));
  },
  isPreviousLineEmpty: function(e20, t2, r2) {
    let n2 = r2(t2) - 1;
    return n2 = _n(e20, n2, { backwards: true }), n2 = kn(e20, n2, { backwards: true }), n2 = _n(e20, n2, { backwards: true }), n2 !== kn(e20, n2, { backwards: true });
  },
  hasNewline: Nn,
  hasNewlineInRange: function(e20, t2, r2) {
    for (let n2 = t2; n2 < r2; ++n2)
      if (e20.charAt(n2) === "\n")
        return true;
    return false;
  },
  hasSpaces: function(e20, t2, r2 = {}) {
    return _n(e20, r2.backwards ? t2 - 1 : t2, r2) !== t2;
  },
  getAlignmentSize: Pn,
  getIndentSize: function(e20, t2) {
    const r2 = e20.lastIndexOf("\n");
    return r2 === -1 ? 0 : Pn(e20.slice(r2 + 1).match(/^[\t ]*/)[0], t2);
  },
  getPreferredQuote: Rn,
  printString: function(e20, t2) {
    return Ln(e20.slice(1, -1), t2.parser === "json" || t2.parser === "json5" && t2.quoteProps === "preserve" && !t2.singleQuote ? '"' : t2.__isInHtmlAttribute ? "'" : Rn(e20, t2.singleQuote ? "'" : '"'), !(t2.parser === "css" || t2.parser === "less" || t2.parser === "scss" || t2.__embeddedInHtml));
  },
  printNumber: function(e20) {
    return e20.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
  },
  makeString: Ln,
  addLeadingComment: function(e20, t2) {
    t2.leading = true, t2.trailing = false, Bn(e20, t2);
  },
  addDanglingComment: function(e20, t2, r2) {
    t2.leading = false, t2.trailing = false, r2 && (t2.marker = r2), Bn(e20, t2);
  },
  addTrailingComment: function(e20, t2) {
    t2.leading = false, t2.trailing = true, Bn(e20, t2);
  },
  isFrontMatterNode: function(e20) {
    return e20 && e20.type === "front-matter";
  },
  getShebang: function(e20) {
    if (!e20.startsWith("#!"))
      return "";
    const t2 = e20.indexOf("\n");
    return t2 === -1 ? e20 : e20.slice(0, t2);
  },
  isNonEmptyArray: function(e20) {
    return Array.isArray(e20) && e20.length > 0;
  },
  createGroupIdMapper: function(e20) {
    const t2 = new WeakMap();
    return function(r2) {
      return t2.has(r2) || t2.set(r2, Symbol(e20)), t2.get(r2);
    };
  }
}, qn = {
  "*": [
    "accesskey",
    "autocapitalize",
    "autofocus",
    "class",
    "contenteditable",
    "dir",
    "draggable",
    "enterkeyhint",
    "hidden",
    "id",
    "inputmode",
    "is",
    "itemid",
    "itemprop",
    "itemref",
    "itemscope",
    "itemtype",
    "lang",
    "nonce",
    "slot",
    "spellcheck",
    "style",
    "tabindex",
    "title",
    "translate"
  ],
  a: [
    "accesskey",
    "charset",
    "coords",
    "download",
    "href",
    "hreflang",
    "name",
    "ping",
    "referrerpolicy",
    "rel",
    "rev",
    "shape",
    "tabindex",
    "target",
    "type"
  ],
  abbr: ["title"],
  applet: [
    "align",
    "alt",
    "archive",
    "code",
    "codebase",
    "height",
    "hspace",
    "name",
    "object",
    "vspace",
    "width"
  ],
  area: [
    "accesskey",
    "alt",
    "coords",
    "download",
    "href",
    "hreflang",
    "nohref",
    "ping",
    "referrerpolicy",
    "rel",
    "shape",
    "tabindex",
    "target",
    "type"
  ],
  audio: [
    "autoplay",
    "controls",
    "crossorigin",
    "loop",
    "muted",
    "preload",
    "src"
  ],
  base: ["href", "target"],
  basefont: ["color", "face", "size"],
  bdo: ["dir"],
  blockquote: ["cite"],
  body: ["alink", "background", "bgcolor", "link", "text", "vlink"],
  br: ["clear"],
  button: [
    "accesskey",
    "autofocus",
    "disabled",
    "form",
    "formaction",
    "formenctype",
    "formmethod",
    "formnovalidate",
    "formtarget",
    "name",
    "tabindex",
    "type",
    "value"
  ],
  canvas: ["height", "width"],
  caption: ["align"],
  col: ["align", "char", "charoff", "span", "valign", "width"],
  colgroup: ["align", "char", "charoff", "span", "valign", "width"],
  data: ["value"],
  del: ["cite", "datetime"],
  details: ["open"],
  dfn: ["title"],
  dialog: ["open"],
  dir: ["compact"],
  div: ["align"],
  dl: ["compact"],
  embed: ["height", "src", "type", "width"],
  fieldset: ["disabled", "form", "name"],
  font: ["color", "face", "size"],
  form: [
    "accept",
    "accept-charset",
    "action",
    "autocomplete",
    "enctype",
    "method",
    "name",
    "novalidate",
    "target"
  ],
  frame: [
    "frameborder",
    "longdesc",
    "marginheight",
    "marginwidth",
    "name",
    "noresize",
    "scrolling",
    "src"
  ],
  frameset: ["cols", "rows"],
  h1: ["align"],
  h2: ["align"],
  h3: ["align"],
  h4: ["align"],
  h5: ["align"],
  h6: ["align"],
  head: ["profile"],
  hr: ["align", "noshade", "size", "width"],
  html: ["manifest", "version"],
  iframe: [
    "align",
    "allow",
    "allowfullscreen",
    "allowpaymentrequest",
    "allowusermedia",
    "frameborder",
    "height",
    "loading",
    "longdesc",
    "marginheight",
    "marginwidth",
    "name",
    "referrerpolicy",
    "sandbox",
    "scrolling",
    "src",
    "srcdoc",
    "width"
  ],
  img: [
    "align",
    "alt",
    "border",
    "crossorigin",
    "decoding",
    "height",
    "hspace",
    "ismap",
    "loading",
    "longdesc",
    "name",
    "referrerpolicy",
    "sizes",
    "src",
    "srcset",
    "usemap",
    "vspace",
    "width"
  ],
  input: [
    "accept",
    "accesskey",
    "align",
    "alt",
    "autocomplete",
    "autofocus",
    "checked",
    "dirname",
    "disabled",
    "form",
    "formaction",
    "formenctype",
    "formmethod",
    "formnovalidate",
    "formtarget",
    "height",
    "ismap",
    "list",
    "max",
    "maxlength",
    "min",
    "minlength",
    "multiple",
    "name",
    "pattern",
    "placeholder",
    "readonly",
    "required",
    "size",
    "src",
    "step",
    "tabindex",
    "title",
    "type",
    "usemap",
    "value",
    "width"
  ],
  ins: ["cite", "datetime"],
  isindex: ["prompt"],
  label: ["accesskey", "for", "form"],
  legend: ["accesskey", "align"],
  li: ["type", "value"],
  link: [
    "as",
    "charset",
    "color",
    "crossorigin",
    "disabled",
    "href",
    "hreflang",
    "imagesizes",
    "imagesrcset",
    "integrity",
    "media",
    "nonce",
    "referrerpolicy",
    "rel",
    "rev",
    "sizes",
    "target",
    "title",
    "type"
  ],
  map: ["name"],
  menu: ["compact"],
  meta: ["charset", "content", "http-equiv", "name", "scheme"],
  meter: ["high", "low", "max", "min", "optimum", "value"],
  object: [
    "align",
    "archive",
    "border",
    "classid",
    "codebase",
    "codetype",
    "data",
    "declare",
    "form",
    "height",
    "hspace",
    "name",
    "standby",
    "tabindex",
    "type",
    "typemustmatch",
    "usemap",
    "vspace",
    "width"
  ],
  ol: ["compact", "reversed", "start", "type"],
  optgroup: ["disabled", "label"],
  option: ["disabled", "label", "selected", "value"],
  output: ["for", "form", "name"],
  p: ["align"],
  param: ["name", "type", "value", "valuetype"],
  pre: ["width"],
  progress: ["max", "value"],
  q: ["cite"],
  script: [
    "async",
    "charset",
    "crossorigin",
    "defer",
    "integrity",
    "language",
    "nomodule",
    "nonce",
    "referrerpolicy",
    "src",
    "type"
  ],
  select: [
    "autocomplete",
    "autofocus",
    "disabled",
    "form",
    "multiple",
    "name",
    "required",
    "size",
    "tabindex"
  ],
  slot: ["name"],
  source: ["media", "sizes", "src", "srcset", "type"],
  style: ["media", "nonce", "title", "type"],
  table: [
    "align",
    "bgcolor",
    "border",
    "cellpadding",
    "cellspacing",
    "frame",
    "rules",
    "summary",
    "width"
  ],
  tbody: ["align", "char", "charoff", "valign"],
  td: [
    "abbr",
    "align",
    "axis",
    "bgcolor",
    "char",
    "charoff",
    "colspan",
    "headers",
    "height",
    "nowrap",
    "rowspan",
    "scope",
    "valign",
    "width"
  ],
  textarea: [
    "accesskey",
    "autocomplete",
    "autofocus",
    "cols",
    "dirname",
    "disabled",
    "form",
    "maxlength",
    "minlength",
    "name",
    "placeholder",
    "readonly",
    "required",
    "rows",
    "tabindex",
    "wrap"
  ],
  tfoot: ["align", "char", "charoff", "valign"],
  th: [
    "abbr",
    "align",
    "axis",
    "bgcolor",
    "char",
    "charoff",
    "colspan",
    "headers",
    "height",
    "nowrap",
    "rowspan",
    "scope",
    "valign",
    "width"
  ],
  thead: ["align", "char", "charoff", "valign"],
  time: ["datetime"],
  tr: ["align", "bgcolor", "char", "charoff", "valign"],
  track: ["default", "kind", "label", "src", "srclang"],
  ul: ["compact", "type"],
  video: [
    "autoplay",
    "controls",
    "crossorigin",
    "height",
    "loop",
    "muted",
    "playsinline",
    "poster",
    "preload",
    "src",
    "width"
  ]
};
function Mn(e20) {
  return { type: "concat", parts: e20 };
}
function jn(e20) {
  return { type: "indent", contents: e20 };
}
function Un(e20, t2) {
  return { type: "align", contents: t2, n: e20 };
}
function Gn(e20, t2 = {}) {
  return {
    type: "group",
    id: t2.id,
    contents: e20,
    break: Boolean(t2.shouldBreak),
    expandedStates: t2.expandedStates
  };
}
const Vn = { type: "break-parent" }, Hn = { type: "line", hard: true }, Xn = { type: "line", hard: true, literal: true }, zn = Mn([Hn, Vn]), Wn = Mn([Xn, Vn]);
var Yn = {
  concat: Mn,
  join: function(e20, t2) {
    const r2 = [];
    for (let n2 = 0; n2 < t2.length; n2++)
      n2 !== 0 && r2.push(e20), r2.push(t2[n2]);
    return Mn(r2);
  },
  line: { type: "line" },
  softline: { type: "line", soft: true },
  hardline: zn,
  literalline: Wn,
  group: Gn,
  conditionalGroup: function(e20, t2) {
    return Gn(e20[0], Object.assign(Object.assign({}, t2), {}, { expandedStates: e20 }));
  },
  fill: function(e20) {
    return { type: "fill", parts: e20 };
  },
  lineSuffix: function(e20) {
    return { type: "line-suffix", contents: e20 };
  },
  lineSuffixBoundary: { type: "line-suffix-boundary" },
  cursor: { type: "cursor", placeholder: Symbol("cursor") },
  breakParent: Vn,
  ifBreak: function(e20, t2, r2 = {}) {
    return {
      type: "if-break",
      breakContents: e20,
      flatContents: t2,
      groupId: r2.groupId
    };
  },
  trim: { type: "trim" },
  indent: jn,
  indentIfBreak: function(e20, t2) {
    return {
      type: "indent-if-break",
      contents: e20,
      groupId: t2.groupId,
      negate: t2.negate
    };
  },
  align: Un,
  addAlignmentToDoc: function(e20, t2, r2) {
    let n2 = e20;
    if (t2 > 0) {
      for (let e21 = 0; e21 < Math.floor(t2 / r2); ++e21)
        n2 = jn(n2);
      n2 = Un(t2 % r2, n2), n2 = Un(Number.NEGATIVE_INFINITY, n2);
    }
    return n2;
  },
  markAsRoot: function(e20) {
    return Un({ type: "root" }, e20);
  },
  dedentToRoot: function(e20) {
    return Un(Number.NEGATIVE_INFINITY, e20);
  },
  dedent: function(e20) {
    return Un(-1, e20);
  },
  hardlineWithoutBreakParent: Hn,
  literallineWithoutBreakParent: Xn,
  label: function(e20, t2) {
    return { type: "label", label: e20, contents: t2 };
  }
};
var Qn = {
  guessEndOfLine: function(e20) {
    const t2 = e20.indexOf("\r");
    return t2 >= 0 ? e20.charAt(t2 + 1) === "\n" ? "crlf" : "cr" : "lf";
  },
  convertEndOfLineToChars: function(e20) {
    switch (e20) {
      case "cr":
        return "\r";
      case "crlf":
        return "\r\n";
      default:
        return "\n";
    }
  },
  countEndOfLineChars: function(e20, t2) {
    let r2;
    if (t2 === "\n")
      r2 = /\n/g;
    else if (t2 === "\r")
      r2 = /\r/g;
    else {
      if (t2 !== "\r\n")
        throw new Error(`Unexpected "eol" ${JSON.stringify(t2)}.`);
      r2 = /\r\n/g;
    }
    const n2 = e20.match(r2);
    return n2 ? n2.length : 0;
  },
  normalizeEndOfLine: function(e20) {
    return e20.replace(/\r\n?/g, "\n");
  }
};
const { literalline: Jn, join: Kn } = Yn, Zn = (e20) => Array.isArray(e20) || e20 && e20.type === "concat", ei = (e20) => {
  if (Array.isArray(e20))
    return e20;
  if (e20.type !== "concat" && e20.type !== "fill")
    throw new Error("Expect doc type to be `concat` or `fill`.");
  return e20.parts;
}, ti = {};
function ri(e20, t2, r2, n2) {
  const i2 = [e20];
  for (; i2.length > 0; ) {
    const e21 = i2.pop();
    if (e21 !== ti) {
      if (r2 && i2.push(e21, ti), !t2 || t2(e21) !== false)
        if (Zn(e21) || e21.type === "fill") {
          const t3 = ei(e21);
          for (let e22 = t3.length - 1; e22 >= 0; --e22)
            i2.push(t3[e22]);
        } else if (e21.type === "if-break")
          e21.flatContents && i2.push(e21.flatContents), e21.breakContents && i2.push(e21.breakContents);
        else if (e21.type === "group" && e21.expandedStates)
          if (n2)
            for (let t3 = e21.expandedStates.length - 1; t3 >= 0; --t3)
              i2.push(e21.expandedStates[t3]);
          else
            i2.push(e21.contents);
        else
          e21.contents && i2.push(e21.contents);
    } else
      r2(i2.pop());
  }
}
function ni(e20, t2) {
  const r2 = new Map();
  return n2(e20);
  function n2(e21) {
    if (r2.has(e21))
      return r2.get(e21);
    const i2 = function(e22) {
      if (Array.isArray(e22))
        return t2(e22.map(n2));
      if (e22.type === "concat" || e22.type === "fill") {
        const r3 = e22.parts.map(n2);
        return t2(Object.assign(Object.assign({}, e22), {}, { parts: r3 }));
      }
      if (e22.type === "if-break") {
        const r3 = e22.breakContents && n2(e22.breakContents), i3 = e22.flatContents && n2(e22.flatContents);
        return t2(Object.assign(Object.assign({}, e22), {}, { breakContents: r3, flatContents: i3 }));
      }
      if (e22.type === "group" && e22.expandedStates) {
        const r3 = e22.expandedStates.map(n2), i3 = r3[0];
        return t2(Object.assign(Object.assign({}, e22), {}, { contents: i3, expandedStates: r3 }));
      }
      if (e22.contents) {
        const r3 = n2(e22.contents);
        return t2(Object.assign(Object.assign({}, e22), {}, { contents: r3 }));
      }
      return t2(e22);
    }(e21);
    return r2.set(e21, i2), i2;
  }
}
function ii(e20, t2, r2) {
  let n2 = r2, i2 = false;
  return ri(e20, function(e21) {
    const r3 = t2(e21);
    if (r3 !== void 0 && (i2 = true, n2 = r3), i2)
      return false;
  }), n2;
}
function si(e20) {
  return !(e20.type !== "group" || !e20.break) || !(e20.type !== "line" || !e20.hard) || e20.type === "break-parent" || void 0;
}
function oi(e20) {
  if (e20.length > 0) {
    const t2 = M$1(e20);
    t2.expandedStates || t2.break || (t2.break = "propagated");
  }
  return null;
}
function ai(e20) {
  return e20.type !== "line" || e20.hard ? e20.type === "if-break" ? e20.flatContents || "" : e20 : e20.soft ? "" : " ";
}
const ui = (e20, t2) => e20 && e20.type === "line" && e20.hard && t2 && t2.type === "break-parent";
function ci(e20) {
  if (!e20)
    return e20;
  if (Zn(e20) || e20.type === "fill") {
    const t2 = ei(e20);
    for (; t2.length > 1 && ui(...t2.slice(-2)); )
      t2.length -= 2;
    if (t2.length > 0) {
      const e21 = ci(M$1(t2));
      t2[t2.length - 1] = e21;
    }
    return Array.isArray(e20) ? t2 : Object.assign(Object.assign({}, e20), {}, { parts: t2 });
  }
  switch (e20.type) {
    case "align":
    case "indent":
    case "indent-if-break":
    case "group":
    case "line-suffix":
    case "label": {
      const t2 = ci(e20.contents);
      return Object.assign(Object.assign({}, e20), {}, { contents: t2 });
    }
    case "if-break": {
      const t2 = ci(e20.breakContents), r2 = ci(e20.flatContents);
      return Object.assign(Object.assign({}, e20), {}, { breakContents: t2, flatContents: r2 });
    }
  }
  return e20;
}
function li(e20) {
  return ni(e20, (e21) => function(e22) {
    switch (e22.type) {
      case "fill":
        if (e22.parts.length === 0 || e22.parts.every((e23) => e23 === ""))
          return "";
        break;
      case "group":
        if (!(e22.contents || e22.id || e22.break || e22.expandedStates))
          return "";
        if (e22.contents.type === "group" && e22.contents.id === e22.id && e22.contents.break === e22.break && e22.contents.expandedStates === e22.expandedStates)
          return e22.contents;
        break;
      case "align":
      case "indent":
      case "indent-if-break":
      case "line-suffix":
        if (!e22.contents)
          return "";
        break;
      case "if-break":
        if (!e22.flatContents && !e22.breakContents)
          return "";
    }
    if (!Zn(e22))
      return e22;
    const t2 = [];
    for (const r2 of ei(e22)) {
      if (!r2)
        continue;
      const [e23, ...n2] = Zn(r2) ? ei(r2) : [r2];
      typeof e23 == "string" && typeof M$1(t2) == "string" ? t2[t2.length - 1] += e23 : t2.push(e23), t2.push(...n2);
    }
    return t2.length === 0 ? "" : t2.length === 1 ? t2[0] : Array.isArray(e22) ? t2 : Object.assign(Object.assign({}, e22), {}, { parts: t2 });
  }(e21));
}
function pi(e20) {
  const t2 = [], r2 = e20.filter(Boolean);
  for (; r2.length > 0; ) {
    const e21 = r2.shift();
    e21 && (Zn(e21) ? r2.unshift(...ei(e21)) : t2.length > 0 && typeof M$1(t2) == "string" && typeof e21 == "string" ? t2[t2.length - 1] += e21 : t2.push(e21));
  }
  return t2;
}
function hi(e20, t2 = Jn) {
  return Kn(t2, e20.split("\n")).parts;
}
var Di = {
  isConcat: Zn,
  getDocParts: ei,
  willBreak: function(e20) {
    return ii(e20, si, false);
  },
  traverseDoc: ri,
  findInDoc: ii,
  mapDoc: ni,
  propagateBreaks: function(e20) {
    const t2 = new Set(), r2 = [];
    ri(e20, function(e21) {
      if (e21.type === "break-parent" && oi(r2), e21.type === "group") {
        if (r2.push(e21), t2.has(e21))
          return false;
        t2.add(e21);
      }
    }, function(e21) {
      if (e21.type === "group") {
        r2.pop().break && oi(r2);
      }
    }, true);
  },
  removeLines: function(e20) {
    return ni(e20, ai);
  },
  stripTrailingHardline: function(e20) {
    return ci(li(e20));
  },
  normalizeParts: pi,
  normalizeDoc: function(e20) {
    return ni(e20, (e21) => Array.isArray(e21) ? pi(e21) : e21.parts ? Object.assign(Object.assign({}, e21), {}, { parts: pi(e21.parts) }) : e21);
  },
  cleanDoc: li,
  replaceTextEndOfLine: hi,
  replaceEndOfLine: function(e20) {
    return ni(e20, (e21) => typeof e21 == "string" && e21.includes("\n") ? hi(e21) : e21);
  }
};
const { getStringWidth: fi, getLast: di } = $n, { convertEndOfLineToChars: gi } = Qn, { fill: mi, cursor: Ei, indent: Ci } = Yn, { isConcat: yi, getDocParts: bi } = Di;
let Si;
function Ti(e20, t2) {
  return vi(e20, { type: "indent" }, t2);
}
function _i(e20, t2, r2) {
  if (t2 === Number.NEGATIVE_INFINITY)
    return e20.root || { value: "", length: 0, queue: [] };
  if (t2 < 0)
    return vi(e20, { type: "dedent" }, r2);
  if (!t2)
    return e20;
  if (t2.type === "root")
    return Object.assign(Object.assign({}, e20), {}, { root: e20 });
  return vi(e20, { type: typeof t2 == "string" ? "stringAlign" : "numberAlign", n: t2 }, r2);
}
function vi(e20, t2, r2) {
  const n2 = t2.type === "dedent" ? e20.queue.slice(0, -1) : [...e20.queue, t2];
  let i2 = "", s2 = 0, o2 = 0, a2 = 0;
  for (const e21 of n2)
    switch (e21.type) {
      case "indent":
        l2(), r2.useTabs ? u2(1) : c2(r2.tabWidth);
        break;
      case "stringAlign":
        l2(), i2 += e21.n, s2 += e21.n.length;
        break;
      case "numberAlign":
        o2 += 1, a2 += e21.n;
        break;
      default:
        throw new Error(`Unexpected type '${e21.type}'`);
    }
  return p2(), Object.assign(Object.assign({}, e20), {}, { value: i2, length: s2, queue: n2 });
  function u2(e21) {
    i2 += "	".repeat(e21), s2 += r2.tabWidth * e21;
  }
  function c2(e21) {
    i2 += " ".repeat(e21), s2 += e21;
  }
  function l2() {
    r2.useTabs ? function() {
      o2 > 0 && u2(o2);
      h2();
    }() : p2();
  }
  function p2() {
    a2 > 0 && c2(a2), h2();
  }
  function h2() {
    o2 = 0, a2 = 0;
  }
}
function Ai(e20) {
  if (e20.length === 0)
    return 0;
  let t2 = 0;
  for (; e20.length > 0 && typeof di(e20) == "string" && /^[\t ]*$/.test(di(e20)); )
    t2 += e20.pop().length;
  if (e20.length > 0 && typeof di(e20) == "string") {
    const r2 = di(e20).replace(/[\t ]*$/, "");
    t2 += di(e20).length - r2.length, e20[e20.length - 1] = r2;
  }
  return t2;
}
function Fi(e20, t2, r2, n2, i2, s2) {
  let o2 = t2.length;
  const a2 = [e20], u2 = [];
  for (; r2 >= 0; ) {
    if (a2.length === 0) {
      if (o2 === 0)
        return true;
      a2.push(t2[o2 - 1]), o2--;
      continue;
    }
    const [e21, c2, l2] = a2.pop();
    if (typeof l2 == "string")
      u2.push(l2), r2 -= fi(l2);
    else if (yi(l2)) {
      const t3 = bi(l2);
      for (let r3 = t3.length - 1; r3 >= 0; r3--)
        a2.push([e21, c2, t3[r3]]);
    } else
      switch (l2.type) {
        case "indent":
          a2.push([Ti(e21, n2), c2, l2.contents]);
          break;
        case "align":
          a2.push([_i(e21, l2.n, n2), c2, l2.contents]);
          break;
        case "trim":
          r2 += Ai(u2);
          break;
        case "group": {
          if (s2 && l2.break)
            return false;
          const t3 = l2.break ? 1 : c2;
          a2.push([
            e21,
            t3,
            l2.expandedStates && t3 === 1 ? di(l2.expandedStates) : l2.contents
          ]), l2.id && (Si[l2.id] = t3);
          break;
        }
        case "fill":
          for (let t3 = l2.parts.length - 1; t3 >= 0; t3--)
            a2.push([e21, c2, l2.parts[t3]]);
          break;
        case "if-break":
        case "indent-if-break": {
          const t3 = l2.groupId ? Si[l2.groupId] : c2;
          if (t3 === 1) {
            const t4 = l2.type === "if-break" ? l2.breakContents : l2.negate ? l2.contents : Ci(l2.contents);
            t4 && a2.push([e21, c2, t4]);
          }
          if (t3 === 2) {
            const t4 = l2.type === "if-break" ? l2.flatContents : l2.negate ? Ci(l2.contents) : l2.contents;
            t4 && a2.push([e21, c2, t4]);
          }
          break;
        }
        case "line":
          switch (c2) {
            case 2:
              if (!l2.hard) {
                l2.soft || (u2.push(" "), r2 -= 1);
                break;
              }
              return true;
            case 1:
              return true;
          }
          break;
        case "line-suffix":
          i2 = true;
          break;
        case "line-suffix-boundary":
          if (i2)
            return false;
          break;
        case "label":
          a2.push([e21, c2, l2.contents]);
      }
  }
  return false;
}
var wi = {
  printDocToString: function(e20, t2) {
    Si = {};
    const r2 = t2.printWidth, n2 = gi(t2.endOfLine);
    let i2 = 0;
    const s2 = [[{ value: "", length: 0, queue: [] }, 1, e20]], o2 = [];
    let a2 = false, u2 = [];
    for (; s2.length > 0; ) {
      const [e21, c3, l2] = s2.pop();
      if (typeof l2 == "string") {
        const e22 = n2 !== "\n" ? l2.replace(/\n/g, n2) : l2;
        o2.push(e22), i2 += fi(e22);
      } else if (yi(l2)) {
        const t3 = bi(l2);
        for (let r3 = t3.length - 1; r3 >= 0; r3--)
          s2.push([e21, c3, t3[r3]]);
      } else
        switch (l2.type) {
          case "cursor":
            o2.push(Ei.placeholder);
            break;
          case "indent":
            s2.push([Ti(e21, t2), c3, l2.contents]);
            break;
          case "align":
            s2.push([_i(e21, l2.n, t2), c3, l2.contents]);
            break;
          case "trim":
            i2 -= Ai(o2);
            break;
          case "group":
            switch (c3) {
              case 2:
                if (!a2) {
                  s2.push([e21, l2.break ? 1 : 2, l2.contents]);
                  break;
                }
              case 1: {
                a2 = false;
                const n3 = [e21, 2, l2.contents], o3 = r2 - i2, c4 = u2.length > 0;
                if (!l2.break && Fi(n3, s2, o3, t2, c4))
                  s2.push(n3);
                else if (l2.expandedStates) {
                  const r3 = di(l2.expandedStates);
                  if (l2.break) {
                    s2.push([e21, 1, r3]);
                    break;
                  }
                  for (let n4 = 1; n4 < l2.expandedStates.length + 1; n4++) {
                    if (n4 >= l2.expandedStates.length) {
                      s2.push([e21, 1, r3]);
                      break;
                    }
                    {
                      const r4 = [
                        e21,
                        2,
                        l2.expandedStates[n4]
                      ];
                      if (Fi(r4, s2, o3, t2, c4)) {
                        s2.push(r4);
                        break;
                      }
                    }
                  }
                } else
                  s2.push([e21, 1, l2.contents]);
                break;
              }
            }
            l2.id && (Si[l2.id] = di(s2)[1]);
            break;
          case "fill": {
            const n3 = r2 - i2, { parts: o3 } = l2;
            if (o3.length === 0)
              break;
            const [a3, p2] = o3, h2 = [e21, 2, a3], D2 = [e21, 1, a3], f2 = Fi(h2, [], n3, t2, u2.length > 0, true);
            if (o3.length === 1) {
              f2 ? s2.push(h2) : s2.push(D2);
              break;
            }
            const d2 = [e21, 2, p2], g2 = [e21, 1, p2];
            if (o3.length === 2) {
              f2 ? s2.push(d2, h2) : s2.push(g2, D2);
              break;
            }
            o3.splice(0, 2);
            const m2 = [e21, c3, mi(o3)];
            Fi([e21, 2, [a3, p2, o3[0]]], [], n3, t2, u2.length > 0, true) ? s2.push(m2, d2, h2) : f2 ? s2.push(m2, g2, h2) : s2.push(m2, g2, D2);
            break;
          }
          case "if-break":
          case "indent-if-break": {
            const t3 = l2.groupId ? Si[l2.groupId] : c3;
            if (t3 === 1) {
              const t4 = l2.type === "if-break" ? l2.breakContents : l2.negate ? l2.contents : Ci(l2.contents);
              t4 && s2.push([e21, c3, t4]);
            }
            if (t3 === 2) {
              const t4 = l2.type === "if-break" ? l2.flatContents : l2.negate ? Ci(l2.contents) : l2.contents;
              t4 && s2.push([e21, c3, t4]);
            }
            break;
          }
          case "line-suffix":
            u2.push([e21, c3, l2.contents]);
            break;
          case "line-suffix-boundary":
            u2.length > 0 && s2.push([e21, c3, { type: "line", hard: true }]);
            break;
          case "line":
            switch (c3) {
              case 2:
                if (!l2.hard) {
                  l2.soft || (o2.push(" "), i2 += 1);
                  break;
                }
                a2 = true;
              case 1:
                if (u2.length > 0) {
                  s2.push([e21, c3, l2], ...u2.reverse()), u2 = [];
                  break;
                }
                l2.literal ? e21.root ? (o2.push(n2, e21.root.value), i2 = e21.root.length) : (o2.push(n2), i2 = 0) : (i2 -= Ai(o2), o2.push(n2 + e21.value), i2 = e21.length);
            }
            break;
          case "label":
            s2.push([e21, c3, l2.contents]);
        }
      s2.length === 0 && u2.length > 0 && (s2.push(...u2.reverse()), u2 = []);
    }
    const c2 = o2.indexOf(Ei.placeholder);
    if (c2 !== -1) {
      const e21 = o2.indexOf(Ei.placeholder, c2 + 1), t3 = o2.slice(0, c2).join(""), r3 = o2.slice(c2 + 1, e21).join("");
      return {
        formatted: t3 + r3 + o2.slice(e21 + 1).join(""),
        cursorNodeStart: t3.length,
        cursorNodeText: r3
      };
    }
    return { formatted: o2.join("") };
  }
};
const { isConcat: ki, getDocParts: Ni } = Di;
function Oi(e20) {
  if (!e20)
    return "";
  if (ki(e20)) {
    const t2 = [];
    for (const r2 of Ni(e20))
      if (ki(r2))
        t2.push(...Oi(r2).parts);
      else {
        const e21 = Oi(r2);
        e21 !== "" && t2.push(e21);
      }
    return { type: "concat", parts: t2 };
  }
  return e20.type === "if-break" ? Object.assign(Object.assign({}, e20), {}, {
    breakContents: Oi(e20.breakContents),
    flatContents: Oi(e20.flatContents)
  }) : e20.type === "group" ? Object.assign(Object.assign({}, e20), {}, {
    contents: Oi(e20.contents),
    expandedStates: e20.expandedStates && e20.expandedStates.map(Oi)
  }) : e20.type === "fill" ? { type: "fill", parts: e20.parts.map(Oi) } : e20.contents ? Object.assign(Object.assign({}, e20), {}, { contents: Oi(e20.contents) }) : e20;
}
var xi = {
  builders: Yn,
  printer: wi,
  utils: Di,
  debug: {
    printDocToDebug: function(e20) {
      const t2 = Object.create(null), r2 = new Set();
      return function e21(t3, r3, i2) {
        if (typeof t3 == "string")
          return JSON.stringify(t3);
        if (ki(t3)) {
          const r4 = Ni(t3).map(e21).filter(Boolean);
          return r4.length === 1 ? r4[0] : `[${r4.join(", ")}]`;
        }
        if (t3.type === "line") {
          const e22 = Array.isArray(i2) && i2[r3 + 1] && i2[r3 + 1].type === "break-parent";
          return t3.literal ? e22 ? "literalline" : "literallineWithoutBreakParent" : t3.hard ? e22 ? "hardline" : "hardlineWithoutBreakParent" : t3.soft ? "softline" : "line";
        }
        if (t3.type === "break-parent") {
          return Array.isArray(i2) && i2[r3 - 1] && i2[r3 - 1].type === "line" && i2[r3 - 1].hard ? void 0 : "breakParent";
        }
        if (t3.type === "trim")
          return "trim";
        if (t3.type === "indent")
          return "indent(" + e21(t3.contents) + ")";
        if (t3.type === "align")
          return t3.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + e21(t3.contents) + ")" : t3.n < 0 ? "dedent(" + e21(t3.contents) + ")" : t3.n.type === "root" ? "markAsRoot(" + e21(t3.contents) + ")" : "align(" + JSON.stringify(t3.n) + ", " + e21(t3.contents) + ")";
        if (t3.type === "if-break")
          return "ifBreak(" + e21(t3.breakContents) + (t3.flatContents ? ", " + e21(t3.flatContents) : "") + (t3.groupId ? (t3.flatContents ? "" : ', ""') + `, { groupId: ${n2(t3.groupId)} }` : "") + ")";
        if (t3.type === "indent-if-break") {
          const r4 = [];
          t3.negate && r4.push("negate: true"), t3.groupId && r4.push(`groupId: ${n2(t3.groupId)}`);
          const i3 = r4.length > 0 ? `, { ${r4.join(", ")} }` : "";
          return `indentIfBreak(${e21(t3.contents)}${i3})`;
        }
        if (t3.type === "group") {
          const r4 = [];
          t3.break && t3.break !== "propagated" && r4.push("shouldBreak: true"), t3.id && r4.push(`id: ${n2(t3.id)}`);
          const i3 = r4.length > 0 ? `, { ${r4.join(", ")} }` : "";
          return t3.expandedStates ? `conditionalGroup([${t3.expandedStates.map((t4) => e21(t4)).join(",")}]${i3})` : `group(${e21(t3.contents)}${i3})`;
        }
        if (t3.type === "fill")
          return `fill([${t3.parts.map((t4) => e21(t4)).join(", ")}])`;
        if (t3.type === "line-suffix")
          return "lineSuffix(" + e21(t3.contents) + ")";
        if (t3.type === "line-suffix-boundary")
          return "lineSuffixBoundary";
        if (t3.type === "label")
          return `label(${JSON.stringify(t3.label)}, ${e21(t3.contents)})`;
        throw new Error("Unknown doc type " + t3.type);
      }(Oi(e20));
      function n2(e21) {
        if (typeof e21 != "symbol")
          return JSON.stringify(String(e21));
        if (e21 in t2)
          return t2[e21];
        const n3 = String(e21).slice(7, -1) || "symbol";
        for (let i2 = 0; ; i2++) {
          const s2 = n3 + (i2 > 0 ? ` #${i2}` : "");
          if (!r2.has(s2))
            return r2.add(s2), t2[e21] = `Symbol.for(${JSON.stringify(s2)})`;
        }
      }
    }
  }
};
const { inferParserByLanguage: Ii, isFrontMatterNode: Pi } = $n, {
  builders: { line: Ri, hardline: Li, join: Bi },
  utils: { getDocParts: $i, replaceTextEndOfLine: qi }
} = xi, {
  CSS_DISPLAY_TAGS: Mi,
  CSS_DISPLAY_DEFAULT: ji,
  CSS_WHITE_SPACE_TAGS: Ui,
  CSS_WHITE_SPACE_DEFAULT: Gi
} = {
  CSS_DISPLAY_TAGS: {
    area: "none",
    base: "none",
    basefont: "none",
    datalist: "none",
    head: "none",
    link: "none",
    meta: "none",
    noembed: "none",
    noframes: "none",
    param: "block",
    rp: "none",
    script: "block",
    source: "block",
    style: "none",
    template: "inline",
    track: "block",
    title: "none",
    html: "block",
    body: "block",
    address: "block",
    blockquote: "block",
    center: "block",
    div: "block",
    figure: "block",
    figcaption: "block",
    footer: "block",
    form: "block",
    header: "block",
    hr: "block",
    legend: "block",
    listing: "block",
    main: "block",
    p: "block",
    plaintext: "block",
    pre: "block",
    xmp: "block",
    slot: "contents",
    ruby: "ruby",
    rt: "ruby-text",
    article: "block",
    aside: "block",
    h1: "block",
    h2: "block",
    h3: "block",
    h4: "block",
    h5: "block",
    h6: "block",
    hgroup: "block",
    nav: "block",
    section: "block",
    dir: "block",
    dd: "block",
    dl: "block",
    dt: "block",
    ol: "block",
    ul: "block",
    li: "list-item",
    table: "table",
    caption: "table-caption",
    colgroup: "table-column-group",
    col: "table-column",
    thead: "table-header-group",
    tbody: "table-row-group",
    tfoot: "table-footer-group",
    tr: "table-row",
    td: "table-cell",
    th: "table-cell",
    fieldset: "block",
    button: "inline-block",
    details: "block",
    summary: "block",
    dialog: "block",
    meter: "inline-block",
    progress: "inline-block",
    object: "inline-block",
    video: "inline-block",
    audio: "inline-block",
    select: "inline-block",
    option: "block",
    optgroup: "block"
  },
  CSS_DISPLAY_DEFAULT: "inline",
  CSS_WHITE_SPACE_TAGS: {
    listing: "pre",
    plaintext: "pre",
    pre: "pre",
    xmp: "pre",
    nobr: "nowrap",
    table: "initial",
    textarea: "pre-wrap"
  },
  CSS_WHITE_SPACE_DEFAULT: "normal"
}, Vi = Yi([
  "a",
  "abbr",
  "acronym",
  "address",
  "applet",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "basefont",
  "bdi",
  "bdo",
  "bgsound",
  "big",
  "blink",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "center",
  "cite",
  "code",
  "col",
  "colgroup",
  "command",
  "content",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "element",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "font",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "image",
  "img",
  "input",
  "ins",
  "isindex",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "listing",
  "main",
  "map",
  "mark",
  "marquee",
  "math",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "multicol",
  "nav",
  "nextid",
  "nobr",
  "noembed",
  "noframes",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "plaintext",
  "pre",
  "progress",
  "q",
  "rb",
  "rbc",
  "rp",
  "rt",
  "rtc",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "shadow",
  "slot",
  "small",
  "source",
  "spacer",
  "span",
  "strike",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "svg",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "tt",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  "xmp"
]), Hi = function(e20, t2) {
  const r2 = Object.create(null);
  for (const [n2, i2] of Object.entries(e20))
    r2[n2] = t2(i2, n2);
  return r2;
}(qn, Yi), Xi = new Set(["	", "\n", "\f", "\r", " "]), zi = (e20) => e20.replace(/[\t\n\f\r ]+$/, ""), Wi = (e20) => ((e21) => e21.replace(/^[\t\f\r ]*?\n/g, ""))(zi(e20));
function Yi(e20) {
  const t2 = Object.create(null);
  for (const r2 of e20)
    t2[r2] = true;
  return t2;
}
function Qi(e20) {
  return e20.type === "element" && (e20.fullName === "script" || e20.fullName === "style" || e20.fullName === "svg:style" || as$3(e20) && (e20.name === "script" || e20.name === "style"));
}
function Ji(e20) {
  return us(e20).startsWith("pre");
}
function Ki(e20) {
  return e20.type === "element" && e20.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(e20.name) || e20.cssDisplay.startsWith("table") && e20.cssDisplay !== "table-cell");
}
function Zi(e20) {
  return ns(e20) || e20.type === "element" && e20.fullName === "br" || es(e20);
}
function es(e20) {
  return ts(e20) && rs(e20);
}
function ts(e20) {
  return e20.hasLeadingSpaces && (e20.prev ? e20.prev.sourceSpan.end.line < e20.sourceSpan.start.line : e20.parent.type === "root" || e20.parent.startSourceSpan.end.line < e20.sourceSpan.start.line);
}
function rs(e20) {
  return e20.hasTrailingSpaces && (e20.next ? e20.next.sourceSpan.start.line > e20.sourceSpan.end.line : e20.parent.type === "root" || e20.parent.endSourceSpan && e20.parent.endSourceSpan.start.line > e20.sourceSpan.end.line);
}
function ns(e20) {
  switch (e20.type) {
    case "ieConditionalComment":
    case "comment":
    case "directive":
      return true;
    case "element":
      return ["script", "select"].includes(e20.name);
  }
  return false;
}
function is(e20) {
  const { type: t2, lang: r2 } = e20.attrMap;
  return t2 === "module" || t2 === "text/javascript" || t2 === "text/babel" || t2 === "application/javascript" || r2 === "jsx" ? "babel" : t2 === "application/x-typescript" || r2 === "ts" || r2 === "tsx" ? "typescript" : t2 === "text/markdown" ? "markdown" : t2 === "text/html" ? "html" : t2 && (t2.endsWith("json") || t2.endsWith("importmap")) ? "json" : t2 === "text/x-handlebars-template" ? "glimmer" : void 0;
}
function ss(e20) {
  return e20 === "block" || e20 === "list-item" || e20.startsWith("table");
}
function os(e20) {
  return us(e20).startsWith("pre");
}
function as$3(e20) {
  return e20.type === "element" && !e20.hasExplicitNamespace && !["html", "svg"].includes(e20.namespace);
}
function us(e20) {
  return e20.type === "element" && (!e20.namespace || as$3(e20)) && Ui[e20.name] || Gi;
}
function cs(e20, t2 = function(e21) {
  let t3 = Number.POSITIVE_INFINITY;
  for (const n2 of e21.split("\n")) {
    if (n2.length === 0)
      continue;
    if (!Xi.has(n2[0]))
      return 0;
    const e22 = (r2 = n2, r2.match(/^[\t\n\f\r ]*/)[0]).length;
    n2.length !== e22 && e22 < t3 && (t3 = e22);
  }
  var r2;
  return t3 === Number.POSITIVE_INFINITY ? 0 : t3;
}(e20)) {
  return t2 === 0 ? e20 : e20.split("\n").map((e21) => e21.slice(t2)).join("\n");
}
const ls = new Set(["template", "style", "script"]);
function ps(e20, t2) {
  return hs(e20, t2) && !ls.has(e20.fullName);
}
function hs(e20, t2) {
  return t2.parser === "vue" && e20.type === "element" && e20.parent.type === "root" && e20.fullName.toLowerCase() !== "html";
}
function Ds(e20, t2) {
  return hs(e20, t2) && (ps(e20, t2) || e20.attrMap.lang && e20.attrMap.lang !== "html");
}
var fs = {
  HTML_ELEMENT_ATTRIBUTES: Hi,
  HTML_TAGS: Vi,
  htmlTrim: (e20) => ((e21) => e21.replace(/^[\t\n\f\r ]+/, ""))(zi(e20)),
  htmlTrimPreserveIndentation: Wi,
  hasHtmlWhitespace: (e20) => /[\t\n\f\r ]/.test(e20),
  getLeadingAndTrailingHtmlWhitespace: (e20) => {
    const [, t2, r2, n2] = e20.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
    return { leadingWhitespace: t2, trailingWhitespace: n2, text: r2 };
  },
  canHaveInterpolation: function(e20) {
    return e20.children && !Qi(e20);
  },
  countChars: function(e20, t2) {
    let r2 = 0;
    for (let n2 = 0; n2 < e20.length; n2++)
      e20[n2] === t2 && r2++;
    return r2;
  },
  countParents: function(e20, t2) {
    let r2 = 0;
    for (let n2 = e20.stack.length - 1; n2 >= 0; n2--) {
      const i2 = e20.stack[n2];
      i2 && typeof i2 == "object" && !Array.isArray(i2) && t2(i2) && r2++;
    }
    return r2;
  },
  dedentString: cs,
  forceBreakChildren: Ki,
  forceBreakContent: function(e20) {
    return Ki(e20) || e20.type === "element" && e20.children.length > 0 && (["body", "script", "style"].includes(e20.name) || e20.children.some((e21) => function(e22) {
      return e22.children && e22.children.some((e23) => e23.type !== "text");
    }(e21))) || e20.firstChild && e20.firstChild === e20.lastChild && e20.firstChild.type !== "text" && ts(e20.firstChild) && (!e20.lastChild.isTrailingSpaceSensitive || rs(e20.lastChild));
  },
  forceNextEmptyLine: function(e20) {
    return Pi(e20) || e20.next && e20.sourceSpan.end && e20.sourceSpan.end.line + 1 < e20.next.sourceSpan.start.line;
  },
  getLastDescendant: function e19(t2) {
    return t2.lastChild ? e19(t2.lastChild) : t2;
  },
  getNodeCssStyleDisplay: function(e20, t2) {
    if (e20.prev && e20.prev.type === "comment") {
      const t3 = e20.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
      if (t3)
        return t3[1];
    }
    let r2 = false;
    if (e20.type === "element" && e20.namespace === "svg") {
      if (!function(e21, t3) {
        let r3 = e21;
        for (; r3; ) {
          if (t3(r3))
            return true;
          r3 = r3.parent;
        }
        return false;
      }(e20, (e21) => e21.fullName === "svg:foreignObject"))
        return e20.name === "svg" ? "inline-block" : "block";
      r2 = true;
    }
    switch (t2.htmlWhitespaceSensitivity) {
      case "strict":
        return "inline";
      case "ignore":
        return "block";
      default:
        return t2.parser === "vue" && e20.parent && e20.parent.type === "root" ? "block" : e20.type === "element" && (!e20.namespace || r2 || as$3(e20)) && Mi[e20.name] || ji;
    }
  },
  getNodeCssStyleWhiteSpace: us,
  hasPrettierIgnore: function(e20) {
    return e20.type !== "attribute" && !!e20.parent && typeof e20.index == "number" && e20.index !== 0 && function(e21) {
      return e21.type === "comment" && e21.value.trim() === "prettier-ignore";
    }(e20.parent.children[e20.index - 1]);
  },
  inferScriptParser: function(e20, t2) {
    return e20.name !== "script" || e20.attrMap.src ? e20.name === "style" ? function(e21) {
      const { lang: t3 } = e21.attrMap;
      return t3 && t3 !== "postcss" && t3 !== "css" ? t3 === "scss" ? "scss" : t3 === "less" ? "less" : void 0 : "css";
    }(e20) : t2 && Ds(e20, t2) ? is(e20) || !("src" in e20.attrMap) && Ii(e20.attrMap.lang, t2) : void 0 : e20.attrMap.lang || e20.attrMap.type ? is(e20) : "babel";
  },
  isVueCustomBlock: ps,
  isVueNonHtmlBlock: Ds,
  isVueSlotAttribute: function(e20) {
    const t2 = e20.fullName;
    return t2.charAt(0) === "#" || t2 === "slot-scope" || t2 === "v-slot" || t2.startsWith("v-slot:");
  },
  isVueSfcBindingsAttribute: function(e20, t2) {
    const r2 = e20.parent;
    if (!hs(r2, t2))
      return false;
    const n2 = r2.fullName, i2 = e20.fullName;
    return n2 === "script" && i2 === "setup" || n2 === "style" && i2 === "vars";
  },
  isDanglingSpaceSensitiveNode: function(e20) {
    return !(t2 = e20.cssDisplay, ss(t2) || t2 === "inline-block" || Qi(e20));
    var t2;
  },
  isIndentationSensitiveNode: Ji,
  isLeadingSpaceSensitiveNode: function(e20, t2) {
    const r2 = function() {
      if (Pi(e20))
        return false;
      if ((e20.type === "text" || e20.type === "interpolation") && e20.prev && (e20.prev.type === "text" || e20.prev.type === "interpolation"))
        return true;
      if (!e20.parent || e20.parent.cssDisplay === "none")
        return false;
      if (os(e20.parent))
        return true;
      if (!e20.prev && (e20.parent.type === "root" || os(e20) && e20.parent || Qi(e20.parent) || ps(e20.parent, t2) || (r3 = e20.parent.cssDisplay, ss(r3) || r3 === "inline-block")))
        return false;
      var r3;
      if (e20.prev && !function(e21) {
        return !ss(e21);
      }(e20.prev.cssDisplay))
        return false;
      return true;
    }();
    return r2 && !e20.prev && e20.parent && e20.parent.tagDefinition && e20.parent.tagDefinition.ignoreFirstLf ? e20.type === "interpolation" : r2;
  },
  isPreLikeNode: os,
  isScriptLikeTag: Qi,
  isTextLikeNode: function(e20) {
    return e20.type === "text" || e20.type === "comment";
  },
  isTrailingSpaceSensitiveNode: function(e20, t2) {
    return !Pi(e20) && (!(e20.type !== "text" && e20.type !== "interpolation" || !e20.next || e20.next.type !== "text" && e20.next.type !== "interpolation") || !(!e20.parent || e20.parent.cssDisplay === "none") && (!!os(e20.parent) || !(!e20.next && (e20.parent.type === "root" || os(e20) && e20.parent || Qi(e20.parent) || ps(e20.parent, t2) || (r2 = e20.parent.cssDisplay, ss(r2) || r2 === "inline-block"))) && !(e20.next && !function(e21) {
      return !ss(e21);
    }(e20.next.cssDisplay))));
    var r2;
  },
  isWhitespaceSensitiveNode: function(e20) {
    return Qi(e20) || e20.type === "interpolation" || Ji(e20);
  },
  isUnknownNamespace: as$3,
  preferHardlineAsLeadingSpaces: function(e20) {
    return ns(e20) || e20.prev && Zi(e20.prev) || es(e20);
  },
  preferHardlineAsTrailingSpaces: Zi,
  shouldPreserveContent: function(e20, t2) {
    return !(e20.type !== "ieConditionalComment" || !e20.lastChild || e20.lastChild.isSelfClosing || e20.lastChild.endSourceSpan) || e20.type === "ieConditionalComment" && !e20.complete || !(!os(e20) || !e20.children.some((e21) => e21.type !== "text" && e21.type !== "interpolation")) || !(!Ds(e20, t2) || Qi(e20) || e20.type === "interpolation");
  },
  unescapeQuoteEntities: function(e20) {
    return e20.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
  },
  getTextValueParts: function(e20, t2 = e20.value) {
    return e20.parent.isWhitespaceSensitive ? e20.parent.isIndentationSensitive ? qi(t2) : qi(cs(Wi(t2)), Li) : $i(Bi(Ri, t2.split(/[\t\n\f\r ]+/)));
  }
};
var ds = {
  hasPragma: function(e20) {
    return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(e20);
  },
  insertPragma: function(e20) {
    return "<!-- @format -->\n\n" + e20.replace(/^\s*\n/, "");
  }
};
const { isNonEmptyArray: gs } = $n, ms = { attrs: true, children: true };
class Es {
  constructor(e20 = {}) {
    for (const [t2, r2] of Object.entries(e20))
      t2 in ms ? this._setNodes(t2, r2) : this[t2] = r2;
  }
  _setNodes(e20, t2) {
    t2 !== this[e20] && (this[e20] = function(e21, t3) {
      const r2 = e21.map((e22) => e22 instanceof Es ? e22.clone() : new Es(e22));
      let n2 = null, i2 = r2[0], s2 = r2[1] || null;
      for (let e22 = 0; e22 < r2.length; e22++)
        ys(i2, {
          index: e22,
          siblings: r2,
          prev: n2,
          next: s2,
          parent: t3
        }), n2 = i2, i2 = s2, s2 = r2[e22 + 2] || null;
      return r2;
    }(t2, this), e20 === "attrs" && ys(this, {
      attrMap: Object.fromEntries(this[e20].map((e21) => [e21.fullName, e21.value]))
    }));
  }
  map(e20) {
    let t2 = null;
    for (const r2 in ms) {
      const n2 = this[r2];
      if (n2) {
        const i2 = Cs(n2, (t3) => t3.map(e20));
        t2 !== n2 && (t2 || (t2 = new Es()), t2._setNodes(r2, i2));
      }
    }
    if (t2) {
      for (const e22 in this)
        e22 in ms || (t2[e22] = this[e22]);
      const { index: e21, siblings: r2, prev: n2, next: i2, parent: s2 } = this;
      ys(t2, { index: e21, siblings: r2, prev: n2, next: i2, parent: s2 });
    }
    return e20(t2 || this);
  }
  walk(e20) {
    for (const t2 in ms) {
      const r2 = this[t2];
      if (r2)
        for (let t3 = 0; t3 < r2.length; t3++)
          r2[t3].walk(e20);
    }
    e20(this);
  }
  clone(e20) {
    return new Es(e20 ? Object.assign(Object.assign({}, this), e20) : this);
  }
  setChildren(e20) {
    this._setNodes("children", e20);
  }
  get firstChild() {
    return gs(this.children) ? this.children[0] : null;
  }
  get lastChild() {
    return gs(this.children) ? M$1(this.children) : null;
  }
  get rawName() {
    return this.hasExplicitNamespace ? this.fullName : this.name;
  }
  get fullName() {
    return this.namespace ? this.namespace + ":" + this.name : this.name;
  }
}
function Cs(e20, t2) {
  const r2 = e20.map(t2);
  return r2.some((t3, r3) => t3 !== e20[r3]) ? r2 : e20;
}
function ys(e20, t2) {
  const r2 = Object.fromEntries(Object.entries(t2).map(([e21, t3]) => [e21, { value: t3, enumerable: false }]));
  Object.defineProperties(e20, r2);
}
var bs = { Node: Es };
const { ParseSourceSpan: Ss } = B$1, Ts = [
  {
    regex: /^(\[if([^\]]*?)]>)(.*?)<!\s*\[endif]$/s,
    parse: function(e20, t2, r2) {
      const [, n2, i2, s2] = r2, o2 = "<!--".length + n2.length, a2 = e20.sourceSpan.start.moveBy(o2), u2 = a2.moveBy(s2.length), [c2, l2] = (() => {
        try {
          return [true, t2(s2, a2).children];
        } catch {
          return [
            false,
            [
              {
                type: "text",
                value: s2,
                sourceSpan: new Ss(a2, u2)
              }
            ]
          ];
        }
      })();
      return {
        type: "ieConditionalComment",
        complete: c2,
        children: l2,
        condition: i2.trim().replace(/\s+/g, " "),
        sourceSpan: e20.sourceSpan,
        startSourceSpan: new Ss(e20.sourceSpan.start, a2),
        endSourceSpan: new Ss(u2, e20.sourceSpan.end)
      };
    }
  },
  {
    regex: /^\[if([^\]]*?)]><!$/,
    parse: function(e20, t2, r2) {
      const [, n2] = r2;
      return {
        type: "ieConditionalStartComment",
        condition: n2.trim().replace(/\s+/g, " "),
        sourceSpan: e20.sourceSpan
      };
    }
  },
  {
    regex: /^<!\s*\[endif]$/,
    parse: function(e20) {
      return {
        type: "ieConditionalEndComment",
        sourceSpan: e20.sourceSpan
      };
    }
  }
];
var _s = {
  parseIeConditionalComment: function(e20, t2) {
    if (e20.value)
      for (const { regex: r2, parse: n2 } of Ts) {
        const i2 = e20.value.match(r2);
        if (i2)
          return n2(e20, t2, i2);
      }
    return null;
  }
};
var vs = {
  locStart: function(e20) {
    return e20.sourceSpan.start.offset;
  },
  locEnd: function(e20) {
    return e20.sourceSpan.end.offset;
  }
}, As = t$1(function(e20, t2) {
  function r2(e21) {
    if (e21[0] != ":")
      return [null, e21];
    const t3 = e21.indexOf(":", 1);
    if (t3 == -1)
      throw new Error(`Unsupported format "${e21}" expecting ":namespace:name"`);
    return [e21.slice(1, t3), e21.slice(t3 + 1)];
  }
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  Object.defineProperty(t2, "__esModule", { value: true }), function(e21) {
    e21[e21.RAW_TEXT = 0] = "RAW_TEXT", e21[e21.ESCAPABLE_RAW_TEXT = 1] = "ESCAPABLE_RAW_TEXT", e21[e21.PARSABLE_DATA = 2] = "PARSABLE_DATA";
  }(t2.TagContentType || (t2.TagContentType = {})), t2.splitNsName = r2, t2.isNgContainer = function(e21) {
    return r2(e21)[1] === "ng-container";
  }, t2.isNgContent = function(e21) {
    return r2(e21)[1] === "ng-content";
  }, t2.isNgTemplate = function(e21) {
    return r2(e21)[1] === "ng-template";
  }, t2.getNsPrefix = function(e21) {
    return e21 === null ? null : r2(e21)[0];
  }, t2.mergeNsAndName = function(e21, t3) {
    return e21 ? `:${e21}:${t3}` : t3;
  }, t2.NAMED_ENTITIES = {
    Aacute: "\xC1",
    aacute: "\xE1",
    Abreve: "\u0102",
    abreve: "\u0103",
    ac: "\u223E",
    acd: "\u223F",
    acE: "\u223E\u0333",
    Acirc: "\xC2",
    acirc: "\xE2",
    acute: "\xB4",
    Acy: "\u0410",
    acy: "\u0430",
    AElig: "\xC6",
    aelig: "\xE6",
    af: "\u2061",
    Afr: "\u{1D504}",
    afr: "\u{1D51E}",
    Agrave: "\xC0",
    agrave: "\xE0",
    alefsym: "\u2135",
    aleph: "\u2135",
    Alpha: "\u0391",
    alpha: "\u03B1",
    Amacr: "\u0100",
    amacr: "\u0101",
    amalg: "\u2A3F",
    AMP: "&",
    amp: "&",
    And: "\u2A53",
    and: "\u2227",
    andand: "\u2A55",
    andd: "\u2A5C",
    andslope: "\u2A58",
    andv: "\u2A5A",
    ang: "\u2220",
    ange: "\u29A4",
    angle: "\u2220",
    angmsd: "\u2221",
    angmsdaa: "\u29A8",
    angmsdab: "\u29A9",
    angmsdac: "\u29AA",
    angmsdad: "\u29AB",
    angmsdae: "\u29AC",
    angmsdaf: "\u29AD",
    angmsdag: "\u29AE",
    angmsdah: "\u29AF",
    angrt: "\u221F",
    angrtvb: "\u22BE",
    angrtvbd: "\u299D",
    angsph: "\u2222",
    angst: "\xC5",
    angzarr: "\u237C",
    Aogon: "\u0104",
    aogon: "\u0105",
    Aopf: "\u{1D538}",
    aopf: "\u{1D552}",
    ap: "\u2248",
    apacir: "\u2A6F",
    apE: "\u2A70",
    ape: "\u224A",
    apid: "\u224B",
    apos: "'",
    ApplyFunction: "\u2061",
    approx: "\u2248",
    approxeq: "\u224A",
    Aring: "\xC5",
    aring: "\xE5",
    Ascr: "\u{1D49C}",
    ascr: "\u{1D4B6}",
    Assign: "\u2254",
    ast: "*",
    asymp: "\u2248",
    asympeq: "\u224D",
    Atilde: "\xC3",
    atilde: "\xE3",
    Auml: "\xC4",
    auml: "\xE4",
    awconint: "\u2233",
    awint: "\u2A11",
    backcong: "\u224C",
    backepsilon: "\u03F6",
    backprime: "\u2035",
    backsim: "\u223D",
    backsimeq: "\u22CD",
    Backslash: "\u2216",
    Barv: "\u2AE7",
    barvee: "\u22BD",
    Barwed: "\u2306",
    barwed: "\u2305",
    barwedge: "\u2305",
    bbrk: "\u23B5",
    bbrktbrk: "\u23B6",
    bcong: "\u224C",
    Bcy: "\u0411",
    bcy: "\u0431",
    bdquo: "\u201E",
    becaus: "\u2235",
    Because: "\u2235",
    because: "\u2235",
    bemptyv: "\u29B0",
    bepsi: "\u03F6",
    bernou: "\u212C",
    Bernoullis: "\u212C",
    Beta: "\u0392",
    beta: "\u03B2",
    beth: "\u2136",
    between: "\u226C",
    Bfr: "\u{1D505}",
    bfr: "\u{1D51F}",
    bigcap: "\u22C2",
    bigcirc: "\u25EF",
    bigcup: "\u22C3",
    bigodot: "\u2A00",
    bigoplus: "\u2A01",
    bigotimes: "\u2A02",
    bigsqcup: "\u2A06",
    bigstar: "\u2605",
    bigtriangledown: "\u25BD",
    bigtriangleup: "\u25B3",
    biguplus: "\u2A04",
    bigvee: "\u22C1",
    bigwedge: "\u22C0",
    bkarow: "\u290D",
    blacklozenge: "\u29EB",
    blacksquare: "\u25AA",
    blacktriangle: "\u25B4",
    blacktriangledown: "\u25BE",
    blacktriangleleft: "\u25C2",
    blacktriangleright: "\u25B8",
    blank: "\u2423",
    blk12: "\u2592",
    blk14: "\u2591",
    blk34: "\u2593",
    block: "\u2588",
    bne: "=\u20E5",
    bnequiv: "\u2261\u20E5",
    bNot: "\u2AED",
    bnot: "\u2310",
    Bopf: "\u{1D539}",
    bopf: "\u{1D553}",
    bot: "\u22A5",
    bottom: "\u22A5",
    bowtie: "\u22C8",
    boxbox: "\u29C9",
    boxDL: "\u2557",
    boxDl: "\u2556",
    boxdL: "\u2555",
    boxdl: "\u2510",
    boxDR: "\u2554",
    boxDr: "\u2553",
    boxdR: "\u2552",
    boxdr: "\u250C",
    boxH: "\u2550",
    boxh: "\u2500",
    boxHD: "\u2566",
    boxHd: "\u2564",
    boxhD: "\u2565",
    boxhd: "\u252C",
    boxHU: "\u2569",
    boxHu: "\u2567",
    boxhU: "\u2568",
    boxhu: "\u2534",
    boxminus: "\u229F",
    boxplus: "\u229E",
    boxtimes: "\u22A0",
    boxUL: "\u255D",
    boxUl: "\u255C",
    boxuL: "\u255B",
    boxul: "\u2518",
    boxUR: "\u255A",
    boxUr: "\u2559",
    boxuR: "\u2558",
    boxur: "\u2514",
    boxV: "\u2551",
    boxv: "\u2502",
    boxVH: "\u256C",
    boxVh: "\u256B",
    boxvH: "\u256A",
    boxvh: "\u253C",
    boxVL: "\u2563",
    boxVl: "\u2562",
    boxvL: "\u2561",
    boxvl: "\u2524",
    boxVR: "\u2560",
    boxVr: "\u255F",
    boxvR: "\u255E",
    boxvr: "\u251C",
    bprime: "\u2035",
    Breve: "\u02D8",
    breve: "\u02D8",
    brvbar: "\xA6",
    Bscr: "\u212C",
    bscr: "\u{1D4B7}",
    bsemi: "\u204F",
    bsim: "\u223D",
    bsime: "\u22CD",
    bsol: "\\",
    bsolb: "\u29C5",
    bsolhsub: "\u27C8",
    bull: "\u2022",
    bullet: "\u2022",
    bump: "\u224E",
    bumpE: "\u2AAE",
    bumpe: "\u224F",
    Bumpeq: "\u224E",
    bumpeq: "\u224F",
    Cacute: "\u0106",
    cacute: "\u0107",
    Cap: "\u22D2",
    cap: "\u2229",
    capand: "\u2A44",
    capbrcup: "\u2A49",
    capcap: "\u2A4B",
    capcup: "\u2A47",
    capdot: "\u2A40",
    CapitalDifferentialD: "\u2145",
    caps: "\u2229\uFE00",
    caret: "\u2041",
    caron: "\u02C7",
    Cayleys: "\u212D",
    ccaps: "\u2A4D",
    Ccaron: "\u010C",
    ccaron: "\u010D",
    Ccedil: "\xC7",
    ccedil: "\xE7",
    Ccirc: "\u0108",
    ccirc: "\u0109",
    Cconint: "\u2230",
    ccups: "\u2A4C",
    ccupssm: "\u2A50",
    Cdot: "\u010A",
    cdot: "\u010B",
    cedil: "\xB8",
    Cedilla: "\xB8",
    cemptyv: "\u29B2",
    cent: "\xA2",
    CenterDot: "\xB7",
    centerdot: "\xB7",
    Cfr: "\u212D",
    cfr: "\u{1D520}",
    CHcy: "\u0427",
    chcy: "\u0447",
    check: "\u2713",
    checkmark: "\u2713",
    Chi: "\u03A7",
    chi: "\u03C7",
    cir: "\u25CB",
    circ: "\u02C6",
    circeq: "\u2257",
    circlearrowleft: "\u21BA",
    circlearrowright: "\u21BB",
    circledast: "\u229B",
    circledcirc: "\u229A",
    circleddash: "\u229D",
    CircleDot: "\u2299",
    circledR: "\xAE",
    circledS: "\u24C8",
    CircleMinus: "\u2296",
    CirclePlus: "\u2295",
    CircleTimes: "\u2297",
    cirE: "\u29C3",
    cire: "\u2257",
    cirfnint: "\u2A10",
    cirmid: "\u2AEF",
    cirscir: "\u29C2",
    ClockwiseContourIntegral: "\u2232",
    CloseCurlyDoubleQuote: "\u201D",
    CloseCurlyQuote: "\u2019",
    clubs: "\u2663",
    clubsuit: "\u2663",
    Colon: "\u2237",
    colon: ":",
    Colone: "\u2A74",
    colone: "\u2254",
    coloneq: "\u2254",
    comma: ",",
    commat: "@",
    comp: "\u2201",
    compfn: "\u2218",
    complement: "\u2201",
    complexes: "\u2102",
    cong: "\u2245",
    congdot: "\u2A6D",
    Congruent: "\u2261",
    Conint: "\u222F",
    conint: "\u222E",
    ContourIntegral: "\u222E",
    Copf: "\u2102",
    copf: "\u{1D554}",
    coprod: "\u2210",
    Coproduct: "\u2210",
    COPY: "\xA9",
    copy: "\xA9",
    copysr: "\u2117",
    CounterClockwiseContourIntegral: "\u2233",
    crarr: "\u21B5",
    Cross: "\u2A2F",
    cross: "\u2717",
    Cscr: "\u{1D49E}",
    cscr: "\u{1D4B8}",
    csub: "\u2ACF",
    csube: "\u2AD1",
    csup: "\u2AD0",
    csupe: "\u2AD2",
    ctdot: "\u22EF",
    cudarrl: "\u2938",
    cudarrr: "\u2935",
    cuepr: "\u22DE",
    cuesc: "\u22DF",
    cularr: "\u21B6",
    cularrp: "\u293D",
    Cup: "\u22D3",
    cup: "\u222A",
    cupbrcap: "\u2A48",
    CupCap: "\u224D",
    cupcap: "\u2A46",
    cupcup: "\u2A4A",
    cupdot: "\u228D",
    cupor: "\u2A45",
    cups: "\u222A\uFE00",
    curarr: "\u21B7",
    curarrm: "\u293C",
    curlyeqprec: "\u22DE",
    curlyeqsucc: "\u22DF",
    curlyvee: "\u22CE",
    curlywedge: "\u22CF",
    curren: "\xA4",
    curvearrowleft: "\u21B6",
    curvearrowright: "\u21B7",
    cuvee: "\u22CE",
    cuwed: "\u22CF",
    cwconint: "\u2232",
    cwint: "\u2231",
    cylcty: "\u232D",
    Dagger: "\u2021",
    dagger: "\u2020",
    daleth: "\u2138",
    Darr: "\u21A1",
    dArr: "\u21D3",
    darr: "\u2193",
    dash: "\u2010",
    Dashv: "\u2AE4",
    dashv: "\u22A3",
    dbkarow: "\u290F",
    dblac: "\u02DD",
    Dcaron: "\u010E",
    dcaron: "\u010F",
    Dcy: "\u0414",
    dcy: "\u0434",
    DD: "\u2145",
    dd: "\u2146",
    ddagger: "\u2021",
    ddarr: "\u21CA",
    DDotrahd: "\u2911",
    ddotseq: "\u2A77",
    deg: "\xB0",
    Del: "\u2207",
    Delta: "\u0394",
    delta: "\u03B4",
    demptyv: "\u29B1",
    dfisht: "\u297F",
    Dfr: "\u{1D507}",
    dfr: "\u{1D521}",
    dHar: "\u2965",
    dharl: "\u21C3",
    dharr: "\u21C2",
    DiacriticalAcute: "\xB4",
    DiacriticalDot: "\u02D9",
    DiacriticalDoubleAcute: "\u02DD",
    DiacriticalGrave: "`",
    DiacriticalTilde: "\u02DC",
    diam: "\u22C4",
    Diamond: "\u22C4",
    diamond: "\u22C4",
    diamondsuit: "\u2666",
    diams: "\u2666",
    die: "\xA8",
    DifferentialD: "\u2146",
    digamma: "\u03DD",
    disin: "\u22F2",
    div: "\xF7",
    divide: "\xF7",
    divideontimes: "\u22C7",
    divonx: "\u22C7",
    DJcy: "\u0402",
    djcy: "\u0452",
    dlcorn: "\u231E",
    dlcrop: "\u230D",
    dollar: "$",
    Dopf: "\u{1D53B}",
    dopf: "\u{1D555}",
    Dot: "\xA8",
    dot: "\u02D9",
    DotDot: "\u20DC",
    doteq: "\u2250",
    doteqdot: "\u2251",
    DotEqual: "\u2250",
    dotminus: "\u2238",
    dotplus: "\u2214",
    dotsquare: "\u22A1",
    doublebarwedge: "\u2306",
    DoubleContourIntegral: "\u222F",
    DoubleDot: "\xA8",
    DoubleDownArrow: "\u21D3",
    DoubleLeftArrow: "\u21D0",
    DoubleLeftRightArrow: "\u21D4",
    DoubleLeftTee: "\u2AE4",
    DoubleLongLeftArrow: "\u27F8",
    DoubleLongLeftRightArrow: "\u27FA",
    DoubleLongRightArrow: "\u27F9",
    DoubleRightArrow: "\u21D2",
    DoubleRightTee: "\u22A8",
    DoubleUpArrow: "\u21D1",
    DoubleUpDownArrow: "\u21D5",
    DoubleVerticalBar: "\u2225",
    DownArrow: "\u2193",
    Downarrow: "\u21D3",
    downarrow: "\u2193",
    DownArrowBar: "\u2913",
    DownArrowUpArrow: "\u21F5",
    DownBreve: "\u0311",
    downdownarrows: "\u21CA",
    downharpoonleft: "\u21C3",
    downharpoonright: "\u21C2",
    DownLeftRightVector: "\u2950",
    DownLeftTeeVector: "\u295E",
    DownLeftVector: "\u21BD",
    DownLeftVectorBar: "\u2956",
    DownRightTeeVector: "\u295F",
    DownRightVector: "\u21C1",
    DownRightVectorBar: "\u2957",
    DownTee: "\u22A4",
    DownTeeArrow: "\u21A7",
    drbkarow: "\u2910",
    drcorn: "\u231F",
    drcrop: "\u230C",
    Dscr: "\u{1D49F}",
    dscr: "\u{1D4B9}",
    DScy: "\u0405",
    dscy: "\u0455",
    dsol: "\u29F6",
    Dstrok: "\u0110",
    dstrok: "\u0111",
    dtdot: "\u22F1",
    dtri: "\u25BF",
    dtrif: "\u25BE",
    duarr: "\u21F5",
    duhar: "\u296F",
    dwangle: "\u29A6",
    DZcy: "\u040F",
    dzcy: "\u045F",
    dzigrarr: "\u27FF",
    Eacute: "\xC9",
    eacute: "\xE9",
    easter: "\u2A6E",
    Ecaron: "\u011A",
    ecaron: "\u011B",
    ecir: "\u2256",
    Ecirc: "\xCA",
    ecirc: "\xEA",
    ecolon: "\u2255",
    Ecy: "\u042D",
    ecy: "\u044D",
    eDDot: "\u2A77",
    Edot: "\u0116",
    eDot: "\u2251",
    edot: "\u0117",
    ee: "\u2147",
    efDot: "\u2252",
    Efr: "\u{1D508}",
    efr: "\u{1D522}",
    eg: "\u2A9A",
    Egrave: "\xC8",
    egrave: "\xE8",
    egs: "\u2A96",
    egsdot: "\u2A98",
    el: "\u2A99",
    Element: "\u2208",
    elinters: "\u23E7",
    ell: "\u2113",
    els: "\u2A95",
    elsdot: "\u2A97",
    Emacr: "\u0112",
    emacr: "\u0113",
    empty: "\u2205",
    emptyset: "\u2205",
    EmptySmallSquare: "\u25FB",
    emptyv: "\u2205",
    EmptyVerySmallSquare: "\u25AB",
    emsp: "\u2003",
    emsp13: "\u2004",
    emsp14: "\u2005",
    ENG: "\u014A",
    eng: "\u014B",
    ensp: "\u2002",
    Eogon: "\u0118",
    eogon: "\u0119",
    Eopf: "\u{1D53C}",
    eopf: "\u{1D556}",
    epar: "\u22D5",
    eparsl: "\u29E3",
    eplus: "\u2A71",
    epsi: "\u03B5",
    Epsilon: "\u0395",
    epsilon: "\u03B5",
    epsiv: "\u03F5",
    eqcirc: "\u2256",
    eqcolon: "\u2255",
    eqsim: "\u2242",
    eqslantgtr: "\u2A96",
    eqslantless: "\u2A95",
    Equal: "\u2A75",
    equals: "=",
    EqualTilde: "\u2242",
    equest: "\u225F",
    Equilibrium: "\u21CC",
    equiv: "\u2261",
    equivDD: "\u2A78",
    eqvparsl: "\u29E5",
    erarr: "\u2971",
    erDot: "\u2253",
    Escr: "\u2130",
    escr: "\u212F",
    esdot: "\u2250",
    Esim: "\u2A73",
    esim: "\u2242",
    Eta: "\u0397",
    eta: "\u03B7",
    ETH: "\xD0",
    eth: "\xF0",
    Euml: "\xCB",
    euml: "\xEB",
    euro: "\u20AC",
    excl: "!",
    exist: "\u2203",
    Exists: "\u2203",
    expectation: "\u2130",
    ExponentialE: "\u2147",
    exponentiale: "\u2147",
    fallingdotseq: "\u2252",
    Fcy: "\u0424",
    fcy: "\u0444",
    female: "\u2640",
    ffilig: "\uFB03",
    fflig: "\uFB00",
    ffllig: "\uFB04",
    Ffr: "\u{1D509}",
    ffr: "\u{1D523}",
    filig: "\uFB01",
    FilledSmallSquare: "\u25FC",
    FilledVerySmallSquare: "\u25AA",
    fjlig: "fj",
    flat: "\u266D",
    fllig: "\uFB02",
    fltns: "\u25B1",
    fnof: "\u0192",
    Fopf: "\u{1D53D}",
    fopf: "\u{1D557}",
    ForAll: "\u2200",
    forall: "\u2200",
    fork: "\u22D4",
    forkv: "\u2AD9",
    Fouriertrf: "\u2131",
    fpartint: "\u2A0D",
    frac12: "\xBD",
    frac13: "\u2153",
    frac14: "\xBC",
    frac15: "\u2155",
    frac16: "\u2159",
    frac18: "\u215B",
    frac23: "\u2154",
    frac25: "\u2156",
    frac34: "\xBE",
    frac35: "\u2157",
    frac38: "\u215C",
    frac45: "\u2158",
    frac56: "\u215A",
    frac58: "\u215D",
    frac78: "\u215E",
    frasl: "\u2044",
    frown: "\u2322",
    Fscr: "\u2131",
    fscr: "\u{1D4BB}",
    gacute: "\u01F5",
    Gamma: "\u0393",
    gamma: "\u03B3",
    Gammad: "\u03DC",
    gammad: "\u03DD",
    gap: "\u2A86",
    Gbreve: "\u011E",
    gbreve: "\u011F",
    Gcedil: "\u0122",
    Gcirc: "\u011C",
    gcirc: "\u011D",
    Gcy: "\u0413",
    gcy: "\u0433",
    Gdot: "\u0120",
    gdot: "\u0121",
    gE: "\u2267",
    ge: "\u2265",
    gEl: "\u2A8C",
    gel: "\u22DB",
    geq: "\u2265",
    geqq: "\u2267",
    geqslant: "\u2A7E",
    ges: "\u2A7E",
    gescc: "\u2AA9",
    gesdot: "\u2A80",
    gesdoto: "\u2A82",
    gesdotol: "\u2A84",
    gesl: "\u22DB\uFE00",
    gesles: "\u2A94",
    Gfr: "\u{1D50A}",
    gfr: "\u{1D524}",
    Gg: "\u22D9",
    gg: "\u226B",
    ggg: "\u22D9",
    gimel: "\u2137",
    GJcy: "\u0403",
    gjcy: "\u0453",
    gl: "\u2277",
    gla: "\u2AA5",
    glE: "\u2A92",
    glj: "\u2AA4",
    gnap: "\u2A8A",
    gnapprox: "\u2A8A",
    gnE: "\u2269",
    gne: "\u2A88",
    gneq: "\u2A88",
    gneqq: "\u2269",
    gnsim: "\u22E7",
    Gopf: "\u{1D53E}",
    gopf: "\u{1D558}",
    grave: "`",
    GreaterEqual: "\u2265",
    GreaterEqualLess: "\u22DB",
    GreaterFullEqual: "\u2267",
    GreaterGreater: "\u2AA2",
    GreaterLess: "\u2277",
    GreaterSlantEqual: "\u2A7E",
    GreaterTilde: "\u2273",
    Gscr: "\u{1D4A2}",
    gscr: "\u210A",
    gsim: "\u2273",
    gsime: "\u2A8E",
    gsiml: "\u2A90",
    GT: ">",
    Gt: "\u226B",
    gt: ">",
    gtcc: "\u2AA7",
    gtcir: "\u2A7A",
    gtdot: "\u22D7",
    gtlPar: "\u2995",
    gtquest: "\u2A7C",
    gtrapprox: "\u2A86",
    gtrarr: "\u2978",
    gtrdot: "\u22D7",
    gtreqless: "\u22DB",
    gtreqqless: "\u2A8C",
    gtrless: "\u2277",
    gtrsim: "\u2273",
    gvertneqq: "\u2269\uFE00",
    gvnE: "\u2269\uFE00",
    Hacek: "\u02C7",
    hairsp: "\u200A",
    half: "\xBD",
    hamilt: "\u210B",
    HARDcy: "\u042A",
    hardcy: "\u044A",
    hArr: "\u21D4",
    harr: "\u2194",
    harrcir: "\u2948",
    harrw: "\u21AD",
    Hat: "^",
    hbar: "\u210F",
    Hcirc: "\u0124",
    hcirc: "\u0125",
    hearts: "\u2665",
    heartsuit: "\u2665",
    hellip: "\u2026",
    hercon: "\u22B9",
    Hfr: "\u210C",
    hfr: "\u{1D525}",
    HilbertSpace: "\u210B",
    hksearow: "\u2925",
    hkswarow: "\u2926",
    hoarr: "\u21FF",
    homtht: "\u223B",
    hookleftarrow: "\u21A9",
    hookrightarrow: "\u21AA",
    Hopf: "\u210D",
    hopf: "\u{1D559}",
    horbar: "\u2015",
    HorizontalLine: "\u2500",
    Hscr: "\u210B",
    hscr: "\u{1D4BD}",
    hslash: "\u210F",
    Hstrok: "\u0126",
    hstrok: "\u0127",
    HumpDownHump: "\u224E",
    HumpEqual: "\u224F",
    hybull: "\u2043",
    hyphen: "\u2010",
    Iacute: "\xCD",
    iacute: "\xED",
    ic: "\u2063",
    Icirc: "\xCE",
    icirc: "\xEE",
    Icy: "\u0418",
    icy: "\u0438",
    Idot: "\u0130",
    IEcy: "\u0415",
    iecy: "\u0435",
    iexcl: "\xA1",
    iff: "\u21D4",
    Ifr: "\u2111",
    ifr: "\u{1D526}",
    Igrave: "\xCC",
    igrave: "\xEC",
    ii: "\u2148",
    iiiint: "\u2A0C",
    iiint: "\u222D",
    iinfin: "\u29DC",
    iiota: "\u2129",
    IJlig: "\u0132",
    ijlig: "\u0133",
    Im: "\u2111",
    Imacr: "\u012A",
    imacr: "\u012B",
    image: "\u2111",
    ImaginaryI: "\u2148",
    imagline: "\u2110",
    imagpart: "\u2111",
    imath: "\u0131",
    imof: "\u22B7",
    imped: "\u01B5",
    Implies: "\u21D2",
    in: "\u2208",
    incare: "\u2105",
    infin: "\u221E",
    infintie: "\u29DD",
    inodot: "\u0131",
    Int: "\u222C",
    int: "\u222B",
    intcal: "\u22BA",
    integers: "\u2124",
    Integral: "\u222B",
    intercal: "\u22BA",
    Intersection: "\u22C2",
    intlarhk: "\u2A17",
    intprod: "\u2A3C",
    InvisibleComma: "\u2063",
    InvisibleTimes: "\u2062",
    IOcy: "\u0401",
    iocy: "\u0451",
    Iogon: "\u012E",
    iogon: "\u012F",
    Iopf: "\u{1D540}",
    iopf: "\u{1D55A}",
    Iota: "\u0399",
    iota: "\u03B9",
    iprod: "\u2A3C",
    iquest: "\xBF",
    Iscr: "\u2110",
    iscr: "\u{1D4BE}",
    isin: "\u2208",
    isindot: "\u22F5",
    isinE: "\u22F9",
    isins: "\u22F4",
    isinsv: "\u22F3",
    isinv: "\u2208",
    it: "\u2062",
    Itilde: "\u0128",
    itilde: "\u0129",
    Iukcy: "\u0406",
    iukcy: "\u0456",
    Iuml: "\xCF",
    iuml: "\xEF",
    Jcirc: "\u0134",
    jcirc: "\u0135",
    Jcy: "\u0419",
    jcy: "\u0439",
    Jfr: "\u{1D50D}",
    jfr: "\u{1D527}",
    jmath: "\u0237",
    Jopf: "\u{1D541}",
    jopf: "\u{1D55B}",
    Jscr: "\u{1D4A5}",
    jscr: "\u{1D4BF}",
    Jsercy: "\u0408",
    jsercy: "\u0458",
    Jukcy: "\u0404",
    jukcy: "\u0454",
    Kappa: "\u039A",
    kappa: "\u03BA",
    kappav: "\u03F0",
    Kcedil: "\u0136",
    kcedil: "\u0137",
    Kcy: "\u041A",
    kcy: "\u043A",
    Kfr: "\u{1D50E}",
    kfr: "\u{1D528}",
    kgreen: "\u0138",
    KHcy: "\u0425",
    khcy: "\u0445",
    KJcy: "\u040C",
    kjcy: "\u045C",
    Kopf: "\u{1D542}",
    kopf: "\u{1D55C}",
    Kscr: "\u{1D4A6}",
    kscr: "\u{1D4C0}",
    lAarr: "\u21DA",
    Lacute: "\u0139",
    lacute: "\u013A",
    laemptyv: "\u29B4",
    lagran: "\u2112",
    Lambda: "\u039B",
    lambda: "\u03BB",
    Lang: "\u27EA",
    lang: "\u27E8",
    langd: "\u2991",
    langle: "\u27E8",
    lap: "\u2A85",
    Laplacetrf: "\u2112",
    laquo: "\xAB",
    Larr: "\u219E",
    lArr: "\u21D0",
    larr: "\u2190",
    larrb: "\u21E4",
    larrbfs: "\u291F",
    larrfs: "\u291D",
    larrhk: "\u21A9",
    larrlp: "\u21AB",
    larrpl: "\u2939",
    larrsim: "\u2973",
    larrtl: "\u21A2",
    lat: "\u2AAB",
    lAtail: "\u291B",
    latail: "\u2919",
    late: "\u2AAD",
    lates: "\u2AAD\uFE00",
    lBarr: "\u290E",
    lbarr: "\u290C",
    lbbrk: "\u2772",
    lbrace: "{",
    lbrack: "[",
    lbrke: "\u298B",
    lbrksld: "\u298F",
    lbrkslu: "\u298D",
    Lcaron: "\u013D",
    lcaron: "\u013E",
    Lcedil: "\u013B",
    lcedil: "\u013C",
    lceil: "\u2308",
    lcub: "{",
    Lcy: "\u041B",
    lcy: "\u043B",
    ldca: "\u2936",
    ldquo: "\u201C",
    ldquor: "\u201E",
    ldrdhar: "\u2967",
    ldrushar: "\u294B",
    ldsh: "\u21B2",
    lE: "\u2266",
    le: "\u2264",
    LeftAngleBracket: "\u27E8",
    LeftArrow: "\u2190",
    Leftarrow: "\u21D0",
    leftarrow: "\u2190",
    LeftArrowBar: "\u21E4",
    LeftArrowRightArrow: "\u21C6",
    leftarrowtail: "\u21A2",
    LeftCeiling: "\u2308",
    LeftDoubleBracket: "\u27E6",
    LeftDownTeeVector: "\u2961",
    LeftDownVector: "\u21C3",
    LeftDownVectorBar: "\u2959",
    LeftFloor: "\u230A",
    leftharpoondown: "\u21BD",
    leftharpoonup: "\u21BC",
    leftleftarrows: "\u21C7",
    LeftRightArrow: "\u2194",
    Leftrightarrow: "\u21D4",
    leftrightarrow: "\u2194",
    leftrightarrows: "\u21C6",
    leftrightharpoons: "\u21CB",
    leftrightsquigarrow: "\u21AD",
    LeftRightVector: "\u294E",
    LeftTee: "\u22A3",
    LeftTeeArrow: "\u21A4",
    LeftTeeVector: "\u295A",
    leftthreetimes: "\u22CB",
    LeftTriangle: "\u22B2",
    LeftTriangleBar: "\u29CF",
    LeftTriangleEqual: "\u22B4",
    LeftUpDownVector: "\u2951",
    LeftUpTeeVector: "\u2960",
    LeftUpVector: "\u21BF",
    LeftUpVectorBar: "\u2958",
    LeftVector: "\u21BC",
    LeftVectorBar: "\u2952",
    lEg: "\u2A8B",
    leg: "\u22DA",
    leq: "\u2264",
    leqq: "\u2266",
    leqslant: "\u2A7D",
    les: "\u2A7D",
    lescc: "\u2AA8",
    lesdot: "\u2A7F",
    lesdoto: "\u2A81",
    lesdotor: "\u2A83",
    lesg: "\u22DA\uFE00",
    lesges: "\u2A93",
    lessapprox: "\u2A85",
    lessdot: "\u22D6",
    lesseqgtr: "\u22DA",
    lesseqqgtr: "\u2A8B",
    LessEqualGreater: "\u22DA",
    LessFullEqual: "\u2266",
    LessGreater: "\u2276",
    lessgtr: "\u2276",
    LessLess: "\u2AA1",
    lesssim: "\u2272",
    LessSlantEqual: "\u2A7D",
    LessTilde: "\u2272",
    lfisht: "\u297C",
    lfloor: "\u230A",
    Lfr: "\u{1D50F}",
    lfr: "\u{1D529}",
    lg: "\u2276",
    lgE: "\u2A91",
    lHar: "\u2962",
    lhard: "\u21BD",
    lharu: "\u21BC",
    lharul: "\u296A",
    lhblk: "\u2584",
    LJcy: "\u0409",
    ljcy: "\u0459",
    Ll: "\u22D8",
    ll: "\u226A",
    llarr: "\u21C7",
    llcorner: "\u231E",
    Lleftarrow: "\u21DA",
    llhard: "\u296B",
    lltri: "\u25FA",
    Lmidot: "\u013F",
    lmidot: "\u0140",
    lmoust: "\u23B0",
    lmoustache: "\u23B0",
    lnap: "\u2A89",
    lnapprox: "\u2A89",
    lnE: "\u2268",
    lne: "\u2A87",
    lneq: "\u2A87",
    lneqq: "\u2268",
    lnsim: "\u22E6",
    loang: "\u27EC",
    loarr: "\u21FD",
    lobrk: "\u27E6",
    LongLeftArrow: "\u27F5",
    Longleftarrow: "\u27F8",
    longleftarrow: "\u27F5",
    LongLeftRightArrow: "\u27F7",
    Longleftrightarrow: "\u27FA",
    longleftrightarrow: "\u27F7",
    longmapsto: "\u27FC",
    LongRightArrow: "\u27F6",
    Longrightarrow: "\u27F9",
    longrightarrow: "\u27F6",
    looparrowleft: "\u21AB",
    looparrowright: "\u21AC",
    lopar: "\u2985",
    Lopf: "\u{1D543}",
    lopf: "\u{1D55D}",
    loplus: "\u2A2D",
    lotimes: "\u2A34",
    lowast: "\u2217",
    lowbar: "_",
    LowerLeftArrow: "\u2199",
    LowerRightArrow: "\u2198",
    loz: "\u25CA",
    lozenge: "\u25CA",
    lozf: "\u29EB",
    lpar: "(",
    lparlt: "\u2993",
    lrarr: "\u21C6",
    lrcorner: "\u231F",
    lrhar: "\u21CB",
    lrhard: "\u296D",
    lrm: "\u200E",
    lrtri: "\u22BF",
    lsaquo: "\u2039",
    Lscr: "\u2112",
    lscr: "\u{1D4C1}",
    Lsh: "\u21B0",
    lsh: "\u21B0",
    lsim: "\u2272",
    lsime: "\u2A8D",
    lsimg: "\u2A8F",
    lsqb: "[",
    lsquo: "\u2018",
    lsquor: "\u201A",
    Lstrok: "\u0141",
    lstrok: "\u0142",
    LT: "<",
    Lt: "\u226A",
    lt: "<",
    ltcc: "\u2AA6",
    ltcir: "\u2A79",
    ltdot: "\u22D6",
    lthree: "\u22CB",
    ltimes: "\u22C9",
    ltlarr: "\u2976",
    ltquest: "\u2A7B",
    ltri: "\u25C3",
    ltrie: "\u22B4",
    ltrif: "\u25C2",
    ltrPar: "\u2996",
    lurdshar: "\u294A",
    luruhar: "\u2966",
    lvertneqq: "\u2268\uFE00",
    lvnE: "\u2268\uFE00",
    macr: "\xAF",
    male: "\u2642",
    malt: "\u2720",
    maltese: "\u2720",
    Map: "\u2905",
    map: "\u21A6",
    mapsto: "\u21A6",
    mapstodown: "\u21A7",
    mapstoleft: "\u21A4",
    mapstoup: "\u21A5",
    marker: "\u25AE",
    mcomma: "\u2A29",
    Mcy: "\u041C",
    mcy: "\u043C",
    mdash: "\u2014",
    mDDot: "\u223A",
    measuredangle: "\u2221",
    MediumSpace: "\u205F",
    Mellintrf: "\u2133",
    Mfr: "\u{1D510}",
    mfr: "\u{1D52A}",
    mho: "\u2127",
    micro: "\xB5",
    mid: "\u2223",
    midast: "*",
    midcir: "\u2AF0",
    middot: "\xB7",
    minus: "\u2212",
    minusb: "\u229F",
    minusd: "\u2238",
    minusdu: "\u2A2A",
    MinusPlus: "\u2213",
    mlcp: "\u2ADB",
    mldr: "\u2026",
    mnplus: "\u2213",
    models: "\u22A7",
    Mopf: "\u{1D544}",
    mopf: "\u{1D55E}",
    mp: "\u2213",
    Mscr: "\u2133",
    mscr: "\u{1D4C2}",
    mstpos: "\u223E",
    Mu: "\u039C",
    mu: "\u03BC",
    multimap: "\u22B8",
    mumap: "\u22B8",
    nabla: "\u2207",
    Nacute: "\u0143",
    nacute: "\u0144",
    nang: "\u2220\u20D2",
    nap: "\u2249",
    napE: "\u2A70\u0338",
    napid: "\u224B\u0338",
    napos: "\u0149",
    napprox: "\u2249",
    natur: "\u266E",
    natural: "\u266E",
    naturals: "\u2115",
    nbsp: "\xA0",
    nbump: "\u224E\u0338",
    nbumpe: "\u224F\u0338",
    ncap: "\u2A43",
    Ncaron: "\u0147",
    ncaron: "\u0148",
    Ncedil: "\u0145",
    ncedil: "\u0146",
    ncong: "\u2247",
    ncongdot: "\u2A6D\u0338",
    ncup: "\u2A42",
    Ncy: "\u041D",
    ncy: "\u043D",
    ndash: "\u2013",
    ne: "\u2260",
    nearhk: "\u2924",
    neArr: "\u21D7",
    nearr: "\u2197",
    nearrow: "\u2197",
    nedot: "\u2250\u0338",
    NegativeMediumSpace: "\u200B",
    NegativeThickSpace: "\u200B",
    NegativeThinSpace: "\u200B",
    NegativeVeryThinSpace: "\u200B",
    nequiv: "\u2262",
    nesear: "\u2928",
    nesim: "\u2242\u0338",
    NestedGreaterGreater: "\u226B",
    NestedLessLess: "\u226A",
    NewLine: "\n",
    nexist: "\u2204",
    nexists: "\u2204",
    Nfr: "\u{1D511}",
    nfr: "\u{1D52B}",
    ngE: "\u2267\u0338",
    nge: "\u2271",
    ngeq: "\u2271",
    ngeqq: "\u2267\u0338",
    ngeqslant: "\u2A7E\u0338",
    nges: "\u2A7E\u0338",
    nGg: "\u22D9\u0338",
    ngsim: "\u2275",
    nGt: "\u226B\u20D2",
    ngt: "\u226F",
    ngtr: "\u226F",
    nGtv: "\u226B\u0338",
    nhArr: "\u21CE",
    nharr: "\u21AE",
    nhpar: "\u2AF2",
    ni: "\u220B",
    nis: "\u22FC",
    nisd: "\u22FA",
    niv: "\u220B",
    NJcy: "\u040A",
    njcy: "\u045A",
    nlArr: "\u21CD",
    nlarr: "\u219A",
    nldr: "\u2025",
    nlE: "\u2266\u0338",
    nle: "\u2270",
    nLeftarrow: "\u21CD",
    nleftarrow: "\u219A",
    nLeftrightarrow: "\u21CE",
    nleftrightarrow: "\u21AE",
    nleq: "\u2270",
    nleqq: "\u2266\u0338",
    nleqslant: "\u2A7D\u0338",
    nles: "\u2A7D\u0338",
    nless: "\u226E",
    nLl: "\u22D8\u0338",
    nlsim: "\u2274",
    nLt: "\u226A\u20D2",
    nlt: "\u226E",
    nltri: "\u22EA",
    nltrie: "\u22EC",
    nLtv: "\u226A\u0338",
    nmid: "\u2224",
    NoBreak: "\u2060",
    NonBreakingSpace: "\xA0",
    Nopf: "\u2115",
    nopf: "\u{1D55F}",
    Not: "\u2AEC",
    not: "\xAC",
    NotCongruent: "\u2262",
    NotCupCap: "\u226D",
    NotDoubleVerticalBar: "\u2226",
    NotElement: "\u2209",
    NotEqual: "\u2260",
    NotEqualTilde: "\u2242\u0338",
    NotExists: "\u2204",
    NotGreater: "\u226F",
    NotGreaterEqual: "\u2271",
    NotGreaterFullEqual: "\u2267\u0338",
    NotGreaterGreater: "\u226B\u0338",
    NotGreaterLess: "\u2279",
    NotGreaterSlantEqual: "\u2A7E\u0338",
    NotGreaterTilde: "\u2275",
    NotHumpDownHump: "\u224E\u0338",
    NotHumpEqual: "\u224F\u0338",
    notin: "\u2209",
    notindot: "\u22F5\u0338",
    notinE: "\u22F9\u0338",
    notinva: "\u2209",
    notinvb: "\u22F7",
    notinvc: "\u22F6",
    NotLeftTriangle: "\u22EA",
    NotLeftTriangleBar: "\u29CF\u0338",
    NotLeftTriangleEqual: "\u22EC",
    NotLess: "\u226E",
    NotLessEqual: "\u2270",
    NotLessGreater: "\u2278",
    NotLessLess: "\u226A\u0338",
    NotLessSlantEqual: "\u2A7D\u0338",
    NotLessTilde: "\u2274",
    NotNestedGreaterGreater: "\u2AA2\u0338",
    NotNestedLessLess: "\u2AA1\u0338",
    notni: "\u220C",
    notniva: "\u220C",
    notnivb: "\u22FE",
    notnivc: "\u22FD",
    NotPrecedes: "\u2280",
    NotPrecedesEqual: "\u2AAF\u0338",
    NotPrecedesSlantEqual: "\u22E0",
    NotReverseElement: "\u220C",
    NotRightTriangle: "\u22EB",
    NotRightTriangleBar: "\u29D0\u0338",
    NotRightTriangleEqual: "\u22ED",
    NotSquareSubset: "\u228F\u0338",
    NotSquareSubsetEqual: "\u22E2",
    NotSquareSuperset: "\u2290\u0338",
    NotSquareSupersetEqual: "\u22E3",
    NotSubset: "\u2282\u20D2",
    NotSubsetEqual: "\u2288",
    NotSucceeds: "\u2281",
    NotSucceedsEqual: "\u2AB0\u0338",
    NotSucceedsSlantEqual: "\u22E1",
    NotSucceedsTilde: "\u227F\u0338",
    NotSuperset: "\u2283\u20D2",
    NotSupersetEqual: "\u2289",
    NotTilde: "\u2241",
    NotTildeEqual: "\u2244",
    NotTildeFullEqual: "\u2247",
    NotTildeTilde: "\u2249",
    NotVerticalBar: "\u2224",
    npar: "\u2226",
    nparallel: "\u2226",
    nparsl: "\u2AFD\u20E5",
    npart: "\u2202\u0338",
    npolint: "\u2A14",
    npr: "\u2280",
    nprcue: "\u22E0",
    npre: "\u2AAF\u0338",
    nprec: "\u2280",
    npreceq: "\u2AAF\u0338",
    nrArr: "\u21CF",
    nrarr: "\u219B",
    nrarrc: "\u2933\u0338",
    nrarrw: "\u219D\u0338",
    nRightarrow: "\u21CF",
    nrightarrow: "\u219B",
    nrtri: "\u22EB",
    nrtrie: "\u22ED",
    nsc: "\u2281",
    nsccue: "\u22E1",
    nsce: "\u2AB0\u0338",
    Nscr: "\u{1D4A9}",
    nscr: "\u{1D4C3}",
    nshortmid: "\u2224",
    nshortparallel: "\u2226",
    nsim: "\u2241",
    nsime: "\u2244",
    nsimeq: "\u2244",
    nsmid: "\u2224",
    nspar: "\u2226",
    nsqsube: "\u22E2",
    nsqsupe: "\u22E3",
    nsub: "\u2284",
    nsubE: "\u2AC5\u0338",
    nsube: "\u2288",
    nsubset: "\u2282\u20D2",
    nsubseteq: "\u2288",
    nsubseteqq: "\u2AC5\u0338",
    nsucc: "\u2281",
    nsucceq: "\u2AB0\u0338",
    nsup: "\u2285",
    nsupE: "\u2AC6\u0338",
    nsupe: "\u2289",
    nsupset: "\u2283\u20D2",
    nsupseteq: "\u2289",
    nsupseteqq: "\u2AC6\u0338",
    ntgl: "\u2279",
    Ntilde: "\xD1",
    ntilde: "\xF1",
    ntlg: "\u2278",
    ntriangleleft: "\u22EA",
    ntrianglelefteq: "\u22EC",
    ntriangleright: "\u22EB",
    ntrianglerighteq: "\u22ED",
    Nu: "\u039D",
    nu: "\u03BD",
    num: "#",
    numero: "\u2116",
    numsp: "\u2007",
    nvap: "\u224D\u20D2",
    nVDash: "\u22AF",
    nVdash: "\u22AE",
    nvDash: "\u22AD",
    nvdash: "\u22AC",
    nvge: "\u2265\u20D2",
    nvgt: ">\u20D2",
    nvHarr: "\u2904",
    nvinfin: "\u29DE",
    nvlArr: "\u2902",
    nvle: "\u2264\u20D2",
    nvlt: "<\u20D2",
    nvltrie: "\u22B4\u20D2",
    nvrArr: "\u2903",
    nvrtrie: "\u22B5\u20D2",
    nvsim: "\u223C\u20D2",
    nwarhk: "\u2923",
    nwArr: "\u21D6",
    nwarr: "\u2196",
    nwarrow: "\u2196",
    nwnear: "\u2927",
    Oacute: "\xD3",
    oacute: "\xF3",
    oast: "\u229B",
    ocir: "\u229A",
    Ocirc: "\xD4",
    ocirc: "\xF4",
    Ocy: "\u041E",
    ocy: "\u043E",
    odash: "\u229D",
    Odblac: "\u0150",
    odblac: "\u0151",
    odiv: "\u2A38",
    odot: "\u2299",
    odsold: "\u29BC",
    OElig: "\u0152",
    oelig: "\u0153",
    ofcir: "\u29BF",
    Ofr: "\u{1D512}",
    ofr: "\u{1D52C}",
    ogon: "\u02DB",
    Ograve: "\xD2",
    ograve: "\xF2",
    ogt: "\u29C1",
    ohbar: "\u29B5",
    ohm: "\u03A9",
    oint: "\u222E",
    olarr: "\u21BA",
    olcir: "\u29BE",
    olcross: "\u29BB",
    oline: "\u203E",
    olt: "\u29C0",
    Omacr: "\u014C",
    omacr: "\u014D",
    Omega: "\u03A9",
    omega: "\u03C9",
    Omicron: "\u039F",
    omicron: "\u03BF",
    omid: "\u29B6",
    ominus: "\u2296",
    Oopf: "\u{1D546}",
    oopf: "\u{1D560}",
    opar: "\u29B7",
    OpenCurlyDoubleQuote: "\u201C",
    OpenCurlyQuote: "\u2018",
    operp: "\u29B9",
    oplus: "\u2295",
    Or: "\u2A54",
    or: "\u2228",
    orarr: "\u21BB",
    ord: "\u2A5D",
    order: "\u2134",
    orderof: "\u2134",
    ordf: "\xAA",
    ordm: "\xBA",
    origof: "\u22B6",
    oror: "\u2A56",
    orslope: "\u2A57",
    orv: "\u2A5B",
    oS: "\u24C8",
    Oscr: "\u{1D4AA}",
    oscr: "\u2134",
    Oslash: "\xD8",
    oslash: "\xF8",
    osol: "\u2298",
    Otilde: "\xD5",
    otilde: "\xF5",
    Otimes: "\u2A37",
    otimes: "\u2297",
    otimesas: "\u2A36",
    Ouml: "\xD6",
    ouml: "\xF6",
    ovbar: "\u233D",
    OverBar: "\u203E",
    OverBrace: "\u23DE",
    OverBracket: "\u23B4",
    OverParenthesis: "\u23DC",
    par: "\u2225",
    para: "\xB6",
    parallel: "\u2225",
    parsim: "\u2AF3",
    parsl: "\u2AFD",
    part: "\u2202",
    PartialD: "\u2202",
    Pcy: "\u041F",
    pcy: "\u043F",
    percnt: "%",
    period: ".",
    permil: "\u2030",
    perp: "\u22A5",
    pertenk: "\u2031",
    Pfr: "\u{1D513}",
    pfr: "\u{1D52D}",
    Phi: "\u03A6",
    phi: "\u03C6",
    phiv: "\u03D5",
    phmmat: "\u2133",
    phone: "\u260E",
    Pi: "\u03A0",
    pi: "\u03C0",
    pitchfork: "\u22D4",
    piv: "\u03D6",
    planck: "\u210F",
    planckh: "\u210E",
    plankv: "\u210F",
    plus: "+",
    plusacir: "\u2A23",
    plusb: "\u229E",
    pluscir: "\u2A22",
    plusdo: "\u2214",
    plusdu: "\u2A25",
    pluse: "\u2A72",
    PlusMinus: "\xB1",
    plusmn: "\xB1",
    plussim: "\u2A26",
    plustwo: "\u2A27",
    pm: "\xB1",
    Poincareplane: "\u210C",
    pointint: "\u2A15",
    Popf: "\u2119",
    popf: "\u{1D561}",
    pound: "\xA3",
    Pr: "\u2ABB",
    pr: "\u227A",
    prap: "\u2AB7",
    prcue: "\u227C",
    prE: "\u2AB3",
    pre: "\u2AAF",
    prec: "\u227A",
    precapprox: "\u2AB7",
    preccurlyeq: "\u227C",
    Precedes: "\u227A",
    PrecedesEqual: "\u2AAF",
    PrecedesSlantEqual: "\u227C",
    PrecedesTilde: "\u227E",
    preceq: "\u2AAF",
    precnapprox: "\u2AB9",
    precneqq: "\u2AB5",
    precnsim: "\u22E8",
    precsim: "\u227E",
    Prime: "\u2033",
    prime: "\u2032",
    primes: "\u2119",
    prnap: "\u2AB9",
    prnE: "\u2AB5",
    prnsim: "\u22E8",
    prod: "\u220F",
    Product: "\u220F",
    profalar: "\u232E",
    profline: "\u2312",
    profsurf: "\u2313",
    prop: "\u221D",
    Proportion: "\u2237",
    Proportional: "\u221D",
    propto: "\u221D",
    prsim: "\u227E",
    prurel: "\u22B0",
    Pscr: "\u{1D4AB}",
    pscr: "\u{1D4C5}",
    Psi: "\u03A8",
    psi: "\u03C8",
    puncsp: "\u2008",
    Qfr: "\u{1D514}",
    qfr: "\u{1D52E}",
    qint: "\u2A0C",
    Qopf: "\u211A",
    qopf: "\u{1D562}",
    qprime: "\u2057",
    Qscr: "\u{1D4AC}",
    qscr: "\u{1D4C6}",
    quaternions: "\u210D",
    quatint: "\u2A16",
    quest: "?",
    questeq: "\u225F",
    QUOT: '"',
    quot: '"',
    rAarr: "\u21DB",
    race: "\u223D\u0331",
    Racute: "\u0154",
    racute: "\u0155",
    radic: "\u221A",
    raemptyv: "\u29B3",
    Rang: "\u27EB",
    rang: "\u27E9",
    rangd: "\u2992",
    range: "\u29A5",
    rangle: "\u27E9",
    raquo: "\xBB",
    Rarr: "\u21A0",
    rArr: "\u21D2",
    rarr: "\u2192",
    rarrap: "\u2975",
    rarrb: "\u21E5",
    rarrbfs: "\u2920",
    rarrc: "\u2933",
    rarrfs: "\u291E",
    rarrhk: "\u21AA",
    rarrlp: "\u21AC",
    rarrpl: "\u2945",
    rarrsim: "\u2974",
    Rarrtl: "\u2916",
    rarrtl: "\u21A3",
    rarrw: "\u219D",
    rAtail: "\u291C",
    ratail: "\u291A",
    ratio: "\u2236",
    rationals: "\u211A",
    RBarr: "\u2910",
    rBarr: "\u290F",
    rbarr: "\u290D",
    rbbrk: "\u2773",
    rbrace: "}",
    rbrack: "]",
    rbrke: "\u298C",
    rbrksld: "\u298E",
    rbrkslu: "\u2990",
    Rcaron: "\u0158",
    rcaron: "\u0159",
    Rcedil: "\u0156",
    rcedil: "\u0157",
    rceil: "\u2309",
    rcub: "}",
    Rcy: "\u0420",
    rcy: "\u0440",
    rdca: "\u2937",
    rdldhar: "\u2969",
    rdquo: "\u201D",
    rdquor: "\u201D",
    rdsh: "\u21B3",
    Re: "\u211C",
    real: "\u211C",
    realine: "\u211B",
    realpart: "\u211C",
    reals: "\u211D",
    rect: "\u25AD",
    REG: "\xAE",
    reg: "\xAE",
    ReverseElement: "\u220B",
    ReverseEquilibrium: "\u21CB",
    ReverseUpEquilibrium: "\u296F",
    rfisht: "\u297D",
    rfloor: "\u230B",
    Rfr: "\u211C",
    rfr: "\u{1D52F}",
    rHar: "\u2964",
    rhard: "\u21C1",
    rharu: "\u21C0",
    rharul: "\u296C",
    Rho: "\u03A1",
    rho: "\u03C1",
    rhov: "\u03F1",
    RightAngleBracket: "\u27E9",
    RightArrow: "\u2192",
    Rightarrow: "\u21D2",
    rightarrow: "\u2192",
    RightArrowBar: "\u21E5",
    RightArrowLeftArrow: "\u21C4",
    rightarrowtail: "\u21A3",
    RightCeiling: "\u2309",
    RightDoubleBracket: "\u27E7",
    RightDownTeeVector: "\u295D",
    RightDownVector: "\u21C2",
    RightDownVectorBar: "\u2955",
    RightFloor: "\u230B",
    rightharpoondown: "\u21C1",
    rightharpoonup: "\u21C0",
    rightleftarrows: "\u21C4",
    rightleftharpoons: "\u21CC",
    rightrightarrows: "\u21C9",
    rightsquigarrow: "\u219D",
    RightTee: "\u22A2",
    RightTeeArrow: "\u21A6",
    RightTeeVector: "\u295B",
    rightthreetimes: "\u22CC",
    RightTriangle: "\u22B3",
    RightTriangleBar: "\u29D0",
    RightTriangleEqual: "\u22B5",
    RightUpDownVector: "\u294F",
    RightUpTeeVector: "\u295C",
    RightUpVector: "\u21BE",
    RightUpVectorBar: "\u2954",
    RightVector: "\u21C0",
    RightVectorBar: "\u2953",
    ring: "\u02DA",
    risingdotseq: "\u2253",
    rlarr: "\u21C4",
    rlhar: "\u21CC",
    rlm: "\u200F",
    rmoust: "\u23B1",
    rmoustache: "\u23B1",
    rnmid: "\u2AEE",
    roang: "\u27ED",
    roarr: "\u21FE",
    robrk: "\u27E7",
    ropar: "\u2986",
    Ropf: "\u211D",
    ropf: "\u{1D563}",
    roplus: "\u2A2E",
    rotimes: "\u2A35",
    RoundImplies: "\u2970",
    rpar: ")",
    rpargt: "\u2994",
    rppolint: "\u2A12",
    rrarr: "\u21C9",
    Rrightarrow: "\u21DB",
    rsaquo: "\u203A",
    Rscr: "\u211B",
    rscr: "\u{1D4C7}",
    Rsh: "\u21B1",
    rsh: "\u21B1",
    rsqb: "]",
    rsquo: "\u2019",
    rsquor: "\u2019",
    rthree: "\u22CC",
    rtimes: "\u22CA",
    rtri: "\u25B9",
    rtrie: "\u22B5",
    rtrif: "\u25B8",
    rtriltri: "\u29CE",
    RuleDelayed: "\u29F4",
    ruluhar: "\u2968",
    rx: "\u211E",
    Sacute: "\u015A",
    sacute: "\u015B",
    sbquo: "\u201A",
    Sc: "\u2ABC",
    sc: "\u227B",
    scap: "\u2AB8",
    Scaron: "\u0160",
    scaron: "\u0161",
    sccue: "\u227D",
    scE: "\u2AB4",
    sce: "\u2AB0",
    Scedil: "\u015E",
    scedil: "\u015F",
    Scirc: "\u015C",
    scirc: "\u015D",
    scnap: "\u2ABA",
    scnE: "\u2AB6",
    scnsim: "\u22E9",
    scpolint: "\u2A13",
    scsim: "\u227F",
    Scy: "\u0421",
    scy: "\u0441",
    sdot: "\u22C5",
    sdotb: "\u22A1",
    sdote: "\u2A66",
    searhk: "\u2925",
    seArr: "\u21D8",
    searr: "\u2198",
    searrow: "\u2198",
    sect: "\xA7",
    semi: ";",
    seswar: "\u2929",
    setminus: "\u2216",
    setmn: "\u2216",
    sext: "\u2736",
    Sfr: "\u{1D516}",
    sfr: "\u{1D530}",
    sfrown: "\u2322",
    sharp: "\u266F",
    SHCHcy: "\u0429",
    shchcy: "\u0449",
    SHcy: "\u0428",
    shcy: "\u0448",
    ShortDownArrow: "\u2193",
    ShortLeftArrow: "\u2190",
    shortmid: "\u2223",
    shortparallel: "\u2225",
    ShortRightArrow: "\u2192",
    ShortUpArrow: "\u2191",
    shy: "\xAD",
    Sigma: "\u03A3",
    sigma: "\u03C3",
    sigmaf: "\u03C2",
    sigmav: "\u03C2",
    sim: "\u223C",
    simdot: "\u2A6A",
    sime: "\u2243",
    simeq: "\u2243",
    simg: "\u2A9E",
    simgE: "\u2AA0",
    siml: "\u2A9D",
    simlE: "\u2A9F",
    simne: "\u2246",
    simplus: "\u2A24",
    simrarr: "\u2972",
    slarr: "\u2190",
    SmallCircle: "\u2218",
    smallsetminus: "\u2216",
    smashp: "\u2A33",
    smeparsl: "\u29E4",
    smid: "\u2223",
    smile: "\u2323",
    smt: "\u2AAA",
    smte: "\u2AAC",
    smtes: "\u2AAC\uFE00",
    SOFTcy: "\u042C",
    softcy: "\u044C",
    sol: "/",
    solb: "\u29C4",
    solbar: "\u233F",
    Sopf: "\u{1D54A}",
    sopf: "\u{1D564}",
    spades: "\u2660",
    spadesuit: "\u2660",
    spar: "\u2225",
    sqcap: "\u2293",
    sqcaps: "\u2293\uFE00",
    sqcup: "\u2294",
    sqcups: "\u2294\uFE00",
    Sqrt: "\u221A",
    sqsub: "\u228F",
    sqsube: "\u2291",
    sqsubset: "\u228F",
    sqsubseteq: "\u2291",
    sqsup: "\u2290",
    sqsupe: "\u2292",
    sqsupset: "\u2290",
    sqsupseteq: "\u2292",
    squ: "\u25A1",
    Square: "\u25A1",
    square: "\u25A1",
    SquareIntersection: "\u2293",
    SquareSubset: "\u228F",
    SquareSubsetEqual: "\u2291",
    SquareSuperset: "\u2290",
    SquareSupersetEqual: "\u2292",
    SquareUnion: "\u2294",
    squarf: "\u25AA",
    squf: "\u25AA",
    srarr: "\u2192",
    Sscr: "\u{1D4AE}",
    sscr: "\u{1D4C8}",
    ssetmn: "\u2216",
    ssmile: "\u2323",
    sstarf: "\u22C6",
    Star: "\u22C6",
    star: "\u2606",
    starf: "\u2605",
    straightepsilon: "\u03F5",
    straightphi: "\u03D5",
    strns: "\xAF",
    Sub: "\u22D0",
    sub: "\u2282",
    subdot: "\u2ABD",
    subE: "\u2AC5",
    sube: "\u2286",
    subedot: "\u2AC3",
    submult: "\u2AC1",
    subnE: "\u2ACB",
    subne: "\u228A",
    subplus: "\u2ABF",
    subrarr: "\u2979",
    Subset: "\u22D0",
    subset: "\u2282",
    subseteq: "\u2286",
    subseteqq: "\u2AC5",
    SubsetEqual: "\u2286",
    subsetneq: "\u228A",
    subsetneqq: "\u2ACB",
    subsim: "\u2AC7",
    subsub: "\u2AD5",
    subsup: "\u2AD3",
    succ: "\u227B",
    succapprox: "\u2AB8",
    succcurlyeq: "\u227D",
    Succeeds: "\u227B",
    SucceedsEqual: "\u2AB0",
    SucceedsSlantEqual: "\u227D",
    SucceedsTilde: "\u227F",
    succeq: "\u2AB0",
    succnapprox: "\u2ABA",
    succneqq: "\u2AB6",
    succnsim: "\u22E9",
    succsim: "\u227F",
    SuchThat: "\u220B",
    Sum: "\u2211",
    sum: "\u2211",
    sung: "\u266A",
    Sup: "\u22D1",
    sup: "\u2283",
    sup1: "\xB9",
    sup2: "\xB2",
    sup3: "\xB3",
    supdot: "\u2ABE",
    supdsub: "\u2AD8",
    supE: "\u2AC6",
    supe: "\u2287",
    supedot: "\u2AC4",
    Superset: "\u2283",
    SupersetEqual: "\u2287",
    suphsol: "\u27C9",
    suphsub: "\u2AD7",
    suplarr: "\u297B",
    supmult: "\u2AC2",
    supnE: "\u2ACC",
    supne: "\u228B",
    supplus: "\u2AC0",
    Supset: "\u22D1",
    supset: "\u2283",
    supseteq: "\u2287",
    supseteqq: "\u2AC6",
    supsetneq: "\u228B",
    supsetneqq: "\u2ACC",
    supsim: "\u2AC8",
    supsub: "\u2AD4",
    supsup: "\u2AD6",
    swarhk: "\u2926",
    swArr: "\u21D9",
    swarr: "\u2199",
    swarrow: "\u2199",
    swnwar: "\u292A",
    szlig: "\xDF",
    Tab: "	",
    target: "\u2316",
    Tau: "\u03A4",
    tau: "\u03C4",
    tbrk: "\u23B4",
    Tcaron: "\u0164",
    tcaron: "\u0165",
    Tcedil: "\u0162",
    tcedil: "\u0163",
    Tcy: "\u0422",
    tcy: "\u0442",
    tdot: "\u20DB",
    telrec: "\u2315",
    Tfr: "\u{1D517}",
    tfr: "\u{1D531}",
    there4: "\u2234",
    Therefore: "\u2234",
    therefore: "\u2234",
    Theta: "\u0398",
    theta: "\u03B8",
    thetasym: "\u03D1",
    thetav: "\u03D1",
    thickapprox: "\u2248",
    thicksim: "\u223C",
    ThickSpace: "\u205F\u200A",
    thinsp: "\u2009",
    ThinSpace: "\u2009",
    thkap: "\u2248",
    thksim: "\u223C",
    THORN: "\xDE",
    thorn: "\xFE",
    Tilde: "\u223C",
    tilde: "\u02DC",
    TildeEqual: "\u2243",
    TildeFullEqual: "\u2245",
    TildeTilde: "\u2248",
    times: "\xD7",
    timesb: "\u22A0",
    timesbar: "\u2A31",
    timesd: "\u2A30",
    tint: "\u222D",
    toea: "\u2928",
    top: "\u22A4",
    topbot: "\u2336",
    topcir: "\u2AF1",
    Topf: "\u{1D54B}",
    topf: "\u{1D565}",
    topfork: "\u2ADA",
    tosa: "\u2929",
    tprime: "\u2034",
    TRADE: "\u2122",
    trade: "\u2122",
    triangle: "\u25B5",
    triangledown: "\u25BF",
    triangleleft: "\u25C3",
    trianglelefteq: "\u22B4",
    triangleq: "\u225C",
    triangleright: "\u25B9",
    trianglerighteq: "\u22B5",
    tridot: "\u25EC",
    trie: "\u225C",
    triminus: "\u2A3A",
    TripleDot: "\u20DB",
    triplus: "\u2A39",
    trisb: "\u29CD",
    tritime: "\u2A3B",
    trpezium: "\u23E2",
    Tscr: "\u{1D4AF}",
    tscr: "\u{1D4C9}",
    TScy: "\u0426",
    tscy: "\u0446",
    TSHcy: "\u040B",
    tshcy: "\u045B",
    Tstrok: "\u0166",
    tstrok: "\u0167",
    twixt: "\u226C",
    twoheadleftarrow: "\u219E",
    twoheadrightarrow: "\u21A0",
    Uacute: "\xDA",
    uacute: "\xFA",
    Uarr: "\u219F",
    uArr: "\u21D1",
    uarr: "\u2191",
    Uarrocir: "\u2949",
    Ubrcy: "\u040E",
    ubrcy: "\u045E",
    Ubreve: "\u016C",
    ubreve: "\u016D",
    Ucirc: "\xDB",
    ucirc: "\xFB",
    Ucy: "\u0423",
    ucy: "\u0443",
    udarr: "\u21C5",
    Udblac: "\u0170",
    udblac: "\u0171",
    udhar: "\u296E",
    ufisht: "\u297E",
    Ufr: "\u{1D518}",
    ufr: "\u{1D532}",
    Ugrave: "\xD9",
    ugrave: "\xF9",
    uHar: "\u2963",
    uharl: "\u21BF",
    uharr: "\u21BE",
    uhblk: "\u2580",
    ulcorn: "\u231C",
    ulcorner: "\u231C",
    ulcrop: "\u230F",
    ultri: "\u25F8",
    Umacr: "\u016A",
    umacr: "\u016B",
    uml: "\xA8",
    UnderBar: "_",
    UnderBrace: "\u23DF",
    UnderBracket: "\u23B5",
    UnderParenthesis: "\u23DD",
    Union: "\u22C3",
    UnionPlus: "\u228E",
    Uogon: "\u0172",
    uogon: "\u0173",
    Uopf: "\u{1D54C}",
    uopf: "\u{1D566}",
    UpArrow: "\u2191",
    Uparrow: "\u21D1",
    uparrow: "\u2191",
    UpArrowBar: "\u2912",
    UpArrowDownArrow: "\u21C5",
    UpDownArrow: "\u2195",
    Updownarrow: "\u21D5",
    updownarrow: "\u2195",
    UpEquilibrium: "\u296E",
    upharpoonleft: "\u21BF",
    upharpoonright: "\u21BE",
    uplus: "\u228E",
    UpperLeftArrow: "\u2196",
    UpperRightArrow: "\u2197",
    Upsi: "\u03D2",
    upsi: "\u03C5",
    upsih: "\u03D2",
    Upsilon: "\u03A5",
    upsilon: "\u03C5",
    UpTee: "\u22A5",
    UpTeeArrow: "\u21A5",
    upuparrows: "\u21C8",
    urcorn: "\u231D",
    urcorner: "\u231D",
    urcrop: "\u230E",
    Uring: "\u016E",
    uring: "\u016F",
    urtri: "\u25F9",
    Uscr: "\u{1D4B0}",
    uscr: "\u{1D4CA}",
    utdot: "\u22F0",
    Utilde: "\u0168",
    utilde: "\u0169",
    utri: "\u25B5",
    utrif: "\u25B4",
    uuarr: "\u21C8",
    Uuml: "\xDC",
    uuml: "\xFC",
    uwangle: "\u29A7",
    vangrt: "\u299C",
    varepsilon: "\u03F5",
    varkappa: "\u03F0",
    varnothing: "\u2205",
    varphi: "\u03D5",
    varpi: "\u03D6",
    varpropto: "\u221D",
    vArr: "\u21D5",
    varr: "\u2195",
    varrho: "\u03F1",
    varsigma: "\u03C2",
    varsubsetneq: "\u228A\uFE00",
    varsubsetneqq: "\u2ACB\uFE00",
    varsupsetneq: "\u228B\uFE00",
    varsupsetneqq: "\u2ACC\uFE00",
    vartheta: "\u03D1",
    vartriangleleft: "\u22B2",
    vartriangleright: "\u22B3",
    Vbar: "\u2AEB",
    vBar: "\u2AE8",
    vBarv: "\u2AE9",
    Vcy: "\u0412",
    vcy: "\u0432",
    VDash: "\u22AB",
    Vdash: "\u22A9",
    vDash: "\u22A8",
    vdash: "\u22A2",
    Vdashl: "\u2AE6",
    Vee: "\u22C1",
    vee: "\u2228",
    veebar: "\u22BB",
    veeeq: "\u225A",
    vellip: "\u22EE",
    Verbar: "\u2016",
    verbar: "|",
    Vert: "\u2016",
    vert: "|",
    VerticalBar: "\u2223",
    VerticalLine: "|",
    VerticalSeparator: "\u2758",
    VerticalTilde: "\u2240",
    VeryThinSpace: "\u200A",
    Vfr: "\u{1D519}",
    vfr: "\u{1D533}",
    vltri: "\u22B2",
    vnsub: "\u2282\u20D2",
    vnsup: "\u2283\u20D2",
    Vopf: "\u{1D54D}",
    vopf: "\u{1D567}",
    vprop: "\u221D",
    vrtri: "\u22B3",
    Vscr: "\u{1D4B1}",
    vscr: "\u{1D4CB}",
    vsubnE: "\u2ACB\uFE00",
    vsubne: "\u228A\uFE00",
    vsupnE: "\u2ACC\uFE00",
    vsupne: "\u228B\uFE00",
    Vvdash: "\u22AA",
    vzigzag: "\u299A",
    Wcirc: "\u0174",
    wcirc: "\u0175",
    wedbar: "\u2A5F",
    Wedge: "\u22C0",
    wedge: "\u2227",
    wedgeq: "\u2259",
    weierp: "\u2118",
    Wfr: "\u{1D51A}",
    wfr: "\u{1D534}",
    Wopf: "\u{1D54E}",
    wopf: "\u{1D568}",
    wp: "\u2118",
    wr: "\u2240",
    wreath: "\u2240",
    Wscr: "\u{1D4B2}",
    wscr: "\u{1D4CC}",
    xcap: "\u22C2",
    xcirc: "\u25EF",
    xcup: "\u22C3",
    xdtri: "\u25BD",
    Xfr: "\u{1D51B}",
    xfr: "\u{1D535}",
    xhArr: "\u27FA",
    xharr: "\u27F7",
    Xi: "\u039E",
    xi: "\u03BE",
    xlArr: "\u27F8",
    xlarr: "\u27F5",
    xmap: "\u27FC",
    xnis: "\u22FB",
    xodot: "\u2A00",
    Xopf: "\u{1D54F}",
    xopf: "\u{1D569}",
    xoplus: "\u2A01",
    xotime: "\u2A02",
    xrArr: "\u27F9",
    xrarr: "\u27F6",
    Xscr: "\u{1D4B3}",
    xscr: "\u{1D4CD}",
    xsqcup: "\u2A06",
    xuplus: "\u2A04",
    xutri: "\u25B3",
    xvee: "\u22C1",
    xwedge: "\u22C0",
    Yacute: "\xDD",
    yacute: "\xFD",
    YAcy: "\u042F",
    yacy: "\u044F",
    Ycirc: "\u0176",
    ycirc: "\u0177",
    Ycy: "\u042B",
    ycy: "\u044B",
    yen: "\xA5",
    Yfr: "\u{1D51C}",
    yfr: "\u{1D536}",
    YIcy: "\u0407",
    yicy: "\u0457",
    Yopf: "\u{1D550}",
    yopf: "\u{1D56A}",
    Yscr: "\u{1D4B4}",
    yscr: "\u{1D4CE}",
    YUcy: "\u042E",
    yucy: "\u044E",
    Yuml: "\u0178",
    yuml: "\xFF",
    Zacute: "\u0179",
    zacute: "\u017A",
    Zcaron: "\u017D",
    zcaron: "\u017E",
    Zcy: "\u0417",
    zcy: "\u0437",
    Zdot: "\u017B",
    zdot: "\u017C",
    zeetrf: "\u2128",
    ZeroWidthSpace: "\u200B",
    Zeta: "\u0396",
    zeta: "\u03B6",
    Zfr: "\u2128",
    zfr: "\u{1D537}",
    ZHcy: "\u0416",
    zhcy: "\u0436",
    zigrarr: "\u21DD",
    Zopf: "\u2124",
    zopf: "\u{1D56B}",
    Zscr: "\u{1D4B5}",
    zscr: "\u{1D4CF}",
    zwj: "\u200D",
    zwnj: "\u200C"
  }, t2.NGSP_UNICODE = "\uE500", t2.NAMED_ENTITIES.ngsp = t2.NGSP_UNICODE;
});
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class Fs {
  constructor({
    closedByChildren: e20,
    implicitNamespacePrefix: t2,
    contentType: r2 = As.TagContentType.PARSABLE_DATA,
    closedByParent: n2 = false,
    isVoid: i2 = false,
    ignoreFirstLf: s2 = false
  } = {}) {
    this.closedByChildren = {}, this.closedByParent = false, this.canSelfClose = false, e20 && e20.length > 0 && e20.forEach((e21) => this.closedByChildren[e21] = true), this.isVoid = i2, this.closedByParent = n2 || i2, this.implicitNamespacePrefix = t2 || null, this.contentType = r2, this.ignoreFirstLf = s2;
  }
  isClosedByChild(e20) {
    return this.isVoid || e20.toLowerCase() in this.closedByChildren;
  }
}
var ws = Fs;
let ks, Ns;
var Os = function(e20) {
  return Ns || (ks = new Fs(), Ns = {
    base: new Fs({ isVoid: true }),
    meta: new Fs({ isVoid: true }),
    area: new Fs({ isVoid: true }),
    embed: new Fs({ isVoid: true }),
    link: new Fs({ isVoid: true }),
    img: new Fs({ isVoid: true }),
    input: new Fs({ isVoid: true }),
    param: new Fs({ isVoid: true }),
    hr: new Fs({ isVoid: true }),
    br: new Fs({ isVoid: true }),
    source: new Fs({ isVoid: true }),
    track: new Fs({ isVoid: true }),
    wbr: new Fs({ isVoid: true }),
    p: new Fs({
      closedByChildren: [
        "address",
        "article",
        "aside",
        "blockquote",
        "div",
        "dl",
        "fieldset",
        "footer",
        "form",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "header",
        "hgroup",
        "hr",
        "main",
        "nav",
        "ol",
        "p",
        "pre",
        "section",
        "table",
        "ul"
      ],
      closedByParent: true
    }),
    thead: new Fs({ closedByChildren: ["tbody", "tfoot"] }),
    tbody: new Fs({
      closedByChildren: ["tbody", "tfoot"],
      closedByParent: true
    }),
    tfoot: new Fs({
      closedByChildren: ["tbody"],
      closedByParent: true
    }),
    tr: new Fs({
      closedByChildren: ["tr"],
      closedByParent: true
    }),
    td: new Fs({
      closedByChildren: ["td", "th"],
      closedByParent: true
    }),
    th: new Fs({
      closedByChildren: ["td", "th"],
      closedByParent: true
    }),
    col: new Fs({ isVoid: true }),
    svg: new Fs({ implicitNamespacePrefix: "svg" }),
    math: new Fs({ implicitNamespacePrefix: "math" }),
    li: new Fs({
      closedByChildren: ["li"],
      closedByParent: true
    }),
    dt: new Fs({ closedByChildren: ["dt", "dd"] }),
    dd: new Fs({
      closedByChildren: ["dt", "dd"],
      closedByParent: true
    }),
    rb: new Fs({
      closedByChildren: ["rb", "rt", "rtc", "rp"],
      closedByParent: true
    }),
    rt: new Fs({
      closedByChildren: ["rb", "rt", "rtc", "rp"],
      closedByParent: true
    }),
    rtc: new Fs({
      closedByChildren: ["rb", "rtc", "rp"],
      closedByParent: true
    }),
    rp: new Fs({
      closedByChildren: ["rb", "rt", "rtc", "rp"],
      closedByParent: true
    }),
    optgroup: new Fs({
      closedByChildren: ["optgroup"],
      closedByParent: true
    }),
    option: new Fs({
      closedByChildren: ["option", "optgroup"],
      closedByParent: true
    }),
    pre: new Fs({ ignoreFirstLf: true }),
    listing: new Fs({ ignoreFirstLf: true }),
    style: new Fs({ contentType: As.TagContentType.RAW_TEXT }),
    script: new Fs({ contentType: As.TagContentType.RAW_TEXT }),
    title: new Fs({
      contentType: As.TagContentType.ESCAPABLE_RAW_TEXT
    }),
    textarea: new Fs({
      contentType: As.TagContentType.ESCAPABLE_RAW_TEXT,
      ignoreFirstLf: true
    })
  }), Ns[e20] || ks;
}, xs = Object.defineProperty({ HtmlTagDefinition: ws, getHtmlTagDefinition: Os }, "__esModule", { value: true });
var Is = class {
  constructor(e20, t2 = -1) {
    this.path = e20, this.position = t2;
  }
  get empty() {
    return !this.path || !this.path.length;
  }
  get head() {
    return this.path[0];
  }
  get tail() {
    return this.path[this.path.length - 1];
  }
  parentOf(e20) {
    return e20 && this.path[this.path.indexOf(e20) - 1];
  }
  childOf(e20) {
    return this.path[this.path.indexOf(e20) + 1];
  }
  first(e20) {
    for (let t2 = this.path.length - 1; t2 >= 0; t2--) {
      let r2 = this.path[t2];
      if (r2 instanceof e20)
        return r2;
    }
  }
  push(e20) {
    this.path.push(e20);
  }
  pop() {
    return this.path.pop();
  }
}, Ps = Object.defineProperty({ AstPath: Is }, "__esModule", { value: true });
var Rs = class {
  constructor(e20, t2, r2) {
    this.value = e20, this.sourceSpan = t2, this.i18n = r2, this.type = "text";
  }
  visit(e20, t2) {
    return e20.visitText(this, t2);
  }
};
var Ls = class {
  constructor(e20, t2) {
    this.value = e20, this.sourceSpan = t2, this.type = "cdata";
  }
  visit(e20, t2) {
    return e20.visitCdata(this, t2);
  }
};
var Bs = class {
  constructor(e20, t2, r2, n2, i2, s2) {
    this.switchValue = e20, this.type = t2, this.cases = r2, this.sourceSpan = n2, this.switchValueSourceSpan = i2, this.i18n = s2;
  }
  visit(e20, t2) {
    return e20.visitExpansion(this, t2);
  }
};
var $s = class {
  constructor(e20, t2, r2, n2, i2) {
    this.value = e20, this.expression = t2, this.sourceSpan = r2, this.valueSourceSpan = n2, this.expSourceSpan = i2;
  }
  visit(e20, t2) {
    return e20.visitExpansionCase(this, t2);
  }
};
var qs$3 = class {
  constructor(e20, t2, r2, n2 = null, i2 = null, s2 = null) {
    this.name = e20, this.value = t2, this.sourceSpan = r2, this.valueSpan = n2, this.nameSpan = i2, this.i18n = s2, this.type = "attribute";
  }
  visit(e20, t2) {
    return e20.visitAttribute(this, t2);
  }
};
class Ms {
  constructor(e20, t2, r2, n2, i2 = null, s2 = null, o2 = null, a2 = null) {
    this.name = e20, this.attrs = t2, this.children = r2, this.sourceSpan = n2, this.startSourceSpan = i2, this.endSourceSpan = s2, this.nameSpan = o2, this.i18n = a2, this.type = "element";
  }
  visit(e20, t2) {
    return e20.visitElement(this, t2);
  }
}
var js = Ms;
var Us = class {
  constructor(e20, t2) {
    this.value = e20, this.sourceSpan = t2, this.type = "comment";
  }
  visit(e20, t2) {
    return e20.visitComment(this, t2);
  }
};
var Gs = class {
  constructor(e20, t2) {
    this.value = e20, this.sourceSpan = t2, this.type = "docType";
  }
  visit(e20, t2) {
    return e20.visitDocType(this, t2);
  }
};
function Vs(e20, t2, r2 = null) {
  const n2 = [], i2 = e20.visit ? (t3) => e20.visit(t3, r2) || t3.visit(e20, r2) : (t3) => t3.visit(e20, r2);
  return t2.forEach((e21) => {
    const t3 = i2(e21);
    t3 && n2.push(t3);
  }), n2;
}
var Hs = Vs;
class Xs {
  constructor() {
  }
  visitElement(e20, t2) {
    this.visitChildren(t2, (t3) => {
      t3(e20.attrs), t3(e20.children);
    });
  }
  visitAttribute(e20, t2) {
  }
  visitText(e20, t2) {
  }
  visitCdata(e20, t2) {
  }
  visitComment(e20, t2) {
  }
  visitDocType(e20, t2) {
  }
  visitExpansion(e20, t2) {
    return this.visitChildren(t2, (t3) => {
      t3(e20.cases);
    });
  }
  visitExpansionCase(e20, t2) {
  }
  visitChildren(e20, t2) {
    let r2 = [], n2 = this;
    return t2(function(t3) {
      t3 && r2.push(Vs(n2, t3, e20));
    }), Array.prototype.concat.apply([], r2);
  }
}
var zs = Xs;
function Ws(e20) {
  const t2 = e20.sourceSpan.start.offset;
  let r2 = e20.sourceSpan.end.offset;
  return e20 instanceof Ms && (e20.endSourceSpan ? r2 = e20.endSourceSpan.end.offset : e20.children && e20.children.length && (r2 = Ws(e20.children[e20.children.length - 1]).end)), { start: t2, end: r2 };
}
var Ys = function(e20, t2) {
  const r2 = [];
  return Vs(new class extends Xs {
    visit(e21, n2) {
      const i2 = Ws(e21);
      if (!(i2.start <= t2 && t2 < i2.end))
        return true;
      r2.push(e21);
    }
  }(), e20), new Ps.AstPath(r2, t2);
}, Qs = Object.defineProperty({
  Text: Rs,
  CDATA: Ls,
  Expansion: Bs,
  ExpansionCase: $s,
  Attribute: qs$3,
  Element: js,
  Comment: Us,
  DocType: Gs,
  visitAll: Hs,
  RecursiveVisitor: zs,
  findNode: Ys
}, "__esModule", { value: true });
var Js = function(e20, t2) {
  if (t2 != null) {
    if (!Array.isArray(t2))
      throw new Error(`Expected '${e20}' to be an array of strings.`);
    for (let r2 = 0; r2 < t2.length; r2 += 1)
      if (typeof t2[r2] != "string")
        throw new Error(`Expected '${e20}' to be an array of strings.`);
  }
};
const Ks = [/^\s*$/, /[<>]/, /^[{}]$/, /&(#|[a-z])/i, /^\/\//];
var Zs = function(e20, t2) {
  if (!(t2 == null || Array.isArray(t2) && t2.length == 2))
    throw new Error(`Expected '${e20}' to be an array, [start, end].`);
  if (t2 != null) {
    const e21 = t2[0], r2 = t2[1];
    Ks.forEach((t3) => {
      if (t3.test(e21) || t3.test(r2))
        throw new Error(`['${e21}', '${r2}'] contains unusable interpolation symbol.`);
    });
  }
}, eo = Object.defineProperty({ assertArrayOfStrings: Js, assertInterpolationSymbols: Zs }, "__esModule", { value: true }), to$3 = t$1(function(e20, t2) {
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  Object.defineProperty(t2, "__esModule", { value: true });
  class r2 {
    constructor(e21, t3) {
      this.start = e21, this.end = t3;
    }
    static fromArray(e21) {
      return e21 ? (eo.assertInterpolationSymbols("interpolation", e21), new r2(e21[0], e21[1])) : t2.DEFAULT_INTERPOLATION_CONFIG;
    }
  }
  t2.InterpolationConfig = r2, t2.DEFAULT_INTERPOLATION_CONFIG = new r2("{{", "}}");
}), ro = t$1(function(e20, t2) {
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  Object.defineProperty(t2, "__esModule", { value: true });
  const n2 = r$1;
  var i2;
  !function(e21) {
    e21[e21.TAG_OPEN_START = 0] = "TAG_OPEN_START", e21[e21.TAG_OPEN_END = 1] = "TAG_OPEN_END", e21[e21.TAG_OPEN_END_VOID = 2] = "TAG_OPEN_END_VOID", e21[e21.TAG_CLOSE = 3] = "TAG_CLOSE", e21[e21.TEXT = 4] = "TEXT", e21[e21.ESCAPABLE_RAW_TEXT = 5] = "ESCAPABLE_RAW_TEXT", e21[e21.RAW_TEXT = 6] = "RAW_TEXT", e21[e21.COMMENT_START = 7] = "COMMENT_START", e21[e21.COMMENT_END = 8] = "COMMENT_END", e21[e21.CDATA_START = 9] = "CDATA_START", e21[e21.CDATA_END = 10] = "CDATA_END", e21[e21.ATTR_NAME = 11] = "ATTR_NAME", e21[e21.ATTR_QUOTE = 12] = "ATTR_QUOTE", e21[e21.ATTR_VALUE = 13] = "ATTR_VALUE", e21[e21.DOC_TYPE_START = 14] = "DOC_TYPE_START", e21[e21.DOC_TYPE_END = 15] = "DOC_TYPE_END", e21[e21.EXPANSION_FORM_START = 16] = "EXPANSION_FORM_START", e21[e21.EXPANSION_CASE_VALUE = 17] = "EXPANSION_CASE_VALUE", e21[e21.EXPANSION_CASE_EXP_START = 18] = "EXPANSION_CASE_EXP_START", e21[e21.EXPANSION_CASE_EXP_END = 19] = "EXPANSION_CASE_EXP_END", e21[e21.EXPANSION_FORM_END = 20] = "EXPANSION_FORM_END", e21[e21.EOF = 21] = "EOF";
  }(i2 = t2.TokenType || (t2.TokenType = {}));
  class s2 {
    constructor(e21, t3, r2) {
      this.type = e21, this.parts = t3, this.sourceSpan = r2;
    }
  }
  t2.Token = s2;
  class o2 extends B$1.ParseError {
    constructor(e21, t3, r2) {
      super(r2, e21), this.tokenType = t3;
    }
  }
  t2.TokenError = o2;
  class a2 {
    constructor(e21, t3) {
      this.tokens = e21, this.errors = t3;
    }
  }
  t2.TokenizeResult = a2, t2.tokenize = function(e21, t3, r2, n3 = {}) {
    return new h2(new B$1.ParseSourceFile(e21, t3), r2, n3).tokenize();
  };
  const u2 = /\r\n?/g;
  function c2(e21) {
    return `Unexpected character "${e21 === n2.$EOF ? "EOF" : String.fromCharCode(e21)}"`;
  }
  function l2(e21) {
    return `Unknown entity "${e21}" - use the "&#<decimal>;" or  "&#x<hex>;" syntax`;
  }
  class p2 {
    constructor(e21) {
      this.error = e21;
    }
  }
  class h2 {
    constructor(e21, t3, r2) {
      this._getTagContentType = t3, this._currentTokenStart = null, this._currentTokenType = null, this._expansionCaseStack = [], this._inInterpolation = false, this._fullNameStack = [], this.tokens = [], this.errors = [], this._tokenizeIcu = r2.tokenizeExpansionForms || false, this._interpolationConfig = r2.interpolationConfig || to$3.DEFAULT_INTERPOLATION_CONFIG, this._leadingTriviaCodePoints = r2.leadingTriviaChars && r2.leadingTriviaChars.map((e22) => e22.codePointAt(0) || 0), this._canSelfClose = r2.canSelfClose || false, this._allowHtmComponentClosingTags = r2.allowHtmComponentClosingTags || false;
      const n3 = r2.range || {
        endPos: e21.content.length,
        startPos: 0,
        startLine: 0,
        startCol: 0
      };
      this._cursor = r2.escapedString ? new C2(e21, n3) : new E2(e21, n3);
      try {
        this._cursor.init();
      } catch (e22) {
        this.handleError(e22);
      }
    }
    _processCarriageReturns(e21) {
      return e21.replace(u2, "\n");
    }
    tokenize() {
      for (; this._cursor.peek() !== n2.$EOF; ) {
        const e21 = this._cursor.clone();
        try {
          if (this._attemptCharCode(n2.$LT))
            if (this._attemptCharCode(n2.$BANG))
              this._attemptStr("[CDATA[") ? this._consumeCdata(e21) : this._attemptStr("--") ? this._consumeComment(e21) : this._attemptStrCaseInsensitive("doctype") ? this._consumeDocType(e21) : this._consumeBogusComment(e21);
            else if (this._attemptCharCode(n2.$SLASH))
              this._consumeTagClose(e21);
            else {
              const t3 = this._cursor.clone();
              this._attemptCharCode(n2.$QUESTION) ? (this._cursor = t3, this._consumeBogusComment(e21)) : this._consumeTagOpen(e21);
            }
          else
            this._tokenizeIcu && this._tokenizeExpansionForm() || this._consumeText();
        } catch (e22) {
          this.handleError(e22);
        }
      }
      return this._beginToken(i2.EOF), this._endToken([]), new a2(function(e21) {
        const t3 = [];
        let r2;
        for (let n3 = 0; n3 < e21.length; n3++) {
          const s3 = e21[n3];
          r2 && r2.type == i2.TEXT && s3.type == i2.TEXT ? (r2.parts[0] += s3.parts[0], r2.sourceSpan.end = s3.sourceSpan.end) : (r2 = s3, t3.push(r2));
        }
        return t3;
      }(this.tokens), this.errors);
    }
    _tokenizeExpansionForm() {
      if (this.isExpansionFormStart())
        return this._consumeExpansionFormStart(), true;
      if (((e21 = this._cursor.peek()) === n2.$EQ || n2.isAsciiLetter(e21) || n2.isDigit(e21)) && this._isInExpansionForm())
        return this._consumeExpansionCaseStart(), true;
      var e21;
      if (this._cursor.peek() === n2.$RBRACE) {
        if (this._isInExpansionCase())
          return this._consumeExpansionCaseEnd(), true;
        if (this._isInExpansionForm())
          return this._consumeExpansionFormEnd(), true;
      }
      return false;
    }
    _beginToken(e21, t3 = this._cursor.clone()) {
      this._currentTokenStart = t3, this._currentTokenType = e21;
    }
    _endToken(e21, t3 = this._cursor.clone()) {
      if (this._currentTokenStart === null)
        throw new o2("Programming error - attempted to end a token when there was no start to the token", this._currentTokenType, this._cursor.getSpan(t3));
      if (this._currentTokenType === null)
        throw new o2("Programming error - attempted to end a token which has no token type", null, this._cursor.getSpan(this._currentTokenStart));
      const r2 = new s2(this._currentTokenType, e21, this._cursor.getSpan(this._currentTokenStart, this._leadingTriviaCodePoints));
      return this.tokens.push(r2), this._currentTokenStart = null, this._currentTokenType = null, r2;
    }
    _createError(e21, t3) {
      this._isInExpansionForm() && (e21 += ` (Do you have an unescaped "{" in your template? Use "{{ '{' }}") to escape it.)`);
      const r2 = new o2(e21, this._currentTokenType, t3);
      return this._currentTokenStart = null, this._currentTokenType = null, new p2(r2);
    }
    handleError(e21) {
      if (e21 instanceof y2 && (e21 = this._createError(e21.msg, this._cursor.getSpan(e21.cursor))), !(e21 instanceof p2))
        throw e21;
      this.errors.push(e21.error);
    }
    _attemptCharCode(e21) {
      return this._cursor.peek() === e21 && (this._cursor.advance(), true);
    }
    _attemptCharCodeCaseInsensitive(e21) {
      return t3 = this._cursor.peek(), r2 = e21, m2(t3) == m2(r2) && (this._cursor.advance(), true);
      var t3, r2;
    }
    _requireCharCode(e21) {
      const t3 = this._cursor.clone();
      if (!this._attemptCharCode(e21))
        throw this._createError(c2(this._cursor.peek()), this._cursor.getSpan(t3));
    }
    _attemptStr(e21) {
      const t3 = e21.length;
      if (this._cursor.charsLeft() < t3)
        return false;
      const r2 = this._cursor.clone();
      for (let n3 = 0; n3 < t3; n3++)
        if (!this._attemptCharCode(e21.charCodeAt(n3)))
          return this._cursor = r2, false;
      return true;
    }
    _attemptStrCaseInsensitive(e21) {
      for (let t3 = 0; t3 < e21.length; t3++)
        if (!this._attemptCharCodeCaseInsensitive(e21.charCodeAt(t3)))
          return false;
      return true;
    }
    _requireStr(e21) {
      const t3 = this._cursor.clone();
      if (!this._attemptStr(e21))
        throw this._createError(c2(this._cursor.peek()), this._cursor.getSpan(t3));
    }
    _requireStrCaseInsensitive(e21) {
      const t3 = this._cursor.clone();
      if (!this._attemptStrCaseInsensitive(e21))
        throw this._createError(c2(this._cursor.peek()), this._cursor.getSpan(t3));
    }
    _attemptCharCodeUntilFn(e21) {
      for (; !e21(this._cursor.peek()); )
        this._cursor.advance();
    }
    _requireCharCodeUntilFn(e21, t3) {
      const r2 = this._cursor.clone();
      this._attemptCharCodeUntilFn(e21);
      if (this._cursor.clone().diff(r2) < t3)
        throw this._createError(c2(this._cursor.peek()), this._cursor.getSpan(r2));
    }
    _attemptUntilChar(e21) {
      for (; this._cursor.peek() !== e21; )
        this._cursor.advance();
    }
    _readChar(e21) {
      if (e21 && this._cursor.peek() === n2.$AMPERSAND)
        return this._decodeEntity();
      {
        const e22 = String.fromCodePoint(this._cursor.peek());
        return this._cursor.advance(), e22;
      }
    }
    _decodeEntity() {
      const e21 = this._cursor.clone();
      if (this._cursor.advance(), !this._attemptCharCode(n2.$HASH)) {
        const t3 = this._cursor.clone();
        if (this._attemptCharCodeUntilFn(g2), this._cursor.peek() != n2.$SEMICOLON)
          return this._cursor = t3, "&";
        const r2 = this._cursor.getChars(t3);
        this._cursor.advance();
        const i3 = As.NAMED_ENTITIES[r2];
        if (!i3)
          throw this._createError(l2(r2), this._cursor.getSpan(e21));
        return i3;
      }
      {
        const t3 = this._attemptCharCode(n2.$x) || this._attemptCharCode(n2.$X), r2 = this._cursor.clone();
        if (this._attemptCharCodeUntilFn(d2), this._cursor.peek() != n2.$SEMICOLON)
          throw this._createError(c2(this._cursor.peek()), this._cursor.getSpan());
        const i3 = this._cursor.getChars(r2);
        this._cursor.advance();
        try {
          const e22 = parseInt(i3, t3 ? 16 : 10);
          return String.fromCharCode(e22);
        } catch (t4) {
          throw this._createError(l2(this._cursor.getChars(e21)), this._cursor.getSpan());
        }
      }
    }
    _consumeRawText(e21, t3) {
      this._beginToken(e21 ? i2.ESCAPABLE_RAW_TEXT : i2.RAW_TEXT);
      const r2 = [];
      for (; ; ) {
        const n3 = this._cursor.clone(), i3 = t3();
        if (this._cursor = n3, i3)
          break;
        r2.push(this._readChar(e21));
      }
      return this._endToken([
        this._processCarriageReturns(r2.join(""))
      ]);
    }
    _consumeComment(e21) {
      this._beginToken(i2.COMMENT_START, e21), this._endToken([]), this._consumeRawText(false, () => this._attemptStr("-->")), this._beginToken(i2.COMMENT_END), this._requireStr("-->"), this._endToken([]);
    }
    _consumeBogusComment(e21) {
      this._beginToken(i2.COMMENT_START, e21), this._endToken([]), this._consumeRawText(false, () => this._cursor.peek() === n2.$GT), this._beginToken(i2.COMMENT_END), this._cursor.advance(), this._endToken([]);
    }
    _consumeCdata(e21) {
      this._beginToken(i2.CDATA_START, e21), this._endToken([]), this._consumeRawText(false, () => this._attemptStr("]]>")), this._beginToken(i2.CDATA_END), this._requireStr("]]>"), this._endToken([]);
    }
    _consumeDocType(e21) {
      this._beginToken(i2.DOC_TYPE_START, e21), this._endToken([]), this._consumeRawText(false, () => this._cursor.peek() === n2.$GT), this._beginToken(i2.DOC_TYPE_END), this._cursor.advance(), this._endToken([]);
    }
    _consumePrefixAndName() {
      const e21 = this._cursor.clone();
      let t3 = "";
      for (; this._cursor.peek() !== n2.$COLON && !(((r2 = this._cursor.peek()) < n2.$a || n2.$z < r2) && (r2 < n2.$A || n2.$Z < r2) && (r2 < n2.$0 || r2 > n2.$9)); )
        this._cursor.advance();
      var r2;
      let i3;
      this._cursor.peek() === n2.$COLON ? (t3 = this._cursor.getChars(e21), this._cursor.advance(), i3 = this._cursor.clone()) : i3 = e21, this._requireCharCodeUntilFn(f2, t3 === "" ? 0 : 1);
      return [t3, this._cursor.getChars(i3)];
    }
    _consumeTagOpen(e21) {
      let t3, r2, s3, o3 = this.tokens.length;
      const a3 = this._cursor.clone(), u3 = [];
      try {
        if (!n2.isAsciiLetter(this._cursor.peek()))
          throw this._createError(c2(this._cursor.peek()), this._cursor.getSpan(e21));
        for (s3 = this._consumeTagOpenStart(e21), r2 = s3.parts[0], t3 = s3.parts[1], this._attemptCharCodeUntilFn(D2); this._cursor.peek() !== n2.$SLASH && this._cursor.peek() !== n2.$GT; ) {
          const [e22, t4] = this._consumeAttributeName();
          if (this._attemptCharCodeUntilFn(D2), this._attemptCharCode(n2.$EQ)) {
            this._attemptCharCodeUntilFn(D2);
            const r3 = this._consumeAttributeValue();
            u3.push({ prefix: e22, name: t4, value: r3 });
          } else
            u3.push({ prefix: e22, name: t4 });
          this._attemptCharCodeUntilFn(D2);
        }
        this._consumeTagOpenEnd();
      } catch (t4) {
        if (t4 instanceof p2)
          return this._cursor = a3, s3 && (this.tokens.length = o3), this._beginToken(i2.TEXT, e21), void this._endToken(["<"]);
        throw t4;
      }
      if (this._canSelfClose && this.tokens[this.tokens.length - 1].type === i2.TAG_OPEN_END_VOID)
        return;
      const l3 = this._getTagContentType(t3, r2, this._fullNameStack.length > 0, u3);
      this._handleFullNameStackForTagOpen(r2, t3), l3 === As.TagContentType.RAW_TEXT ? this._consumeRawTextWithTagClose(r2, t3, false) : l3 === As.TagContentType.ESCAPABLE_RAW_TEXT && this._consumeRawTextWithTagClose(r2, t3, true);
    }
    _consumeRawTextWithTagClose(e21, t3, r2) {
      this._consumeRawText(r2, () => !!this._attemptCharCode(n2.$LT) && !!this._attemptCharCode(n2.$SLASH) && (this._attemptCharCodeUntilFn(D2), !!this._attemptStrCaseInsensitive(e21 ? `${e21}:${t3}` : t3) && (this._attemptCharCodeUntilFn(D2), this._attemptCharCode(n2.$GT)))), this._beginToken(i2.TAG_CLOSE), this._requireCharCodeUntilFn((e22) => e22 === n2.$GT, 3), this._cursor.advance(), this._endToken([e21, t3]), this._handleFullNameStackForTagClose(e21, t3);
    }
    _consumeTagOpenStart(e21) {
      this._beginToken(i2.TAG_OPEN_START, e21);
      const t3 = this._consumePrefixAndName();
      return this._endToken(t3);
    }
    _consumeAttributeName() {
      const e21 = this._cursor.peek();
      if (e21 === n2.$SQ || e21 === n2.$DQ)
        throw this._createError(c2(e21), this._cursor.getSpan());
      this._beginToken(i2.ATTR_NAME);
      const t3 = this._consumePrefixAndName();
      return this._endToken(t3), t3;
    }
    _consumeAttributeValue() {
      let e21;
      if (this._cursor.peek() === n2.$SQ || this._cursor.peek() === n2.$DQ) {
        this._beginToken(i2.ATTR_QUOTE);
        const t3 = this._cursor.peek();
        this._cursor.advance(), this._endToken([String.fromCodePoint(t3)]), this._beginToken(i2.ATTR_VALUE);
        const r2 = [];
        for (; this._cursor.peek() !== t3; )
          r2.push(this._readChar(true));
        e21 = this._processCarriageReturns(r2.join("")), this._endToken([e21]), this._beginToken(i2.ATTR_QUOTE), this._cursor.advance(), this._endToken([String.fromCodePoint(t3)]);
      } else {
        this._beginToken(i2.ATTR_VALUE);
        const t3 = this._cursor.clone();
        this._requireCharCodeUntilFn(f2, 1), e21 = this._processCarriageReturns(this._cursor.getChars(t3)), this._endToken([e21]);
      }
      return e21;
    }
    _consumeTagOpenEnd() {
      const e21 = this._attemptCharCode(n2.$SLASH) ? i2.TAG_OPEN_END_VOID : i2.TAG_OPEN_END;
      this._beginToken(e21), this._requireCharCode(n2.$GT), this._endToken([]);
    }
    _consumeTagClose(e21) {
      if (this._beginToken(i2.TAG_CLOSE, e21), this._attemptCharCodeUntilFn(D2), this._allowHtmComponentClosingTags && this._attemptCharCode(n2.$SLASH))
        this._attemptCharCodeUntilFn(D2), this._requireCharCode(n2.$GT), this._endToken([]);
      else {
        const [e22, t3] = this._consumePrefixAndName();
        this._attemptCharCodeUntilFn(D2), this._requireCharCode(n2.$GT), this._endToken([e22, t3]), this._handleFullNameStackForTagClose(e22, t3);
      }
    }
    _consumeExpansionFormStart() {
      this._beginToken(i2.EXPANSION_FORM_START), this._requireCharCode(n2.$LBRACE), this._endToken([]), this._expansionCaseStack.push(i2.EXPANSION_FORM_START), this._beginToken(i2.RAW_TEXT);
      const e21 = this._readUntil(n2.$COMMA);
      this._endToken([e21]), this._requireCharCode(n2.$COMMA), this._attemptCharCodeUntilFn(D2), this._beginToken(i2.RAW_TEXT);
      const t3 = this._readUntil(n2.$COMMA);
      this._endToken([t3]), this._requireCharCode(n2.$COMMA), this._attemptCharCodeUntilFn(D2);
    }
    _consumeExpansionCaseStart() {
      this._beginToken(i2.EXPANSION_CASE_VALUE);
      const e21 = this._readUntil(n2.$LBRACE).trim();
      this._endToken([e21]), this._attemptCharCodeUntilFn(D2), this._beginToken(i2.EXPANSION_CASE_EXP_START), this._requireCharCode(n2.$LBRACE), this._endToken([]), this._attemptCharCodeUntilFn(D2), this._expansionCaseStack.push(i2.EXPANSION_CASE_EXP_START);
    }
    _consumeExpansionCaseEnd() {
      this._beginToken(i2.EXPANSION_CASE_EXP_END), this._requireCharCode(n2.$RBRACE), this._endToken([]), this._attemptCharCodeUntilFn(D2), this._expansionCaseStack.pop();
    }
    _consumeExpansionFormEnd() {
      this._beginToken(i2.EXPANSION_FORM_END), this._requireCharCode(n2.$RBRACE), this._endToken([]), this._expansionCaseStack.pop();
    }
    _consumeText() {
      const e21 = this._cursor.clone();
      this._beginToken(i2.TEXT, e21);
      const t3 = [];
      do {
        this._interpolationConfig && this._attemptStr(this._interpolationConfig.start) ? (t3.push(this._interpolationConfig.start), this._inInterpolation = true) : this._interpolationConfig && this._inInterpolation && this._attemptStr(this._interpolationConfig.end) ? (t3.push(this._interpolationConfig.end), this._inInterpolation = false) : t3.push(this._readChar(true));
      } while (!this._isTextEnd());
      this._endToken([this._processCarriageReturns(t3.join(""))]);
    }
    _isTextEnd() {
      if (this._cursor.peek() === n2.$LT || this._cursor.peek() === n2.$EOF)
        return true;
      if (this._tokenizeIcu && !this._inInterpolation) {
        if (this.isExpansionFormStart())
          return true;
        if (this._cursor.peek() === n2.$RBRACE && this._isInExpansionCase())
          return true;
      }
      return false;
    }
    _readUntil(e21) {
      const t3 = this._cursor.clone();
      return this._attemptUntilChar(e21), this._cursor.getChars(t3);
    }
    _isInExpansionCase() {
      return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === i2.EXPANSION_CASE_EXP_START;
    }
    _isInExpansionForm() {
      return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === i2.EXPANSION_FORM_START;
    }
    isExpansionFormStart() {
      if (this._cursor.peek() !== n2.$LBRACE)
        return false;
      if (this._interpolationConfig) {
        const e21 = this._cursor.clone(), t3 = this._attemptStr(this._interpolationConfig.start);
        return this._cursor = e21, !t3;
      }
      return true;
    }
    _handleFullNameStackForTagOpen(e21, t3) {
      const r2 = As.mergeNsAndName(e21, t3);
      this._fullNameStack.length !== 0 && this._fullNameStack[this._fullNameStack.length - 1] !== r2 || this._fullNameStack.push(r2);
    }
    _handleFullNameStackForTagClose(e21, t3) {
      const r2 = As.mergeNsAndName(e21, t3);
      this._fullNameStack.length !== 0 && this._fullNameStack[this._fullNameStack.length - 1] === r2 && this._fullNameStack.pop();
    }
  }
  function D2(e21) {
    return !n2.isWhitespace(e21) || e21 === n2.$EOF;
  }
  function f2(e21) {
    return n2.isWhitespace(e21) || e21 === n2.$GT || e21 === n2.$SLASH || e21 === n2.$SQ || e21 === n2.$DQ || e21 === n2.$EQ;
  }
  function d2(e21) {
    return e21 == n2.$SEMICOLON || e21 == n2.$EOF || !n2.isAsciiHexDigit(e21);
  }
  function g2(e21) {
    return e21 == n2.$SEMICOLON || e21 == n2.$EOF || !n2.isAsciiLetter(e21);
  }
  function m2(e21) {
    return e21 >= n2.$a && e21 <= n2.$z ? e21 - n2.$a + n2.$A : e21;
  }
  class E2 {
    constructor(e21, t3) {
      if (e21 instanceof E2)
        this.file = e21.file, this.input = e21.input, this.end = e21.end, this.state = Object.assign({}, e21.state);
      else {
        if (!t3)
          throw new Error("Programming error: the range argument must be provided with a file argument.");
        this.file = e21, this.input = e21.content, this.end = t3.endPos, this.state = {
          peek: -1,
          offset: t3.startPos,
          line: t3.startLine,
          column: t3.startCol
        };
      }
    }
    clone() {
      return new E2(this);
    }
    peek() {
      return this.state.peek;
    }
    charsLeft() {
      return this.end - this.state.offset;
    }
    diff(e21) {
      return this.state.offset - e21.state.offset;
    }
    advance() {
      this.advanceState(this.state);
    }
    init() {
      this.updatePeek(this.state);
    }
    getSpan(e21, t3) {
      if (e21 = e21 || this, t3)
        for (e21 = e21.clone(); this.diff(e21) > 0 && t3.indexOf(e21.peek()) !== -1; )
          e21.advance();
      return new B$1.ParseSourceSpan(new B$1.ParseLocation(e21.file, e21.state.offset, e21.state.line, e21.state.column), new B$1.ParseLocation(this.file, this.state.offset, this.state.line, this.state.column));
    }
    getChars(e21) {
      return this.input.substring(e21.state.offset, this.state.offset);
    }
    charAt(e21) {
      return this.input.charCodeAt(e21);
    }
    advanceState(e21) {
      if (e21.offset >= this.end)
        throw this.state = e21, new y2('Unexpected character "EOF"', this);
      const t3 = this.charAt(e21.offset);
      t3 === n2.$LF ? (e21.line++, e21.column = 0) : n2.isNewLine(t3) || e21.column++, e21.offset++, this.updatePeek(e21);
    }
    updatePeek(e21) {
      e21.peek = e21.offset >= this.end ? n2.$EOF : this.charAt(e21.offset);
    }
  }
  class C2 extends E2 {
    constructor(e21, t3) {
      e21 instanceof C2 ? (super(e21), this.internalState = Object.assign({}, e21.internalState)) : (super(e21, t3), this.internalState = this.state);
    }
    advance() {
      this.state = this.internalState, super.advance(), this.processEscapeSequence();
    }
    init() {
      super.init(), this.processEscapeSequence();
    }
    clone() {
      return new C2(this);
    }
    getChars(e21) {
      const t3 = e21.clone();
      let r2 = "";
      for (; t3.internalState.offset < this.internalState.offset; )
        r2 += String.fromCodePoint(t3.peek()), t3.advance();
      return r2;
    }
    processEscapeSequence() {
      const e21 = () => this.internalState.peek;
      if (e21() === n2.$BACKSLASH)
        if (this.internalState = Object.assign({}, this.state), this.advanceState(this.internalState), e21() === n2.$n)
          this.state.peek = n2.$LF;
        else if (e21() === n2.$r)
          this.state.peek = n2.$CR;
        else if (e21() === n2.$v)
          this.state.peek = n2.$VTAB;
        else if (e21() === n2.$t)
          this.state.peek = n2.$TAB;
        else if (e21() === n2.$b)
          this.state.peek = n2.$BSPACE;
        else if (e21() === n2.$f)
          this.state.peek = n2.$FF;
        else if (e21() === n2.$u)
          if (this.advanceState(this.internalState), e21() === n2.$LBRACE) {
            this.advanceState(this.internalState);
            const t3 = this.clone();
            let r2 = 0;
            for (; e21() !== n2.$RBRACE; )
              this.advanceState(this.internalState), r2++;
            this.state.peek = this.decodeHexDigits(t3, r2);
          } else {
            const e22 = this.clone();
            this.advanceState(this.internalState), this.advanceState(this.internalState), this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(e22, 4);
          }
        else if (e21() === n2.$x) {
          this.advanceState(this.internalState);
          const e22 = this.clone();
          this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(e22, 2);
        } else if (n2.isOctalDigit(e21())) {
          let t3 = "", r2 = 0, i3 = this.clone();
          for (; n2.isOctalDigit(e21()) && r2 < 3; )
            i3 = this.clone(), t3 += String.fromCodePoint(e21()), this.advanceState(this.internalState), r2++;
          this.state.peek = parseInt(t3, 8), this.internalState = i3.internalState;
        } else
          n2.isNewLine(this.internalState.peek) ? (this.advanceState(this.internalState), this.state = this.internalState) : this.state.peek = this.internalState.peek;
    }
    decodeHexDigits(e21, t3) {
      const r2 = this.input.substr(e21.internalState.offset, t3), n3 = parseInt(r2, 16);
      if (isNaN(n3))
        throw e21.state = e21.internalState, new y2("Invalid hexadecimal escape sequence", e21);
      return n3;
    }
  }
  class y2 {
    constructor(e21, t3) {
      this.msg = e21, this.cursor = t3;
    }
  }
  t2.CursorError = y2;
});
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class no extends B$1.ParseError {
  constructor(e20, t2, r2) {
    super(t2, r2), this.elementName = e20;
  }
  static create(e20, t2, r2) {
    return new no(e20, t2, r2);
  }
}
var io = no;
class so {
  constructor(e20, t2) {
    this.rootNodes = e20, this.errors = t2;
  }
}
var oo = so;
var ao = class {
  constructor(e20) {
    this.getTagDefinition = e20;
  }
  parse(e20, t2, r2, n2 = false, i2) {
    const s2 = (e21) => (t3, ...r3) => e21(t3.toLowerCase(), ...r3), o2 = n2 ? this.getTagDefinition : s2(this.getTagDefinition), a2 = (e21) => o2(e21).contentType, u2 = n2 ? i2 : s2(i2), c2 = i2 ? (e21, t3, r3, n3) => {
      const i3 = u2(e21, t3, r3, n3);
      return i3 !== void 0 ? i3 : a2(e21);
    } : a2, l2 = ro.tokenize(e20, t2, c2, r2), p2 = r2 && r2.canSelfClose || false, h2 = r2 && r2.allowHtmComponentClosingTags || false, D2 = new uo(l2.tokens, o2, p2, h2, n2).build();
    return new so(D2.rootNodes, l2.errors.concat(D2.errors));
  }
};
class uo {
  constructor(e20, t2, r2, n2, i2) {
    this.tokens = e20, this.getTagDefinition = t2, this.canSelfClose = r2, this.allowHtmComponentClosingTags = n2, this.isTagNameCaseSensitive = i2, this._index = -1, this._rootNodes = [], this._errors = [], this._elementStack = [], this._advance();
  }
  build() {
    for (; this._peek.type !== ro.TokenType.EOF; )
      this._peek.type === ro.TokenType.TAG_OPEN_START ? this._consumeStartTag(this._advance()) : this._peek.type === ro.TokenType.TAG_CLOSE ? (this._closeVoidElement(), this._consumeEndTag(this._advance())) : this._peek.type === ro.TokenType.CDATA_START ? (this._closeVoidElement(), this._consumeCdata(this._advance())) : this._peek.type === ro.TokenType.COMMENT_START ? (this._closeVoidElement(), this._consumeComment(this._advance())) : this._peek.type === ro.TokenType.TEXT || this._peek.type === ro.TokenType.RAW_TEXT || this._peek.type === ro.TokenType.ESCAPABLE_RAW_TEXT ? (this._closeVoidElement(), this._consumeText(this._advance())) : this._peek.type === ro.TokenType.EXPANSION_FORM_START ? this._consumeExpansion(this._advance()) : this._peek.type === ro.TokenType.DOC_TYPE_START ? this._consumeDocType(this._advance()) : this._advance();
    return new so(this._rootNodes, this._errors);
  }
  _advance() {
    const e20 = this._peek;
    return this._index < this.tokens.length - 1 && this._index++, this._peek = this.tokens[this._index], e20;
  }
  _advanceIf(e20) {
    return this._peek.type === e20 ? this._advance() : null;
  }
  _consumeCdata(e20) {
    const t2 = this._advance(), r2 = this._getText(t2), n2 = this._advanceIf(ro.TokenType.CDATA_END);
    this._addToParent(new Qs.CDATA(r2, new B$1.ParseSourceSpan(e20.sourceSpan.start, (n2 || t2).sourceSpan.end)));
  }
  _consumeComment(e20) {
    const t2 = this._advanceIf(ro.TokenType.RAW_TEXT), r2 = this._advanceIf(ro.TokenType.COMMENT_END), n2 = t2 != null ? t2.parts[0].trim() : null, i2 = new B$1.ParseSourceSpan(e20.sourceSpan.start, (r2 || t2 || e20).sourceSpan.end);
    this._addToParent(new Qs.Comment(n2, i2));
  }
  _consumeDocType(e20) {
    const t2 = this._advanceIf(ro.TokenType.RAW_TEXT), r2 = this._advanceIf(ro.TokenType.DOC_TYPE_END), n2 = t2 != null ? t2.parts[0].trim() : null, i2 = new B$1.ParseSourceSpan(e20.sourceSpan.start, (r2 || t2 || e20).sourceSpan.end);
    this._addToParent(new Qs.DocType(n2, i2));
  }
  _consumeExpansion(e20) {
    const t2 = this._advance(), r2 = this._advance(), n2 = [];
    for (; this._peek.type === ro.TokenType.EXPANSION_CASE_VALUE; ) {
      const e21 = this._parseExpansionCase();
      if (!e21)
        return;
      n2.push(e21);
    }
    if (this._peek.type !== ro.TokenType.EXPANSION_FORM_END)
      return void this._errors.push(no.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
    const i2 = new B$1.ParseSourceSpan(e20.sourceSpan.start, this._peek.sourceSpan.end);
    this._addToParent(new Qs.Expansion(t2.parts[0], r2.parts[0], n2, i2, t2.sourceSpan)), this._advance();
  }
  _parseExpansionCase() {
    const e20 = this._advance();
    if (this._peek.type !== ro.TokenType.EXPANSION_CASE_EXP_START)
      return this._errors.push(no.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'.")), null;
    const t2 = this._advance(), r2 = this._collectExpansionExpTokens(t2);
    if (!r2)
      return null;
    const n2 = this._advance();
    r2.push(new ro.Token(ro.TokenType.EOF, [], n2.sourceSpan));
    const i2 = new uo(r2, this.getTagDefinition, this.canSelfClose, this.allowHtmComponentClosingTags, this.isTagNameCaseSensitive).build();
    if (i2.errors.length > 0)
      return this._errors = this._errors.concat(i2.errors), null;
    const s2 = new B$1.ParseSourceSpan(e20.sourceSpan.start, n2.sourceSpan.end), o2 = new B$1.ParseSourceSpan(t2.sourceSpan.start, n2.sourceSpan.end);
    return new Qs.ExpansionCase(e20.parts[0], i2.rootNodes, s2, e20.sourceSpan, o2);
  }
  _collectExpansionExpTokens(e20) {
    const t2 = [], r2 = [ro.TokenType.EXPANSION_CASE_EXP_START];
    for (; ; ) {
      if (this._peek.type !== ro.TokenType.EXPANSION_FORM_START && this._peek.type !== ro.TokenType.EXPANSION_CASE_EXP_START || r2.push(this._peek.type), this._peek.type === ro.TokenType.EXPANSION_CASE_EXP_END) {
        if (!co(r2, ro.TokenType.EXPANSION_CASE_EXP_START))
          return this._errors.push(no.create(null, e20.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
        if (r2.pop(), r2.length == 0)
          return t2;
      }
      if (this._peek.type === ro.TokenType.EXPANSION_FORM_END) {
        if (!co(r2, ro.TokenType.EXPANSION_FORM_START))
          return this._errors.push(no.create(null, e20.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
        r2.pop();
      }
      if (this._peek.type === ro.TokenType.EOF)
        return this._errors.push(no.create(null, e20.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      t2.push(this._advance());
    }
  }
  _getText(e20) {
    let t2 = e20.parts[0];
    if (t2.length > 0 && t2[0] == "\n") {
      const e21 = this._getParentElement();
      e21 != null && e21.children.length == 0 && this.getTagDefinition(e21.name).ignoreFirstLf && (t2 = t2.substring(1));
    }
    return t2;
  }
  _consumeText(e20) {
    const t2 = this._getText(e20);
    t2.length > 0 && this._addToParent(new Qs.Text(t2, e20.sourceSpan));
  }
  _closeVoidElement() {
    const e20 = this._getParentElement();
    e20 && this.getTagDefinition(e20.name).isVoid && this._elementStack.pop();
  }
  _consumeStartTag(e20) {
    const t2 = e20.parts[0], r2 = e20.parts[1], n2 = [];
    for (; this._peek.type === ro.TokenType.ATTR_NAME; )
      n2.push(this._consumeAttr(this._advance()));
    const i2 = this._getElementFullName(t2, r2, this._getParentElement());
    let s2 = false;
    if (this._peek.type === ro.TokenType.TAG_OPEN_END_VOID) {
      this._advance(), s2 = true;
      const t3 = this.getTagDefinition(i2);
      this.canSelfClose || t3.canSelfClose || As.getNsPrefix(i2) !== null || t3.isVoid || this._errors.push(no.create(i2, e20.sourceSpan, `Only void and foreign elements can be self closed "${e20.parts[1]}"`));
    } else
      this._peek.type === ro.TokenType.TAG_OPEN_END && (this._advance(), s2 = false);
    const o2 = this._peek.sourceSpan.start, a2 = new B$1.ParseSourceSpan(e20.sourceSpan.start, o2), u2 = new B$1.ParseSourceSpan(e20.sourceSpan.start.moveBy(1), e20.sourceSpan.end), c2 = new Qs.Element(i2, n2, [], a2, a2, void 0, u2);
    this._pushElement(c2), s2 && (this._popElement(i2), c2.endSourceSpan = a2);
  }
  _pushElement(e20) {
    const t2 = this._getParentElement();
    t2 && this.getTagDefinition(t2.name).isClosedByChild(e20.name) && this._elementStack.pop(), this._addToParent(e20), this._elementStack.push(e20);
  }
  _consumeEndTag(e20) {
    const t2 = this.allowHtmComponentClosingTags && e20.parts.length === 0 ? null : this._getElementFullName(e20.parts[0], e20.parts[1], this._getParentElement());
    if (this._getParentElement() && (this._getParentElement().endSourceSpan = e20.sourceSpan), t2 && this.getTagDefinition(t2).isVoid)
      this._errors.push(no.create(t2, e20.sourceSpan, `Void elements do not have end tags "${e20.parts[1]}"`));
    else if (!this._popElement(t2)) {
      const r2 = `Unexpected closing tag "${t2}". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;
      this._errors.push(no.create(t2, e20.sourceSpan, r2));
    }
  }
  _popElement(e20) {
    for (let t2 = this._elementStack.length - 1; t2 >= 0; t2--) {
      const r2 = this._elementStack[t2];
      if (!e20 || (As.getNsPrefix(r2.name) ? r2.name == e20 : r2.name.toLowerCase() == e20.toLowerCase()))
        return this._elementStack.splice(t2, this._elementStack.length - t2), true;
      if (!this.getTagDefinition(r2.name).closedByParent)
        return false;
    }
    return false;
  }
  _consumeAttr(e20) {
    const t2 = As.mergeNsAndName(e20.parts[0], e20.parts[1]);
    let r2, n2, i2 = e20.sourceSpan.end, s2 = "";
    if (this._peek.type === ro.TokenType.ATTR_QUOTE) {
      n2 = this._advance().sourceSpan.start;
    }
    if (this._peek.type === ro.TokenType.ATTR_VALUE) {
      const e21 = this._advance();
      s2 = e21.parts[0], i2 = e21.sourceSpan.end, r2 = e21.sourceSpan;
    }
    if (this._peek.type === ro.TokenType.ATTR_QUOTE) {
      i2 = this._advance().sourceSpan.end, r2 = new B$1.ParseSourceSpan(n2, i2);
    }
    return new Qs.Attribute(t2, s2, new B$1.ParseSourceSpan(e20.sourceSpan.start, i2), r2, e20.sourceSpan);
  }
  _getParentElement() {
    return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;
  }
  _getParentElementSkippingContainers() {
    let e20 = null;
    for (let t2 = this._elementStack.length - 1; t2 >= 0; t2--) {
      if (!As.isNgContainer(this._elementStack[t2].name))
        return { parent: this._elementStack[t2], container: e20 };
      e20 = this._elementStack[t2];
    }
    return { parent: null, container: e20 };
  }
  _addToParent(e20) {
    const t2 = this._getParentElement();
    t2 != null ? t2.children.push(e20) : this._rootNodes.push(e20);
  }
  _insertBeforeContainer(e20, t2, r2) {
    if (t2) {
      if (e20) {
        const n2 = e20.children.indexOf(t2);
        e20.children[n2] = r2;
      } else
        this._rootNodes.push(r2);
      r2.children.push(t2), this._elementStack.splice(this._elementStack.indexOf(t2), 0, r2);
    } else
      this._addToParent(r2), this._elementStack.push(r2);
  }
  _getElementFullName(e20, t2, r2) {
    return e20 === "" && (e20 = this.getTagDefinition(t2).implicitNamespacePrefix || "") === "" && r2 != null && (e20 = As.getNsPrefix(r2.name)), As.mergeNsAndName(e20, t2);
  }
}
function co(e20, t2) {
  return e20.length > 0 && e20[e20.length - 1] === t2;
}
var lo = Object.defineProperty({ TreeError: io, ParseTreeResult: oo, Parser: ao }, "__esModule", { value: true }), po = lo, ho = po.ParseTreeResult, Do = po.TreeError;
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class fo extends lo.Parser {
  constructor() {
    super(xs.getHtmlTagDefinition);
  }
  parse(e20, t2, r2, n2 = false, i2) {
    return super.parse(e20, t2, r2, n2, i2);
  }
}
var go = fo, mo = Object.defineProperty({ ParseTreeResult: ho, TreeError: Do, HtmlParser: go }, "__esModule", { value: true }), Eo = As.TagContentType;
let Co = null;
var yo = function(e20, t2 = {}) {
  const {
    canSelfClose: r2 = false,
    allowHtmComponentClosingTags: n2 = false,
    isTagNameCaseSensitive: i2 = false,
    getTagContentType: s2
  } = t2;
  return (Co || (Co = new mo.HtmlParser()), Co).parse(e20, "angular-html-parser", {
    tokenizeExpansionForms: false,
    interpolationConfig: void 0,
    canSelfClose: r2,
    allowHtmComponentClosingTags: n2
  }, i2, s2);
}, bo = Object.defineProperty({ TagContentType: Eo, parse: yo }, "__esModule", { value: true });
const { ParseSourceSpan: So, ParseLocation: To, ParseSourceFile: _o } = B$1, { inferParserByLanguage: vo } = $n, { HTML_ELEMENT_ATTRIBUTES: Ao, HTML_TAGS: Fo, isUnknownNamespace: wo } = fs, { hasPragma: ko } = ds, { Node: No } = bs, { parseIeConditionalComment: Oo } = _s, { locStart: xo, locEnd: Io } = vs;
function Po(e20, {
  recognizeSelfClosing: t2,
  normalizeTagName: r2,
  normalizeAttributeName: n2,
  allowHtmComponentClosingTags: i2,
  isTagNameCaseSensitive: s2,
  getTagContentType: o2
}, a2) {
  const u2 = bo, { RecursiveVisitor: c2, visitAll: l2 } = Qs, { ParseSourceSpan: p2 } = B$1, { getHtmlTagDefinition: h2 } = xs;
  let { rootNodes: D2, errors: f2 } = u2.parse(e20, {
    canSelfClose: t2,
    allowHtmComponentClosingTags: i2,
    isTagNameCaseSensitive: s2,
    getTagContentType: o2
  });
  if (a2.parser === "vue") {
    if (D2.some((e21) => e21.type === "docType" && e21.value === "html" || e21.type === "element" && e21.name.toLowerCase() === "html")) {
      t2 = true, r2 = true, n2 = true, i2 = true, s2 = false;
      const o3 = u2.parse(e20, {
        canSelfClose: t2,
        allowHtmComponentClosingTags: i2,
        isTagNameCaseSensitive: s2
      });
      D2 = o3.rootNodes, f2 = o3.errors;
    } else {
      const r3 = (e21) => {
        if (!e21)
          return false;
        if (e21.type !== "element" || e21.name !== "template")
          return false;
        const t3 = e21.attrs.find((e22) => e22.name === "lang"), r4 = t3 && t3.value;
        return !r4 || vo(r4, a2) === "html";
      };
      if (D2.some(r3)) {
        let n3;
        const o3 = () => u2.parse(e20, {
          canSelfClose: t2,
          allowHtmComponentClosingTags: i2,
          isTagNameCaseSensitive: s2
        }), a3 = () => n3 || (n3 = o3()), c3 = (e21) => a3().rootNodes.find(({ startSourceSpan: t3 }) => t3 && t3.start.offset === e21.startSourceSpan.start.offset);
        for (let e21 = 0; e21 < D2.length; e21++) {
          const t3 = D2[e21], { endSourceSpan: n4, startSourceSpan: i3 } = t3;
          if (n4 === null) {
            f2 = a3().errors, D2[e21] = c3(t3) || t3;
          } else if (r3(t3)) {
            const r4 = a3(), s3 = i3.end.offset, o4 = n4.start.offset;
            for (const e22 of r4.errors) {
              const { offset: t4 } = e22.span.start;
              if (s3 < t4 && t4 < o4) {
                f2 = [e22];
                break;
              }
            }
            D2[e21] = c3(t3) || t3;
          }
        }
      }
    }
  }
  if (f2.length > 0) {
    const {
      msg: e21,
      span: { start: t3, end: r3 }
    } = f2[0];
    throw j$1(e21, {
      start: { line: t3.line + 1, column: t3.col + 1 },
      end: { line: r3.line + 1, column: r3.col + 1 }
    });
  }
  const d2 = (e21) => {
    const t3 = e21.name.startsWith(":") ? e21.name.slice(1).split(":")[0] : null, r3 = e21.nameSpan.toString(), n3 = t3 !== null && r3.startsWith(`${t3}:`), i3 = n3 ? r3.slice(t3.length + 1) : r3;
    e21.name = i3, e21.namespace = t3, e21.hasExplicitNamespace = n3;
  }, g2 = (e21, t3) => {
    const r3 = e21.toLowerCase();
    return t3(r3) ? r3 : e21;
  };
  return l2(new class extends c2 {
    visit(e21) {
      ((e22) => {
        if (e22.type === "element") {
          d2(e22);
          for (const t3 of e22.attrs)
            d2(t3), t3.valueSpan ? (t3.value = t3.valueSpan.toString(), /["']/.test(t3.value[0]) && (t3.value = t3.value.slice(1, -1))) : t3.value = null;
        } else
          e22.type === "comment" ? e22.value = e22.sourceSpan.toString().slice("<!--".length, -"-->".length) : e22.type === "text" && (e22.value = e22.sourceSpan.toString());
      })(e21), ((e22) => {
        if (e22.type === "element") {
          const t3 = h2(s2 ? e22.name : e22.name.toLowerCase());
          !e22.namespace || e22.namespace === t3.implicitNamespacePrefix || wo(e22) ? e22.tagDefinition = t3 : e22.tagDefinition = h2("");
        }
      })(e21), ((e22) => {
        if (e22.type === "element" && (!r2 || e22.namespace && e22.namespace !== e22.tagDefinition.implicitNamespacePrefix && !wo(e22) || (e22.name = g2(e22.name, (e23) => e23 in Fo)), n2)) {
          const t3 = Ao[e22.name] || Object.create(null);
          for (const r3 of e22.attrs)
            r3.namespace || (r3.name = g2(r3.name, (r4) => e22.name in Ao && (r4 in Ao["*"] || r4 in t3)));
        }
      })(e21), ((e22) => {
        e22.sourceSpan && e22.endSourceSpan && (e22.sourceSpan = new p2(e22.sourceSpan.start, e22.endSourceSpan.end));
      })(e21);
    }
  }(), D2), D2;
}
function Ro(e20, t2, r2, n2 = true) {
  const { frontMatter: i2, content: s2 } = n2 ? q$1(e20) : { frontMatter: null, content: e20 }, o2 = new _o(e20, t2.filepath), a2 = new To(o2, 0, 0, 0), u2 = a2.moveBy(e20.length), c2 = { type: "root", sourceSpan: new So(a2, u2), children: Po(s2, r2, t2) };
  if (i2) {
    const e21 = new To(o2, 0, 0, 0), t3 = e21.moveBy(i2.raw.length);
    i2.sourceSpan = new So(e21, t3), c2.children.unshift(i2);
  }
  const l2 = new No(c2), p2 = (n3, i3) => {
    const { offset: s3 } = i3, o3 = Ro(e20.slice(0, s3).replace(/[^\n\r]/g, " ") + n3, t2, r2, false);
    o3.sourceSpan = new So(i3, M$1(o3.children).sourceSpan.end);
    const a3 = o3.children[0];
    return a3.length === s3 ? o3.children.shift() : (a3.sourceSpan = new So(a3.sourceSpan.start.moveBy(s3), a3.sourceSpan.end), a3.value = a3.value.slice(s3)), o3;
  };
  return l2.map((e21) => {
    if (e21.type === "comment") {
      const t3 = Oo(e21, p2);
      if (t3)
        return t3;
    }
    return e21;
  });
}
function Lo({
  recognizeSelfClosing: e20 = false,
  normalizeTagName: t2 = false,
  normalizeAttributeName: r2 = false,
  allowHtmComponentClosingTags: n2 = false,
  isTagNameCaseSensitive: i2 = false,
  getTagContentType: s2
} = {}) {
  return {
    parse: (o2, a2, u2) => Ro(o2, u2, {
      recognizeSelfClosing: e20,
      normalizeTagName: t2,
      normalizeAttributeName: r2,
      allowHtmComponentClosingTags: n2,
      isTagNameCaseSensitive: i2,
      getTagContentType: s2
    }),
    hasPragma: ko,
    astFormat: "html",
    locStart: xo,
    locEnd: Io
  };
}
var Bo = {
  parsers: {
    html: Lo({
      recognizeSelfClosing: true,
      normalizeTagName: true,
      normalizeAttributeName: true,
      allowHtmComponentClosingTags: true
    }),
    angular: Lo(),
    vue: Lo({
      recognizeSelfClosing: true,
      isTagNameCaseSensitive: true,
      getTagContentType: (e20, t2, r2, n2) => {
        if (e20.toLowerCase() !== "html" && !r2 && (e20 !== "template" || n2.some(({ name: e21, value: t3 }) => e21 === "lang" && t3 !== "html")))
          return bo.TagContentType.RAW_TEXT;
      }
    }),
    lwc: Lo()
  }
};
var e = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
function t(e20) {
  return e20 && e20.__esModule && Object.prototype.hasOwnProperty.call(e20, "default") ? e20.default : e20;
}
function r(e20) {
  var t2 = { exports: {} };
  return e20(t2, t2.exports), t2.exports;
}
var n, o, i = function(e20) {
  return e20 && e20.Math == Math && e20;
}, s = i(typeof globalThis == "object" && globalThis) || i(typeof window == "object" && window) || i(typeof self == "object" && self) || i(typeof e == "object" && e) || function() {
  return this;
}() || Function("return this")(), u = function(e20) {
  try {
    return !!e20();
  } catch (e21) {
    return true;
  }
}, a$4 = !u(function() {
  return Object.defineProperty({}, 1, {
    get: function() {
      return 7;
    }
  })[1] != 7;
}), c = {}.propertyIsEnumerable, l = Object.getOwnPropertyDescriptor, f = {
  f: l && !c.call({ 1: 2 }, 1) ? function(e20) {
    var t2 = l(this, e20);
    return !!t2 && t2.enumerable;
  } : c
}, p = function(e20, t2) {
  return {
    enumerable: !(1 & e20),
    configurable: !(2 & e20),
    writable: !(4 & e20),
    value: t2
  };
}, h = {}.toString, d$4 = function(e20) {
  return h.call(e20).slice(8, -1);
}, D = "".split, g = u(function() {
  return !Object("z").propertyIsEnumerable(0);
}) ? function(e20) {
  return d$4(e20) == "String" ? D.call(e20, "") : Object(e20);
} : Object, m = function(e20) {
  if (e20 == null)
    throw TypeError("Can't call method on " + e20);
  return e20;
}, v = function(e20) {
  return g(m(e20));
}, y = function(e20) {
  return typeof e20 == "object" ? e20 !== null : typeof e20 == "function";
}, w = function(e20) {
  return typeof e20 == "function" ? e20 : void 0;
}, b = function(e20, t2) {
  return arguments.length < 2 ? w(s[e20]) : s[e20] && s[e20][t2];
}, C = b("navigator", "userAgent") || "", E = s.process, F = s.Deno, x = E && E.versions || F && F.version, A = x && x.v8;
A ? o = (n = A.split("."))[0] < 4 ? 1 : n[0] + n[1] : C && (!(n = C.match(/Edge\/(\d+)/)) || n[1] >= 74) && (n = C.match(/Chrome\/(\d+)/)) && (o = n[1]);
var k$4 = o && +o, O = !!Object.getOwnPropertySymbols && !u(function() {
  var e20 = Symbol();
  return !String(e20) || !(Object(e20) instanceof Symbol) || !Symbol.sham && k$4 && k$4 < 41;
}), _ = O && !Symbol.sham && typeof Symbol.iterator == "symbol", S = _ ? function(e20) {
  return typeof e20 == "symbol";
} : function(e20) {
  var t2 = b("Symbol");
  return typeof t2 == "function" && Object(e20) instanceof t2;
}, T = function(e20, t2) {
  try {
    Object.defineProperty(s, e20, {
      value: t2,
      configurable: true,
      writable: true
    });
  } catch (r2) {
    s[e20] = t2;
  }
  return t2;
}, I = s["__core-js_shared__"] || T("__core-js_shared__", {}), N = r(function(e20) {
  (e20.exports = function(e21, t2) {
    return I[e21] || (I[e21] = t2 !== void 0 ? t2 : {});
  })("versions", []).push({
    version: "3.17.3",
    mode: "global",
    copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)"
  });
}), M = function(e20) {
  return Object(m(e20));
}, R = {}.hasOwnProperty, j$4 = Object.hasOwn || function(e20, t2) {
  return R.call(M(e20), t2);
}, L = 0, B = Math.random(), P = function(e20) {
  return "Symbol(" + String(e20 === void 0 ? "" : e20) + ")_" + (++L + B).toString(36);
}, $ = N("wks"), U = s.Symbol, G = _ ? U : U && U.withoutSetter || P, W = function(e20) {
  return j$4($, e20) && (O || typeof $[e20] == "string") || (O && j$4(U, e20) ? $[e20] = U[e20] : $[e20] = G("Symbol." + e20)), $[e20];
}, z = W("toPrimitive"), V = function(e20, t2) {
  if (!y(e20) || S(e20))
    return e20;
  var r2, n2 = e20[z];
  if (n2 !== void 0) {
    if (t2 === void 0 && (t2 = "default"), r2 = n2.call(e20, t2), !y(r2) || S(r2))
      return r2;
    throw TypeError("Can't convert object to primitive value");
  }
  return t2 === void 0 && (t2 = "number"), function(e21, t3) {
    var r3, n3;
    if (t3 === "string" && typeof (r3 = e21.toString) == "function" && !y(n3 = r3.call(e21)))
      return n3;
    if (typeof (r3 = e21.valueOf) == "function" && !y(n3 = r3.call(e21)))
      return n3;
    if (t3 !== "string" && typeof (r3 = e21.toString) == "function" && !y(n3 = r3.call(e21)))
      return n3;
    throw TypeError("Can't convert object to primitive value");
  }(e20, t2);
}, q = function(e20) {
  var t2 = V(e20, "string");
  return S(t2) ? t2 : String(t2);
}, X = s.document, J = y(X) && y(X.createElement), H = !a$4 && !u(function() {
  return Object.defineProperty((e20 = "div", J ? X.createElement(e20) : {}), "a", {
    get: function() {
      return 7;
    }
  }).a != 7;
  var e20;
}), Y = Object.getOwnPropertyDescriptor, K = {
  f: a$4 ? Y : function(e20, t2) {
    if (e20 = v(e20), t2 = q(t2), H)
      try {
        return Y(e20, t2);
      } catch (e21) {
      }
    if (j$4(e20, t2))
      return p(!f.f.call(e20, t2), e20[t2]);
  }
}, Z = function(e20) {
  if (!y(e20))
    throw TypeError(String(e20) + " is not an object");
  return e20;
}, Q = Object.defineProperty, ee = {
  f: a$4 ? Q : function(e20, t2, r2) {
    if (Z(e20), t2 = q(t2), Z(r2), H)
      try {
        return Q(e20, t2, r2);
      } catch (e21) {
      }
    if ("get" in r2 || "set" in r2)
      throw TypeError("Accessors not supported");
    return "value" in r2 && (e20[t2] = r2.value), e20;
  }
}, te = a$4 ? function(e20, t2, r2) {
  return ee.f(e20, t2, p(1, r2));
} : function(e20, t2, r2) {
  return e20[t2] = r2, e20;
}, re = Function.toString;
typeof I.inspectSource != "function" && (I.inspectSource = function(e20) {
  return re.call(e20);
});
var ne, oe, ie, se, ue = I.inspectSource, ae = s.WeakMap, ce = typeof ae == "function" && /native code/.test(ue(ae)), le = N("keys"), fe = {}, pe = s.WeakMap;
if (ce || I.state) {
  var he = I.state || (I.state = new pe()), de = he.get, De = he.has, ge = he.set;
  ne = function(e20, t2) {
    if (De.call(he, e20))
      throw new TypeError("Object already initialized");
    return t2.facade = e20, ge.call(he, e20, t2), t2;
  }, oe = function(e20) {
    return de.call(he, e20) || {};
  }, ie = function(e20) {
    return De.call(he, e20);
  };
} else {
  var me = le[se = "state"] || (le[se] = P(se));
  fe[me] = true, ne = function(e20, t2) {
    if (j$4(e20, me))
      throw new TypeError("Object already initialized");
    return t2.facade = e20, te(e20, me, t2), t2;
  }, oe = function(e20) {
    return j$4(e20, me) ? e20[me] : {};
  }, ie = function(e20) {
    return j$4(e20, me);
  };
}
var ve, ye, we = {
  set: ne,
  get: oe,
  has: ie,
  enforce: function(e20) {
    return ie(e20) ? oe(e20) : ne(e20, {});
  },
  getterFor: function(e20) {
    return function(t2) {
      var r2;
      if (!y(t2) || (r2 = oe(t2)).type !== e20)
        throw TypeError("Incompatible receiver, " + e20 + " required");
      return r2;
    };
  }
}, be = r(function(e20) {
  var t2 = we.get, r2 = we.enforce, n2 = String(String).split("String");
  (e20.exports = function(e21, t3, o2, i2) {
    var u2, a2 = !!i2 && !!i2.unsafe, c2 = !!i2 && !!i2.enumerable, l2 = !!i2 && !!i2.noTargetGet;
    typeof o2 == "function" && (typeof t3 != "string" || j$4(o2, "name") || te(o2, "name", t3), (u2 = r2(o2)).source || (u2.source = n2.join(typeof t3 == "string" ? t3 : ""))), e21 !== s ? (a2 ? !l2 && e21[t3] && (c2 = true) : delete e21[t3], c2 ? e21[t3] = o2 : te(e21, t3, o2)) : c2 ? e21[t3] = o2 : T(t3, o2);
  })(Function.prototype, "toString", function() {
    return typeof this == "function" && t2(this).source || ue(this);
  });
}), Ce = Math.ceil, Ee = Math.floor, Fe = function(e20) {
  return isNaN(e20 = +e20) ? 0 : (e20 > 0 ? Ee : Ce)(e20);
}, xe = Math.min, Ae = function(e20) {
  return e20 > 0 ? xe(Fe(e20), 9007199254740991) : 0;
}, ke = Math.max, Oe = Math.min, _e$4 = function(e20) {
  return function(t2, r2, n2) {
    var o2, i2 = v(t2), s2 = Ae(i2.length), u2 = function(e21, t3) {
      var r3 = Fe(e21);
      return r3 < 0 ? ke(r3 + t3, 0) : Oe(r3, t3);
    }(n2, s2);
    if (e20 && r2 != r2) {
      for (; s2 > u2; )
        if ((o2 = i2[u2++]) != o2)
          return true;
    } else
      for (; s2 > u2; u2++)
        if ((e20 || u2 in i2) && i2[u2] === r2)
          return e20 || u2 || 0;
    return !e20 && -1;
  };
}, Se = { includes: _e$4(true), indexOf: _e$4(false) }.indexOf, Te = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf"
].concat("length", "prototype"), Ie = {
  f: Object.getOwnPropertyNames || function(e20) {
    return function(e21, t2) {
      var r2, n2 = v(e21), o2 = 0, i2 = [];
      for (r2 in n2)
        !j$4(fe, r2) && j$4(n2, r2) && i2.push(r2);
      for (; t2.length > o2; )
        j$4(n2, r2 = t2[o2++]) && (~Se(i2, r2) || i2.push(r2));
      return i2;
    }(e20, Te);
  }
}, Ne = { f: Object.getOwnPropertySymbols }, Me = b("Reflect", "ownKeys") || function(e20) {
  var t2 = Ie.f(Z(e20)), r2 = Ne.f;
  return r2 ? t2.concat(r2(e20)) : t2;
}, Re = function(e20, t2) {
  for (var r2 = Me(t2), n2 = ee.f, o2 = K.f, i2 = 0; i2 < r2.length; i2++) {
    var s2 = r2[i2];
    j$4(e20, s2) || n2(e20, s2, o2(t2, s2));
  }
}, je = /#|\.prototype\./, Le = function(e20, t2) {
  var r2 = Pe[Be(e20)];
  return r2 == Ue || r2 != $e && (typeof t2 == "function" ? u(t2) : !!t2);
}, Be = Le.normalize = function(e20) {
  return String(e20).replace(je, ".").toLowerCase();
}, Pe = Le.data = {}, $e = Le.NATIVE = "N", Ue = Le.POLYFILL = "P", Ge = Le, We = K.f, ze = function(e20, t2) {
  var r2, n2, o2, i2, u2, a2 = e20.target, c2 = e20.global, l2 = e20.stat;
  if (r2 = c2 ? s : l2 ? s[a2] || T(a2, {}) : (s[a2] || {}).prototype)
    for (n2 in t2) {
      if (i2 = t2[n2], o2 = e20.noTargetGet ? (u2 = We(r2, n2)) && u2.value : r2[n2], !Ge(c2 ? n2 : a2 + (l2 ? "." : "#") + n2, e20.forced) && o2 !== void 0) {
        if (typeof i2 == typeof o2)
          continue;
        Re(i2, o2);
      }
      (e20.sham || o2 && o2.sham) && te(i2, "sham", true), be(r2, n2, i2, e20);
    }
}, Ve = function(e20) {
  if (typeof e20 != "function")
    throw TypeError(String(e20) + " is not a function");
  return e20;
}, qe = function(e20) {
  if (S(e20))
    throw TypeError("Cannot convert a Symbol value to a string");
  return String(e20);
}, Xe = Math.floor, Je = function(e20, t2) {
  var r2 = e20.length, n2 = Xe(r2 / 2);
  return r2 < 8 ? He(e20, t2) : Ye(Je(e20.slice(0, n2), t2), Je(e20.slice(n2), t2), t2);
}, He = function(e20, t2) {
  for (var r2, n2, o2 = e20.length, i2 = 1; i2 < o2; ) {
    for (n2 = i2, r2 = e20[i2]; n2 && t2(e20[n2 - 1], r2) > 0; )
      e20[n2] = e20[--n2];
    n2 !== i2++ && (e20[n2] = r2);
  }
  return e20;
}, Ye = function(e20, t2, r2) {
  for (var n2 = e20.length, o2 = t2.length, i2 = 0, s2 = 0, u2 = []; i2 < n2 || s2 < o2; )
    i2 < n2 && s2 < o2 ? u2.push(r2(e20[i2], t2[s2]) <= 0 ? e20[i2++] : t2[s2++]) : u2.push(i2 < n2 ? e20[i2++] : t2[s2++]);
  return u2;
}, Ke = Je, Ze = C.match(/firefox\/(\d+)/i), Qe = !!Ze && +Ze[1], et = /MSIE|Trident/.test(C), tt = C.match(/AppleWebKit\/(\d+)\./), rt = !!tt && +tt[1], nt = [], ot = nt.sort, it = u(function() {
  nt.sort(void 0);
}), st = u(function() {
  nt.sort(null);
}), ut = !!(ye = []["sort"]) && u(function() {
  ye.call(null, ve || function() {
    throw 1;
  }, 1);
}), at = !u(function() {
  if (k$4)
    return k$4 < 70;
  if (!(Qe && Qe > 3)) {
    if (et)
      return true;
    if (rt)
      return rt < 603;
    var e20, t2, r2, n2, o2 = "";
    for (e20 = 65; e20 < 76; e20++) {
      switch (t2 = String.fromCharCode(e20), e20) {
        case 66:
        case 69:
        case 70:
        case 72:
          r2 = 3;
          break;
        case 68:
        case 71:
          r2 = 4;
          break;
        default:
          r2 = 2;
      }
      for (n2 = 0; n2 < 47; n2++)
        nt.push({ k: t2 + n2, v: r2 });
    }
    for (nt.sort(function(e21, t3) {
      return t3.v - e21.v;
    }), n2 = 0; n2 < nt.length; n2++)
      t2 = nt[n2].k.charAt(0), o2.charAt(o2.length - 1) !== t2 && (o2 += t2);
    return o2 !== "DGBEFHACIJK";
  }
});
ze({ target: "Array", proto: true, forced: it || !st || !ut || !at }, {
  sort: function(e20) {
    e20 !== void 0 && Ve(e20);
    var t2 = M(this);
    if (at)
      return e20 === void 0 ? ot.call(t2) : ot.call(t2, e20);
    var r2, n2, o2 = [], i2 = Ae(t2.length);
    for (n2 = 0; n2 < i2; n2++)
      n2 in t2 && o2.push(t2[n2]);
    for (r2 = (o2 = Ke(o2, function(e21) {
      return function(t3, r3) {
        return r3 === void 0 ? -1 : t3 === void 0 ? 1 : e21 !== void 0 ? +e21(t3, r3) || 0 : qe(t3) > qe(r3) ? 1 : -1;
      };
    }(e20))).length, n2 = 0; n2 < r2; )
      t2[n2] = o2[n2++];
    for (; n2 < i2; )
      delete t2[n2++];
    return t2;
  }
});
var ct = Array.isArray || function(e20) {
  return d$4(e20) == "Array";
}, lt = function(e20, t2, r2) {
  if (Ve(e20), t2 === void 0)
    return e20;
  switch (r2) {
    case 0:
      return function() {
        return e20.call(t2);
      };
    case 1:
      return function(r3) {
        return e20.call(t2, r3);
      };
    case 2:
      return function(r3, n2) {
        return e20.call(t2, r3, n2);
      };
    case 3:
      return function(r3, n2, o2) {
        return e20.call(t2, r3, n2, o2);
      };
  }
  return function() {
    return e20.apply(t2, arguments);
  };
}, ft = function(e20, t2, r2, n2, o2, i2, s2, u2) {
  for (var a2, c2 = o2, l2 = 0, f2 = !!s2 && lt(s2, u2, 3); l2 < n2; ) {
    if (l2 in r2) {
      if (a2 = f2 ? f2(r2[l2], l2, t2) : r2[l2], i2 > 0 && ct(a2))
        c2 = ft(e20, t2, a2, Ae(a2.length), c2, i2 - 1) - 1;
      else {
        if (c2 >= 9007199254740991)
          throw TypeError("Exceed the acceptable array length");
        e20[c2] = a2;
      }
      c2++;
    }
    l2++;
  }
  return c2;
}, pt = ft, ht = W("species"), dt = function(e20, t2) {
  return new (function(e21) {
    var t3;
    return ct(e21) && (typeof (t3 = e21.constructor) != "function" || t3 !== Array && !ct(t3.prototype) ? y(t3) && (t3 = t3[ht]) === null && (t3 = void 0) : t3 = void 0), t3 === void 0 ? Array : t3;
  }(e20))(t2 === 0 ? 0 : t2);
};
ze({ target: "Array", proto: true }, {
  flatMap: function(e20) {
    var t2, r2 = M(this), n2 = Ae(r2.length);
    return Ve(e20), (t2 = dt(r2, 0)).length = pt(t2, r2, r2, n2, 0, 1, e20, arguments.length > 1 ? arguments[1] : void 0), t2;
  }
});
var Dt = {}, gt = W("iterator"), mt = Array.prototype, vt = {};
vt[W("toStringTag")] = "z";
var yt = String(vt) === "[object z]", wt = W("toStringTag"), bt = d$4(function() {
  return arguments;
}()) == "Arguments", Ct = yt ? d$4 : function(e20) {
  var t2, r2, n2;
  return e20 === void 0 ? "Undefined" : e20 === null ? "Null" : typeof (r2 = function(e21, t3) {
    try {
      return e21[t3];
    } catch (e22) {
    }
  }(t2 = Object(e20), wt)) == "string" ? r2 : bt ? d$4(t2) : (n2 = d$4(t2)) == "Object" && typeof t2.callee == "function" ? "Arguments" : n2;
}, Et = W("iterator"), Ft = function(e20) {
  if (e20 != null)
    return e20[Et] || e20["@@iterator"] || Dt[Ct(e20)];
}, xt = function(e20, t2, r2) {
  var n2, o2;
  Z(e20);
  try {
    if ((n2 = e20.return) === void 0) {
      if (t2 === "throw")
        throw r2;
      return r2;
    }
    n2 = n2.call(e20);
  } catch (e21) {
    o2 = true, n2 = e21;
  }
  if (t2 === "throw")
    throw r2;
  if (o2)
    throw n2;
  return Z(n2), r2;
}, At = function(e20, t2) {
  this.stopped = e20, this.result = t2;
}, kt = function(e20, t2, r2) {
  var n2, o2, i2, s2, u2, a2, c2, l2, f2 = r2 && r2.that, p2 = !(!r2 || !r2.AS_ENTRIES), h2 = !(!r2 || !r2.IS_ITERATOR), d2 = !(!r2 || !r2.INTERRUPTED), D2 = lt(t2, f2, 1 + p2 + d2), g2 = function(e21) {
    return n2 && xt(n2, "normal", e21), new At(true, e21);
  }, m2 = function(e21) {
    return p2 ? (Z(e21), d2 ? D2(e21[0], e21[1], g2) : D2(e21[0], e21[1])) : d2 ? D2(e21, g2) : D2(e21);
  };
  if (h2)
    n2 = e20;
  else {
    if (typeof (o2 = Ft(e20)) != "function")
      throw TypeError("Target is not iterable");
    if ((l2 = o2) !== void 0 && (Dt.Array === l2 || mt[gt] === l2)) {
      for (i2 = 0, s2 = Ae(e20.length); s2 > i2; i2++)
        if ((u2 = m2(e20[i2])) && u2 instanceof At)
          return u2;
      return new At(false);
    }
    n2 = function(e21, t3) {
      var r3 = arguments.length < 2 ? Ft(e21) : t3;
      if (typeof r3 != "function")
        throw TypeError(String(e21) + " is not iterable");
      return Z(r3.call(e21));
    }(e20, o2);
  }
  for (a2 = n2.next; !(c2 = a2.call(n2)).done; ) {
    try {
      u2 = m2(c2.value);
    } catch (e21) {
      xt(n2, "throw", e21);
    }
    if (typeof u2 == "object" && u2 && u2 instanceof At)
      return u2;
  }
  return new At(false);
};
ze({ target: "Object", stat: true }, {
  fromEntries: function(e20) {
    var t2 = {};
    return kt(e20, function(e21, r2) {
      !function(e22, t3, r3) {
        var n2 = q(t3);
        n2 in e22 ? ee.f(e22, n2, p(0, r3)) : e22[n2] = r3;
      }(t2, e21, r2);
    }, { AS_ENTRIES: true }), t2;
  }
});
var Ot = t(r(function(e20, t2) {
  new Function("return this")(), e20.exports = (() => {
    var e21 = {
      2426: (e22) => {
        e22.exports = ({ onlyFirst: e23 = false } = {}) => {
          const t4 = [
            "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
            "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
          ].join("|");
          return new RegExp(t4, e23 ? void 0 : "g");
        };
      },
      118: (e22) => {
        e22.exports = function(e23) {
          if (typeof e23 != "function")
            throw TypeError(String(e23) + " is not a function");
          return e23;
        };
      },
      6956: (e22, t4, r3) => {
        var n2 = r3(2521);
        e22.exports = function(e23) {
          if (!n2(e23))
            throw TypeError(String(e23) + " is not an object");
          return e23;
        };
      },
      9729: (e22, t4, r3) => {
        var n2 = r3(9969), o2 = r3(8331), i2 = r3(1588), s2 = function(e23) {
          return function(t5, r4, s3) {
            var u2, a2 = n2(t5), c2 = o2(a2.length), l2 = i2(s3, c2);
            if (e23 && r4 != r4) {
              for (; c2 > l2; )
                if ((u2 = a2[l2++]) != u2)
                  return true;
            } else
              for (; c2 > l2; l2++)
                if ((e23 || l2 in a2) && a2[l2] === r4)
                  return e23 || l2 || 0;
            return !e23 && -1;
          };
        };
        e22.exports = { includes: s2(true), indexOf: s2(false) };
      },
      9719: (e22, t4, r3) => {
        var n2 = r3(2763);
        e22.exports = function(e23, t5) {
          var r4 = [][e23];
          return !!r4 && n2(function() {
            r4.call(null, t5 || function() {
              throw 1;
            }, 1);
          });
        };
      },
      3407: (e22) => {
        var t4 = Math.floor, r3 = function(e23, i2) {
          var s2 = e23.length, u2 = t4(s2 / 2);
          return s2 < 8 ? n2(e23, i2) : o2(r3(e23.slice(0, u2), i2), r3(e23.slice(u2), i2), i2);
        }, n2 = function(e23, t5) {
          for (var r4, n3, o3 = e23.length, i2 = 1; i2 < o3; ) {
            for (n3 = i2, r4 = e23[i2]; n3 && t5(e23[n3 - 1], r4) > 0; )
              e23[n3] = e23[--n3];
            n3 !== i2++ && (e23[n3] = r4);
          }
          return e23;
        }, o2 = function(e23, t5, r4) {
          for (var n3 = e23.length, o3 = t5.length, i2 = 0, s2 = 0, u2 = []; i2 < n3 || s2 < o3; )
            i2 < n3 && s2 < o3 ? u2.push(r4(e23[i2], t5[s2]) <= 0 ? e23[i2++] : t5[s2++]) : u2.push(i2 < n3 ? e23[i2++] : t5[s2++]);
          return u2;
        };
        e22.exports = r3;
      },
      2021: (e22, t4, r3) => {
        var n2 = r3(2521), o2 = r3(3964), i2 = r3(1386)("species");
        e22.exports = function(e23) {
          var t5;
          return o2(e23) && (typeof (t5 = e23.constructor) != "function" || t5 !== Array && !o2(t5.prototype) ? n2(t5) && (t5 = t5[i2]) === null && (t5 = void 0) : t5 = void 0), t5 === void 0 ? Array : t5;
        };
      },
      8347: (e22, t4, r3) => {
        var n2 = r3(2021);
        e22.exports = function(e23, t5) {
          return new (n2(e23))(t5 === 0 ? 0 : t5);
        };
      },
      2849: (e22) => {
        var t4 = {}.toString;
        e22.exports = function(e23) {
          return t4.call(e23).slice(8, -1);
        };
      },
      9538: (e22, t4, r3) => {
        var n2 = r3(6395), o2 = r3(2849), i2 = r3(1386)("toStringTag"), s2 = o2(function() {
          return arguments;
        }()) == "Arguments";
        e22.exports = n2 ? o2 : function(e23) {
          var t5, r4, n3;
          return e23 === void 0 ? "Undefined" : e23 === null ? "Null" : typeof (r4 = function(e24, t6) {
            try {
              return e24[t6];
            } catch (e25) {
            }
          }(t5 = Object(e23), i2)) == "string" ? r4 : s2 ? o2(t5) : (n3 = o2(t5)) == "Object" && typeof t5.callee == "function" ? "Arguments" : n3;
        };
      },
      4488: (e22, t4, r3) => {
        var n2 = r3(2766), o2 = r3(9593), i2 = r3(8769), s2 = r3(7455);
        e22.exports = function(e23, t5) {
          for (var r4 = o2(t5), u2 = s2.f, a2 = i2.f, c2 = 0; c2 < r4.length; c2++) {
            var l2 = r4[c2];
            n2(e23, l2) || u2(e23, l2, a2(t5, l2));
          }
        };
      },
      1471: (e22, t4, r3) => {
        var n2 = r3(7703), o2 = r3(7455), i2 = r3(5938);
        e22.exports = n2 ? function(e23, t5, r4) {
          return o2.f(e23, t5, i2(1, r4));
        } : function(e23, t5, r4) {
          return e23[t5] = r4, e23;
        };
      },
      5938: (e22) => {
        e22.exports = function(e23, t4) {
          return {
            enumerable: !(1 & e23),
            configurable: !(2 & e23),
            writable: !(4 & e23),
            value: t4
          };
        };
      },
      2385: (e22, t4, r3) => {
        var n2 = r3(5224), o2 = r3(7455), i2 = r3(5938);
        e22.exports = function(e23, t5, r4) {
          var s2 = n2(t5);
          s2 in e23 ? o2.f(e23, s2, i2(0, r4)) : e23[s2] = r4;
        };
      },
      7703: (e22, t4, r3) => {
        var n2 = r3(2763);
        e22.exports = !n2(function() {
          return Object.defineProperty({}, 1, {
            get: function() {
              return 7;
            }
          })[1] != 7;
        });
      },
      6004: (e22, t4, r3) => {
        var n2 = r3(6121), o2 = r3(2521), i2 = n2.document, s2 = o2(i2) && o2(i2.createElement);
        e22.exports = function(e23) {
          return s2 ? i2.createElement(e23) : {};
        };
      },
      5249: (e22, t4, r3) => {
        var n2 = r3(8635).match(/firefox\/(\d+)/i);
        e22.exports = !!n2 && +n2[1];
      },
      2049: (e22, t4, r3) => {
        var n2 = r3(8635);
        e22.exports = /MSIE|Trident/.test(n2);
      },
      8635: (e22, t4, r3) => {
        var n2 = r3(7642);
        e22.exports = n2("navigator", "userAgent") || "";
      },
      6962: (e22, t4, r3) => {
        var n2, o2, i2 = r3(6121), s2 = r3(8635), u2 = i2.process, a2 = i2.Deno, c2 = u2 && u2.versions || a2 && a2.version, l2 = c2 && c2.v8;
        l2 ? o2 = (n2 = l2.split("."))[0] < 4 ? 1 : n2[0] + n2[1] : s2 && (!(n2 = s2.match(/Edge\/(\d+)/)) || n2[1] >= 74) && (n2 = s2.match(/Chrome\/(\d+)/)) && (o2 = n2[1]), e22.exports = o2 && +o2;
      },
      8998: (e22, t4, r3) => {
        var n2 = r3(8635).match(/AppleWebKit\/(\d+)\./);
        e22.exports = !!n2 && +n2[1];
      },
      4731: (e22) => {
        e22.exports = [
          "constructor",
          "hasOwnProperty",
          "isPrototypeOf",
          "propertyIsEnumerable",
          "toLocaleString",
          "toString",
          "valueOf"
        ];
      },
      7309: (e22, t4, r3) => {
        var n2 = r3(6121), o2 = r3(8769).f, i2 = r3(1471), s2 = r3(2327), u2 = r3(6565), a2 = r3(4488), c2 = r3(676);
        e22.exports = function(e23, t5) {
          var r4, l2, f2, p2, h2, d2 = e23.target, D2 = e23.global, g2 = e23.stat;
          if (r4 = D2 ? n2 : g2 ? n2[d2] || u2(d2, {}) : (n2[d2] || {}).prototype)
            for (l2 in t5) {
              if (p2 = t5[l2], f2 = e23.noTargetGet ? (h2 = o2(r4, l2)) && h2.value : r4[l2], !c2(D2 ? l2 : d2 + (g2 ? "." : "#") + l2, e23.forced) && f2 !== void 0) {
                if (typeof p2 == typeof f2)
                  continue;
                a2(p2, f2);
              }
              (e23.sham || f2 && f2.sham) && i2(p2, "sham", true), s2(r4, l2, p2, e23);
            }
        };
      },
      2763: (e22) => {
        e22.exports = function(e23) {
          try {
            return !!e23();
          } catch (e24) {
            return true;
          }
        };
      },
      5538: (e22, t4, r3) => {
        var n2 = r3(3964), o2 = r3(8331), i2 = r3(3322), s2 = function(e23, t5, r4, u2, a2, c2, l2, f2) {
          for (var p2, h2 = a2, d2 = 0, D2 = !!l2 && i2(l2, f2, 3); d2 < u2; ) {
            if (d2 in r4) {
              if (p2 = D2 ? D2(r4[d2], d2, t5) : r4[d2], c2 > 0 && n2(p2))
                h2 = s2(e23, t5, p2, o2(p2.length), h2, c2 - 1) - 1;
              else {
                if (h2 >= 9007199254740991)
                  throw TypeError("Exceed the acceptable array length");
                e23[h2] = p2;
              }
              h2++;
            }
            d2++;
          }
          return h2;
        };
        e22.exports = s2;
      },
      3322: (e22, t4, r3) => {
        var n2 = r3(118);
        e22.exports = function(e23, t5, r4) {
          if (n2(e23), t5 === void 0)
            return e23;
          switch (r4) {
            case 0:
              return function() {
                return e23.call(t5);
              };
            case 1:
              return function(r5) {
                return e23.call(t5, r5);
              };
            case 2:
              return function(r5, n3) {
                return e23.call(t5, r5, n3);
              };
            case 3:
              return function(r5, n3, o2) {
                return e23.call(t5, r5, n3, o2);
              };
          }
          return function() {
            return e23.apply(t5, arguments);
          };
        };
      },
      7642: (e22, t4, r3) => {
        var n2 = r3(6121), o2 = function(e23) {
          return typeof e23 == "function" ? e23 : void 0;
        };
        e22.exports = function(e23, t5) {
          return arguments.length < 2 ? o2(n2[e23]) : n2[e23] && n2[e23][t5];
        };
      },
      5111: (e22, t4, r3) => {
        var n2 = r3(9538), o2 = r3(3403), i2 = r3(1386)("iterator");
        e22.exports = function(e23) {
          if (e23 != null)
            return e23[i2] || e23["@@iterator"] || o2[n2(e23)];
        };
      },
      8977: (e22, t4, r3) => {
        var n2 = r3(6956), o2 = r3(5111);
        e22.exports = function(e23, t5) {
          var r4 = arguments.length < 2 ? o2(e23) : t5;
          if (typeof r4 != "function")
            throw TypeError(String(e23) + " is not iterable");
          return n2(r4.call(e23));
        };
      },
      6121: (e22, t4, r3) => {
        var n2 = function(e23) {
          return e23 && e23.Math == Math && e23;
        };
        e22.exports = n2(typeof globalThis == "object" && globalThis) || n2(typeof window == "object" && window) || n2(typeof self == "object" && self) || n2(typeof r3.g == "object" && r3.g) || function() {
          return this;
        }() || Function("return this")();
      },
      2766: (e22, t4, r3) => {
        var n2 = r3(4766), o2 = {}.hasOwnProperty;
        e22.exports = Object.hasOwn || function(e23, t5) {
          return o2.call(n2(e23), t5);
        };
      },
      2048: (e22) => {
        e22.exports = {};
      },
      7226: (e22, t4, r3) => {
        var n2 = r3(7703), o2 = r3(2763), i2 = r3(6004);
        e22.exports = !n2 && !o2(function() {
          return Object.defineProperty(i2("div"), "a", {
            get: function() {
              return 7;
            }
          }).a != 7;
        });
      },
      3169: (e22, t4, r3) => {
        var n2 = r3(2763), o2 = r3(2849), i2 = "".split;
        e22.exports = n2(function() {
          return !Object("z").propertyIsEnumerable(0);
        }) ? function(e23) {
          return o2(e23) == "String" ? i2.call(e23, "") : Object(e23);
        } : Object;
      },
      9835: (e22, t4, r3) => {
        var n2 = r3(4682), o2 = Function.toString;
        typeof n2.inspectSource != "function" && (n2.inspectSource = function(e23) {
          return o2.call(e23);
        }), e22.exports = n2.inspectSource;
      },
      2995: (e22, t4, r3) => {
        var n2, o2, i2, s2 = r3(5546), u2 = r3(6121), a2 = r3(2521), c2 = r3(1471), l2 = r3(2766), f2 = r3(4682), p2 = r3(2562), h2 = r3(2048), d2 = "Object already initialized", D2 = u2.WeakMap;
        if (s2 || f2.state) {
          var g2 = f2.state || (f2.state = new D2()), m2 = g2.get, v2 = g2.has, y2 = g2.set;
          n2 = function(e23, t5) {
            if (v2.call(g2, e23))
              throw new TypeError(d2);
            return t5.facade = e23, y2.call(g2, e23, t5), t5;
          }, o2 = function(e23) {
            return m2.call(g2, e23) || {};
          }, i2 = function(e23) {
            return v2.call(g2, e23);
          };
        } else {
          var w2 = p2("state");
          h2[w2] = true, n2 = function(e23, t5) {
            if (l2(e23, w2))
              throw new TypeError(d2);
            return t5.facade = e23, c2(e23, w2, t5), t5;
          }, o2 = function(e23) {
            return l2(e23, w2) ? e23[w2] : {};
          }, i2 = function(e23) {
            return l2(e23, w2);
          };
        }
        e22.exports = {
          set: n2,
          get: o2,
          has: i2,
          enforce: function(e23) {
            return i2(e23) ? o2(e23) : n2(e23, {});
          },
          getterFor: function(e23) {
            return function(t5) {
              var r4;
              if (!a2(t5) || (r4 = o2(t5)).type !== e23)
                throw TypeError("Incompatible receiver, " + e23 + " required");
              return r4;
            };
          }
        };
      },
      9439: (e22, t4, r3) => {
        var n2 = r3(1386), o2 = r3(3403), i2 = n2("iterator"), s2 = Array.prototype;
        e22.exports = function(e23) {
          return e23 !== void 0 && (o2.Array === e23 || s2[i2] === e23);
        };
      },
      3964: (e22, t4, r3) => {
        var n2 = r3(2849);
        e22.exports = Array.isArray || function(e23) {
          return n2(e23) == "Array";
        };
      },
      676: (e22, t4, r3) => {
        var n2 = r3(2763), o2 = /#|\.prototype\./, i2 = function(e23, t5) {
          var r4 = u2[s2(e23)];
          return r4 == c2 || r4 != a2 && (typeof t5 == "function" ? n2(t5) : !!t5);
        }, s2 = i2.normalize = function(e23) {
          return String(e23).replace(o2, ".").toLowerCase();
        }, u2 = i2.data = {}, a2 = i2.NATIVE = "N", c2 = i2.POLYFILL = "P";
        e22.exports = i2;
      },
      2521: (e22) => {
        e22.exports = function(e23) {
          return typeof e23 == "object" ? e23 !== null : typeof e23 == "function";
        };
      },
      8451: (e22) => {
        e22.exports = false;
      },
      5057: (e22, t4, r3) => {
        var n2 = r3(7642), o2 = r3(2020);
        e22.exports = o2 ? function(e23) {
          return typeof e23 == "symbol";
        } : function(e23) {
          var t5 = n2("Symbol");
          return typeof t5 == "function" && Object(e23) instanceof t5;
        };
      },
      4572: (e22, t4, r3) => {
        var n2 = r3(6956), o2 = r3(9439), i2 = r3(8331), s2 = r3(3322), u2 = r3(8977), a2 = r3(5111), c2 = r3(4556), l2 = function(e23, t5) {
          this.stopped = e23, this.result = t5;
        };
        e22.exports = function(e23, t5, r4) {
          var f2, p2, h2, d2, D2, g2, m2, v2 = r4 && r4.that, y2 = !(!r4 || !r4.AS_ENTRIES), w2 = !(!r4 || !r4.IS_ITERATOR), b2 = !(!r4 || !r4.INTERRUPTED), C2 = s2(t5, v2, 1 + y2 + b2), E2 = function(e24) {
            return f2 && c2(f2, "normal", e24), new l2(true, e24);
          }, F2 = function(e24) {
            return y2 ? (n2(e24), b2 ? C2(e24[0], e24[1], E2) : C2(e24[0], e24[1])) : b2 ? C2(e24, E2) : C2(e24);
          };
          if (w2)
            f2 = e23;
          else {
            if (typeof (p2 = a2(e23)) != "function")
              throw TypeError("Target is not iterable");
            if (o2(p2)) {
              for (h2 = 0, d2 = i2(e23.length); d2 > h2; h2++)
                if ((D2 = F2(e23[h2])) && D2 instanceof l2)
                  return D2;
              return new l2(false);
            }
            f2 = u2(e23, p2);
          }
          for (g2 = f2.next; !(m2 = g2.call(f2)).done; ) {
            try {
              D2 = F2(m2.value);
            } catch (e24) {
              c2(f2, "throw", e24);
            }
            if (typeof D2 == "object" && D2 && D2 instanceof l2)
              return D2;
          }
          return new l2(false);
        };
      },
      4556: (e22, t4, r3) => {
        var n2 = r3(6956);
        e22.exports = function(e23, t5, r4) {
          var o2, i2;
          n2(e23);
          try {
            if ((o2 = e23.return) === void 0) {
              if (t5 === "throw")
                throw r4;
              return r4;
            }
            o2 = o2.call(e23);
          } catch (e24) {
            i2 = true, o2 = e24;
          }
          if (t5 === "throw")
            throw r4;
          if (i2)
            throw o2;
          return n2(o2), r4;
        };
      },
      3403: (e22) => {
        e22.exports = {};
      },
      4020: (e22, t4, r3) => {
        var n2 = r3(6962), o2 = r3(2763);
        e22.exports = !!Object.getOwnPropertySymbols && !o2(function() {
          var e23 = Symbol();
          return !String(e23) || !(Object(e23) instanceof Symbol) || !Symbol.sham && n2 && n2 < 41;
        });
      },
      5546: (e22, t4, r3) => {
        var n2 = r3(6121), o2 = r3(9835), i2 = n2.WeakMap;
        e22.exports = typeof i2 == "function" && /native code/.test(o2(i2));
      },
      7455: (e22, t4, r3) => {
        var n2 = r3(7703), o2 = r3(7226), i2 = r3(6956), s2 = r3(5224), u2 = Object.defineProperty;
        t4.f = n2 ? u2 : function(e23, t5, r4) {
          if (i2(e23), t5 = s2(t5), i2(r4), o2)
            try {
              return u2(e23, t5, r4);
            } catch (e24) {
            }
          if ("get" in r4 || "set" in r4)
            throw TypeError("Accessors not supported");
          return "value" in r4 && (e23[t5] = r4.value), e23;
        };
      },
      8769: (e22, t4, r3) => {
        var n2 = r3(7703), o2 = r3(7751), i2 = r3(5938), s2 = r3(9969), u2 = r3(5224), a2 = r3(2766), c2 = r3(7226), l2 = Object.getOwnPropertyDescriptor;
        t4.f = n2 ? l2 : function(e23, t5) {
          if (e23 = s2(e23), t5 = u2(t5), c2)
            try {
              return l2(e23, t5);
            } catch (e24) {
            }
          if (a2(e23, t5))
            return i2(!o2.f.call(e23, t5), e23[t5]);
        };
      },
      2042: (e22, t4, r3) => {
        var n2 = r3(3224), o2 = r3(4731).concat("length", "prototype");
        t4.f = Object.getOwnPropertyNames || function(e23) {
          return n2(e23, o2);
        };
      },
      2719: (e22, t4) => {
        t4.f = Object.getOwnPropertySymbols;
      },
      3224: (e22, t4, r3) => {
        var n2 = r3(2766), o2 = r3(9969), i2 = r3(9729).indexOf, s2 = r3(2048);
        e22.exports = function(e23, t5) {
          var r4, u2 = o2(e23), a2 = 0, c2 = [];
          for (r4 in u2)
            !n2(s2, r4) && n2(u2, r4) && c2.push(r4);
          for (; t5.length > a2; )
            n2(u2, r4 = t5[a2++]) && (~i2(c2, r4) || c2.push(r4));
          return c2;
        };
      },
      7751: (e22, t4) => {
        var r3 = {}.propertyIsEnumerable, n2 = Object.getOwnPropertyDescriptor, o2 = n2 && !r3.call({ 1: 2 }, 1);
        t4.f = o2 ? function(e23) {
          var t5 = n2(this, e23);
          return !!t5 && t5.enumerable;
        } : r3;
      },
      1047: (e22, t4, r3) => {
        var n2 = r3(2521);
        e22.exports = function(e23, t5) {
          var r4, o2;
          if (t5 === "string" && typeof (r4 = e23.toString) == "function" && !n2(o2 = r4.call(e23)))
            return o2;
          if (typeof (r4 = e23.valueOf) == "function" && !n2(o2 = r4.call(e23)))
            return o2;
          if (t5 !== "string" && typeof (r4 = e23.toString) == "function" && !n2(o2 = r4.call(e23)))
            return o2;
          throw TypeError("Can't convert object to primitive value");
        };
      },
      9593: (e22, t4, r3) => {
        var n2 = r3(7642), o2 = r3(2042), i2 = r3(2719), s2 = r3(6956);
        e22.exports = n2("Reflect", "ownKeys") || function(e23) {
          var t5 = o2.f(s2(e23)), r4 = i2.f;
          return r4 ? t5.concat(r4(e23)) : t5;
        };
      },
      2327: (e22, t4, r3) => {
        var n2 = r3(6121), o2 = r3(1471), i2 = r3(2766), s2 = r3(6565), u2 = r3(9835), a2 = r3(2995), c2 = a2.get, l2 = a2.enforce, f2 = String(String).split("String");
        (e22.exports = function(e23, t5, r4, u3) {
          var a3, c3 = !!u3 && !!u3.unsafe, p2 = !!u3 && !!u3.enumerable, h2 = !!u3 && !!u3.noTargetGet;
          typeof r4 == "function" && (typeof t5 != "string" || i2(r4, "name") || o2(r4, "name", t5), (a3 = l2(r4)).source || (a3.source = f2.join(typeof t5 == "string" ? t5 : ""))), e23 !== n2 ? (c3 ? !h2 && e23[t5] && (p2 = true) : delete e23[t5], p2 ? e23[t5] = r4 : o2(e23, t5, r4)) : p2 ? e23[t5] = r4 : s2(t5, r4);
        })(Function.prototype, "toString", function() {
          return typeof this == "function" && c2(this).source || u2(this);
        });
      },
      7263: (e22) => {
        e22.exports = function(e23) {
          if (e23 == null)
            throw TypeError("Can't call method on " + e23);
          return e23;
        };
      },
      6565: (e22, t4, r3) => {
        var n2 = r3(6121);
        e22.exports = function(e23, t5) {
          try {
            Object.defineProperty(n2, e23, {
              value: t5,
              configurable: true,
              writable: true
            });
          } catch (r4) {
            n2[e23] = t5;
          }
          return t5;
        };
      },
      2562: (e22, t4, r3) => {
        var n2 = r3(896), o2 = r3(1735), i2 = n2("keys");
        e22.exports = function(e23) {
          return i2[e23] || (i2[e23] = o2(e23));
        };
      },
      4682: (e22, t4, r3) => {
        var n2 = r3(6121), o2 = r3(6565), i2 = "__core-js_shared__", s2 = n2[i2] || o2(i2, {});
        e22.exports = s2;
      },
      896: (e22, t4, r3) => {
        var n2 = r3(8451), o2 = r3(4682);
        (e22.exports = function(e23, t5) {
          return o2[e23] || (o2[e23] = t5 !== void 0 ? t5 : {});
        })("versions", []).push({
          version: "3.17.3",
          mode: n2 ? "pure" : "global",
          copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)"
        });
      },
      1588: (e22, t4, r3) => {
        var n2 = r3(5623), o2 = Math.max, i2 = Math.min;
        e22.exports = function(e23, t5) {
          var r4 = n2(e23);
          return r4 < 0 ? o2(r4 + t5, 0) : i2(r4, t5);
        };
      },
      9969: (e22, t4, r3) => {
        var n2 = r3(3169), o2 = r3(7263);
        e22.exports = function(e23) {
          return n2(o2(e23));
        };
      },
      5623: (e22) => {
        var t4 = Math.ceil, r3 = Math.floor;
        e22.exports = function(e23) {
          return isNaN(e23 = +e23) ? 0 : (e23 > 0 ? r3 : t4)(e23);
        };
      },
      8331: (e22, t4, r3) => {
        var n2 = r3(5623), o2 = Math.min;
        e22.exports = function(e23) {
          return e23 > 0 ? o2(n2(e23), 9007199254740991) : 0;
        };
      },
      4766: (e22, t4, r3) => {
        var n2 = r3(7263);
        e22.exports = function(e23) {
          return Object(n2(e23));
        };
      },
      687: (e22, t4, r3) => {
        var n2 = r3(2521), o2 = r3(5057), i2 = r3(1047), s2 = r3(1386)("toPrimitive");
        e22.exports = function(e23, t5) {
          if (!n2(e23) || o2(e23))
            return e23;
          var r4, u2 = e23[s2];
          if (u2 !== void 0) {
            if (t5 === void 0 && (t5 = "default"), r4 = u2.call(e23, t5), !n2(r4) || o2(r4))
              return r4;
            throw TypeError("Can't convert object to primitive value");
          }
          return t5 === void 0 && (t5 = "number"), i2(e23, t5);
        };
      },
      5224: (e22, t4, r3) => {
        var n2 = r3(687), o2 = r3(5057);
        e22.exports = function(e23) {
          var t5 = n2(e23, "string");
          return o2(t5) ? t5 : String(t5);
        };
      },
      6395: (e22, t4, r3) => {
        var n2 = {};
        n2[r3(1386)("toStringTag")] = "z", e22.exports = String(n2) === "[object z]";
      },
      3710: (e22, t4, r3) => {
        var n2 = r3(5057);
        e22.exports = function(e23) {
          if (n2(e23))
            throw TypeError("Cannot convert a Symbol value to a string");
          return String(e23);
        };
      },
      1735: (e22) => {
        var t4 = 0, r3 = Math.random();
        e22.exports = function(e23) {
          return "Symbol(" + String(e23 === void 0 ? "" : e23) + ")_" + (++t4 + r3).toString(36);
        };
      },
      2020: (e22, t4, r3) => {
        var n2 = r3(4020);
        e22.exports = n2 && !Symbol.sham && typeof Symbol.iterator == "symbol";
      },
      1386: (e22, t4, r3) => {
        var n2 = r3(6121), o2 = r3(896), i2 = r3(2766), s2 = r3(1735), u2 = r3(4020), a2 = r3(2020), c2 = o2("wks"), l2 = n2.Symbol, f2 = a2 ? l2 : l2 && l2.withoutSetter || s2;
        e22.exports = function(e23) {
          return i2(c2, e23) && (u2 || typeof c2[e23] == "string") || (u2 && i2(l2, e23) ? c2[e23] = l2[e23] : c2[e23] = f2("Symbol." + e23)), c2[e23];
        };
      },
      4304: (e22, t4, r3) => {
        var n2 = r3(7309), o2 = r3(5538), i2 = r3(4766), s2 = r3(8331), u2 = r3(118), a2 = r3(8347);
        n2({ target: "Array", proto: true }, {
          flatMap: function(e23) {
            var t5, r4 = i2(this), n3 = s2(r4.length);
            return u2(e23), (t5 = a2(r4, 0)).length = o2(t5, r4, r4, n3, 0, 1, e23, arguments.length > 1 ? arguments[1] : void 0), t5;
          }
        });
      },
      4070: (e22, t4, r3) => {
        var n2 = r3(7309), o2 = r3(118), i2 = r3(4766), s2 = r3(8331), u2 = r3(3710), a2 = r3(2763), c2 = r3(3407), l2 = r3(9719), f2 = r3(5249), p2 = r3(2049), h2 = r3(6962), d2 = r3(8998), D2 = [], g2 = D2.sort, m2 = a2(function() {
          D2.sort(void 0);
        }), v2 = a2(function() {
          D2.sort(null);
        }), y2 = l2("sort"), w2 = !a2(function() {
          if (h2)
            return h2 < 70;
          if (!(f2 && f2 > 3)) {
            if (p2)
              return true;
            if (d2)
              return d2 < 603;
            var e23, t5, r4, n3, o3 = "";
            for (e23 = 65; e23 < 76; e23++) {
              switch (t5 = String.fromCharCode(e23), e23) {
                case 66:
                case 69:
                case 70:
                case 72:
                  r4 = 3;
                  break;
                case 68:
                case 71:
                  r4 = 4;
                  break;
                default:
                  r4 = 2;
              }
              for (n3 = 0; n3 < 47; n3++)
                D2.push({ k: t5 + n3, v: r4 });
            }
            for (D2.sort(function(e24, t6) {
              return t6.v - e24.v;
            }), n3 = 0; n3 < D2.length; n3++)
              t5 = D2[n3].k.charAt(0), o3.charAt(o3.length - 1) !== t5 && (o3 += t5);
            return o3 !== "DGBEFHACIJK";
          }
        });
        n2({
          target: "Array",
          proto: true,
          forced: m2 || !v2 || !y2 || !w2
        }, {
          sort: function(e23) {
            e23 !== void 0 && o2(e23);
            var t5 = i2(this);
            if (w2)
              return e23 === void 0 ? g2.call(t5) : g2.call(t5, e23);
            var r4, n3, a3 = [], l3 = s2(t5.length);
            for (n3 = 0; n3 < l3; n3++)
              n3 in t5 && a3.push(t5[n3]);
            for (r4 = (a3 = c2(a3, function(e24) {
              return function(t6, r5) {
                return r5 === void 0 ? -1 : t6 === void 0 ? 1 : e24 !== void 0 ? +e24(t6, r5) || 0 : u2(t6) > u2(r5) ? 1 : -1;
              };
            }(e23))).length, n3 = 0; n3 < r4; )
              t5[n3] = a3[n3++];
            for (; n3 < l3; )
              delete t5[n3++];
            return t5;
          }
        });
      },
      2612: (e22, t4, r3) => {
        var n2 = r3(7309), o2 = r3(4572), i2 = r3(2385);
        n2({ target: "Object", stat: true }, {
          fromEntries: function(e23) {
            var t5 = {};
            return o2(e23, function(e24, r4) {
              i2(t5, e24, r4);
            }, { AS_ENTRIES: true }), t5;
          }
        });
      },
      3584: (e22) => {
        const t4 = (e23) => {
          if (typeof e23 != "string")
            throw new TypeError("Expected a string");
          const t5 = e23.match(/(?:\r?\n)/g) || [];
          if (t5.length === 0)
            return;
          const r3 = t5.filter((e24) => e24 === "\r\n").length;
          return r3 > t5.length - r3 ? "\r\n" : "\n";
        };
        e22.exports = t4, e22.exports.graceful = (e23) => typeof e23 == "string" && t4(e23) || "\n";
      },
      541: (e22) => {
        e22.exports = function() {
          return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
        };
      },
      2240: (e22) => {
        e22.exports = (e23) => {
          if (typeof e23 != "string")
            throw new TypeError("Expected a string");
          return e23.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
        };
      },
      8051: (e22) => {
        e22.exports = function(e23, t4) {
          return (t4 = typeof t4 == "number" ? t4 : 1 / 0) ? function e24(r3, n2) {
            return r3.reduce(function(r4, o2) {
              return Array.isArray(o2) && n2 < t4 ? r4.concat(e24(o2, n2 + 1)) : r4.concat(o2);
            }, []);
          }(e23, 1) : Array.isArray(e23) ? e23.map(function(e24) {
            return e24;
          }) : e23;
        };
      },
      7886: (e22) => {
        e22.exports = function(e23, t4) {
          for (var r3 = -1, n2 = []; (r3 = e23.indexOf(t4, r3 + 1)) !== -1; )
            n2.push(r3);
          return n2;
        };
      },
      8528: (e22) => {
        const t4 = (e23) => !Number.isNaN(e23) && e23 >= 4352 && (e23 <= 4447 || e23 === 9001 || e23 === 9002 || 11904 <= e23 && e23 <= 12871 && e23 !== 12351 || 12880 <= e23 && e23 <= 19903 || 19968 <= e23 && e23 <= 42182 || 43360 <= e23 && e23 <= 43388 || 44032 <= e23 && e23 <= 55203 || 63744 <= e23 && e23 <= 64255 || 65040 <= e23 && e23 <= 65049 || 65072 <= e23 && e23 <= 65131 || 65281 <= e23 && e23 <= 65376 || 65504 <= e23 && e23 <= 65510 || 110592 <= e23 && e23 <= 110593 || 127488 <= e23 && e23 <= 127569 || 131072 <= e23 && e23 <= 262141);
        e22.exports = t4, e22.exports.default = t4;
      },
      9234: (e22, t4, r3) => {
        function n2() {
          const e23 = r3(4372);
          return n2 = function() {
            return e23;
          }, e23;
        }
        function o2() {
          const e23 = (t5 = r3(3584)) && t5.__esModule ? t5 : { default: t5 };
          var t5;
          return o2 = function() {
            return e23;
          }, e23;
        }
        Object.defineProperty(t4, "__esModule", {
          value: true
        }), t4.extract = function(e23) {
          const t5 = e23.match(u2);
          return t5 ? t5[0].trimLeft() : "";
        }, t4.strip = function(e23) {
          const t5 = e23.match(u2);
          return t5 && t5[0] ? e23.substring(t5[0].length) : e23;
        }, t4.parse = function(e23) {
          return d2(e23).pragmas;
        }, t4.parseWithComments = d2, t4.print = function({
          comments: e23 = "",
          pragmas: t5 = {}
        }) {
          const r4 = (0, o2().default)(e23) || n2().EOL, i3 = " *", s3 = Object.keys(t5), u3 = s3.map((e24) => D2(e24, t5[e24])).reduce((e24, t6) => e24.concat(t6), []).map((e24) => " * " + e24 + r4).join("");
          if (!e23) {
            if (s3.length === 0)
              return "";
            if (s3.length === 1 && !Array.isArray(t5[s3[0]])) {
              const e24 = t5[s3[0]];
              return `/** ${D2(s3[0], e24)[0]} */`;
            }
          }
          const a3 = e23.split(r4).map((e24) => ` * ${e24}`).join(r4) + r4;
          return "/**" + r4 + (e23 ? a3 : "") + (e23 && s3.length ? i3 + r4 : "") + u3 + " */";
        };
        const i2 = /\*\/$/, s2 = /^\/\*\*/, u2 = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, a2 = /(^|\s+)\/\/([^\r\n]*)/g, c2 = /^(\r?\n)+/, l2 = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, f2 = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, p2 = /(\r?\n|^) *\* ?/g, h2 = [];
        function d2(e23) {
          const t5 = (0, o2().default)(e23) || n2().EOL;
          e23 = e23.replace(s2, "").replace(i2, "").replace(p2, "$1");
          let r4 = "";
          for (; r4 !== e23; )
            r4 = e23, e23 = e23.replace(l2, `${t5}$1 $2${t5}`);
          e23 = e23.replace(c2, "").trimRight();
          const u3 = Object.create(null), d3 = e23.replace(f2, "").replace(c2, "").trimRight();
          let D3;
          for (; D3 = f2.exec(e23); ) {
            const e24 = D3[2].replace(a2, "");
            typeof u3[D3[1]] == "string" || Array.isArray(u3[D3[1]]) ? u3[D3[1]] = h2.concat(u3[D3[1]], e24) : u3[D3[1]] = e24;
          }
          return { comments: d3, pragmas: u3 };
        }
        function D2(e23, t5) {
          return h2.concat(t5).map((t6) => `@${e23} ${t6}`.trim());
        }
      },
      5311: (e22, t4, r3) => {
        function n2() {
          for (var e23 = [], t5 = 0; t5 < arguments.length; t5++)
            e23[t5] = arguments[t5];
        }
        function o2() {
          return typeof WeakMap != "undefined" ? new WeakMap() : {
            add: n2,
            delete: n2,
            get: n2,
            set: n2,
            has: function(e23) {
              return false;
            }
          };
        }
        r3.r(t4), r3.d(t4, { default: () => m2, outdent: () => g2 }), e22 = r3.hmd(e22);
        var i2 = Object.prototype.hasOwnProperty, s2 = function(e23, t5) {
          return i2.call(e23, t5);
        };
        function u2(e23, t5) {
          for (var r4 in t5)
            s2(t5, r4) && (e23[r4] = t5[r4]);
          return e23;
        }
        var a2 = /^[ \t]*(?:\r\n|\r|\n)/, c2 = /(?:\r\n|\r|\n)[ \t]*$/, l2 = /^(?:[\r\n]|$)/, f2 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, p2 = /^[ \t]*[\r\n][ \t\r\n]*$/;
        function h2(e23, t5, r4) {
          var n3 = 0, o3 = e23[0].match(f2);
          o3 && (n3 = o3[1].length);
          var i3 = new RegExp("(\\r\\n|\\r|\\n).{0," + n3 + "}", "g");
          t5 && (e23 = e23.slice(1));
          var s3 = r4.newline, u3 = r4.trimLeadingNewline, l3 = r4.trimTrailingNewline, p3 = typeof s3 == "string", h3 = e23.length;
          return e23.map(function(e24, t6) {
            return e24 = e24.replace(i3, "$1"), t6 === 0 && u3 && (e24 = e24.replace(a2, "")), t6 === h3 - 1 && l3 && (e24 = e24.replace(c2, "")), p3 && (e24 = e24.replace(/\r\n|\n|\r/g, function(e25) {
              return s3;
            })), e24;
          });
        }
        function d2(e23, t5) {
          for (var r4 = "", n3 = 0, o3 = e23.length; n3 < o3; n3++)
            r4 += e23[n3], n3 < o3 - 1 && (r4 += t5[n3]);
          return r4;
        }
        function D2(e23) {
          return s2(e23, "raw") && s2(e23, "length");
        }
        var g2 = function e23(t5) {
          var r4 = o2(), n3 = o2();
          return u2(function o3(i3) {
            for (var s3 = [], a3 = 1; a3 < arguments.length; a3++)
              s3[a3 - 1] = arguments[a3];
            if (D2(i3)) {
              var c3 = i3, f3 = (s3[0] === o3 || s3[0] === g2) && p2.test(c3[0]) && l2.test(c3[1]), m3 = f3 ? n3 : r4, v2 = m3.get(c3);
              return v2 || (v2 = h2(c3, f3, t5), m3.set(c3, v2)), s3.length === 0 ? v2[0] : d2(v2, f3 ? s3.slice(1) : s3);
            }
            return e23(u2(u2({}, t5), i3 || {}));
          }, {
            string: function(e24) {
              return h2([e24], false, t5)[0];
            }
          });
        }({
          trimLeadingNewline: true,
          trimTrailingNewline: true
        });
        const m2 = g2;
        try {
          e22.exports = g2, Object.defineProperty(g2, "__esModule", {
            value: true
          }), g2.default = g2, g2.outdent = g2;
        } catch (e23) {
        }
      },
      5724: (e22) => {
        function t4(e23) {
          if (typeof e23 != "string")
            throw new TypeError("Path must be a string. Received " + JSON.stringify(e23));
        }
        function r3(e23, t5) {
          for (var r4, n3 = "", o2 = 0, i2 = -1, s2 = 0, u2 = 0; u2 <= e23.length; ++u2) {
            if (u2 < e23.length)
              r4 = e23.charCodeAt(u2);
            else {
              if (r4 === 47)
                break;
              r4 = 47;
            }
            if (r4 === 47) {
              if (i2 === u2 - 1 || s2 === 1)
                ;
              else if (i2 !== u2 - 1 && s2 === 2) {
                if (n3.length < 2 || o2 !== 2 || n3.charCodeAt(n3.length - 1) !== 46 || n3.charCodeAt(n3.length - 2) !== 46) {
                  if (n3.length > 2) {
                    var a2 = n3.lastIndexOf("/");
                    if (a2 !== n3.length - 1) {
                      a2 === -1 ? (n3 = "", o2 = 0) : o2 = (n3 = n3.slice(0, a2)).length - 1 - n3.lastIndexOf("/"), i2 = u2, s2 = 0;
                      continue;
                    }
                  } else if (n3.length === 2 || n3.length === 1) {
                    n3 = "", o2 = 0, i2 = u2, s2 = 0;
                    continue;
                  }
                }
                t5 && (n3.length > 0 ? n3 += "/.." : n3 = "..", o2 = 2);
              } else
                n3.length > 0 ? n3 += "/" + e23.slice(i2 + 1, u2) : n3 = e23.slice(i2 + 1, u2), o2 = u2 - i2 - 1;
              i2 = u2, s2 = 0;
            } else
              r4 === 46 && s2 !== -1 ? ++s2 : s2 = -1;
          }
          return n3;
        }
        var n2 = {
          resolve: function() {
            for (var e23, n3 = "", o2 = false, i2 = arguments.length - 1; i2 >= -1 && !o2; i2--) {
              var s2;
              i2 >= 0 ? s2 = arguments[i2] : (e23 === void 0 && (e23 = process.cwd()), s2 = e23), t4(s2), s2.length !== 0 && (n3 = s2 + "/" + n3, o2 = s2.charCodeAt(0) === 47);
            }
            return n3 = r3(n3, !o2), o2 ? n3.length > 0 ? "/" + n3 : "/" : n3.length > 0 ? n3 : ".";
          },
          normalize: function(e23) {
            if (t4(e23), e23.length === 0)
              return ".";
            var n3 = e23.charCodeAt(0) === 47, o2 = e23.charCodeAt(e23.length - 1) === 47;
            return (e23 = r3(e23, !n3)).length !== 0 || n3 || (e23 = "."), e23.length > 0 && o2 && (e23 += "/"), n3 ? "/" + e23 : e23;
          },
          isAbsolute: function(e23) {
            return t4(e23), e23.length > 0 && e23.charCodeAt(0) === 47;
          },
          join: function() {
            if (arguments.length === 0)
              return ".";
            for (var e23, r4 = 0; r4 < arguments.length; ++r4) {
              var o2 = arguments[r4];
              t4(o2), o2.length > 0 && (e23 === void 0 ? e23 = o2 : e23 += "/" + o2);
            }
            return e23 === void 0 ? "." : n2.normalize(e23);
          },
          relative: function(e23, r4) {
            if (t4(e23), t4(r4), e23 === r4)
              return "";
            if ((e23 = n2.resolve(e23)) === (r4 = n2.resolve(r4)))
              return "";
            for (var o2 = 1; o2 < e23.length && e23.charCodeAt(o2) === 47; ++o2)
              ;
            for (var i2 = e23.length, s2 = i2 - o2, u2 = 1; u2 < r4.length && r4.charCodeAt(u2) === 47; ++u2)
              ;
            for (var a2 = r4.length - u2, c2 = s2 < a2 ? s2 : a2, l2 = -1, f2 = 0; f2 <= c2; ++f2) {
              if (f2 === c2) {
                if (a2 > c2) {
                  if (r4.charCodeAt(u2 + f2) === 47)
                    return r4.slice(u2 + f2 + 1);
                  if (f2 === 0)
                    return r4.slice(u2 + f2);
                } else
                  s2 > c2 && (e23.charCodeAt(o2 + f2) === 47 ? l2 = f2 : f2 === 0 && (l2 = 0));
                break;
              }
              var p2 = e23.charCodeAt(o2 + f2);
              if (p2 !== r4.charCodeAt(u2 + f2))
                break;
              p2 === 47 && (l2 = f2);
            }
            var h2 = "";
            for (f2 = o2 + l2 + 1; f2 <= i2; ++f2)
              f2 !== i2 && e23.charCodeAt(f2) !== 47 || (h2.length === 0 ? h2 += ".." : h2 += "/..");
            return h2.length > 0 ? h2 + r4.slice(u2 + l2) : (u2 += l2, r4.charCodeAt(u2) === 47 && ++u2, r4.slice(u2));
          },
          _makeLong: function(e23) {
            return e23;
          },
          dirname: function(e23) {
            if (t4(e23), e23.length === 0)
              return ".";
            for (var r4 = e23.charCodeAt(0), n3 = r4 === 47, o2 = -1, i2 = true, s2 = e23.length - 1; s2 >= 1; --s2)
              if ((r4 = e23.charCodeAt(s2)) === 47) {
                if (!i2) {
                  o2 = s2;
                  break;
                }
              } else
                i2 = false;
            return o2 === -1 ? n3 ? "/" : "." : n3 && o2 === 1 ? "//" : e23.slice(0, o2);
          },
          basename: function(e23, r4) {
            if (r4 !== void 0 && typeof r4 != "string")
              throw new TypeError('"ext" argument must be a string');
            t4(e23);
            var n3, o2 = 0, i2 = -1, s2 = true;
            if (r4 !== void 0 && r4.length > 0 && r4.length <= e23.length) {
              if (r4.length === e23.length && r4 === e23)
                return "";
              var u2 = r4.length - 1, a2 = -1;
              for (n3 = e23.length - 1; n3 >= 0; --n3) {
                var c2 = e23.charCodeAt(n3);
                if (c2 === 47) {
                  if (!s2) {
                    o2 = n3 + 1;
                    break;
                  }
                } else
                  a2 === -1 && (s2 = false, a2 = n3 + 1), u2 >= 0 && (c2 === r4.charCodeAt(u2) ? --u2 == -1 && (i2 = n3) : (u2 = -1, i2 = a2));
              }
              return o2 === i2 ? i2 = a2 : i2 === -1 && (i2 = e23.length), e23.slice(o2, i2);
            }
            for (n3 = e23.length - 1; n3 >= 0; --n3)
              if (e23.charCodeAt(n3) === 47) {
                if (!s2) {
                  o2 = n3 + 1;
                  break;
                }
              } else
                i2 === -1 && (s2 = false, i2 = n3 + 1);
            return i2 === -1 ? "" : e23.slice(o2, i2);
          },
          extname: function(e23) {
            t4(e23);
            for (var r4 = -1, n3 = 0, o2 = -1, i2 = true, s2 = 0, u2 = e23.length - 1; u2 >= 0; --u2) {
              var a2 = e23.charCodeAt(u2);
              if (a2 !== 47)
                o2 === -1 && (i2 = false, o2 = u2 + 1), a2 === 46 ? r4 === -1 ? r4 = u2 : s2 !== 1 && (s2 = 1) : r4 !== -1 && (s2 = -1);
              else if (!i2) {
                n3 = u2 + 1;
                break;
              }
            }
            return r4 === -1 || o2 === -1 || s2 === 0 || s2 === 1 && r4 === o2 - 1 && r4 === n3 + 1 ? "" : e23.slice(r4, o2);
          },
          format: function(e23) {
            if (e23 === null || typeof e23 != "object")
              throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof e23);
            return function(e24, t5) {
              var r4 = t5.dir || t5.root, n3 = t5.base || (t5.name || "") + (t5.ext || "");
              return r4 ? r4 === t5.root ? r4 + n3 : r4 + e24 + n3 : n3;
            }("/", e23);
          },
          parse: function(e23) {
            t4(e23);
            var r4 = {
              root: "",
              dir: "",
              base: "",
              ext: "",
              name: ""
            };
            if (e23.length === 0)
              return r4;
            var n3, o2 = e23.charCodeAt(0), i2 = o2 === 47;
            i2 ? (r4.root = "/", n3 = 1) : n3 = 0;
            for (var s2 = -1, u2 = 0, a2 = -1, c2 = true, l2 = e23.length - 1, f2 = 0; l2 >= n3; --l2)
              if ((o2 = e23.charCodeAt(l2)) !== 47)
                a2 === -1 && (c2 = false, a2 = l2 + 1), o2 === 46 ? s2 === -1 ? s2 = l2 : f2 !== 1 && (f2 = 1) : s2 !== -1 && (f2 = -1);
              else if (!c2) {
                u2 = l2 + 1;
                break;
              }
            return s2 === -1 || a2 === -1 || f2 === 0 || f2 === 1 && s2 === a2 - 1 && s2 === u2 + 1 ? a2 !== -1 && (r4.base = r4.name = u2 === 0 && i2 ? e23.slice(1, a2) : e23.slice(u2, a2)) : (u2 === 0 && i2 ? (r4.name = e23.slice(1, s2), r4.base = e23.slice(1, a2)) : (r4.name = e23.slice(u2, s2), r4.base = e23.slice(u2, a2)), r4.ext = e23.slice(s2, a2)), u2 > 0 ? r4.dir = e23.slice(0, u2 - 1) : i2 && (r4.dir = "/"), r4;
          },
          sep: "/",
          delimiter: ":",
          win32: null,
          posix: null
        };
        n2.posix = n2, e22.exports = n2;
      },
      8681: (e22, t4, r3) => {
        const n2 = r3(3102), o2 = r3(7116), { isInlineComment: i2 } = r3(1101), { interpolation: s2 } = r3(3295), { isMixinToken: u2 } = r3(5953), a2 = r3(1330), c2 = r3(5255), l2 = /(!\s*important)$/i;
        e22.exports = class extends o2 {
          constructor(...e23) {
            super(...e23), this.lastNode = null;
          }
          atrule(e23) {
            s2.bind(this)(e23) || (super.atrule(e23), a2(this.lastNode), c2(this.lastNode));
          }
          decl(...e23) {
            super.decl(...e23), /extend\(.+\)/i.test(this.lastNode.value) && (this.lastNode.extend = true);
          }
          each(e23) {
            e23[0][1] = ` ${e23[0][1]}`;
            const t5 = e23.findIndex((e24) => e24[0] === "("), r4 = e23.reverse().find((e24) => e24[0] === ")"), n3 = e23.reverse().indexOf(r4), o3 = e23.splice(t5, n3).map((e24) => e24[1]).join("");
            for (const t6 of e23.reverse())
              this.tokenizer.back(t6);
            this.atrule(this.tokenizer.nextToken()), this.lastNode.function = true, this.lastNode.params = o3;
          }
          init(e23, t5, r4) {
            super.init(e23, t5, r4), this.lastNode = e23;
          }
          inlineComment(e23) {
            const t5 = new n2(), r4 = e23[1].slice(2);
            if (this.init(t5, e23[2], e23[3]), t5.source.end = {
              line: e23[4],
              column: e23[5]
            }, t5.inline = true, t5.raws.begin = "//", /^\s*$/.test(r4))
              t5.text = "", t5.raws.left = r4, t5.raws.right = "";
            else {
              const e24 = r4.match(/^(\s*)([^]*[^\s])(\s*)$/);
              [, t5.raws.left, t5.text, t5.raws.right] = e24;
            }
          }
          mixin(e23) {
            const [t5] = e23, r4 = t5[1].slice(0, 1), n3 = e23.findIndex((e24) => e24[0] === "brackets"), o3 = e23.findIndex((e24) => e24[0] === "(");
            let i3 = "";
            if ((n3 < 0 || n3 > 3) && o3 > 0) {
              const t6 = e23.reduce((e24, t7, r6) => t7[0] === ")" ? r6 : e24), r5 = e23.slice(o3, t6 + o3).map((e24) => e24[1]).join(""), [n4] = e23.slice(o3), i4 = [n4[2], n4[3]], [s4] = e23.slice(t6, t6 + 1), u4 = [s4[2], s4[3]], a3 = ["brackets", r5].concat(i4, u4), c3 = e23.slice(0, o3), l3 = e23.slice(t6 + 1);
              (e23 = c3).push(a3), e23 = e23.concat(l3);
            }
            const s3 = [];
            for (const t6 of e23)
              if ((t6[1] === "!" || s3.length) && s3.push(t6), t6[1] === "important")
                break;
            if (s3.length) {
              const [t6] = s3, r5 = e23.indexOf(t6), n4 = s3[s3.length - 1], o4 = [t6[2], t6[3]], i4 = [n4[4], n4[5]], u4 = [
                "word",
                s3.map((e24) => e24[1]).join("")
              ].concat(o4, i4);
              e23.splice(r5, s3.length, u4);
            }
            const u3 = e23.findIndex((e24) => l2.test(e24[1]));
            u3 > 0 && ([, i3] = e23[u3], e23.splice(u3, 1));
            for (const t6 of e23.reverse())
              this.tokenizer.back(t6);
            this.atrule(this.tokenizer.nextToken()), this.lastNode.mixin = true, this.lastNode.raws.identifier = r4, i3 && (this.lastNode.important = true, this.lastNode.raws.important = i3);
          }
          other(e23) {
            i2.bind(this)(e23) || super.other(e23);
          }
          rule(e23) {
            const t5 = e23[e23.length - 1], r4 = e23[e23.length - 2];
            if (r4[0] === "at-word" && t5[0] === "{" && (this.tokenizer.back(t5), s2.bind(this)(r4))) {
              const t6 = this.tokenizer.nextToken();
              e23 = e23.slice(0, e23.length - 2).concat([t6]);
              for (const t7 of e23.reverse())
                this.tokenizer.back(t7);
            } else
              super.rule(e23), /:extend\(.+\)/i.test(this.lastNode.selector) && (this.lastNode.extend = true);
          }
          unknownWord(e23) {
            const [t5] = e23;
            e23[0][1] !== "each" || e23[1][0] !== "(" ? u2(t5) ? this.mixin(e23) : super.unknownWord(e23) : this.each(e23);
          }
        };
      },
      3406: (e22, t4, r3) => {
        const n2 = r3(5701);
        e22.exports = class extends n2 {
          atrule(e23, t5) {
            if (!e23.mixin && !e23.variable && !e23.function)
              return void super.atrule(e23, t5);
            let r4 = `${e23.function ? "" : e23.raws.identifier || "@"}${e23.name}`, n3 = e23.params ? this.rawValue(e23, "params") : "";
            const o2 = e23.raws.important || "";
            if (e23.variable && (n3 = e23.value), e23.raws.afterName !== void 0 ? r4 += e23.raws.afterName : n3 && (r4 += " "), e23.nodes)
              this.block(e23, r4 + n3 + o2);
            else {
              const i2 = (e23.raws.between || "") + o2 + (t5 ? ";" : "");
              this.builder(r4 + n3 + i2, e23);
            }
          }
          comment(e23) {
            if (e23.inline) {
              const t5 = this.raw(e23, "left", "commentLeft"), r4 = this.raw(e23, "right", "commentRight");
              this.builder(`//${t5}${e23.text}${r4}`, e23);
            } else
              super.comment(e23);
          }
        };
      },
      7371: (e22, t4, r3) => {
        const n2 = r3(2993), o2 = r3(8681), i2 = r3(3406);
        e22.exports = {
          parse(e23, t5) {
            const r4 = new n2(e23, t5), i3 = new o2(r4);
            return i3.parse(), i3.root;
          },
          stringify(e23, t5) {
            new i2(t5).stringify(e23);
          },
          nodeToString(t5) {
            let r4 = "";
            return e22.exports.stringify(t5, (e23) => {
              r4 += e23;
            }), r4;
          }
        };
      },
      1330: (e22, t4, r3) => {
        const n2 = r3(1157), o2 = /^url\((.+)\)/;
        e22.exports = (e23) => {
          const { name: t5, params: r4 = "" } = e23;
          if (t5 === "import" && r4.length) {
            e23.import = true;
            const t6 = n2({ css: r4 });
            for (e23.filename = r4.replace(o2, "$1"); !t6.endOfFile(); ) {
              const [n3, o3] = t6.nextToken();
              if (n3 === "word" && o3 === "url")
                return;
              if (n3 === "brackets") {
                e23.options = o3, e23.filename = r4.replace(o3, "").trim();
                break;
              }
            }
          }
        };
      },
      1101: (e22, t4, r3) => {
        const n2 = r3(1157), o2 = r3(2993);
        e22.exports = {
          isInlineComment(t5) {
            if (t5[0] === "word" && t5[1].slice(0, 2) === "//") {
              const e23 = t5, r4 = [];
              let i2;
              for (; t5; ) {
                if (/\r?\n/.test(t5[1])) {
                  if (/['"].*\r?\n/.test(t5[1])) {
                    r4.push(t5[1].substring(0, t5[1].indexOf("\n")));
                    let e24 = t5[1].substring(t5[1].indexOf("\n"));
                    e24 += this.input.css.valueOf().substring(this.tokenizer.position()), this.input = new o2(e24), this.tokenizer = n2(this.input);
                  } else
                    this.tokenizer.back(t5);
                  break;
                }
                r4.push(t5[1]), i2 = t5, t5 = this.tokenizer.nextToken({
                  ignoreUnclosed: true
                });
              }
              const s2 = [
                "comment",
                r4.join(""),
                e23[2],
                e23[3],
                i2[2],
                i2[3]
              ];
              return this.inlineComment(s2), true;
            }
            if (t5[1] === "/") {
              const r4 = this.tokenizer.nextToken({
                ignoreUnclosed: true
              });
              if (r4[0] === "comment" && /^\/\*/.test(r4[1]))
                return r4[0] = "word", r4[1] = r4[1].slice(1), t5[1] = "//", this.tokenizer.back(r4), e22.exports.isInlineComment.bind(this)(t5);
            }
            return false;
          }
        };
      },
      3295: (e22) => {
        e22.exports = {
          interpolation(e23) {
            let t4 = e23;
            const r3 = [e23], n2 = ["word", "{", "}"];
            if (e23 = this.tokenizer.nextToken(), t4[1].length > 1 || e23[0] !== "{")
              return this.tokenizer.back(e23), false;
            for (; e23 && n2.includes(e23[0]); )
              r3.push(e23), e23 = this.tokenizer.nextToken();
            const o2 = r3.map((e24) => e24[1]);
            [t4] = r3;
            const i2 = r3.pop(), s2 = [t4[2], t4[3]], u2 = [i2[4] || i2[2], i2[5] || i2[3]], a2 = ["word", o2.join("")].concat(s2, u2);
            return this.tokenizer.back(e23), this.tokenizer.back(a2), true;
          }
        };
      },
      5953: (e22) => {
        const t4 = /^#[0-9a-fA-F]{6}$|^#[0-9a-fA-F]{3}$/, r3 = /\.[0-9]/;
        e22.exports = {
          isMixinToken: (e23) => {
            const [, n2] = e23, [o2] = n2;
            return (o2 === "." || o2 === "#") && t4.test(n2) === false && r3.test(n2) === false;
          }
        };
      },
      5255: (e22) => {
        const t4 = /:$/, r3 = /^:(\s+)?/;
        e22.exports = (e23) => {
          const { name: n2, params: o2 = "" } = e23;
          if (e23.name.slice(-1) === ":") {
            if (t4.test(n2)) {
              const [r4] = n2.match(t4);
              e23.name = n2.replace(r4, ""), e23.raws.afterName = r4 + (e23.raws.afterName || ""), e23.variable = true, e23.value = e23.params;
            }
            if (r3.test(o2)) {
              const [t5] = o2.match(r3);
              e23.value = o2.replace(t5, ""), e23.raws.afterName = (e23.raws.afterName || "") + t5, e23.variable = true;
            }
          }
        };
      },
      8322: (e22, t4, r3) => {
        t4.Z = function(e23) {
          return new o2.default({
            nodes: (0, i2.parseMediaList)(e23),
            type: "media-query-list",
            value: e23.trim()
          });
        };
        var n2, o2 = (n2 = r3(9066)) && n2.__esModule ? n2 : { default: n2 }, i2 = r3(7625);
      },
      9066: (e22, t4, r3) => {
        Object.defineProperty(t4, "__esModule", {
          value: true
        });
        var n2, o2 = (n2 = r3(7680)) && n2.__esModule ? n2 : { default: n2 };
        function i2(e23) {
          var t5 = this;
          this.constructor(e23), this.nodes = e23.nodes, this.after === void 0 && (this.after = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1].after : ""), this.before === void 0 && (this.before = this.nodes.length > 0 ? this.nodes[0].before : ""), this.sourceIndex === void 0 && (this.sourceIndex = this.before.length), this.nodes.forEach(function(e24) {
            e24.parent = t5;
          });
        }
        i2.prototype = Object.create(o2.default.prototype), i2.constructor = o2.default, i2.prototype.walk = function(e23, t5) {
          for (var r4 = typeof e23 == "string" || e23 instanceof RegExp, n3 = r4 ? t5 : e23, o3 = typeof e23 == "string" ? new RegExp(e23) : e23, i3 = 0; i3 < this.nodes.length; i3++) {
            var s2 = this.nodes[i3];
            if ((!r4 || o3.test(s2.type)) && n3 && n3(s2, i3, this.nodes) === false)
              return false;
            if (s2.nodes && s2.walk(e23, t5) === false)
              return false;
          }
          return true;
        }, i2.prototype.each = function() {
          for (var e23 = arguments.length <= 0 || arguments[0] === void 0 ? function() {
          } : arguments[0], t5 = 0; t5 < this.nodes.length; t5++)
            if (e23(this.nodes[t5], t5, this.nodes) === false)
              return false;
          return true;
        }, t4.default = i2;
      },
      7680: (e22, t4) => {
        Object.defineProperty(t4, "__esModule", {
          value: true
        }), t4.default = function(e23) {
          this.after = e23.after, this.before = e23.before, this.type = e23.type, this.value = e23.value, this.sourceIndex = e23.sourceIndex;
        };
      },
      7625: (e22, t4, r3) => {
        Object.defineProperty(t4, "__esModule", {
          value: true
        }), t4.parseMediaFeature = s2, t4.parseMediaQuery = u2, t4.parseMediaList = function(e23) {
          var t5 = [], r4 = 0, i3 = 0, s3 = /^(\s*)url\s*\(/.exec(e23);
          if (s3 !== null) {
            for (var a2 = s3[0].length, c2 = 1; c2 > 0; ) {
              var l2 = e23[a2];
              l2 === "(" && c2++, l2 === ")" && c2--, a2++;
            }
            t5.unshift(new n2.default({
              type: "url",
              value: e23.substring(0, a2).trim(),
              sourceIndex: s3[1].length,
              before: s3[1],
              after: /^(\s*)/.exec(e23.substring(a2))[1]
            })), r4 = a2;
          }
          for (var f2 = r4; f2 < e23.length; f2++) {
            var p2 = e23[f2];
            if (p2 === "(" && i3++, p2 === ")" && i3--, i3 === 0 && p2 === ",") {
              var h2 = e23.substring(r4, f2), d2 = /^(\s*)/.exec(h2)[1];
              t5.push(new o2.default({
                type: "media-query",
                value: h2.trim(),
                sourceIndex: r4 + d2.length,
                nodes: u2(h2, r4),
                before: d2,
                after: /(\s*)$/.exec(h2)[1]
              })), r4 = f2 + 1;
            }
          }
          var D2 = e23.substring(r4), g2 = /^(\s*)/.exec(D2)[1];
          return t5.push(new o2.default({
            type: "media-query",
            value: D2.trim(),
            sourceIndex: r4 + g2.length,
            nodes: u2(D2, r4),
            before: g2,
            after: /(\s*)$/.exec(D2)[1]
          })), t5;
        };
        var n2 = i2(r3(7680)), o2 = i2(r3(9066));
        function i2(e23) {
          return e23 && e23.__esModule ? e23 : { default: e23 };
        }
        function s2(e23) {
          var t5 = [{ mode: "normal", character: null }], r4 = [], n3 = 0, o3 = "", i3 = null, s3 = null, u3 = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], a2 = e23;
          e23[0] === "(" && e23[e23.length - 1] === ")" && (a2 = e23.substring(1, e23.length - 1), u3++);
          for (var c2 = 0; c2 < a2.length; c2++) {
            var l2 = a2[c2];
            if (l2 !== "'" && l2 !== '"' || (t5[n3].isCalculationEnabled === true ? (t5.push({
              mode: "string",
              isCalculationEnabled: false,
              character: l2
            }), n3++) : t5[n3].mode === "string" && t5[n3].character === l2 && a2[c2 - 1] !== "\\" && (t5.pop(), n3--)), l2 === "{" ? (t5.push({
              mode: "interpolation",
              isCalculationEnabled: true
            }), n3++) : l2 === "}" && (t5.pop(), n3--), t5[n3].mode === "normal" && l2 === ":") {
              var f2 = a2.substring(c2 + 1);
              (s3 = {
                type: "value",
                before: /^(\s*)/.exec(f2)[1],
                after: /(\s*)$/.exec(f2)[1],
                value: f2.trim()
              }).sourceIndex = s3.before.length + c2 + 1 + u3, i3 = {
                type: "colon",
                sourceIndex: c2 + u3,
                after: s3.before,
                value: ":"
              };
              break;
            }
            o3 += l2;
          }
          return (o3 = {
            type: "media-feature",
            before: /^(\s*)/.exec(o3)[1],
            after: /(\s*)$/.exec(o3)[1],
            value: o3.trim()
          }).sourceIndex = o3.before.length + u3, r4.push(o3), i3 !== null && (i3.before = o3.after, r4.push(i3)), s3 !== null && r4.push(s3), r4;
        }
        function u2(e23) {
          var t5 = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], r4 = [], i3 = 0, u3 = false, a2 = void 0;
          a2 = { before: "", after: "", value: "" };
          for (var c2 = 0; c2 < e23.length; c2++) {
            var l2 = e23[c2];
            u3 ? (a2.value += l2, l2 !== "{" && l2 !== "(" || i3++, l2 !== ")" && l2 !== "}" || i3--) : l2.search(/\s/) !== -1 ? a2.before += l2 : (l2 === "(" && (a2.type = "media-feature-expression", i3++), a2.value = l2, a2.sourceIndex = t5 + c2, u3 = true), !u3 || i3 !== 0 || l2 !== ")" && c2 !== e23.length - 1 && e23[c2 + 1].search(/\s/) === -1 || (["not", "only", "and"].indexOf(a2.value) !== -1 && (a2.type = "keyword"), a2.type === "media-feature-expression" && (a2.nodes = s2(a2.value, a2.sourceIndex)), r4.push(Array.isArray(a2.nodes) ? new o2.default(a2) : new n2.default(a2)), a2 = {
              before: "",
              after: "",
              value: ""
            }, u3 = false);
          }
          for (var f2 = 0; f2 < r4.length; f2++)
            if (a2 = r4[f2], f2 > 0 && (r4[f2 - 1].after = a2.before), a2.type === void 0) {
              if (f2 > 0) {
                if (r4[f2 - 1].type === "media-feature-expression") {
                  a2.type = "keyword";
                  continue;
                }
                if (r4[f2 - 1].value === "not" || r4[f2 - 1].value === "only") {
                  a2.type = "media-type";
                  continue;
                }
                if (r4[f2 - 1].value === "and") {
                  a2.type = "media-feature-expression";
                  continue;
                }
                r4[f2 - 1].type === "media-type" && (r4[f2 + 1] ? a2.type = r4[f2 + 1].type === "media-feature-expression" ? "keyword" : "media-feature-expression" : a2.type = "media-feature-expression");
              }
              if (f2 === 0) {
                if (!r4[f2 + 1]) {
                  a2.type = "media-type";
                  continue;
                }
                if (r4[f2 + 1] && (r4[f2 + 1].type === "media-feature-expression" || r4[f2 + 1].type === "keyword")) {
                  a2.type = "media-type";
                  continue;
                }
                if (r4[f2 + 2]) {
                  if (r4[f2 + 2].type === "media-feature-expression") {
                    a2.type = "media-type", r4[f2 + 1].type = "keyword";
                    continue;
                  }
                  if (r4[f2 + 2].type === "keyword") {
                    a2.type = "keyword", r4[f2 + 1].type = "media-type";
                    continue;
                  }
                }
                if (r4[f2 + 3] && r4[f2 + 3].type === "media-feature-expression") {
                  a2.type = "keyword", r4[f2 + 1].type = "media-type", r4[f2 + 2].type = "keyword";
                  continue;
                }
              }
            }
          return r4;
        }
      },
      5822: (e22, t4, r3) => {
        var n2 = function(e23) {
          var t5, r4;
          function n3(t6) {
            var r5;
            return (r5 = e23.call(this, t6) || this).type = "decl", r5.isNested = true, r5.nodes || (r5.nodes = []), r5;
          }
          return r4 = e23, (t5 = n3).prototype = Object.create(r4.prototype), t5.prototype.constructor = t5, t5.__proto__ = r4, n3;
        }(r3(1204));
        e22.exports = n2;
      },
      1945: (e22, t4, r3) => {
        var n2 = r3(2993), o2 = r3(1713);
        e22.exports = function(e23, t5) {
          var r4 = new n2(e23, t5), i2 = new o2(r4);
          return i2.parse(), i2.root;
        };
      },
      1713: (e22, t4, r3) => {
        var n2 = r3(3102), o2 = r3(7116), i2 = r3(5822), s2 = r3(6256), u2 = function(e23) {
          var t5, r4;
          function o3() {
            return e23.apply(this, arguments) || this;
          }
          r4 = e23, (t5 = o3).prototype = Object.create(r4.prototype), t5.prototype.constructor = t5, t5.__proto__ = r4;
          var u3 = o3.prototype;
          return u3.createTokenizer = function() {
            this.tokenizer = s2(this.input);
          }, u3.rule = function(t6) {
            var r5 = false, n3 = 0, o4 = "", s3 = t6, u4 = Array.isArray(s3), a2 = 0;
            for (s3 = u4 ? s3 : s3[Symbol.iterator](); ; ) {
              var c2;
              if (u4) {
                if (a2 >= s3.length)
                  break;
                c2 = s3[a2++];
              } else {
                if ((a2 = s3.next()).done)
                  break;
                c2 = a2.value;
              }
              var l2 = c2;
              if (r5)
                l2[0] !== "comment" && l2[0] !== "{" && (o4 += l2[1]);
              else {
                if (l2[0] === "space" && l2[1].indexOf("\n") !== -1)
                  break;
                l2[0] === "(" ? n3 += 1 : l2[0] === ")" ? n3 -= 1 : n3 === 0 && l2[0] === ":" && (r5 = true);
              }
            }
            if (!r5 || o4.trim() === "" || /^[a-zA-Z-:#]/.test(o4))
              e23.prototype.rule.call(this, t6);
            else {
              t6.pop();
              var f2 = new i2();
              this.init(f2);
              var p2, h2 = t6[t6.length - 1];
              for (h2[4] ? f2.source.end = {
                line: h2[4],
                column: h2[5]
              } : f2.source.end = {
                line: h2[2],
                column: h2[3]
              }; t6[0][0] !== "word"; )
                f2.raws.before += t6.shift()[1];
              for (f2.source.start = {
                line: t6[0][2],
                column: t6[0][3]
              }, f2.prop = ""; t6.length; ) {
                var d2 = t6[0][0];
                if (d2 === ":" || d2 === "space" || d2 === "comment")
                  break;
                f2.prop += t6.shift()[1];
              }
              for (f2.raws.between = ""; t6.length; ) {
                if ((p2 = t6.shift())[0] === ":") {
                  f2.raws.between += p2[1];
                  break;
                }
                f2.raws.between += p2[1];
              }
              f2.prop[0] !== "_" && f2.prop[0] !== "*" || (f2.raws.before += f2.prop[0], f2.prop = f2.prop.slice(1)), f2.raws.between += this.spacesAndCommentsFromStart(t6), this.precheckMissedSemicolon(t6);
              for (var D2 = t6.length - 1; D2 > 0; D2--) {
                if ((p2 = t6[D2])[1] === "!important") {
                  f2.important = true;
                  var g2 = this.stringFrom(t6, D2);
                  (g2 = this.spacesFromEnd(t6) + g2) !== " !important" && (f2.raws.important = g2);
                  break;
                }
                if (p2[1] === "important") {
                  for (var m2 = t6.slice(0), v2 = "", y2 = D2; y2 > 0; y2--) {
                    var w2 = m2[y2][0];
                    if (v2.trim().indexOf("!") === 0 && w2 !== "space")
                      break;
                    v2 = m2.pop()[1] + v2;
                  }
                  v2.trim().indexOf("!") === 0 && (f2.important = true, f2.raws.important = v2, t6 = m2);
                }
                if (p2[0] !== "space" && p2[0] !== "comment")
                  break;
              }
              this.raw(f2, "value", t6), f2.value.indexOf(":") !== -1 && this.checkMissedSemicolon(t6), this.current = f2;
            }
          }, u3.comment = function(t6) {
            if (t6[6] === "inline") {
              var r5 = new n2();
              this.init(r5, t6[2], t6[3]), r5.raws.inline = true, r5.source.end = {
                line: t6[4],
                column: t6[5]
              };
              var o4 = t6[1].slice(2);
              if (/^\s*$/.test(o4))
                r5.text = "", r5.raws.left = o4, r5.raws.right = "";
              else {
                var i3 = o4.match(/^(\s*)([^]*[^\s])(\s*)$/), s3 = i3[2].replace(/(\*\/|\/\*)/g, "*//*");
                r5.text = s3, r5.raws.left = i3[1], r5.raws.right = i3[3], r5.raws.text = i3[2];
              }
            } else
              e23.prototype.comment.call(this, t6);
          }, u3.raw = function(t6, r5, n3) {
            if (e23.prototype.raw.call(this, t6, r5, n3), t6.raws[r5]) {
              var o4 = t6.raws[r5].raw;
              t6.raws[r5].raw = n3.reduce(function(e24, t7) {
                return t7[0] === "comment" && t7[6] === "inline" ? e24 + "/*" + t7[1].slice(2).replace(/(\*\/|\/\*)/g, "*//*") + "*/" : e24 + t7[1];
              }, ""), o4 !== t6.raws[r5].raw && (t6.raws[r5].scss = o4);
            }
          }, o3;
        }(o2);
        e22.exports = u2;
      },
      9235: (e22, t4, r3) => {
        var n2 = function(e23) {
          var t5, r4;
          function n3() {
            return e23.apply(this, arguments) || this;
          }
          r4 = e23, (t5 = n3).prototype = Object.create(r4.prototype), t5.prototype.constructor = t5, t5.__proto__ = r4;
          var o2 = n3.prototype;
          return o2.comment = function(e24) {
            var t6 = this.raw(e24, "left", "commentLeft"), r5 = this.raw(e24, "right", "commentRight");
            if (e24.raws.inline) {
              var n4 = e24.raws.text || e24.text;
              this.builder("//" + t6 + n4 + r5, e24);
            } else
              this.builder("/*" + t6 + e24.text + r5 + "*/", e24);
          }, o2.decl = function(t6, r5) {
            if (t6.isNested) {
              var n4, o3 = this.raw(t6, "between", "colon"), i2 = t6.prop + o3 + this.rawValue(t6, "value");
              t6.important && (i2 += t6.raws.important || " !important"), this.builder(i2 + "{", t6, "start"), t6.nodes && t6.nodes.length ? (this.body(t6), n4 = this.raw(t6, "after")) : n4 = this.raw(t6, "after", "emptyBody"), n4 && this.builder(n4), this.builder("}", t6, "end");
            } else
              e23.prototype.decl.call(this, t6, r5);
          }, o2.rawValue = function(e24, t6) {
            var r5 = e24[t6], n4 = e24.raws[t6];
            return n4 && n4.value === r5 ? n4.scss ? n4.scss : n4.raw : r5;
          }, n3;
        }(r3(5701));
        e22.exports = n2;
      },
      4933: (e22, t4, r3) => {
        var n2 = r3(9235);
        e22.exports = function(e23, t5) {
          new n2(t5).stringify(e23);
        };
      },
      304: (e22, t4, r3) => {
        var n2 = r3(4933), o2 = r3(1945);
        e22.exports = { parse: o2, stringify: n2 };
      },
      6256: (e22) => {
        var t4 = "'".charCodeAt(0), r3 = '"'.charCodeAt(0), n2 = "\\".charCodeAt(0), o2 = "/".charCodeAt(0), i2 = "\n".charCodeAt(0), s2 = " ".charCodeAt(0), u2 = "\f".charCodeAt(0), a2 = "	".charCodeAt(0), c2 = "\r".charCodeAt(0), l2 = "[".charCodeAt(0), f2 = "]".charCodeAt(0), p2 = "(".charCodeAt(0), h2 = ")".charCodeAt(0), d2 = "{".charCodeAt(0), D2 = "}".charCodeAt(0), g2 = ";".charCodeAt(0), m2 = "*".charCodeAt(0), v2 = ":".charCodeAt(0), y2 = "@".charCodeAt(0), w2 = ",".charCodeAt(0), b2 = "#".charCodeAt(0), C2 = /[ \n\t\r\f{}()'"\\;/[\]#]/g, E2 = /[ \n\t\r\f(){}:;@!'"\\\][#]|\/(?=\*)/g, F2 = /.[\\/("'\n]/, x2 = /[a-f0-9]/i, A2 = /[\r\f\n]/g;
        e22.exports = function(e23, k2) {
          k2 === void 0 && (k2 = {});
          var O2, _2, S2, T2, I2, N2, M2, R2, j2, L2, B2, P2, $2, U2, G2 = e23.css.valueOf(), W2 = k2.ignoreErrors, z2 = G2.length, V2 = -1, q2 = 1, X2 = 0, J2 = [], H2 = [];
          function Y2(t5) {
            throw e23.error("Unclosed " + t5, q2, X2 - V2);
          }
          function K2() {
            for (var e24 = 1, o3 = false, i3 = false; e24 > 0; )
              _2 += 1, G2.length <= _2 && Y2("interpolation"), O2 = G2.charCodeAt(_2), P2 = G2.charCodeAt(_2 + 1), o3 ? i3 || O2 !== o3 ? O2 === n2 ? i3 = !L2 : i3 && (i3 = false) : (o3 = false, i3 = false) : O2 === t4 || O2 === r3 ? o3 = O2 : O2 === D2 ? e24 -= 1 : O2 === b2 && P2 === d2 && (e24 += 1);
          }
          return {
            back: function(e24) {
              H2.push(e24);
            },
            nextToken: function() {
              if (H2.length)
                return H2.pop();
              if (!(X2 >= z2)) {
                switch (((O2 = G2.charCodeAt(X2)) === i2 || O2 === u2 || O2 === c2 && G2.charCodeAt(X2 + 1) !== i2) && (V2 = X2, q2 += 1), O2) {
                  case i2:
                  case s2:
                  case a2:
                  case c2:
                  case u2:
                    _2 = X2;
                    do {
                      _2 += 1, (O2 = G2.charCodeAt(_2)) === i2 && (V2 = _2, q2 += 1);
                    } while (O2 === s2 || O2 === i2 || O2 === a2 || O2 === c2 || O2 === u2);
                    $2 = [
                      "space",
                      G2.slice(X2, _2)
                    ], X2 = _2 - 1;
                    break;
                  case l2:
                    $2 = ["[", "[", q2, X2 - V2];
                    break;
                  case f2:
                    $2 = ["]", "]", q2, X2 - V2];
                    break;
                  case d2:
                    $2 = ["{", "{", q2, X2 - V2];
                    break;
                  case D2:
                    $2 = ["}", "}", q2, X2 - V2];
                    break;
                  case w2:
                    $2 = [
                      "word",
                      ",",
                      q2,
                      X2 - V2,
                      q2,
                      X2 - V2 + 1
                    ];
                    break;
                  case v2:
                    $2 = [":", ":", q2, X2 - V2];
                    break;
                  case g2:
                    $2 = [";", ";", q2, X2 - V2];
                    break;
                  case p2:
                    if (B2 = J2.length ? J2.pop()[1] : "", P2 = G2.charCodeAt(X2 + 1), B2 === "url" && P2 !== t4 && P2 !== r3) {
                      for (U2 = 1, L2 = false, _2 = X2 + 1; _2 <= G2.length - 1; ) {
                        if ((P2 = G2.charCodeAt(_2)) === n2)
                          L2 = !L2;
                        else if (P2 === p2)
                          U2 += 1;
                        else if (P2 === h2 && (U2 -= 1) == 0)
                          break;
                        _2 += 1;
                      }
                      N2 = G2.slice(X2, _2 + 1), T2 = N2.split("\n"), (I2 = T2.length - 1) > 0 ? (R2 = q2 + I2, j2 = _2 - T2[I2].length) : (R2 = q2, j2 = V2), $2 = [
                        "brackets",
                        N2,
                        q2,
                        X2 - V2,
                        R2,
                        _2 - j2
                      ], V2 = j2, q2 = R2, X2 = _2;
                    } else
                      _2 = G2.indexOf(")", X2 + 1), N2 = G2.slice(X2, _2 + 1), _2 === -1 || F2.test(N2) ? $2 = [
                        "(",
                        "(",
                        q2,
                        X2 - V2
                      ] : ($2 = [
                        "brackets",
                        N2,
                        q2,
                        X2 - V2,
                        q2,
                        _2 - V2
                      ], X2 = _2);
                    break;
                  case h2:
                    $2 = [")", ")", q2, X2 - V2];
                    break;
                  case t4:
                  case r3:
                    for (S2 = O2, _2 = X2, L2 = false; _2 < z2 && (++_2 === z2 && Y2("string"), O2 = G2.charCodeAt(_2), P2 = G2.charCodeAt(_2 + 1), L2 || O2 !== S2); )
                      O2 === n2 ? L2 = !L2 : L2 ? L2 = false : O2 === b2 && P2 === d2 && K2();
                    N2 = G2.slice(X2, _2 + 1), T2 = N2.split("\n"), (I2 = T2.length - 1) > 0 ? (R2 = q2 + I2, j2 = _2 - T2[I2].length) : (R2 = q2, j2 = V2), $2 = [
                      "string",
                      G2.slice(X2, _2 + 1),
                      q2,
                      X2 - V2,
                      R2,
                      _2 - j2
                    ], V2 = j2, q2 = R2, X2 = _2;
                    break;
                  case y2:
                    C2.lastIndex = X2 + 1, C2.test(G2), _2 = C2.lastIndex === 0 ? G2.length - 1 : C2.lastIndex - 2, $2 = [
                      "at-word",
                      G2.slice(X2, _2 + 1),
                      q2,
                      X2 - V2,
                      q2,
                      _2 - V2
                    ], X2 = _2;
                    break;
                  case n2:
                    for (_2 = X2, M2 = true; G2.charCodeAt(_2 + 1) === n2; )
                      _2 += 1, M2 = !M2;
                    if (O2 = G2.charCodeAt(_2 + 1), M2 && O2 !== o2 && O2 !== s2 && O2 !== i2 && O2 !== a2 && O2 !== c2 && O2 !== u2 && (_2 += 1, x2.test(G2.charAt(_2)))) {
                      for (; x2.test(G2.charAt(_2 + 1)); )
                        _2 += 1;
                      G2.charCodeAt(_2 + 1) === s2 && (_2 += 1);
                    }
                    $2 = [
                      "word",
                      G2.slice(X2, _2 + 1),
                      q2,
                      X2 - V2,
                      q2,
                      _2 - V2
                    ], X2 = _2;
                    break;
                  default:
                    P2 = G2.charCodeAt(X2 + 1), O2 === b2 && P2 === d2 ? (_2 = X2, K2(), N2 = G2.slice(X2, _2 + 1), T2 = N2.split("\n"), (I2 = T2.length - 1) > 0 ? (R2 = q2 + I2, j2 = _2 - T2[I2].length) : (R2 = q2, j2 = V2), $2 = [
                      "word",
                      N2,
                      q2,
                      X2 - V2,
                      R2,
                      _2 - j2
                    ], V2 = j2, q2 = R2, X2 = _2) : O2 === o2 && P2 === m2 ? ((_2 = G2.indexOf("*/", X2 + 2) + 1) === 0 && (W2 ? _2 = G2.length : Y2("comment")), N2 = G2.slice(X2, _2 + 1), T2 = N2.split("\n"), (I2 = T2.length - 1) > 0 ? (R2 = q2 + I2, j2 = _2 - T2[I2].length) : (R2 = q2, j2 = V2), $2 = [
                      "comment",
                      N2,
                      q2,
                      X2 - V2,
                      R2,
                      _2 - j2
                    ], V2 = j2, q2 = R2, X2 = _2) : O2 === o2 && P2 === o2 ? (A2.lastIndex = X2 + 1, A2.test(G2), _2 = A2.lastIndex === 0 ? G2.length - 1 : A2.lastIndex - 2, N2 = G2.slice(X2, _2 + 1), $2 = [
                      "comment",
                      N2,
                      q2,
                      X2 - V2,
                      q2,
                      _2 - V2,
                      "inline"
                    ], X2 = _2) : (E2.lastIndex = X2 + 1, E2.test(G2), _2 = E2.lastIndex === 0 ? G2.length - 1 : E2.lastIndex - 2, $2 = [
                      "word",
                      G2.slice(X2, _2 + 1),
                      q2,
                      X2 - V2,
                      q2,
                      _2 - V2
                    ], J2.push($2), X2 = _2);
                }
                return X2++, $2;
              }
            },
            endOfFile: function() {
              return H2.length === 0 && X2 >= z2;
            }
          };
        };
      },
      1264: (e22, t4, r3) => {
        t4.__esModule = true;
        var n2 = m2(r3(2566)), o2 = m2(r3(616)), i2 = m2(r3(7835)), s2 = m2(r3(478)), u2 = m2(r3(4907)), a2 = m2(r3(8420)), c2 = m2(r3(7523)), l2 = m2(r3(4316)), f2 = m2(r3(6909)), p2 = m2(r3(6279)), h2 = m2(r3(439)), d2 = m2(r3(9956)), D2 = m2(r3(70)), g2 = function(e23) {
          if (e23 && e23.__esModule)
            return e23;
          var t5 = {};
          if (e23 != null)
            for (var r4 in e23)
              Object.prototype.hasOwnProperty.call(e23, r4) && (t5[r4] = e23[r4]);
          return t5.default = e23, t5;
        }(r3(8790));
        function m2(e23) {
          return e23 && e23.__esModule ? e23 : { default: e23 };
        }
        var v2 = function(e23) {
          return new n2.default(e23);
        };
        v2.attribute = function(e23) {
          return new o2.default(e23);
        }, v2.className = function(e23) {
          return new i2.default(e23);
        }, v2.combinator = function(e23) {
          return new s2.default(e23);
        }, v2.comment = function(e23) {
          return new u2.default(e23);
        }, v2.id = function(e23) {
          return new a2.default(e23);
        }, v2.nesting = function(e23) {
          return new c2.default(e23);
        }, v2.pseudo = function(e23) {
          return new l2.default(e23);
        }, v2.root = function(e23) {
          return new f2.default(e23);
        }, v2.selector = function(e23) {
          return new p2.default(e23);
        }, v2.string = function(e23) {
          return new h2.default(e23);
        }, v2.tag = function(e23) {
          return new d2.default(e23);
        }, v2.universal = function(e23) {
          return new D2.default(e23);
        }, Object.keys(g2).forEach(function(e23) {
          e23 !== "__esModule" && (v2[e23] = g2[e23]);
        }), t4.default = v2, e22.exports = t4.default;
      },
      5269: (e22, t4, r3) => {
        t4.__esModule = true;
        var n2 = function() {
          function e23(e24, t5) {
            for (var r4 = 0; r4 < t5.length; r4++) {
              var n3 = t5[r4];
              n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e24, n3.key, n3);
            }
          }
          return function(t5, r4, n3) {
            return r4 && e23(t5.prototype, r4), n3 && e23(t5, n3), t5;
          };
        }(), o2 = C2(r3(8051)), i2 = C2(r3(7886)), s2 = C2(r3(3210)), u2 = C2(r3(6909)), a2 = C2(r3(6279)), c2 = C2(r3(7835)), l2 = C2(r3(4907)), f2 = C2(r3(8420)), p2 = C2(r3(9956)), h2 = C2(r3(439)), d2 = C2(r3(4316)), D2 = C2(r3(616)), g2 = C2(r3(70)), m2 = C2(r3(478)), v2 = C2(r3(7523)), y2 = C2(r3(9788)), w2 = C2(r3(6554)), b2 = function(e23) {
          if (e23 && e23.__esModule)
            return e23;
          var t5 = {};
          if (e23 != null)
            for (var r4 in e23)
              Object.prototype.hasOwnProperty.call(e23, r4) && (t5[r4] = e23[r4]);
          return t5.default = e23, t5;
        }(r3(8790));
        function C2(e23) {
          return e23 && e23.__esModule ? e23 : { default: e23 };
        }
        var E2 = function() {
          function e23(t5) {
            !function(e24, t6) {
              if (!(e24 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, e23), this.input = t5, this.lossy = t5.options.lossless === false, this.position = 0, this.root = new u2.default();
            var r4 = new a2.default();
            return this.root.append(r4), this.current = r4, this.lossy ? this.tokens = (0, w2.default)({
              safe: t5.safe,
              css: t5.css.trim()
            }) : this.tokens = (0, w2.default)(t5), this.loop();
          }
          return e23.prototype.attribute = function() {
            var e24 = "", t5 = void 0, r4 = this.currToken;
            for (this.position++; this.position < this.tokens.length && this.currToken[0] !== "]"; )
              e24 += this.tokens[this.position][1], this.position++;
            this.position !== this.tokens.length || ~e24.indexOf("]") || this.error("Expected a closing square bracket.");
            var n3 = e24.split(/((?:[*~^$|]?=))([^]*)/), o3 = n3[0].split(/(\|)/g), i3 = {
              operator: n3[1],
              value: n3[2],
              source: {
                start: {
                  line: r4[2],
                  column: r4[3]
                },
                end: {
                  line: this.currToken[2],
                  column: this.currToken[3]
                }
              },
              sourceIndex: r4[4]
            };
            if (o3.length > 1 ? (o3[0] === "" && (o3[0] = true), i3.attribute = this.parseValue(o3[2]), i3.namespace = this.parseNamespace(o3[0])) : i3.attribute = this.parseValue(n3[0]), t5 = new D2.default(i3), n3[2]) {
              var s3 = n3[2].split(/(\s+i\s*?)$/), u3 = s3[0].trim();
              t5.value = this.lossy ? u3 : s3[0], s3[1] && (t5.insensitive = true, this.lossy || (t5.raws.insensitive = s3[1])), t5.quoted = u3[0] === "'" || u3[0] === '"', t5.raws.unquoted = t5.quoted ? u3.slice(1, -1) : u3;
            }
            this.newNode(t5), this.position++;
          }, e23.prototype.combinator = function() {
            if (this.currToken[1] === "|")
              return this.namespace();
            for (var e24 = new m2.default({
              value: "",
              source: {
                start: {
                  line: this.currToken[2],
                  column: this.currToken[3]
                },
                end: {
                  line: this.currToken[2],
                  column: this.currToken[3]
                }
              },
              sourceIndex: this.currToken[4]
            }); this.position < this.tokens.length && this.currToken && (this.currToken[0] === "space" || this.currToken[0] === "combinator"); )
              this.nextToken && this.nextToken[0] === "combinator" ? (e24.spaces.before = this.parseSpace(this.currToken[1]), e24.source.start.line = this.nextToken[2], e24.source.start.column = this.nextToken[3], e24.source.end.column = this.nextToken[3], e24.source.end.line = this.nextToken[2], e24.sourceIndex = this.nextToken[4]) : this.prevToken && this.prevToken[0] === "combinator" ? e24.spaces.after = this.parseSpace(this.currToken[1]) : this.currToken[0] === "combinator" ? e24.value = this.currToken[1] : this.currToken[0] === "space" && (e24.value = this.parseSpace(this.currToken[1], " ")), this.position++;
            return this.newNode(e24);
          }, e23.prototype.comma = function() {
            if (this.position === this.tokens.length - 1)
              return this.root.trailingComma = true, void this.position++;
            var e24 = new a2.default();
            this.current.parent.append(e24), this.current = e24, this.position++;
          }, e23.prototype.comment = function() {
            var e24 = new l2.default({
              value: this.currToken[1],
              source: {
                start: {
                  line: this.currToken[2],
                  column: this.currToken[3]
                },
                end: {
                  line: this.currToken[4],
                  column: this.currToken[5]
                }
              },
              sourceIndex: this.currToken[6]
            });
            this.newNode(e24), this.position++;
          }, e23.prototype.error = function(e24) {
            throw new this.input.error(e24);
          }, e23.prototype.missingBackslash = function() {
            return this.error("Expected a backslash preceding the semicolon.");
          }, e23.prototype.missingParenthesis = function() {
            return this.error("Expected opening parenthesis.");
          }, e23.prototype.missingSquareBracket = function() {
            return this.error("Expected opening square bracket.");
          }, e23.prototype.namespace = function() {
            var e24 = this.prevToken && this.prevToken[1] || true;
            return this.nextToken[0] === "word" ? (this.position++, this.word(e24)) : this.nextToken[0] === "*" ? (this.position++, this.universal(e24)) : void 0;
          }, e23.prototype.nesting = function() {
            this.newNode(new v2.default({
              value: this.currToken[1],
              source: {
                start: {
                  line: this.currToken[2],
                  column: this.currToken[3]
                },
                end: {
                  line: this.currToken[2],
                  column: this.currToken[3]
                }
              },
              sourceIndex: this.currToken[4]
            })), this.position++;
          }, e23.prototype.parentheses = function() {
            var e24 = this.current.last;
            if (e24 && e24.type === b2.PSEUDO) {
              var t5 = new a2.default(), r4 = this.current;
              e24.append(t5), this.current = t5;
              var n3 = 1;
              for (this.position++; this.position < this.tokens.length && n3; )
                this.currToken[0] === "(" && n3++, this.currToken[0] === ")" && n3--, n3 ? this.parse() : (t5.parent.source.end.line = this.currToken[2], t5.parent.source.end.column = this.currToken[3], this.position++);
              n3 && this.error("Expected closing parenthesis."), this.current = r4;
            } else {
              var o3 = 1;
              for (this.position++, e24.value += "("; this.position < this.tokens.length && o3; )
                this.currToken[0] === "(" && o3++, this.currToken[0] === ")" && o3--, e24.value += this.parseParenthesisToken(this.currToken), this.position++;
              o3 && this.error("Expected closing parenthesis.");
            }
          }, e23.prototype.pseudo = function() {
            for (var e24 = this, t5 = "", r4 = this.currToken; this.currToken && this.currToken[0] === ":"; )
              t5 += this.currToken[1], this.position++;
            if (!this.currToken)
              return this.error("Expected pseudo-class or pseudo-element");
            if (this.currToken[0] === "word") {
              var n3 = void 0;
              this.splitWord(false, function(o3, i3) {
                t5 += o3, n3 = new d2.default({
                  value: t5,
                  source: {
                    start: {
                      line: r4[2],
                      column: r4[3]
                    },
                    end: {
                      line: e24.currToken[4],
                      column: e24.currToken[5]
                    }
                  },
                  sourceIndex: r4[4]
                }), e24.newNode(n3), i3 > 1 && e24.nextToken && e24.nextToken[0] === "(" && e24.error("Misplaced parenthesis.");
              });
            } else
              this.error('Unexpected "' + this.currToken[0] + '" found.');
          }, e23.prototype.space = function() {
            var e24 = this.currToken;
            this.position === 0 || this.prevToken[0] === "," || this.prevToken[0] === "(" ? (this.spaces = this.parseSpace(e24[1]), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.spaces.after = this.parseSpace(e24[1]), this.position++) : this.combinator();
          }, e23.prototype.string = function() {
            var e24 = this.currToken;
            this.newNode(new h2.default({
              value: this.currToken[1],
              source: {
                start: {
                  line: e24[2],
                  column: e24[3]
                },
                end: {
                  line: e24[4],
                  column: e24[5]
                }
              },
              sourceIndex: e24[6]
            })), this.position++;
          }, e23.prototype.universal = function(e24) {
            var t5 = this.nextToken;
            if (t5 && t5[1] === "|")
              return this.position++, this.namespace();
            this.newNode(new g2.default({
              value: this.currToken[1],
              source: {
                start: {
                  line: this.currToken[2],
                  column: this.currToken[3]
                },
                end: {
                  line: this.currToken[2],
                  column: this.currToken[3]
                }
              },
              sourceIndex: this.currToken[4]
            }), e24), this.position++;
          }, e23.prototype.splitWord = function(e24, t5) {
            for (var r4 = this, n3 = this.nextToken, u3 = this.currToken[1]; n3 && n3[0] === "word"; ) {
              this.position++;
              var a3 = this.currToken[1];
              if (u3 += a3, a3.lastIndexOf("\\") === a3.length - 1) {
                var l3 = this.nextToken;
                l3 && l3[0] === "space" && (u3 += this.parseSpace(l3[1], " "), this.position++);
              }
              n3 = this.nextToken;
            }
            var h3 = (0, i2.default)(u3, "."), d3 = (0, i2.default)(u3, "#"), D3 = (0, i2.default)(u3, "#{");
            D3.length && (d3 = d3.filter(function(e25) {
              return !~D3.indexOf(e25);
            }));
            var g3 = (0, y2.default)((0, s2.default)((0, o2.default)([[0], h3, d3])));
            g3.forEach(function(n4, o3) {
              var i3 = g3[o3 + 1] || u3.length, s3 = u3.slice(n4, i3);
              if (o3 === 0 && t5)
                return t5.call(r4, s3, g3.length);
              var a4 = void 0;
              a4 = ~h3.indexOf(n4) ? new c2.default({
                value: s3.slice(1),
                source: {
                  start: {
                    line: r4.currToken[2],
                    column: r4.currToken[3] + n4
                  },
                  end: {
                    line: r4.currToken[4],
                    column: r4.currToken[3] + (i3 - 1)
                  }
                },
                sourceIndex: r4.currToken[6] + g3[o3]
              }) : ~d3.indexOf(n4) ? new f2.default({
                value: s3.slice(1),
                source: {
                  start: {
                    line: r4.currToken[2],
                    column: r4.currToken[3] + n4
                  },
                  end: {
                    line: r4.currToken[4],
                    column: r4.currToken[3] + (i3 - 1)
                  }
                },
                sourceIndex: r4.currToken[6] + g3[o3]
              }) : new p2.default({
                value: s3,
                source: {
                  start: {
                    line: r4.currToken[2],
                    column: r4.currToken[3] + n4
                  },
                  end: {
                    line: r4.currToken[4],
                    column: r4.currToken[3] + (i3 - 1)
                  }
                },
                sourceIndex: r4.currToken[6] + g3[o3]
              }), r4.newNode(a4, e24);
            }), this.position++;
          }, e23.prototype.word = function(e24) {
            var t5 = this.nextToken;
            return t5 && t5[1] === "|" ? (this.position++, this.namespace()) : this.splitWord(e24);
          }, e23.prototype.loop = function() {
            for (; this.position < this.tokens.length; )
              this.parse(true);
            return this.root;
          }, e23.prototype.parse = function(e24) {
            switch (this.currToken[0]) {
              case "space":
                this.space();
                break;
              case "comment":
                this.comment();
                break;
              case "(":
                this.parentheses();
                break;
              case ")":
                e24 && this.missingParenthesis();
                break;
              case "[":
                this.attribute();
                break;
              case "]":
                this.missingSquareBracket();
                break;
              case "at-word":
              case "word":
                this.word();
                break;
              case ":":
                this.pseudo();
                break;
              case ";":
                this.missingBackslash();
                break;
              case ",":
                this.comma();
                break;
              case "*":
                this.universal();
                break;
              case "&":
                this.nesting();
                break;
              case "combinator":
                this.combinator();
                break;
              case "string":
                this.string();
            }
          }, e23.prototype.parseNamespace = function(e24) {
            if (this.lossy && typeof e24 == "string") {
              var t5 = e24.trim();
              return !t5.length || t5;
            }
            return e24;
          }, e23.prototype.parseSpace = function(e24, t5) {
            return this.lossy ? t5 || "" : e24;
          }, e23.prototype.parseValue = function(e24) {
            return this.lossy && e24 && typeof e24 == "string" ? e24.trim() : e24;
          }, e23.prototype.parseParenthesisToken = function(e24) {
            return this.lossy ? e24[0] === "space" ? this.parseSpace(e24[1], " ") : this.parseValue(e24[1]) : e24[1];
          }, e23.prototype.newNode = function(e24, t5) {
            return t5 && (e24.namespace = this.parseNamespace(t5)), this.spaces && (e24.spaces.before = this.spaces, this.spaces = ""), this.current.append(e24);
          }, n2(e23, [
            {
              key: "currToken",
              get: function() {
                return this.tokens[this.position];
              }
            },
            {
              key: "nextToken",
              get: function() {
                return this.tokens[this.position + 1];
              }
            },
            {
              key: "prevToken",
              get: function() {
                return this.tokens[this.position - 1];
              }
            }
          ]), e23;
        }();
        t4.default = E2, e22.exports = t4.default;
      },
      2566: (e22, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = function() {
          function e23(e24, t5) {
            for (var r4 = 0; r4 < t5.length; r4++) {
              var n3 = t5[r4];
              n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e24, n3.key, n3);
            }
          }
          return function(t5, r4, n3) {
            return r4 && e23(t5.prototype, r4), n3 && e23(t5, n3), t5;
          };
        }(), i2 = (n2 = r3(5269)) && n2.__esModule ? n2 : { default: n2 }, s2 = function() {
          function e23(t5) {
            return function(e24, t6) {
              if (!(e24 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, e23), this.func = t5 || function() {
            }, this;
          }
          return e23.prototype.process = function(e24) {
            var t5 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r4 = new i2.default({
              css: e24,
              error: function(e25) {
                throw new Error(e25);
              },
              options: t5
            });
            return this.res = r4, this.func(r4), this;
          }, o2(e23, [
            {
              key: "result",
              get: function() {
                return String(this.res);
              }
            }
          ]), e23;
        }();
        t4.default = s2, e22.exports = t4.default;
      },
      616: (e22, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(4379)) && n2.__esModule ? n2 : { default: n2 }, i2 = r3(8790), s2 = function(e23) {
          function t5(r4) {
            !function(e24, t6) {
              if (!(e24 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e24, t6) {
              if (!e24)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
            }(this, e23.call(this, r4));
            return n3.type = i2.ATTRIBUTE, n3.raws = {}, n3;
          }
          return function(e24, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e24.prototype = Object.create(t6 && t6.prototype, {
              constructor: {
                value: e24,
                enumerable: false,
                writable: true,
                configurable: true
              }
            }), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
          }(t5, e23), t5.prototype.toString = function() {
            var e24 = [
              this.spaces.before,
              "[",
              this.ns,
              this.attribute
            ];
            return this.operator && e24.push(this.operator), this.value && e24.push(this.value), this.raws.insensitive ? e24.push(this.raws.insensitive) : this.insensitive && e24.push(" i"), e24.push("]"), e24.concat(this.spaces.after).join("");
          }, t5;
        }(o2.default);
        t4.default = s2, e22.exports = t4.default;
      },
      7835: (e22, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(4379)) && n2.__esModule ? n2 : { default: n2 }, i2 = r3(8790), s2 = function(e23) {
          function t5(r4) {
            !function(e24, t6) {
              if (!(e24 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e24, t6) {
              if (!e24)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
            }(this, e23.call(this, r4));
            return n3.type = i2.CLASS, n3;
          }
          return function(e24, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e24.prototype = Object.create(t6 && t6.prototype, {
              constructor: {
                value: e24,
                enumerable: false,
                writable: true,
                configurable: true
              }
            }), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
          }(t5, e23), t5.prototype.toString = function() {
            return [
              this.spaces.before,
              this.ns,
              String("." + this.value),
              this.spaces.after
            ].join("");
          }, t5;
        }(o2.default);
        t4.default = s2, e22.exports = t4.default;
      },
      478: (e22, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(8871)) && n2.__esModule ? n2 : { default: n2 }, i2 = r3(8790), s2 = function(e23) {
          function t5(r4) {
            !function(e24, t6) {
              if (!(e24 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e24, t6) {
              if (!e24)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
            }(this, e23.call(this, r4));
            return n3.type = i2.COMBINATOR, n3;
          }
          return function(e24, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e24.prototype = Object.create(t6 && t6.prototype, {
              constructor: {
                value: e24,
                enumerable: false,
                writable: true,
                configurable: true
              }
            }), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
          }(t5, e23), t5;
        }(o2.default);
        t4.default = s2, e22.exports = t4.default;
      },
      4907: (e22, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(8871)) && n2.__esModule ? n2 : { default: n2 }, i2 = r3(8790), s2 = function(e23) {
          function t5(r4) {
            !function(e24, t6) {
              if (!(e24 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e24, t6) {
              if (!e24)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
            }(this, e23.call(this, r4));
            return n3.type = i2.COMMENT, n3;
          }
          return function(e24, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e24.prototype = Object.create(t6 && t6.prototype, {
              constructor: {
                value: e24,
                enumerable: false,
                writable: true,
                configurable: true
              }
            }), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
          }(t5, e23), t5;
        }(o2.default);
        t4.default = s2, e22.exports = t4.default;
      },
      7144: (e22, t4, r3) => {
        r3(4070), t4.__esModule = true;
        var n2, o2 = function() {
          function e23(e24, t5) {
            for (var r4 = 0; r4 < t5.length; r4++) {
              var n3 = t5[r4];
              n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e24, n3.key, n3);
            }
          }
          return function(t5, r4, n3) {
            return r4 && e23(t5.prototype, r4), n3 && e23(t5, n3), t5;
          };
        }(), i2 = (n2 = r3(8871)) && n2.__esModule ? n2 : { default: n2 }, s2 = function(e23) {
          if (e23 && e23.__esModule)
            return e23;
          var t5 = {};
          if (e23 != null)
            for (var r4 in e23)
              Object.prototype.hasOwnProperty.call(e23, r4) && (t5[r4] = e23[r4]);
          return t5.default = e23, t5;
        }(r3(8790)), u2 = function(e23) {
          function t5(r4) {
            !function(e24, t6) {
              if (!(e24 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e24, t6) {
              if (!e24)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
            }(this, e23.call(this, r4));
            return n3.nodes || (n3.nodes = []), n3;
          }
          return function(e24, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e24.prototype = Object.create(t6 && t6.prototype, {
              constructor: {
                value: e24,
                enumerable: false,
                writable: true,
                configurable: true
              }
            }), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
          }(t5, e23), t5.prototype.append = function(e24) {
            return e24.parent = this, this.nodes.push(e24), this;
          }, t5.prototype.prepend = function(e24) {
            return e24.parent = this, this.nodes.unshift(e24), this;
          }, t5.prototype.at = function(e24) {
            return this.nodes[e24];
          }, t5.prototype.index = function(e24) {
            return typeof e24 == "number" ? e24 : this.nodes.indexOf(e24);
          }, t5.prototype.removeChild = function(e24) {
            e24 = this.index(e24), this.at(e24).parent = void 0, this.nodes.splice(e24, 1);
            var t6 = void 0;
            for (var r4 in this.indexes)
              (t6 = this.indexes[r4]) >= e24 && (this.indexes[r4] = t6 - 1);
            return this;
          }, t5.prototype.removeAll = function() {
            var e24 = this.nodes, t6 = Array.isArray(e24), r4 = 0;
            for (e24 = t6 ? e24 : e24[Symbol.iterator](); ; ) {
              var n3;
              if (t6) {
                if (r4 >= e24.length)
                  break;
                n3 = e24[r4++];
              } else {
                if ((r4 = e24.next()).done)
                  break;
                n3 = r4.value;
              }
              n3.parent = void 0;
            }
            return this.nodes = [], this;
          }, t5.prototype.empty = function() {
            return this.removeAll();
          }, t5.prototype.insertAfter = function(e24, t6) {
            var r4 = this.index(e24);
            this.nodes.splice(r4 + 1, 0, t6);
            var n3 = void 0;
            for (var o3 in this.indexes)
              r4 <= (n3 = this.indexes[o3]) && (this.indexes[o3] = n3 + this.nodes.length);
            return this;
          }, t5.prototype.insertBefore = function(e24, t6) {
            var r4 = this.index(e24);
            this.nodes.splice(r4, 0, t6);
            var n3 = void 0;
            for (var o3 in this.indexes)
              r4 <= (n3 = this.indexes[o3]) && (this.indexes[o3] = n3 + this.nodes.length);
            return this;
          }, t5.prototype.each = function(e24) {
            this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
            var t6 = this.lastEach;
            if (this.indexes[t6] = 0, this.length) {
              for (var r4 = void 0, n3 = void 0; this.indexes[t6] < this.length && (r4 = this.indexes[t6], (n3 = e24(this.at(r4), r4)) !== false); )
                this.indexes[t6] += 1;
              return delete this.indexes[t6], n3 !== false && void 0;
            }
          }, t5.prototype.walk = function(e24) {
            return this.each(function(t6, r4) {
              var n3 = e24(t6, r4);
              if (n3 !== false && t6.length && (n3 = t6.walk(e24)), n3 === false)
                return false;
            });
          }, t5.prototype.walkAttributes = function(e24) {
            var t6 = this;
            return this.walk(function(r4) {
              if (r4.type === s2.ATTRIBUTE)
                return e24.call(t6, r4);
            });
          }, t5.prototype.walkClasses = function(e24) {
            var t6 = this;
            return this.walk(function(r4) {
              if (r4.type === s2.CLASS)
                return e24.call(t6, r4);
            });
          }, t5.prototype.walkCombinators = function(e24) {
            var t6 = this;
            return this.walk(function(r4) {
              if (r4.type === s2.COMBINATOR)
                return e24.call(t6, r4);
            });
          }, t5.prototype.walkComments = function(e24) {
            var t6 = this;
            return this.walk(function(r4) {
              if (r4.type === s2.COMMENT)
                return e24.call(t6, r4);
            });
          }, t5.prototype.walkIds = function(e24) {
            var t6 = this;
            return this.walk(function(r4) {
              if (r4.type === s2.ID)
                return e24.call(t6, r4);
            });
          }, t5.prototype.walkNesting = function(e24) {
            var t6 = this;
            return this.walk(function(r4) {
              if (r4.type === s2.NESTING)
                return e24.call(t6, r4);
            });
          }, t5.prototype.walkPseudos = function(e24) {
            var t6 = this;
            return this.walk(function(r4) {
              if (r4.type === s2.PSEUDO)
                return e24.call(t6, r4);
            });
          }, t5.prototype.walkTags = function(e24) {
            var t6 = this;
            return this.walk(function(r4) {
              if (r4.type === s2.TAG)
                return e24.call(t6, r4);
            });
          }, t5.prototype.walkUniversals = function(e24) {
            var t6 = this;
            return this.walk(function(r4) {
              if (r4.type === s2.UNIVERSAL)
                return e24.call(t6, r4);
            });
          }, t5.prototype.split = function(e24) {
            var t6 = this, r4 = [];
            return this.reduce(function(n3, o3, i3) {
              var s3 = e24.call(t6, o3);
              return r4.push(o3), s3 ? (n3.push(r4), r4 = []) : i3 === t6.length - 1 && n3.push(r4), n3;
            }, []);
          }, t5.prototype.map = function(e24) {
            return this.nodes.map(e24);
          }, t5.prototype.reduce = function(e24, t6) {
            return this.nodes.reduce(e24, t6);
          }, t5.prototype.every = function(e24) {
            return this.nodes.every(e24);
          }, t5.prototype.some = function(e24) {
            return this.nodes.some(e24);
          }, t5.prototype.filter = function(e24) {
            return this.nodes.filter(e24);
          }, t5.prototype.sort = function(e24) {
            return this.nodes.sort(e24);
          }, t5.prototype.toString = function() {
            return this.map(String).join("");
          }, o2(t5, [
            {
              key: "first",
              get: function() {
                return this.at(0);
              }
            },
            {
              key: "last",
              get: function() {
                return this.at(this.length - 1);
              }
            },
            {
              key: "length",
              get: function() {
                return this.nodes.length;
              }
            }
          ]), t5;
        }(i2.default);
        t4.default = u2, e22.exports = t4.default;
      },
      8420: (e22, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(4379)) && n2.__esModule ? n2 : { default: n2 }, i2 = r3(8790), s2 = function(e23) {
          function t5(r4) {
            !function(e24, t6) {
              if (!(e24 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e24, t6) {
              if (!e24)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
            }(this, e23.call(this, r4));
            return n3.type = i2.ID, n3;
          }
          return function(e24, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e24.prototype = Object.create(t6 && t6.prototype, {
              constructor: {
                value: e24,
                enumerable: false,
                writable: true,
                configurable: true
              }
            }), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
          }(t5, e23), t5.prototype.toString = function() {
            return [
              this.spaces.before,
              this.ns,
              String("#" + this.value),
              this.spaces.after
            ].join("");
          }, t5;
        }(o2.default);
        t4.default = s2, e22.exports = t4.default;
      },
      4379: (e22, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = function() {
          function e23(e24, t5) {
            for (var r4 = 0; r4 < t5.length; r4++) {
              var n3 = t5[r4];
              n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e24, n3.key, n3);
            }
          }
          return function(t5, r4, n3) {
            return r4 && e23(t5.prototype, r4), n3 && e23(t5, n3), t5;
          };
        }();
        function i2(e23, t5) {
          if (!(e23 instanceof t5))
            throw new TypeError("Cannot call a class as a function");
        }
        function s2(e23, t5) {
          if (!e23)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return !t5 || typeof t5 != "object" && typeof t5 != "function" ? e23 : t5;
        }
        var u2 = function(e23) {
          function t5() {
            return i2(this, t5), s2(this, e23.apply(this, arguments));
          }
          return function(e24, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e24.prototype = Object.create(t6 && t6.prototype, {
              constructor: {
                value: e24,
                enumerable: false,
                writable: true,
                configurable: true
              }
            }), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
          }(t5, e23), t5.prototype.toString = function() {
            return [
              this.spaces.before,
              this.ns,
              String(this.value),
              this.spaces.after
            ].join("");
          }, o2(t5, [
            {
              key: "ns",
              get: function() {
                var e24 = this.namespace;
                return e24 ? (typeof e24 == "string" ? e24 : "") + "|" : "";
              }
            }
          ]), t5;
        }(((n2 = r3(8871)) && n2.__esModule ? n2 : { default: n2 }).default);
        t4.default = u2, e22.exports = t4.default;
      },
      7523: (e22, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(8871)) && n2.__esModule ? n2 : { default: n2 }, i2 = r3(8790), s2 = function(e23) {
          function t5(r4) {
            !function(e24, t6) {
              if (!(e24 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e24, t6) {
              if (!e24)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
            }(this, e23.call(this, r4));
            return n3.type = i2.NESTING, n3.value = "&", n3;
          }
          return function(e24, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e24.prototype = Object.create(t6 && t6.prototype, {
              constructor: {
                value: e24,
                enumerable: false,
                writable: true,
                configurable: true
              }
            }), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
          }(t5, e23), t5;
        }(o2.default);
        t4.default = s2, e22.exports = t4.default;
      },
      8871: (e22, t4) => {
        t4.__esModule = true;
        var r3 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e23) {
          return typeof e23;
        } : function(e23) {
          return e23 && typeof Symbol == "function" && e23.constructor === Symbol && e23 !== Symbol.prototype ? "symbol" : typeof e23;
        };
        function n2(e23, t5) {
          if (!(e23 instanceof t5))
            throw new TypeError("Cannot call a class as a function");
        }
        var o2 = function e23(t5, n3) {
          if ((t5 === void 0 ? "undefined" : r3(t5)) !== "object")
            return t5;
          var o3 = new t5.constructor();
          for (var i3 in t5)
            if (t5.hasOwnProperty(i3)) {
              var s2 = t5[i3], u2 = s2 === void 0 ? "undefined" : r3(s2);
              i3 === "parent" && u2 === "object" ? n3 && (o3[i3] = n3) : o3[i3] = s2 instanceof Array ? s2.map(function(t6) {
                return e23(t6, o3);
              }) : e23(s2, o3);
            }
          return o3;
        }, i2 = function() {
          function e23() {
            var t5 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            for (var r4 in n2(this, e23), t5)
              this[r4] = t5[r4];
            var o3 = t5.spaces, i3 = (o3 = o3 === void 0 ? {} : o3).before, s2 = i3 === void 0 ? "" : i3, u2 = o3.after, a2 = u2 === void 0 ? "" : u2;
            this.spaces = { before: s2, after: a2 };
          }
          return e23.prototype.remove = function() {
            return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
          }, e23.prototype.replaceWith = function() {
            if (this.parent) {
              for (var e24 in arguments)
                this.parent.insertBefore(this, arguments[e24]);
              this.remove();
            }
            return this;
          }, e23.prototype.next = function() {
            return this.parent.at(this.parent.index(this) + 1);
          }, e23.prototype.prev = function() {
            return this.parent.at(this.parent.index(this) - 1);
          }, e23.prototype.clone = function() {
            var e24 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t5 = o2(this);
            for (var r4 in e24)
              t5[r4] = e24[r4];
            return t5;
          }, e23.prototype.toString = function() {
            return [
              this.spaces.before,
              String(this.value),
              this.spaces.after
            ].join("");
          }, e23;
        }();
        t4.default = i2, e22.exports = t4.default;
      },
      4316: (e22, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(7144)) && n2.__esModule ? n2 : { default: n2 }, i2 = r3(8790), s2 = function(e23) {
          function t5(r4) {
            !function(e24, t6) {
              if (!(e24 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e24, t6) {
              if (!e24)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
            }(this, e23.call(this, r4));
            return n3.type = i2.PSEUDO, n3;
          }
          return function(e24, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e24.prototype = Object.create(t6 && t6.prototype, {
              constructor: {
                value: e24,
                enumerable: false,
                writable: true,
                configurable: true
              }
            }), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
          }(t5, e23), t5.prototype.toString = function() {
            var e24 = this.length ? "(" + this.map(String).join(",") + ")" : "";
            return [
              this.spaces.before,
              String(this.value),
              e24,
              this.spaces.after
            ].join("");
          }, t5;
        }(o2.default);
        t4.default = s2, e22.exports = t4.default;
      },
      6909: (e22, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(7144)) && n2.__esModule ? n2 : { default: n2 }, i2 = r3(8790), s2 = function(e23) {
          function t5(r4) {
            !function(e24, t6) {
              if (!(e24 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e24, t6) {
              if (!e24)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
            }(this, e23.call(this, r4));
            return n3.type = i2.ROOT, n3;
          }
          return function(e24, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e24.prototype = Object.create(t6 && t6.prototype, {
              constructor: {
                value: e24,
                enumerable: false,
                writable: true,
                configurable: true
              }
            }), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
          }(t5, e23), t5.prototype.toString = function() {
            var e24 = this.reduce(function(e25, t6) {
              var r4 = String(t6);
              return r4 ? e25 + r4 + "," : "";
            }, "").slice(0, -1);
            return this.trailingComma ? e24 + "," : e24;
          }, t5;
        }(o2.default);
        t4.default = s2, e22.exports = t4.default;
      },
      6279: (e22, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(7144)) && n2.__esModule ? n2 : { default: n2 }, i2 = r3(8790), s2 = function(e23) {
          function t5(r4) {
            !function(e24, t6) {
              if (!(e24 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e24, t6) {
              if (!e24)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
            }(this, e23.call(this, r4));
            return n3.type = i2.SELECTOR, n3;
          }
          return function(e24, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e24.prototype = Object.create(t6 && t6.prototype, {
              constructor: {
                value: e24,
                enumerable: false,
                writable: true,
                configurable: true
              }
            }), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
          }(t5, e23), t5;
        }(o2.default);
        t4.default = s2, e22.exports = t4.default;
      },
      439: (e22, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(8871)) && n2.__esModule ? n2 : { default: n2 }, i2 = r3(8790), s2 = function(e23) {
          function t5(r4) {
            !function(e24, t6) {
              if (!(e24 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e24, t6) {
              if (!e24)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
            }(this, e23.call(this, r4));
            return n3.type = i2.STRING, n3;
          }
          return function(e24, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e24.prototype = Object.create(t6 && t6.prototype, {
              constructor: {
                value: e24,
                enumerable: false,
                writable: true,
                configurable: true
              }
            }), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
          }(t5, e23), t5;
        }(o2.default);
        t4.default = s2, e22.exports = t4.default;
      },
      9956: (e22, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(4379)) && n2.__esModule ? n2 : { default: n2 }, i2 = r3(8790), s2 = function(e23) {
          function t5(r4) {
            !function(e24, t6) {
              if (!(e24 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e24, t6) {
              if (!e24)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
            }(this, e23.call(this, r4));
            return n3.type = i2.TAG, n3;
          }
          return function(e24, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e24.prototype = Object.create(t6 && t6.prototype, {
              constructor: {
                value: e24,
                enumerable: false,
                writable: true,
                configurable: true
              }
            }), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
          }(t5, e23), t5;
        }(o2.default);
        t4.default = s2, e22.exports = t4.default;
      },
      8790: (e22, t4) => {
        t4.__esModule = true, t4.TAG = "tag", t4.STRING = "string", t4.SELECTOR = "selector", t4.ROOT = "root", t4.PSEUDO = "pseudo", t4.NESTING = "nesting", t4.ID = "id", t4.COMMENT = "comment", t4.COMBINATOR = "combinator", t4.CLASS = "class", t4.ATTRIBUTE = "attribute", t4.UNIVERSAL = "universal";
      },
      70: (e22, t4, r3) => {
        t4.__esModule = true;
        var n2, o2 = (n2 = r3(4379)) && n2.__esModule ? n2 : { default: n2 }, i2 = r3(8790), s2 = function(e23) {
          function t5(r4) {
            !function(e24, t6) {
              if (!(e24 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5);
            var n3 = function(e24, t6) {
              if (!e24)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t6 || typeof t6 != "object" && typeof t6 != "function" ? e24 : t6;
            }(this, e23.call(this, r4));
            return n3.type = i2.UNIVERSAL, n3.value = "*", n3;
          }
          return function(e24, t6) {
            if (typeof t6 != "function" && t6 !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t6);
            e24.prototype = Object.create(t6 && t6.prototype, {
              constructor: {
                value: e24,
                enumerable: false,
                writable: true,
                configurable: true
              }
            }), t6 && (Object.setPrototypeOf ? Object.setPrototypeOf(e24, t6) : e24.__proto__ = t6);
          }(t5, e23), t5;
        }(o2.default);
        t4.default = s2, e22.exports = t4.default;
      },
      9788: (e22, t4, r3) => {
        r3(4070), t4.__esModule = true, t4.default = function(e23) {
          return e23.sort(function(e24, t5) {
            return e24 - t5;
          });
        }, e22.exports = t4.default;
      },
      6554: (e22, t4) => {
        t4.__esModule = true, t4.default = function(e23) {
          for (var t5 = [], o2 = e23.css.valueOf(), i2 = void 0, s2 = void 0, u2 = void 0, a2 = void 0, c2 = void 0, l2 = void 0, f2 = void 0, p2 = void 0, h2 = void 0, d2 = void 0, D2 = void 0, g2 = o2.length, m2 = -1, v2 = 1, y2 = 0, w2 = function(t6, r4) {
            if (!e23.safe)
              throw e23.error("Unclosed " + t6, v2, y2 - m2, y2);
            s2 = (o2 += r4).length - 1;
          }; y2 < g2; ) {
            switch ((i2 = o2.charCodeAt(y2)) === 10 && (m2 = y2, v2 += 1), i2) {
              case 10:
              case 32:
              case 9:
              case 13:
              case 12:
                s2 = y2;
                do {
                  s2 += 1, (i2 = o2.charCodeAt(s2)) === 10 && (m2 = s2, v2 += 1);
                } while (i2 === 32 || i2 === 10 || i2 === 9 || i2 === 13 || i2 === 12);
                t5.push([
                  "space",
                  o2.slice(y2, s2),
                  v2,
                  y2 - m2,
                  y2
                ]), y2 = s2 - 1;
                break;
              case 43:
              case 62:
              case 126:
              case 124:
                s2 = y2;
                do {
                  s2 += 1, i2 = o2.charCodeAt(s2);
                } while (i2 === 43 || i2 === 62 || i2 === 126 || i2 === 124);
                t5.push([
                  "combinator",
                  o2.slice(y2, s2),
                  v2,
                  y2 - m2,
                  y2
                ]), y2 = s2 - 1;
                break;
              case 42:
                t5.push(["*", "*", v2, y2 - m2, y2]);
                break;
              case 38:
                t5.push(["&", "&", v2, y2 - m2, y2]);
                break;
              case 44:
                t5.push([",", ",", v2, y2 - m2, y2]);
                break;
              case 91:
                t5.push(["[", "[", v2, y2 - m2, y2]);
                break;
              case 93:
                t5.push(["]", "]", v2, y2 - m2, y2]);
                break;
              case 58:
                t5.push([":", ":", v2, y2 - m2, y2]);
                break;
              case 59:
                t5.push([";", ";", v2, y2 - m2, y2]);
                break;
              case 40:
                t5.push(["(", "(", v2, y2 - m2, y2]);
                break;
              case 41:
                t5.push([")", ")", v2, y2 - m2, y2]);
                break;
              case 39:
              case 34:
                u2 = i2 === 39 ? "'" : '"', s2 = y2;
                do {
                  for (d2 = false, (s2 = o2.indexOf(u2, s2 + 1)) === -1 && w2("quote", u2), D2 = s2; o2.charCodeAt(D2 - 1) === 92; )
                    D2 -= 1, d2 = !d2;
                } while (d2);
                t5.push([
                  "string",
                  o2.slice(y2, s2 + 1),
                  v2,
                  y2 - m2,
                  v2,
                  s2 - m2,
                  y2
                ]), y2 = s2;
                break;
              case 64:
                r3.lastIndex = y2 + 1, r3.test(o2), s2 = r3.lastIndex === 0 ? o2.length - 1 : r3.lastIndex - 2, t5.push([
                  "at-word",
                  o2.slice(y2, s2 + 1),
                  v2,
                  y2 - m2,
                  v2,
                  s2 - m2,
                  y2
                ]), y2 = s2;
                break;
              case 92:
                for (s2 = y2, f2 = true; o2.charCodeAt(s2 + 1) === 92; )
                  s2 += 1, f2 = !f2;
                i2 = o2.charCodeAt(s2 + 1), f2 && i2 !== 47 && i2 !== 32 && i2 !== 10 && i2 !== 9 && i2 !== 13 && i2 !== 12 && (s2 += 1), t5.push([
                  "word",
                  o2.slice(y2, s2 + 1),
                  v2,
                  y2 - m2,
                  v2,
                  s2 - m2,
                  y2
                ]), y2 = s2;
                break;
              default:
                i2 === 47 && o2.charCodeAt(y2 + 1) === 42 ? ((s2 = o2.indexOf("*/", y2 + 2) + 1) === 0 && w2("comment", "*/"), (c2 = (a2 = (l2 = o2.slice(y2, s2 + 1)).split("\n")).length - 1) > 0 ? (p2 = v2 + c2, h2 = s2 - a2[c2].length) : (p2 = v2, h2 = m2), t5.push([
                  "comment",
                  l2,
                  v2,
                  y2 - m2,
                  p2,
                  s2 - h2,
                  y2
                ]), m2 = h2, v2 = p2, y2 = s2) : (n2.lastIndex = y2 + 1, n2.test(o2), s2 = n2.lastIndex === 0 ? o2.length - 1 : n2.lastIndex - 2, t5.push([
                  "word",
                  o2.slice(y2, s2 + 1),
                  v2,
                  y2 - m2,
                  v2,
                  s2 - m2,
                  y2
                ]), y2 = s2);
            }
            y2++;
          }
          return t5;
        };
        var r3 = /[ \n\t\r\{\(\)'"\\;/]/g, n2 = /[ \n\t\r\(\)\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g;
        e22.exports = t4.default;
      },
      5294: (e22, t4, r3) => {
        const n2 = r3(4196);
        class o2 extends n2 {
          constructor(e23) {
            super(e23), this.type = "atword";
          }
          toString() {
            return this.quoted && this.raws.quote, [
              this.raws.before,
              "@",
              String.prototype.toString.call(this.value),
              this.raws.after
            ].join("");
          }
        }
        n2.registerWalker(o2), e22.exports = o2;
      },
      8709: (e22, t4, r3) => {
        const n2 = r3(4196), o2 = r3(1466);
        class i2 extends o2 {
          constructor(e23) {
            super(e23), this.type = "colon";
          }
        }
        n2.registerWalker(i2), e22.exports = i2;
      },
      3627: (e22, t4, r3) => {
        const n2 = r3(4196), o2 = r3(1466);
        class i2 extends o2 {
          constructor(e23) {
            super(e23), this.type = "comma";
          }
        }
        n2.registerWalker(i2), e22.exports = i2;
      },
      4384: (e22, t4, r3) => {
        const n2 = r3(4196), o2 = r3(1466);
        class i2 extends o2 {
          constructor(e23) {
            super(e23), this.type = "comment", this.inline = Object(e23).inline || false;
          }
          toString() {
            return [
              this.raws.before,
              this.inline ? "//" : "/*",
              String(this.value),
              this.inline ? "" : "*/",
              this.raws.after
            ].join("");
          }
        }
        n2.registerWalker(i2), e22.exports = i2;
      },
      4196: (e22, t4, r3) => {
        const n2 = r3(1466);
        class o2 extends n2 {
          constructor(e23) {
            super(e23), this.nodes || (this.nodes = []);
          }
          push(e23) {
            return e23.parent = this, this.nodes.push(e23), this;
          }
          each(e23) {
            this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
            let t5, r4, n3 = this.lastEach;
            if (this.indexes[n3] = 0, this.nodes) {
              for (; this.indexes[n3] < this.nodes.length && (t5 = this.indexes[n3], r4 = e23(this.nodes[t5], t5), r4 !== false); )
                this.indexes[n3] += 1;
              return delete this.indexes[n3], r4;
            }
          }
          walk(e23) {
            return this.each((t5, r4) => {
              let n3 = e23(t5, r4);
              return n3 !== false && t5.walk && (n3 = t5.walk(e23)), n3;
            });
          }
          walkType(e23, t5) {
            if (!e23 || !t5)
              throw new Error("Parameters {type} and {callback} are required.");
            const r4 = typeof e23 == "function";
            return this.walk((n3, o3) => {
              if (r4 && n3 instanceof e23 || !r4 && n3.type === e23)
                return t5.call(this, n3, o3);
            });
          }
          append(e23) {
            return e23.parent = this, this.nodes.push(e23), this;
          }
          prepend(e23) {
            return e23.parent = this, this.nodes.unshift(e23), this;
          }
          cleanRaws(e23) {
            if (super.cleanRaws(e23), this.nodes)
              for (let t5 of this.nodes)
                t5.cleanRaws(e23);
          }
          insertAfter(e23, t5) {
            let r4, n3 = this.index(e23);
            this.nodes.splice(n3 + 1, 0, t5);
            for (let e24 in this.indexes)
              r4 = this.indexes[e24], n3 <= r4 && (this.indexes[e24] = r4 + this.nodes.length);
            return this;
          }
          insertBefore(e23, t5) {
            let r4, n3 = this.index(e23);
            this.nodes.splice(n3, 0, t5);
            for (let e24 in this.indexes)
              r4 = this.indexes[e24], n3 <= r4 && (this.indexes[e24] = r4 + this.nodes.length);
            return this;
          }
          removeChild(e23) {
            let t5;
            e23 = this.index(e23), this.nodes[e23].parent = void 0, this.nodes.splice(e23, 1);
            for (let r4 in this.indexes)
              t5 = this.indexes[r4], t5 >= e23 && (this.indexes[r4] = t5 - 1);
            return this;
          }
          removeAll() {
            for (let e23 of this.nodes)
              e23.parent = void 0;
            return this.nodes = [], this;
          }
          every(e23) {
            return this.nodes.every(e23);
          }
          some(e23) {
            return this.nodes.some(e23);
          }
          index(e23) {
            return typeof e23 == "number" ? e23 : this.nodes.indexOf(e23);
          }
          get first() {
            if (this.nodes)
              return this.nodes[0];
          }
          get last() {
            if (this.nodes)
              return this.nodes[this.nodes.length - 1];
          }
          toString() {
            let e23 = this.nodes.map(String).join("");
            return this.value && (e23 = this.value + e23), this.raws.before && (e23 = this.raws.before + e23), this.raws.after && (e23 += this.raws.after), e23;
          }
        }
        o2.registerWalker = (e23) => {
          let t5 = "walk" + e23.name;
          t5.lastIndexOf("s") !== t5.length - 1 && (t5 += "s"), o2.prototype[t5] || (o2.prototype[t5] = function(t6) {
            return this.walkType(e23, t6);
          });
        }, e22.exports = o2;
      },
      9645: (e22) => {
        class t4 extends Error {
          constructor(e23) {
            super(e23), this.name = this.constructor.name, this.message = e23 || "An error ocurred while parsing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(e23).stack;
          }
        }
        e22.exports = t4;
      },
      5128: (e22) => {
        class t4 extends Error {
          constructor(e23) {
            super(e23), this.name = this.constructor.name, this.message = e23 || "An error ocurred while tokzenizing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(e23).stack;
          }
        }
        e22.exports = t4;
      },
      4320: (e22, t4, r3) => {
        const n2 = r3(4196);
        class o2 extends n2 {
          constructor(e23) {
            super(e23), this.type = "func", this.unbalanced = -1;
          }
        }
        n2.registerWalker(o2), e22.exports = o2;
      },
      9962: (e22, t4, r3) => {
        const n2 = r3(3784), o2 = r3(5294), i2 = r3(8709), s2 = r3(3627), u2 = r3(4384), a2 = r3(4320), c2 = r3(3074), l2 = r3(7214), f2 = r3(1238), p2 = r3(9672), h2 = r3(1369), d2 = r3(2057), D2 = r3(6593);
        let g2 = function(e23, t5) {
          return new n2(e23, t5);
        };
        g2.atword = function(e23) {
          return new o2(e23);
        }, g2.colon = function(e23) {
          return new i2(Object.assign({ value: ":" }, e23));
        }, g2.comma = function(e23) {
          return new s2(Object.assign({ value: "," }, e23));
        }, g2.comment = function(e23) {
          return new u2(e23);
        }, g2.func = function(e23) {
          return new a2(e23);
        }, g2.number = function(e23) {
          return new c2(e23);
        }, g2.operator = function(e23) {
          return new l2(e23);
        }, g2.paren = function(e23) {
          return new f2(Object.assign({ value: "(" }, e23));
        }, g2.string = function(e23) {
          return new p2(Object.assign({ quote: "'" }, e23));
        }, g2.value = function(e23) {
          return new d2(e23);
        }, g2.word = function(e23) {
          return new D2(e23);
        }, g2.unicodeRange = function(e23) {
          return new h2(e23);
        }, e22.exports = g2;
      },
      1466: (e22) => {
        let t4 = function(e23, r3) {
          let n2 = new e23.constructor();
          for (let o2 in e23) {
            if (!e23.hasOwnProperty(o2))
              continue;
            let i2 = e23[o2], s2 = typeof i2;
            o2 === "parent" && s2 === "object" ? r3 && (n2[o2] = r3) : o2 === "source" ? n2[o2] = i2 : i2 instanceof Array ? n2[o2] = i2.map((e24) => t4(e24, n2)) : o2 !== "before" && o2 !== "after" && o2 !== "between" && o2 !== "semicolon" && (s2 === "object" && i2 !== null && (i2 = t4(i2)), n2[o2] = i2);
          }
          return n2;
        };
        e22.exports = class {
          constructor(e23) {
            e23 = e23 || {}, this.raws = { before: "", after: "" };
            for (let t5 in e23)
              this[t5] = e23[t5];
          }
          remove() {
            return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
          }
          toString() {
            return [
              this.raws.before,
              String(this.value),
              this.raws.after
            ].join("");
          }
          clone(e23) {
            e23 = e23 || {};
            let r3 = t4(this);
            for (let t5 in e23)
              r3[t5] = e23[t5];
            return r3;
          }
          cloneBefore(e23) {
            e23 = e23 || {};
            let t5 = this.clone(e23);
            return this.parent.insertBefore(this, t5), t5;
          }
          cloneAfter(e23) {
            e23 = e23 || {};
            let t5 = this.clone(e23);
            return this.parent.insertAfter(this, t5), t5;
          }
          replaceWith() {
            let e23 = Array.prototype.slice.call(arguments);
            if (this.parent) {
              for (let t5 of e23)
                this.parent.insertBefore(this, t5);
              this.remove();
            }
            return this;
          }
          moveTo(e23) {
            return this.cleanRaws(this.root() === e23.root()), this.remove(), e23.append(this), this;
          }
          moveBefore(e23) {
            return this.cleanRaws(this.root() === e23.root()), this.remove(), e23.parent.insertBefore(e23, this), this;
          }
          moveAfter(e23) {
            return this.cleanRaws(this.root() === e23.root()), this.remove(), e23.parent.insertAfter(e23, this), this;
          }
          next() {
            let e23 = this.parent.index(this);
            return this.parent.nodes[e23 + 1];
          }
          prev() {
            let e23 = this.parent.index(this);
            return this.parent.nodes[e23 - 1];
          }
          toJSON() {
            let e23 = {};
            for (let t5 in this) {
              if (!this.hasOwnProperty(t5))
                continue;
              if (t5 === "parent")
                continue;
              let r3 = this[t5];
              r3 instanceof Array ? e23[t5] = r3.map((e24) => typeof e24 == "object" && e24.toJSON ? e24.toJSON() : e24) : typeof r3 == "object" && r3.toJSON ? e23[t5] = r3.toJSON() : e23[t5] = r3;
            }
            return e23;
          }
          root() {
            let e23 = this;
            for (; e23.parent; )
              e23 = e23.parent;
            return e23;
          }
          cleanRaws(e23) {
            delete this.raws.before, delete this.raws.after, e23 || delete this.raws.between;
          }
          positionInside(e23) {
            let t5 = this.toString(), r3 = this.source.start.column, n2 = this.source.start.line;
            for (let o2 = 0; o2 < e23; o2++)
              t5[o2] === "\n" ? (r3 = 1, n2 += 1) : r3 += 1;
            return { line: n2, column: r3 };
          }
          positionBy(e23) {
            let t5 = this.source.start;
            if (Object(e23).index)
              t5 = this.positionInside(e23.index);
            else if (Object(e23).word) {
              let r3 = this.toString().indexOf(e23.word);
              r3 !== -1 && (t5 = this.positionInside(r3));
            }
            return t5;
          }
        };
      },
      3074: (e22, t4, r3) => {
        const n2 = r3(4196), o2 = r3(1466);
        class i2 extends o2 {
          constructor(e23) {
            super(e23), this.type = "number", this.unit = Object(e23).unit || "";
          }
          toString() {
            return [
              this.raws.before,
              String(this.value),
              this.unit,
              this.raws.after
            ].join("");
          }
        }
        n2.registerWalker(i2), e22.exports = i2;
      },
      7214: (e22, t4, r3) => {
        const n2 = r3(4196), o2 = r3(1466);
        class i2 extends o2 {
          constructor(e23) {
            super(e23), this.type = "operator";
          }
        }
        n2.registerWalker(i2), e22.exports = i2;
      },
      1238: (e22, t4, r3) => {
        const n2 = r3(4196), o2 = r3(1466);
        class i2 extends o2 {
          constructor(e23) {
            super(e23), this.type = "paren", this.parenType = "";
          }
        }
        n2.registerWalker(i2), e22.exports = i2;
      },
      3784: (e22, t4, r3) => {
        r3(4070);
        const n2 = r3(4343), o2 = r3(2057), i2 = r3(5294), s2 = r3(8709), u2 = r3(3627), a2 = r3(4384), c2 = r3(4320), l2 = r3(3074), f2 = r3(7214), p2 = r3(1238), h2 = r3(9672), d2 = r3(6593), D2 = r3(1369), g2 = r3(2481), m2 = r3(8051), v2 = r3(7886), y2 = r3(3210), w2 = r3(9645);
        e22.exports = class {
          constructor(e23, t5) {
            this.cache = [], this.input = e23, this.options = Object.assign({}, { loose: false }, t5), this.position = 0, this.unbalanced = 0, this.root = new n2();
            let r4 = new o2();
            this.root.append(r4), this.current = r4, this.tokens = g2(e23, this.options);
          }
          parse() {
            return this.loop();
          }
          colon() {
            let e23 = this.currToken;
            this.newNode(new s2({
              value: e23[1],
              source: {
                start: {
                  line: e23[2],
                  column: e23[3]
                },
                end: {
                  line: e23[4],
                  column: e23[5]
                }
              },
              sourceIndex: e23[6]
            })), this.position++;
          }
          comma() {
            let e23 = this.currToken;
            this.newNode(new u2({
              value: e23[1],
              source: {
                start: {
                  line: e23[2],
                  column: e23[3]
                },
                end: {
                  line: e23[4],
                  column: e23[5]
                }
              },
              sourceIndex: e23[6]
            })), this.position++;
          }
          comment() {
            let e23, t5 = false, r4 = this.currToken[1].replace(/\/\*|\*\//g, "");
            this.options.loose && r4.startsWith("//") && (r4 = r4.substring(2), t5 = true), e23 = new a2({
              value: r4,
              inline: t5,
              source: {
                start: {
                  line: this.currToken[2],
                  column: this.currToken[3]
                },
                end: {
                  line: this.currToken[4],
                  column: this.currToken[5]
                }
              },
              sourceIndex: this.currToken[6]
            }), this.newNode(e23), this.position++;
          }
          error(e23, t5) {
            throw new w2(e23 + ` at line: ${t5[2]}, column ${t5[3]}`);
          }
          loop() {
            for (; this.position < this.tokens.length; )
              this.parseTokens();
            return !this.current.last && this.spaces ? this.current.raws.before += this.spaces : this.spaces && (this.current.last.raws.after += this.spaces), this.spaces = "", this.root;
          }
          operator() {
            let e23, t5 = this.currToken[1];
            if (t5 === "+" || t5 === "-") {
              if (this.options.loose || this.position > 0 && (this.current.type === "func" && this.current.value === "calc" ? (this.prevToken[0] !== "space" && this.prevToken[0] !== "(" || this.nextToken[0] !== "space" && this.nextToken[0] !== "word" || this.nextToken[0] === "word" && this.current.last.type !== "operator" && this.current.last.value !== "(") && this.error("Syntax Error", this.currToken) : this.nextToken[0] !== "space" && this.nextToken[0] !== "operator" && this.prevToken[0] !== "operator" || this.error("Syntax Error", this.currToken)), this.options.loose) {
                if ((!this.current.nodes.length || this.current.last && this.current.last.type === "operator") && this.nextToken[0] === "word")
                  return this.word();
              } else if (this.nextToken[0] === "word")
                return this.word();
            }
            return e23 = new f2({
              value: this.currToken[1],
              source: {
                start: {
                  line: this.currToken[2],
                  column: this.currToken[3]
                },
                end: {
                  line: this.currToken[2],
                  column: this.currToken[3]
                }
              },
              sourceIndex: this.currToken[4]
            }), this.position++, this.newNode(e23);
          }
          parseTokens() {
            switch (this.currToken[0]) {
              case "space":
                this.space();
                break;
              case "colon":
                this.colon();
                break;
              case "comma":
                this.comma();
                break;
              case "comment":
                this.comment();
                break;
              case "(":
                this.parenOpen();
                break;
              case ")":
                this.parenClose();
                break;
              case "atword":
              case "word":
                this.word();
                break;
              case "operator":
                this.operator();
                break;
              case "string":
                this.string();
                break;
              case "unicoderange":
                this.unicodeRange();
                break;
              default:
                this.word();
            }
          }
          parenOpen() {
            let e23, t5 = 1, r4 = this.position + 1, n3 = this.currToken;
            for (; r4 < this.tokens.length && t5; ) {
              let e24 = this.tokens[r4];
              e24[0] === "(" && t5++, e24[0] === ")" && t5--, r4++;
            }
            if (t5 && this.error("Expected closing parenthesis", n3), e23 = this.current.last, e23 && e23.type === "func" && e23.unbalanced < 0 && (e23.unbalanced = 0, this.current = e23), this.current.unbalanced++, this.newNode(new p2({
              value: n3[1],
              source: {
                start: {
                  line: n3[2],
                  column: n3[3]
                },
                end: {
                  line: n3[4],
                  column: n3[5]
                }
              },
              sourceIndex: n3[6]
            })), this.position++, this.current.type === "func" && this.current.unbalanced && this.current.value === "url" && this.currToken[0] !== "string" && this.currToken[0] !== ")" && !this.options.loose) {
              let e24 = this.nextToken, t6 = this.currToken[1], r5 = {
                line: this.currToken[2],
                column: this.currToken[3]
              };
              for (; e24 && e24[0] !== ")" && this.current.unbalanced; )
                this.position++, t6 += this.currToken[1], e24 = this.nextToken;
              this.position !== this.tokens.length - 1 && (this.position++, this.newNode(new d2({
                value: t6,
                source: {
                  start: r5,
                  end: {
                    line: this.currToken[4],
                    column: this.currToken[5]
                  }
                },
                sourceIndex: this.currToken[6]
              })));
            }
          }
          parenClose() {
            let e23 = this.currToken;
            this.newNode(new p2({
              value: e23[1],
              source: {
                start: {
                  line: e23[2],
                  column: e23[3]
                },
                end: {
                  line: e23[4],
                  column: e23[5]
                }
              },
              sourceIndex: e23[6]
            })), this.position++, this.position >= this.tokens.length - 1 && !this.current.unbalanced || (this.current.unbalanced--, this.current.unbalanced < 0 && this.error("Expected opening parenthesis", e23), !this.current.unbalanced && this.cache.length && (this.current = this.cache.pop()));
          }
          space() {
            let e23 = this.currToken;
            this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.raws.after += e23[1], this.position++) : (this.spaces = e23[1], this.position++);
          }
          unicodeRange() {
            let e23 = this.currToken;
            this.newNode(new D2({
              value: e23[1],
              source: {
                start: {
                  line: e23[2],
                  column: e23[3]
                },
                end: {
                  line: e23[4],
                  column: e23[5]
                }
              },
              sourceIndex: e23[6]
            })), this.position++;
          }
          splitWord() {
            let e23, t5, r4 = this.nextToken, n3 = this.currToken[1], o3 = /^[\+\-]?((\d+(\.\d*)?)|(\.\d+))([eE][\+\-]?\d+)?/;
            if (!/^(?!\#([a-z0-9]+))[\#\{\}]/gi.test(n3))
              for (; r4 && r4[0] === "word"; ) {
                this.position++;
                let e24 = this.currToken[1];
                n3 += e24, r4 = this.nextToken;
              }
            var s3;
            e23 = v2(n3, "@"), s3 = y2(m2([[0], e23])), t5 = s3.sort((e24, t6) => e24 - t6), t5.forEach((s4, u3) => {
              let a3, f3 = t5[u3 + 1] || n3.length, p3 = n3.slice(s4, f3);
              if (~e23.indexOf(s4))
                a3 = new i2({
                  value: p3.slice(1),
                  source: {
                    start: {
                      line: this.currToken[2],
                      column: this.currToken[3] + s4
                    },
                    end: {
                      line: this.currToken[4],
                      column: this.currToken[3] + (f3 - 1)
                    }
                  },
                  sourceIndex: this.currToken[6] + t5[u3]
                });
              else if (o3.test(this.currToken[1])) {
                let e24 = p3.replace(o3, "");
                a3 = new l2({
                  value: p3.replace(e24, ""),
                  source: {
                    start: {
                      line: this.currToken[2],
                      column: this.currToken[3] + s4
                    },
                    end: {
                      line: this.currToken[4],
                      column: this.currToken[3] + (f3 - 1)
                    }
                  },
                  sourceIndex: this.currToken[6] + t5[u3],
                  unit: e24
                });
              } else
                a3 = new (r4 && r4[0] === "(" ? c2 : d2)({
                  value: p3,
                  source: {
                    start: {
                      line: this.currToken[2],
                      column: this.currToken[3] + s4
                    },
                    end: {
                      line: this.currToken[4],
                      column: this.currToken[3] + (f3 - 1)
                    }
                  },
                  sourceIndex: this.currToken[6] + t5[u3]
                }), a3.constructor.name === "Word" ? (a3.isHex = /^#(.+)/.test(p3), a3.isColor = /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i.test(p3)) : this.cache.push(this.current);
              this.newNode(a3);
            }), this.position++;
          }
          string() {
            let e23, t5 = this.currToken, r4 = this.currToken[1], n3 = /^(\"|\')/, o3 = n3.test(r4), i3 = "";
            o3 && (i3 = r4.match(n3)[0], r4 = r4.slice(1, r4.length - 1)), e23 = new h2({
              value: r4,
              source: {
                start: {
                  line: t5[2],
                  column: t5[3]
                },
                end: {
                  line: t5[4],
                  column: t5[5]
                }
              },
              sourceIndex: t5[6],
              quoted: o3
            }), e23.raws.quote = i3, this.newNode(e23), this.position++;
          }
          word() {
            return this.splitWord();
          }
          newNode(e23) {
            return this.spaces && (e23.raws.before += this.spaces, this.spaces = ""), this.current.append(e23);
          }
          get currToken() {
            return this.tokens[this.position];
          }
          get nextToken() {
            return this.tokens[this.position + 1];
          }
          get prevToken() {
            return this.tokens[this.position - 1];
          }
        };
      },
      4343: (e22, t4, r3) => {
        const n2 = r3(4196);
        e22.exports = class extends n2 {
          constructor(e23) {
            super(e23), this.type = "root";
          }
        };
      },
      9672: (e22, t4, r3) => {
        const n2 = r3(4196), o2 = r3(1466);
        class i2 extends o2 {
          constructor(e23) {
            super(e23), this.type = "string";
          }
          toString() {
            let e23 = this.quoted ? this.raws.quote : "";
            return [
              this.raws.before,
              e23,
              this.value + "",
              e23,
              this.raws.after
            ].join("");
          }
        }
        n2.registerWalker(i2), e22.exports = i2;
      },
      2481: (e22, t4, r3) => {
        const n2 = "{".charCodeAt(0), o2 = "}".charCodeAt(0), i2 = "(".charCodeAt(0), s2 = ")".charCodeAt(0), u2 = "'".charCodeAt(0), a2 = '"'.charCodeAt(0), c2 = "\\".charCodeAt(0), l2 = "/".charCodeAt(0), f2 = ".".charCodeAt(0), p2 = ",".charCodeAt(0), h2 = ":".charCodeAt(0), d2 = "*".charCodeAt(0), D2 = "-".charCodeAt(0), g2 = "+".charCodeAt(0), m2 = "#".charCodeAt(0), v2 = "\n".charCodeAt(0), y2 = " ".charCodeAt(0), w2 = "\f".charCodeAt(0), b2 = "	".charCodeAt(0), C2 = "\r".charCodeAt(0), E2 = "@".charCodeAt(0), F2 = "e".charCodeAt(0), x2 = "E".charCodeAt(0), A2 = "0".charCodeAt(0), k2 = "9".charCodeAt(0), O2 = "u".charCodeAt(0), _2 = "U".charCodeAt(0), S2 = /[ \n\t\r\{\(\)'"\\;,/]/g, T2 = /[ \n\t\r\(\)\{\}\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g, I2 = /[ \n\t\r\(\)\{\}\*:;@!&'"\-\+\|~>,\[\]\\]|\//g, N2 = /^[a-z0-9]/i, M2 = /^[a-f0-9?\-]/i, R2 = r3(8472), j2 = r3(5128);
        e22.exports = function(e23, t5) {
          t5 = t5 || {};
          let r4, L2, B2, P2, $2, U2, G2, W2, z2, V2, q2, X2 = [], J2 = e23.valueOf(), H2 = J2.length, Y2 = -1, K2 = 1, Z2 = 0, Q2 = 0, ee2 = null;
          function te2(e24) {
            let t6 = R2.format("Unclosed %s at line: %d, column: %d, token: %d", e24, K2, Z2 - Y2, Z2);
            throw new j2(t6);
          }
          for (; Z2 < H2; ) {
            switch (r4 = J2.charCodeAt(Z2), r4 === v2 && (Y2 = Z2, K2 += 1), r4) {
              case v2:
              case y2:
              case b2:
              case C2:
              case w2:
                L2 = Z2;
                do {
                  L2 += 1, r4 = J2.charCodeAt(L2), r4 === v2 && (Y2 = L2, K2 += 1);
                } while (r4 === y2 || r4 === v2 || r4 === b2 || r4 === C2 || r4 === w2);
                X2.push([
                  "space",
                  J2.slice(Z2, L2),
                  K2,
                  Z2 - Y2,
                  K2,
                  L2 - Y2,
                  Z2
                ]), Z2 = L2 - 1;
                break;
              case h2:
                L2 = Z2 + 1, X2.push([
                  "colon",
                  J2.slice(Z2, L2),
                  K2,
                  Z2 - Y2,
                  K2,
                  L2 - Y2,
                  Z2
                ]), Z2 = L2 - 1;
                break;
              case p2:
                L2 = Z2 + 1, X2.push([
                  "comma",
                  J2.slice(Z2, L2),
                  K2,
                  Z2 - Y2,
                  K2,
                  L2 - Y2,
                  Z2
                ]), Z2 = L2 - 1;
                break;
              case n2:
                X2.push([
                  "{",
                  "{",
                  K2,
                  Z2 - Y2,
                  K2,
                  L2 - Y2,
                  Z2
                ]);
                break;
              case o2:
                X2.push([
                  "}",
                  "}",
                  K2,
                  Z2 - Y2,
                  K2,
                  L2 - Y2,
                  Z2
                ]);
                break;
              case i2:
                Q2++, ee2 = !ee2 && Q2 === 1 && X2.length > 0 && X2[X2.length - 1][0] === "word" && X2[X2.length - 1][1] === "url", X2.push([
                  "(",
                  "(",
                  K2,
                  Z2 - Y2,
                  K2,
                  L2 - Y2,
                  Z2
                ]);
                break;
              case s2:
                Q2--, ee2 = ee2 && Q2 > 0, X2.push([
                  ")",
                  ")",
                  K2,
                  Z2 - Y2,
                  K2,
                  L2 - Y2,
                  Z2
                ]);
                break;
              case u2:
              case a2:
                B2 = r4 === u2 ? "'" : '"', L2 = Z2;
                do {
                  for (z2 = false, L2 = J2.indexOf(B2, L2 + 1), L2 === -1 && te2("quote"), V2 = L2; J2.charCodeAt(V2 - 1) === c2; )
                    V2 -= 1, z2 = !z2;
                } while (z2);
                X2.push([
                  "string",
                  J2.slice(Z2, L2 + 1),
                  K2,
                  Z2 - Y2,
                  K2,
                  L2 - Y2,
                  Z2
                ]), Z2 = L2;
                break;
              case E2:
                S2.lastIndex = Z2 + 1, S2.test(J2), L2 = S2.lastIndex === 0 ? J2.length - 1 : S2.lastIndex - 2, X2.push([
                  "atword",
                  J2.slice(Z2, L2 + 1),
                  K2,
                  Z2 - Y2,
                  K2,
                  L2 - Y2,
                  Z2
                ]), Z2 = L2;
                break;
              case c2:
                L2 = Z2, r4 = J2.charCodeAt(L2 + 1), X2.push([
                  "word",
                  J2.slice(Z2, L2 + 1),
                  K2,
                  Z2 - Y2,
                  K2,
                  L2 - Y2,
                  Z2
                ]), Z2 = L2;
                break;
              case g2:
              case D2:
              case d2:
                if (L2 = Z2 + 1, q2 = J2.slice(Z2 + 1, L2 + 1), J2.slice(Z2 - 1, Z2), r4 === D2 && q2.charCodeAt(0) === D2) {
                  L2++, X2.push([
                    "word",
                    J2.slice(Z2, L2),
                    K2,
                    Z2 - Y2,
                    K2,
                    L2 - Y2,
                    Z2
                  ]), Z2 = L2 - 1;
                  break;
                }
                X2.push([
                  "operator",
                  J2.slice(Z2, L2),
                  K2,
                  Z2 - Y2,
                  K2,
                  L2 - Y2,
                  Z2
                ]), Z2 = L2 - 1;
                break;
              default:
                if (r4 === l2 && (J2.charCodeAt(Z2 + 1) === d2 || t5.loose && !ee2 && J2.charCodeAt(Z2 + 1) === l2)) {
                  if (J2.charCodeAt(Z2 + 1) === d2)
                    L2 = J2.indexOf("*/", Z2 + 2) + 1, L2 === 0 && te2("comment");
                  else {
                    const e24 = J2.indexOf("\n", Z2 + 2);
                    L2 = e24 !== -1 ? e24 - 1 : H2;
                  }
                  U2 = J2.slice(Z2, L2 + 1), P2 = U2.split("\n"), $2 = P2.length - 1, $2 > 0 ? (G2 = K2 + $2, W2 = L2 - P2[$2].length) : (G2 = K2, W2 = Y2), X2.push([
                    "comment",
                    U2,
                    K2,
                    Z2 - Y2,
                    G2,
                    L2 - W2,
                    Z2
                  ]), Y2 = W2, K2 = G2, Z2 = L2;
                } else if (r4 !== m2 || N2.test(J2.slice(Z2 + 1, Z2 + 2)))
                  if (r4 !== O2 && r4 !== _2 || J2.charCodeAt(Z2 + 1) !== g2)
                    if (r4 === l2)
                      L2 = Z2 + 1, X2.push([
                        "operator",
                        J2.slice(Z2, L2),
                        K2,
                        Z2 - Y2,
                        K2,
                        L2 - Y2,
                        Z2
                      ]), Z2 = L2 - 1;
                    else {
                      let e24 = T2;
                      if (r4 >= A2 && r4 <= k2 && (e24 = I2), e24.lastIndex = Z2 + 1, e24.test(J2), L2 = e24.lastIndex === 0 ? J2.length - 1 : e24.lastIndex - 2, e24 === I2 || r4 === f2) {
                        let e25 = J2.charCodeAt(L2), t6 = J2.charCodeAt(L2 + 1), r5 = J2.charCodeAt(L2 + 2);
                        (e25 === F2 || e25 === x2) && (t6 === D2 || t6 === g2) && r5 >= A2 && r5 <= k2 && (I2.lastIndex = L2 + 2, I2.test(J2), L2 = I2.lastIndex === 0 ? J2.length - 1 : I2.lastIndex - 2);
                      }
                      X2.push([
                        "word",
                        J2.slice(Z2, L2 + 1),
                        K2,
                        Z2 - Y2,
                        K2,
                        L2 - Y2,
                        Z2
                      ]), Z2 = L2;
                    }
                  else {
                    L2 = Z2 + 2;
                    do {
                      L2 += 1, r4 = J2.charCodeAt(L2);
                    } while (L2 < H2 && M2.test(J2.slice(L2, L2 + 1)));
                    X2.push([
                      "unicoderange",
                      J2.slice(Z2, L2),
                      K2,
                      Z2 - Y2,
                      K2,
                      L2 - Y2,
                      Z2
                    ]), Z2 = L2 - 1;
                  }
                else
                  L2 = Z2 + 1, X2.push([
                    "#",
                    J2.slice(Z2, L2),
                    K2,
                    Z2 - Y2,
                    K2,
                    L2 - Y2,
                    Z2
                  ]), Z2 = L2 - 1;
            }
            Z2++;
          }
          return X2;
        };
      },
      1369: (e22, t4, r3) => {
        const n2 = r3(4196), o2 = r3(1466);
        class i2 extends o2 {
          constructor(e23) {
            super(e23), this.type = "unicode-range";
          }
        }
        n2.registerWalker(i2), e22.exports = i2;
      },
      2057: (e22, t4, r3) => {
        const n2 = r3(4196);
        e22.exports = class extends n2 {
          constructor(e23) {
            super(e23), this.type = "value", this.unbalanced = 0;
          }
        };
      },
      6593: (e22, t4, r3) => {
        const n2 = r3(4196), o2 = r3(1466);
        class i2 extends o2 {
          constructor(e23) {
            super(e23), this.type = "word";
          }
        }
        n2.registerWalker(i2), e22.exports = i2;
      },
      8940: (e22, t4, r3) => {
        var n2;
        t4.__esModule = true, t4.default = void 0;
        var o2 = function(e23) {
          var t5, r4;
          function n3(t6) {
            var r5;
            return (r5 = e23.call(this, t6) || this).type = "atrule", r5;
          }
          r4 = e23, (t5 = n3).prototype = Object.create(r4.prototype), t5.prototype.constructor = t5, t5.__proto__ = r4;
          var o3 = n3.prototype;
          return o3.append = function() {
            var t6;
            this.nodes || (this.nodes = []);
            for (var r5 = arguments.length, n4 = new Array(r5), o4 = 0; o4 < r5; o4++)
              n4[o4] = arguments[o4];
            return (t6 = e23.prototype.append).call.apply(t6, [this].concat(n4));
          }, o3.prepend = function() {
            var t6;
            this.nodes || (this.nodes = []);
            for (var r5 = arguments.length, n4 = new Array(r5), o4 = 0; o4 < r5; o4++)
              n4[o4] = arguments[o4];
            return (t6 = e23.prototype.prepend).call.apply(t6, [this].concat(n4));
          }, n3;
        }(((n2 = r3(1204)) && n2.__esModule ? n2 : { default: n2 }).default);
        t4.default = o2, e22.exports = t4.default;
      },
      3102: (e22, t4, r3) => {
        var n2;
        t4.__esModule = true, t4.default = void 0;
        var o2 = function(e23) {
          var t5, r4;
          function n3(t6) {
            var r5;
            return (r5 = e23.call(this, t6) || this).type = "comment", r5;
          }
          return r4 = e23, (t5 = n3).prototype = Object.create(r4.prototype), t5.prototype.constructor = t5, t5.__proto__ = r4, n3;
        }(((n2 = r3(1714)) && n2.__esModule ? n2 : { default: n2 }).default);
        t4.default = o2, e22.exports = t4.default;
      },
      1204: (e22, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2 = i2(r3(6417)), o2 = i2(r3(3102));
        function i2(e23) {
          return e23 && e23.__esModule ? e23 : { default: e23 };
        }
        function s2(e23, t5) {
          var r4;
          if (typeof Symbol == "undefined" || e23[Symbol.iterator] == null) {
            if (Array.isArray(e23) || (r4 = function(e24, t6) {
              if (e24) {
                if (typeof e24 == "string")
                  return u2(e24, t6);
                var r5 = Object.prototype.toString.call(e24).slice(8, -1);
                return r5 === "Object" && e24.constructor && (r5 = e24.constructor.name), r5 === "Map" || r5 === "Set" ? Array.from(e24) : r5 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r5) ? u2(e24, t6) : void 0;
              }
            }(e23)) || t5 && e23 && typeof e23.length == "number") {
              r4 && (e23 = r4);
              var n3 = 0;
              return function() {
                return n3 >= e23.length ? { done: true } : { done: false, value: e23[n3++] };
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          return (r4 = e23[Symbol.iterator]()).next.bind(r4);
        }
        function u2(e23, t5) {
          (t5 == null || t5 > e23.length) && (t5 = e23.length);
          for (var r4 = 0, n3 = new Array(t5); r4 < t5; r4++)
            n3[r4] = e23[r4];
          return n3;
        }
        function a2(e23, t5) {
          for (var r4 = 0; r4 < t5.length; r4++) {
            var n3 = t5[r4];
            n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e23, n3.key, n3);
          }
        }
        function c2(e23) {
          return e23.map(function(e24) {
            return e24.nodes && (e24.nodes = c2(e24.nodes)), delete e24.source, e24;
          });
        }
        var l2 = function(e23) {
          var t5, i3;
          function u3() {
            return e23.apply(this, arguments) || this;
          }
          i3 = e23, (t5 = u3).prototype = Object.create(i3.prototype), t5.prototype.constructor = t5, t5.__proto__ = i3;
          var l3, f2 = u3.prototype;
          return f2.push = function(e24) {
            return e24.parent = this, this.nodes.push(e24), this;
          }, f2.each = function(e24) {
            this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
            var t6 = this.lastEach;
            if (this.indexes[t6] = 0, this.nodes) {
              for (var r4, n3; this.indexes[t6] < this.nodes.length && (r4 = this.indexes[t6], (n3 = e24(this.nodes[r4], r4)) !== false); )
                this.indexes[t6] += 1;
              return delete this.indexes[t6], n3;
            }
          }, f2.walk = function(e24) {
            return this.each(function(t6, r4) {
              var n3;
              try {
                n3 = e24(t6, r4);
              } catch (e25) {
                if (e25.postcssNode = t6, e25.stack && t6.source && /\n\s{4}at /.test(e25.stack)) {
                  var o3 = t6.source;
                  e25.stack = e25.stack.replace(/\n\s{4}at /, "$&" + o3.input.from + ":" + o3.start.line + ":" + o3.start.column + "$&");
                }
                throw e25;
              }
              return n3 !== false && t6.walk && (n3 = t6.walk(e24)), n3;
            });
          }, f2.walkDecls = function(e24, t6) {
            return t6 ? e24 instanceof RegExp ? this.walk(function(r4, n3) {
              if (r4.type === "decl" && e24.test(r4.prop))
                return t6(r4, n3);
            }) : this.walk(function(r4, n3) {
              if (r4.type === "decl" && r4.prop === e24)
                return t6(r4, n3);
            }) : (t6 = e24, this.walk(function(e25, r4) {
              if (e25.type === "decl")
                return t6(e25, r4);
            }));
          }, f2.walkRules = function(e24, t6) {
            return t6 ? e24 instanceof RegExp ? this.walk(function(r4, n3) {
              if (r4.type === "rule" && e24.test(r4.selector))
                return t6(r4, n3);
            }) : this.walk(function(r4, n3) {
              if (r4.type === "rule" && r4.selector === e24)
                return t6(r4, n3);
            }) : (t6 = e24, this.walk(function(e25, r4) {
              if (e25.type === "rule")
                return t6(e25, r4);
            }));
          }, f2.walkAtRules = function(e24, t6) {
            return t6 ? e24 instanceof RegExp ? this.walk(function(r4, n3) {
              if (r4.type === "atrule" && e24.test(r4.name))
                return t6(r4, n3);
            }) : this.walk(function(r4, n3) {
              if (r4.type === "atrule" && r4.name === e24)
                return t6(r4, n3);
            }) : (t6 = e24, this.walk(function(e25, r4) {
              if (e25.type === "atrule")
                return t6(e25, r4);
            }));
          }, f2.walkComments = function(e24) {
            return this.walk(function(t6, r4) {
              if (t6.type === "comment")
                return e24(t6, r4);
            });
          }, f2.append = function() {
            for (var e24 = arguments.length, t6 = new Array(e24), r4 = 0; r4 < e24; r4++)
              t6[r4] = arguments[r4];
            for (var n3 = 0, o3 = t6; n3 < o3.length; n3++)
              for (var i4, u4 = o3[n3], a3 = s2(this.normalize(u4, this.last)); !(i4 = a3()).done; ) {
                var c3 = i4.value;
                this.nodes.push(c3);
              }
            return this;
          }, f2.prepend = function() {
            for (var e24 = arguments.length, t6 = new Array(e24), r4 = 0; r4 < e24; r4++)
              t6[r4] = arguments[r4];
            for (var n3, o3 = s2(t6 = t6.reverse()); !(n3 = o3()).done; ) {
              for (var i4, u4 = n3.value, a3 = this.normalize(u4, this.first, "prepend").reverse(), c3 = s2(a3); !(i4 = c3()).done; ) {
                var l4 = i4.value;
                this.nodes.unshift(l4);
              }
              for (var f3 in this.indexes)
                this.indexes[f3] = this.indexes[f3] + a3.length;
            }
            return this;
          }, f2.cleanRaws = function(t6) {
            if (e23.prototype.cleanRaws.call(this, t6), this.nodes)
              for (var r4, n3 = s2(this.nodes); !(r4 = n3()).done; )
                r4.value.cleanRaws(t6);
          }, f2.insertBefore = function(e24, t6) {
            for (var r4, n3, o3 = (e24 = this.index(e24)) === 0 && "prepend", i4 = this.normalize(t6, this.nodes[e24], o3).reverse(), u4 = s2(i4); !(r4 = u4()).done; ) {
              var a3 = r4.value;
              this.nodes.splice(e24, 0, a3);
            }
            for (var c3 in this.indexes)
              e24 <= (n3 = this.indexes[c3]) && (this.indexes[c3] = n3 + i4.length);
            return this;
          }, f2.insertAfter = function(e24, t6) {
            e24 = this.index(e24);
            for (var r4, n3, o3 = this.normalize(t6, this.nodes[e24]).reverse(), i4 = s2(o3); !(r4 = i4()).done; ) {
              var u4 = r4.value;
              this.nodes.splice(e24 + 1, 0, u4);
            }
            for (var a3 in this.indexes)
              e24 < (n3 = this.indexes[a3]) && (this.indexes[a3] = n3 + o3.length);
            return this;
          }, f2.removeChild = function(e24) {
            var t6;
            for (var r4 in e24 = this.index(e24), this.nodes[e24].parent = void 0, this.nodes.splice(e24, 1), this.indexes)
              (t6 = this.indexes[r4]) >= e24 && (this.indexes[r4] = t6 - 1);
            return this;
          }, f2.removeAll = function() {
            for (var e24, t6 = s2(this.nodes); !(e24 = t6()).done; )
              e24.value.parent = void 0;
            return this.nodes = [], this;
          }, f2.replaceValues = function(e24, t6, r4) {
            return r4 || (r4 = t6, t6 = {}), this.walkDecls(function(n3) {
              t6.props && t6.props.indexOf(n3.prop) === -1 || t6.fast && n3.value.indexOf(t6.fast) === -1 || (n3.value = n3.value.replace(e24, r4));
            }), this;
          }, f2.every = function(e24) {
            return this.nodes.every(e24);
          }, f2.some = function(e24) {
            return this.nodes.some(e24);
          }, f2.index = function(e24) {
            return typeof e24 == "number" ? e24 : this.nodes.indexOf(e24);
          }, f2.normalize = function(e24, t6) {
            var i4 = this;
            if (typeof e24 == "string")
              e24 = c2(r3(7057)(e24).nodes);
            else if (Array.isArray(e24))
              for (var u4, a3 = s2(e24 = e24.slice(0)); !(u4 = a3()).done; ) {
                var l4 = u4.value;
                l4.parent && l4.parent.removeChild(l4, "ignore");
              }
            else if (e24.type === "root")
              for (var f3, p2 = s2(e24 = e24.nodes.slice(0)); !(f3 = p2()).done; ) {
                var h2 = f3.value;
                h2.parent && h2.parent.removeChild(h2, "ignore");
              }
            else if (e24.type)
              e24 = [e24];
            else if (e24.prop) {
              if (e24.value === void 0)
                throw new Error("Value field is missed in node creation");
              typeof e24.value != "string" && (e24.value = String(e24.value)), e24 = [new n2.default(e24)];
            } else if (e24.selector)
              e24 = [new (r3(6621))(e24)];
            else if (e24.name)
              e24 = [new (r3(8940))(e24)];
            else {
              if (!e24.text)
                throw new Error("Unknown node type in node creation");
              e24 = [new o2.default(e24)];
            }
            return e24.map(function(e25) {
              return e25.parent && e25.parent.removeChild(e25), e25.raws.before === void 0 && t6 && t6.raws.before !== void 0 && (e25.raws.before = t6.raws.before.replace(/[^\s]/g, "")), e25.parent = i4, e25;
            });
          }, (l3 = [
            {
              key: "first",
              get: function() {
                if (this.nodes)
                  return this.nodes[0];
              }
            },
            {
              key: "last",
              get: function() {
                if (this.nodes)
                  return this.nodes[this.nodes.length - 1];
              }
            }
          ]) && a2(u3.prototype, l3), u3;
        }(i2(r3(1714)).default);
        t4.default = l2, e22.exports = t4.default;
      },
      1667: (e22, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2 = s2(r3(6083)), o2 = s2(r3(3248)), i2 = s2(r3(2868));
        function s2(e23) {
          return e23 && e23.__esModule ? e23 : { default: e23 };
        }
        function u2(e23) {
          var t5 = typeof Map == "function" ? new Map() : void 0;
          return (u2 = function(e24) {
            if (e24 === null || (r4 = e24, Function.toString.call(r4).indexOf("[native code]") === -1))
              return e24;
            var r4;
            if (typeof e24 != "function")
              throw new TypeError("Super expression must either be null or a function");
            if (t5 !== void 0) {
              if (t5.has(e24))
                return t5.get(e24);
              t5.set(e24, n3);
            }
            function n3() {
              return a2(e24, arguments, f2(this).constructor);
            }
            return n3.prototype = Object.create(e24.prototype, {
              constructor: {
                value: n3,
                enumerable: false,
                writable: true,
                configurable: true
              }
            }), l2(n3, e24);
          })(e23);
        }
        function a2(e23, t5, r4) {
          return (a2 = c2() ? Reflect.construct : function(e24, t6, r5) {
            var n3 = [null];
            n3.push.apply(n3, t6);
            var o3 = new (Function.bind.apply(e24, n3))();
            return r5 && l2(o3, r5.prototype), o3;
          }).apply(null, arguments);
        }
        function c2() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (e23) {
            return false;
          }
        }
        function l2(e23, t5) {
          return (l2 = Object.setPrototypeOf || function(e24, t6) {
            return e24.__proto__ = t6, e24;
          })(e23, t5);
        }
        function f2(e23) {
          return (f2 = Object.setPrototypeOf ? Object.getPrototypeOf : function(e24) {
            return e24.__proto__ || Object.getPrototypeOf(e24);
          })(e23);
        }
        var p2 = function(e23) {
          var t5, r4;
          function s3(t6, r5, n3, o3, i3, u4) {
            var a3;
            return (a3 = e23.call(this, t6) || this).name = "CssSyntaxError", a3.reason = t6, i3 && (a3.file = i3), o3 && (a3.source = o3), u4 && (a3.plugin = u4), r5 !== void 0 && n3 !== void 0 && (a3.line = r5, a3.column = n3), a3.setMessage(), Error.captureStackTrace && Error.captureStackTrace(function(e24) {
              if (e24 === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e24;
            }(a3), s3), a3;
          }
          r4 = e23, (t5 = s3).prototype = Object.create(r4.prototype), t5.prototype.constructor = t5, t5.__proto__ = r4;
          var u3 = s3.prototype;
          return u3.setMessage = function() {
            this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", this.line !== void 0 && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
          }, u3.showSourceCode = function(e24) {
            var t6 = this;
            if (!this.source)
              return "";
            var r5 = this.source;
            i2.default && (e24 === void 0 && (e24 = n2.default.stdout), e24 && (r5 = (0, i2.default)(r5)));
            var s4 = r5.split(/\r?\n/), u4 = Math.max(this.line - 3, 0), a3 = Math.min(this.line + 2, s4.length), c3 = String(a3).length;
            function l3(t7) {
              return e24 && o2.default.red ? o2.default.red.bold(t7) : t7;
            }
            function f3(t7) {
              return e24 && o2.default.gray ? o2.default.gray(t7) : t7;
            }
            return s4.slice(u4, a3).map(function(e25, r6) {
              var n3 = u4 + 1 + r6, o3 = " " + (" " + n3).slice(-c3) + " | ";
              if (n3 === t6.line) {
                var i3 = f3(o3.replace(/\d/g, " ")) + e25.slice(0, t6.column - 1).replace(/[^\t]/g, " ");
                return l3(">") + f3(o3) + e25 + "\n " + i3 + l3("^");
              }
              return " " + f3(o3) + e25;
            }).join("\n");
          }, u3.toString = function() {
            var e24 = this.showSourceCode();
            return e24 && (e24 = "\n\n" + e24 + "\n"), this.name + ": " + this.message + e24;
          }, s3;
        }(u2(Error));
        t4.default = p2, e22.exports = t4.default;
      },
      6417: (e22, t4, r3) => {
        var n2;
        t4.__esModule = true, t4.default = void 0;
        var o2 = function(e23) {
          var t5, r4;
          function n3(t6) {
            var r5;
            return (r5 = e23.call(this, t6) || this).type = "decl", r5;
          }
          return r4 = e23, (t5 = n3).prototype = Object.create(r4.prototype), t5.prototype.constructor = t5, t5.__proto__ = r4, n3;
        }(((n2 = r3(1714)) && n2.__esModule ? n2 : { default: n2 }).default);
        t4.default = o2, e22.exports = t4.default;
      },
      2993: (e22, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2 = s2(r3(3974)), o2 = s2(r3(1667)), i2 = s2(r3(3353));
        function s2(e23) {
          return e23 && e23.__esModule ? e23 : { default: e23 };
        }
        function u2(e23, t5) {
          for (var r4 = 0; r4 < t5.length; r4++) {
            var n3 = t5[r4];
            n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e23, n3.key, n3);
          }
        }
        var a2 = 0, c2 = function() {
          function e23(e24, t6) {
            if (t6 === void 0 && (t6 = {}), e24 == null || typeof e24 == "object" && !e24.toString)
              throw new Error("PostCSS received " + e24 + " instead of CSS string");
            this.css = e24.toString(), this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE" ? (this.hasBOM = true, this.css = this.css.slice(1)) : this.hasBOM = false, t6.from && (/^\w+:\/\//.test(t6.from) || n2.default.isAbsolute(t6.from) ? this.file = t6.from : this.file = n2.default.resolve(t6.from));
            var r5 = new i2.default(this.css, t6);
            if (r5.text) {
              this.map = r5;
              var o3 = r5.consumer().file;
              !this.file && o3 && (this.file = this.mapResolve(o3));
            }
            this.file || (a2 += 1, this.id = "<input css " + a2 + ">"), this.map && (this.map.file = this.from);
          }
          var t5, r4 = e23.prototype;
          return r4.error = function(e24, t6, r5, n3) {
            var i3;
            n3 === void 0 && (n3 = {});
            var s3 = this.origin(t6, r5);
            return (i3 = s3 ? new o2.default(e24, s3.line, s3.column, s3.source, s3.file, n3.plugin) : new o2.default(e24, t6, r5, this.css, this.file, n3.plugin)).input = {
              line: t6,
              column: r5,
              source: this.css
            }, this.file && (i3.input.file = this.file), i3;
          }, r4.origin = function(e24, t6) {
            if (!this.map)
              return false;
            var r5 = this.map.consumer(), n3 = r5.originalPositionFor({
              line: e24,
              column: t6
            });
            if (!n3.source)
              return false;
            var o3 = {
              file: this.mapResolve(n3.source),
              line: n3.line,
              column: n3.column
            }, i3 = r5.sourceContentFor(n3.source);
            return i3 && (o3.source = i3), o3;
          }, r4.mapResolve = function(e24) {
            return /^\w+:\/\//.test(e24) ? e24 : n2.default.resolve(this.map.consumer().sourceRoot || ".", e24);
          }, (t5 = [
            {
              key: "from",
              get: function() {
                return this.file || this.id;
              }
            }
          ]) && u2(e23.prototype, t5), e23;
        }();
        t4.default = c2, e22.exports = t4.default;
      },
      6992: (e22, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2 = u2(r3(8991)), o2 = u2(r3(6157)), i2 = (u2(r3(6574)), u2(r3(6865))), s2 = u2(r3(7057));
        function u2(e23) {
          return e23 && e23.__esModule ? e23 : { default: e23 };
        }
        function a2(e23, t5) {
          var r4;
          if (typeof Symbol == "undefined" || e23[Symbol.iterator] == null) {
            if (Array.isArray(e23) || (r4 = function(e24, t6) {
              if (e24) {
                if (typeof e24 == "string")
                  return c2(e24, t6);
                var r5 = Object.prototype.toString.call(e24).slice(8, -1);
                return r5 === "Object" && e24.constructor && (r5 = e24.constructor.name), r5 === "Map" || r5 === "Set" ? Array.from(e24) : r5 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r5) ? c2(e24, t6) : void 0;
              }
            }(e23)) || t5 && e23 && typeof e23.length == "number") {
              r4 && (e23 = r4);
              var n3 = 0;
              return function() {
                return n3 >= e23.length ? { done: true } : { done: false, value: e23[n3++] };
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          return (r4 = e23[Symbol.iterator]()).next.bind(r4);
        }
        function c2(e23, t5) {
          (t5 == null || t5 > e23.length) && (t5 = e23.length);
          for (var r4 = 0, n3 = new Array(t5); r4 < t5; r4++)
            n3[r4] = e23[r4];
          return n3;
        }
        function l2(e23, t5) {
          for (var r4 = 0; r4 < t5.length; r4++) {
            var n3 = t5[r4];
            n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e23, n3.key, n3);
          }
        }
        function f2(e23) {
          return typeof e23 == "object" && typeof e23.then == "function";
        }
        var p2 = function() {
          function e23(t6, r5, n3) {
            var o3;
            if (this.stringified = false, this.processed = false, typeof r5 == "object" && r5 !== null && r5.type === "root")
              o3 = r5;
            else if (r5 instanceof e23 || r5 instanceof i2.default)
              o3 = r5.root, r5.map && (n3.map === void 0 && (n3.map = {}), n3.map.inline || (n3.map.inline = false), n3.map.prev = r5.map);
            else {
              var u3 = s2.default;
              n3.syntax && (u3 = n3.syntax.parse), n3.parser && (u3 = n3.parser), u3.parse && (u3 = u3.parse);
              try {
                o3 = u3(r5, n3);
              } catch (t7) {
                this.error = t7;
              }
            }
            this.result = new i2.default(t6, o3, n3);
          }
          var t5, r4 = e23.prototype;
          return r4.warnings = function() {
            return this.sync().warnings();
          }, r4.toString = function() {
            return this.css;
          }, r4.then = function(e24, t6) {
            return this.async().then(e24, t6);
          }, r4.catch = function(e24) {
            return this.async().catch(e24);
          }, r4.finally = function(e24) {
            return this.async().then(e24, e24);
          }, r4.handleError = function(e24, t6) {
            try {
              this.error = e24, e24.name !== "CssSyntaxError" || e24.plugin ? t6.postcssVersion : (e24.plugin = t6.postcssPlugin, e24.setMessage());
            } catch (e25) {
              console && console.error && console.error(e25);
            }
          }, r4.asyncTick = function(e24, t6) {
            var r5 = this;
            if (this.plugin >= this.processor.plugins.length)
              return this.processed = true, e24();
            try {
              var n3 = this.processor.plugins[this.plugin], o3 = this.run(n3);
              this.plugin += 1, f2(o3) ? o3.then(function() {
                r5.asyncTick(e24, t6);
              }).catch(function(e25) {
                r5.handleError(e25, n3), r5.processed = true, t6(e25);
              }) : this.asyncTick(e24, t6);
            } catch (e25) {
              this.processed = true, t6(e25);
            }
          }, r4.async = function() {
            var e24 = this;
            return this.processed ? new Promise(function(t6, r5) {
              e24.error ? r5(e24.error) : t6(e24.stringify());
            }) : (this.processing || (this.processing = new Promise(function(t6, r5) {
              if (e24.error)
                return r5(e24.error);
              e24.plugin = 0, e24.asyncTick(t6, r5);
            }).then(function() {
              return e24.processed = true, e24.stringify();
            })), this.processing);
          }, r4.sync = function() {
            if (this.processed)
              return this.result;
            if (this.processed = true, this.processing)
              throw new Error("Use process(css).then(cb) to work with async plugins");
            if (this.error)
              throw this.error;
            for (var e24, t6 = a2(this.result.processor.plugins); !(e24 = t6()).done; ) {
              var r5 = e24.value;
              if (f2(this.run(r5)))
                throw new Error("Use process(css).then(cb) to work with async plugins");
            }
            return this.result;
          }, r4.run = function(e24) {
            this.result.lastPlugin = e24;
            try {
              return e24(this.result.root, this.result);
            } catch (t6) {
              throw this.handleError(t6, e24), t6;
            }
          }, r4.stringify = function() {
            if (this.stringified)
              return this.result;
            this.stringified = true, this.sync();
            var e24 = this.result.opts, t6 = o2.default;
            e24.syntax && (t6 = e24.syntax.stringify), e24.stringifier && (t6 = e24.stringifier), t6.stringify && (t6 = t6.stringify);
            var r5 = new n2.default(t6, this.result.root, this.result.opts).generate();
            return this.result.css = r5[0], this.result.map = r5[1], this.result;
          }, (t5 = [
            {
              key: "processor",
              get: function() {
                return this.result.processor;
              }
            },
            {
              key: "opts",
              get: function() {
                return this.result.opts;
              }
            },
            {
              key: "css",
              get: function() {
                return this.stringify().css;
              }
            },
            {
              key: "content",
              get: function() {
                return this.stringify().content;
              }
            },
            {
              key: "map",
              get: function() {
                return this.stringify().map;
              }
            },
            {
              key: "root",
              get: function() {
                return this.sync().root;
              }
            },
            {
              key: "messages",
              get: function() {
                return this.sync().messages;
              }
            }
          ]) && l2(e23.prototype, t5), e23;
        }();
        t4.default = p2, e22.exports = t4.default;
      },
      6136: (e22, t4) => {
        t4.__esModule = true, t4.default = void 0;
        var r3 = {
          split: function(e23, t5, r4) {
            for (var n3 = [], o2 = "", i2 = false, s2 = 0, u2 = false, a2 = false, c2 = 0; c2 < e23.length; c2++) {
              var l2 = e23[c2];
              u2 ? a2 ? a2 = false : l2 === "\\" ? a2 = true : l2 === u2 && (u2 = false) : l2 === '"' || l2 === "'" ? u2 = l2 : l2 === "(" ? s2 += 1 : l2 === ")" ? s2 > 0 && (s2 -= 1) : s2 === 0 && t5.indexOf(l2) !== -1 && (i2 = true), i2 ? (o2 !== "" && n3.push(o2.trim()), o2 = "", i2 = false) : o2 += l2;
            }
            return (r4 || o2 !== "") && n3.push(o2.trim()), n3;
          },
          space: function(e23) {
            return r3.split(e23, [" ", "\n", "	"]);
          },
          comma: function(e23) {
            return r3.split(e23, [","], true);
          }
        }, n2 = r3;
        t4.default = n2, e22.exports = t4.default;
      },
      8991: (e22, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2 = i2(r3(2447)), o2 = i2(r3(3974));
        function i2(e23) {
          return e23 && e23.__esModule ? e23 : { default: e23 };
        }
        function s2(e23, t5) {
          var r4;
          if (typeof Symbol == "undefined" || e23[Symbol.iterator] == null) {
            if (Array.isArray(e23) || (r4 = function(e24, t6) {
              if (e24) {
                if (typeof e24 == "string")
                  return u2(e24, t6);
                var r5 = Object.prototype.toString.call(e24).slice(8, -1);
                return r5 === "Object" && e24.constructor && (r5 = e24.constructor.name), r5 === "Map" || r5 === "Set" ? Array.from(e24) : r5 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r5) ? u2(e24, t6) : void 0;
              }
            }(e23)) || t5 && e23 && typeof e23.length == "number") {
              r4 && (e23 = r4);
              var n3 = 0;
              return function() {
                return n3 >= e23.length ? { done: true } : { done: false, value: e23[n3++] };
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          return (r4 = e23[Symbol.iterator]()).next.bind(r4);
        }
        function u2(e23, t5) {
          (t5 == null || t5 > e23.length) && (t5 = e23.length);
          for (var r4 = 0, n3 = new Array(t5); r4 < t5; r4++)
            n3[r4] = e23[r4];
          return n3;
        }
        var a2 = function() {
          function e23(e24, t6, r4) {
            this.stringify = e24, this.mapOpts = r4.map || {}, this.root = t6, this.opts = r4;
          }
          var t5 = e23.prototype;
          return t5.isMap = function() {
            return this.opts.map !== void 0 ? !!this.opts.map : this.previous().length > 0;
          }, t5.previous = function() {
            var e24 = this;
            return this.previousMaps || (this.previousMaps = [], this.root.walk(function(t6) {
              if (t6.source && t6.source.input.map) {
                var r4 = t6.source.input.map;
                e24.previousMaps.indexOf(r4) === -1 && e24.previousMaps.push(r4);
              }
            })), this.previousMaps;
          }, t5.isInline = function() {
            if (this.mapOpts.inline !== void 0)
              return this.mapOpts.inline;
            var e24 = this.mapOpts.annotation;
            return (e24 === void 0 || e24 === true) && (!this.previous().length || this.previous().some(function(e25) {
              return e25.inline;
            }));
          }, t5.isSourcesContent = function() {
            return this.mapOpts.sourcesContent !== void 0 ? this.mapOpts.sourcesContent : !this.previous().length || this.previous().some(function(e24) {
              return e24.withContent();
            });
          }, t5.clearAnnotation = function() {
            if (this.mapOpts.annotation !== false)
              for (var e24, t6 = this.root.nodes.length - 1; t6 >= 0; t6--)
                (e24 = this.root.nodes[t6]).type === "comment" && e24.text.indexOf("# sourceMappingURL=") === 0 && this.root.removeChild(t6);
          }, t5.setSourcesContent = function() {
            var e24 = this, t6 = {};
            this.root.walk(function(r4) {
              if (r4.source) {
                var n3 = r4.source.input.from;
                if (n3 && !t6[n3]) {
                  t6[n3] = true;
                  var o3 = e24.relative(n3);
                  e24.map.setSourceContent(o3, r4.source.input.css);
                }
              }
            });
          }, t5.applyPrevMaps = function() {
            for (var e24, t6 = s2(this.previous()); !(e24 = t6()).done; ) {
              var r4 = e24.value, i3 = this.relative(r4.file), u3 = r4.root || o2.default.dirname(r4.file), a3 = void 0;
              this.mapOpts.sourcesContent === false ? (a3 = new n2.default.SourceMapConsumer(r4.text)).sourcesContent && (a3.sourcesContent = a3.sourcesContent.map(function() {
                return null;
              })) : a3 = r4.consumer(), this.map.applySourceMap(a3, i3, this.relative(u3));
            }
          }, t5.isAnnotation = function() {
            return !!this.isInline() || (this.mapOpts.annotation !== void 0 ? this.mapOpts.annotation : !this.previous().length || this.previous().some(function(e24) {
              return e24.annotation;
            }));
          }, t5.toBase64 = function(e24) {
            return Buffer ? Buffer.from(e24).toString("base64") : window.btoa(unescape(encodeURIComponent(e24)));
          }, t5.addAnnotation = function() {
            var e24;
            e24 = this.isInline() ? "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? this.mapOpts.annotation : this.outputFile() + ".map";
            var t6 = "\n";
            this.css.indexOf("\r\n") !== -1 && (t6 = "\r\n"), this.css += t6 + "/*# sourceMappingURL=" + e24 + " */";
          }, t5.outputFile = function() {
            return this.opts.to ? this.relative(this.opts.to) : this.opts.from ? this.relative(this.opts.from) : "to.css";
          }, t5.generateMap = function() {
            return this.generateString(), this.isSourcesContent() && this.setSourcesContent(), this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
          }, t5.relative = function(e24) {
            if (e24.indexOf("<") === 0)
              return e24;
            if (/^\w+:\/\//.test(e24))
              return e24;
            var t6 = this.opts.to ? o2.default.dirname(this.opts.to) : ".";
            return typeof this.mapOpts.annotation == "string" && (t6 = o2.default.dirname(o2.default.resolve(t6, this.mapOpts.annotation))), e24 = o2.default.relative(t6, e24), o2.default.sep === "\\" ? e24.replace(/\\/g, "/") : e24;
          }, t5.sourcePath = function(e24) {
            return this.mapOpts.from ? this.mapOpts.from : this.relative(e24.source.input.from);
          }, t5.generateString = function() {
            var e24 = this;
            this.css = "", this.map = new n2.default.SourceMapGenerator({ file: this.outputFile() });
            var t6, r4, o3 = 1, i3 = 1;
            this.stringify(this.root, function(n3, s3, u3) {
              if (e24.css += n3, s3 && u3 !== "end" && (s3.source && s3.source.start ? e24.map.addMapping({
                source: e24.sourcePath(s3),
                generated: {
                  line: o3,
                  column: i3 - 1
                },
                original: {
                  line: s3.source.start.line,
                  column: s3.source.start.column - 1
                }
              }) : e24.map.addMapping({
                source: "<no source>",
                original: {
                  line: 1,
                  column: 0
                },
                generated: {
                  line: o3,
                  column: i3 - 1
                }
              })), (t6 = n3.match(/\n/g)) ? (o3 += t6.length, r4 = n3.lastIndexOf("\n"), i3 = n3.length - r4) : i3 += n3.length, s3 && u3 !== "start") {
                var a3 = s3.parent || {
                  raws: {}
                };
                (s3.type !== "decl" || s3 !== a3.last || a3.raws.semicolon) && (s3.source && s3.source.end ? e24.map.addMapping({
                  source: e24.sourcePath(s3),
                  generated: {
                    line: o3,
                    column: i3 - 2
                  },
                  original: {
                    line: s3.source.end.line,
                    column: s3.source.end.column - 1
                  }
                }) : e24.map.addMapping({
                  source: "<no source>",
                  original: {
                    line: 1,
                    column: 0
                  },
                  generated: {
                    line: o3,
                    column: i3 - 1
                  }
                }));
              }
            });
          }, t5.generate = function() {
            if (this.clearAnnotation(), this.isMap())
              return this.generateMap();
            var e24 = "";
            return this.stringify(this.root, function(t6) {
              e24 += t6;
            }), [e24];
          }, e23;
        }();
        t4.default = a2, e22.exports = t4.default;
      },
      1714: (e22, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2 = s2(r3(1667)), o2 = s2(r3(5701)), i2 = s2(r3(6157));
        function s2(e23) {
          return e23 && e23.__esModule ? e23 : { default: e23 };
        }
        function u2(e23, t5) {
          var r4 = new e23.constructor();
          for (var n3 in e23)
            if (e23.hasOwnProperty(n3)) {
              var o3 = e23[n3], i3 = typeof o3;
              n3 === "parent" && i3 === "object" ? t5 && (r4[n3] = t5) : n3 === "source" ? r4[n3] = o3 : o3 instanceof Array ? r4[n3] = o3.map(function(e24) {
                return u2(e24, r4);
              }) : (i3 === "object" && o3 !== null && (o3 = u2(o3)), r4[n3] = o3);
            }
          return r4;
        }
        var a2 = function() {
          function e23(e24) {
            for (var t6 in e24 === void 0 && (e24 = {}), this.raws = {}, e24)
              this[t6] = e24[t6];
          }
          var t5 = e23.prototype;
          return t5.error = function(e24, t6) {
            if (t6 === void 0 && (t6 = {}), this.source) {
              var r4 = this.positionBy(t6);
              return this.source.input.error(e24, r4.line, r4.column, t6);
            }
            return new n2.default(e24);
          }, t5.warn = function(e24, t6, r4) {
            var n3 = { node: this };
            for (var o3 in r4)
              n3[o3] = r4[o3];
            return e24.warn(t6, n3);
          }, t5.remove = function() {
            return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
          }, t5.toString = function(e24) {
            e24 === void 0 && (e24 = i2.default), e24.stringify && (e24 = e24.stringify);
            var t6 = "";
            return e24(this, function(e25) {
              t6 += e25;
            }), t6;
          }, t5.clone = function(e24) {
            e24 === void 0 && (e24 = {});
            var t6 = u2(this);
            for (var r4 in e24)
              t6[r4] = e24[r4];
            return t6;
          }, t5.cloneBefore = function(e24) {
            e24 === void 0 && (e24 = {});
            var t6 = this.clone(e24);
            return this.parent.insertBefore(this, t6), t6;
          }, t5.cloneAfter = function(e24) {
            e24 === void 0 && (e24 = {});
            var t6 = this.clone(e24);
            return this.parent.insertAfter(this, t6), t6;
          }, t5.replaceWith = function() {
            if (this.parent) {
              for (var e24 = arguments.length, t6 = new Array(e24), r4 = 0; r4 < e24; r4++)
                t6[r4] = arguments[r4];
              for (var n3 = 0, o3 = t6; n3 < o3.length; n3++) {
                var i3 = o3[n3];
                this.parent.insertBefore(this, i3);
              }
              this.remove();
            }
            return this;
          }, t5.next = function() {
            if (this.parent) {
              var e24 = this.parent.index(this);
              return this.parent.nodes[e24 + 1];
            }
          }, t5.prev = function() {
            if (this.parent) {
              var e24 = this.parent.index(this);
              return this.parent.nodes[e24 - 1];
            }
          }, t5.before = function(e24) {
            return this.parent.insertBefore(this, e24), this;
          }, t5.after = function(e24) {
            return this.parent.insertAfter(this, e24), this;
          }, t5.toJSON = function() {
            var e24 = {};
            for (var t6 in this)
              if (this.hasOwnProperty(t6) && t6 !== "parent") {
                var r4 = this[t6];
                r4 instanceof Array ? e24[t6] = r4.map(function(e25) {
                  return typeof e25 == "object" && e25.toJSON ? e25.toJSON() : e25;
                }) : typeof r4 == "object" && r4.toJSON ? e24[t6] = r4.toJSON() : e24[t6] = r4;
              }
            return e24;
          }, t5.raw = function(e24, t6) {
            return new o2.default().raw(this, e24, t6);
          }, t5.root = function() {
            for (var e24 = this; e24.parent; )
              e24 = e24.parent;
            return e24;
          }, t5.cleanRaws = function(e24) {
            delete this.raws.before, delete this.raws.after, e24 || delete this.raws.between;
          }, t5.positionInside = function(e24) {
            for (var t6 = this.toString(), r4 = this.source.start.column, n3 = this.source.start.line, o3 = 0; o3 < e24; o3++)
              t6[o3] === "\n" ? (r4 = 1, n3 += 1) : r4 += 1;
            return { line: n3, column: r4 };
          }, t5.positionBy = function(e24) {
            var t6 = this.source.start;
            if (e24.index)
              t6 = this.positionInside(e24.index);
            else if (e24.word) {
              var r4 = this.toString().indexOf(e24.word);
              r4 !== -1 && (t6 = this.positionInside(r4));
            }
            return t6;
          }, e23;
        }();
        t4.default = a2, e22.exports = t4.default;
      },
      7057: (e22, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2 = i2(r3(7116)), o2 = i2(r3(2993));
        function i2(e23) {
          return e23 && e23.__esModule ? e23 : { default: e23 };
        }
        var s2 = function(e23, t5) {
          var r4 = new o2.default(e23, t5), i3 = new n2.default(r4);
          try {
            i3.parse();
          } catch (e24) {
            throw e24;
          }
          return i3.root;
        };
        t4.default = s2, e22.exports = t4.default;
      },
      7116: (e22, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2 = c2(r3(6417)), o2 = c2(r3(1157)), i2 = c2(r3(3102)), s2 = c2(r3(8940)), u2 = c2(r3(7563)), a2 = c2(r3(6621));
        function c2(e23) {
          return e23 && e23.__esModule ? e23 : { default: e23 };
        }
        var l2 = function() {
          function e23(e24) {
            this.input = e24, this.root = new u2.default(), this.current = this.root, this.spaces = "", this.semicolon = false, this.createTokenizer(), this.root.source = {
              input: e24,
              start: { line: 1, column: 1 }
            };
          }
          var t5 = e23.prototype;
          return t5.createTokenizer = function() {
            this.tokenizer = (0, o2.default)(this.input);
          }, t5.parse = function() {
            for (var e24; !this.tokenizer.endOfFile(); )
              switch ((e24 = this.tokenizer.nextToken())[0]) {
                case "space":
                  this.spaces += e24[1];
                  break;
                case ";":
                  this.freeSemicolon(e24);
                  break;
                case "}":
                  this.end(e24);
                  break;
                case "comment":
                  this.comment(e24);
                  break;
                case "at-word":
                  this.atrule(e24);
                  break;
                case "{":
                  this.emptyRule(e24);
                  break;
                default:
                  this.other(e24);
              }
            this.endFile();
          }, t5.comment = function(e24) {
            var t6 = new i2.default();
            this.init(t6, e24[2], e24[3]), t6.source.end = {
              line: e24[4],
              column: e24[5]
            };
            var r4 = e24[1].slice(2, -2);
            if (/^\s*$/.test(r4))
              t6.text = "", t6.raws.left = r4, t6.raws.right = "";
            else {
              var n3 = r4.match(/^(\s*)([^]*[^\s])(\s*)$/);
              t6.text = n3[2], t6.raws.left = n3[1], t6.raws.right = n3[3];
            }
          }, t5.emptyRule = function(e24) {
            var t6 = new a2.default();
            this.init(t6, e24[2], e24[3]), t6.selector = "", t6.raws.between = "", this.current = t6;
          }, t5.other = function(e24) {
            for (var t6 = false, r4 = null, n3 = false, o3 = null, i3 = [], s3 = [], u3 = e24; u3; ) {
              if (r4 = u3[0], s3.push(u3), r4 === "(" || r4 === "[")
                o3 || (o3 = u3), i3.push(r4 === "(" ? ")" : "]");
              else if (i3.length === 0) {
                if (r4 === ";") {
                  if (n3)
                    return void this.decl(s3);
                  break;
                }
                if (r4 === "{")
                  return void this.rule(s3);
                if (r4 === "}") {
                  this.tokenizer.back(s3.pop()), t6 = true;
                  break;
                }
                r4 === ":" && (n3 = true);
              } else
                r4 === i3[i3.length - 1] && (i3.pop(), i3.length === 0 && (o3 = null));
              u3 = this.tokenizer.nextToken();
            }
            if (this.tokenizer.endOfFile() && (t6 = true), i3.length > 0 && this.unclosedBracket(o3), t6 && n3) {
              for (; s3.length && ((u3 = s3[s3.length - 1][0]) === "space" || u3 === "comment"); )
                this.tokenizer.back(s3.pop());
              this.decl(s3);
            } else
              this.unknownWord(s3);
          }, t5.rule = function(e24) {
            e24.pop();
            var t6 = new a2.default();
            this.init(t6, e24[0][2], e24[0][3]), t6.raws.between = this.spacesAndCommentsFromEnd(e24), this.raw(t6, "selector", e24), this.current = t6;
          }, t5.decl = function(e24) {
            var t6 = new n2.default();
            this.init(t6);
            var r4, o3 = e24[e24.length - 1];
            for (o3[0] === ";" && (this.semicolon = true, e24.pop()), o3[4] ? t6.source.end = {
              line: o3[4],
              column: o3[5]
            } : t6.source.end = {
              line: o3[2],
              column: o3[3]
            }; e24[0][0] !== "word"; )
              e24.length === 1 && this.unknownWord(e24), t6.raws.before += e24.shift()[1];
            for (t6.source.start = {
              line: e24[0][2],
              column: e24[0][3]
            }, t6.prop = ""; e24.length; ) {
              var i3 = e24[0][0];
              if (i3 === ":" || i3 === "space" || i3 === "comment")
                break;
              t6.prop += e24.shift()[1];
            }
            for (t6.raws.between = ""; e24.length; ) {
              if ((r4 = e24.shift())[0] === ":") {
                t6.raws.between += r4[1];
                break;
              }
              r4[0] === "word" && /\w/.test(r4[1]) && this.unknownWord([r4]), t6.raws.between += r4[1];
            }
            t6.prop[0] !== "_" && t6.prop[0] !== "*" || (t6.raws.before += t6.prop[0], t6.prop = t6.prop.slice(1)), t6.raws.between += this.spacesAndCommentsFromStart(e24), this.precheckMissedSemicolon(e24);
            for (var s3 = e24.length - 1; s3 > 0; s3--) {
              if ((r4 = e24[s3])[1].toLowerCase() === "!important") {
                t6.important = true;
                var u3 = this.stringFrom(e24, s3);
                (u3 = this.spacesFromEnd(e24) + u3) !== " !important" && (t6.raws.important = u3);
                break;
              }
              if (r4[1].toLowerCase() === "important") {
                for (var a3 = e24.slice(0), c3 = "", l3 = s3; l3 > 0; l3--) {
                  var f2 = a3[l3][0];
                  if (c3.trim().indexOf("!") === 0 && f2 !== "space")
                    break;
                  c3 = a3.pop()[1] + c3;
                }
                c3.trim().indexOf("!") === 0 && (t6.important = true, t6.raws.important = c3, e24 = a3);
              }
              if (r4[0] !== "space" && r4[0] !== "comment")
                break;
            }
            this.raw(t6, "value", e24), t6.value.indexOf(":") !== -1 && this.checkMissedSemicolon(e24);
          }, t5.atrule = function(e24) {
            var t6, r4, n3 = new s2.default();
            n3.name = e24[1].slice(1), n3.name === "" && this.unnamedAtrule(n3, e24), this.init(n3, e24[2], e24[3]);
            for (var o3 = false, i3 = false, u3 = []; !this.tokenizer.endOfFile(); ) {
              if ((e24 = this.tokenizer.nextToken())[0] === ";") {
                n3.source.end = {
                  line: e24[2],
                  column: e24[3]
                }, this.semicolon = true;
                break;
              }
              if (e24[0] === "{") {
                i3 = true;
                break;
              }
              if (e24[0] === "}") {
                if (u3.length > 0) {
                  for (t6 = u3[r4 = u3.length - 1]; t6 && t6[0] === "space"; )
                    t6 = u3[--r4];
                  t6 && (n3.source.end = {
                    line: t6[4],
                    column: t6[5]
                  });
                }
                this.end(e24);
                break;
              }
              if (u3.push(e24), this.tokenizer.endOfFile()) {
                o3 = true;
                break;
              }
            }
            n3.raws.between = this.spacesAndCommentsFromEnd(u3), u3.length ? (n3.raws.afterName = this.spacesAndCommentsFromStart(u3), this.raw(n3, "params", u3), o3 && (e24 = u3[u3.length - 1], n3.source.end = {
              line: e24[4],
              column: e24[5]
            }, this.spaces = n3.raws.between, n3.raws.between = "")) : (n3.raws.afterName = "", n3.params = ""), i3 && (n3.nodes = [], this.current = n3);
          }, t5.end = function(e24) {
            this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = false, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = {
              line: e24[2],
              column: e24[3]
            }, this.current = this.current.parent) : this.unexpectedClose(e24);
          }, t5.endFile = function() {
            this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces;
          }, t5.freeSemicolon = function(e24) {
            if (this.spaces += e24[1], this.current.nodes) {
              var t6 = this.current.nodes[this.current.nodes.length - 1];
              t6 && t6.type === "rule" && !t6.raws.ownSemicolon && (t6.raws.ownSemicolon = this.spaces, this.spaces = "");
            }
          }, t5.init = function(e24, t6, r4) {
            this.current.push(e24), e24.source = {
              start: { line: t6, column: r4 },
              input: this.input
            }, e24.raws.before = this.spaces, this.spaces = "", e24.type !== "comment" && (this.semicolon = false);
          }, t5.raw = function(e24, t6, r4) {
            for (var n3, o3, i3, s3, u3 = r4.length, a3 = "", c3 = true, l3 = /^([.|#])?([\w])+/i, f2 = 0; f2 < u3; f2 += 1)
              (o3 = (n3 = r4[f2])[0]) !== "comment" || e24.type !== "rule" ? o3 === "comment" || o3 === "space" && f2 === u3 - 1 ? c3 = false : a3 += n3[1] : (s3 = r4[f2 - 1], i3 = r4[f2 + 1], s3[0] !== "space" && i3[0] !== "space" && l3.test(s3[1]) && l3.test(i3[1]) ? a3 += n3[1] : c3 = false);
            if (!c3) {
              var p2 = r4.reduce(function(e25, t7) {
                return e25 + t7[1];
              }, "");
              e24.raws[t6] = { value: a3, raw: p2 };
            }
            e24[t6] = a3;
          }, t5.spacesAndCommentsFromEnd = function(e24) {
            for (var t6, r4 = ""; e24.length && ((t6 = e24[e24.length - 1][0]) === "space" || t6 === "comment"); )
              r4 = e24.pop()[1] + r4;
            return r4;
          }, t5.spacesAndCommentsFromStart = function(e24) {
            for (var t6, r4 = ""; e24.length && ((t6 = e24[0][0]) === "space" || t6 === "comment"); )
              r4 += e24.shift()[1];
            return r4;
          }, t5.spacesFromEnd = function(e24) {
            for (var t6 = ""; e24.length && e24[e24.length - 1][0] === "space"; )
              t6 = e24.pop()[1] + t6;
            return t6;
          }, t5.stringFrom = function(e24, t6) {
            for (var r4 = "", n3 = t6; n3 < e24.length; n3++)
              r4 += e24[n3][1];
            return e24.splice(t6, e24.length - t6), r4;
          }, t5.colon = function(e24) {
            for (var t6, r4, n3, o3 = 0, i3 = 0; i3 < e24.length; i3++) {
              if ((r4 = (t6 = e24[i3])[0]) === "(" && (o3 += 1), r4 === ")" && (o3 -= 1), o3 === 0 && r4 === ":") {
                if (n3) {
                  if (n3[0] === "word" && n3[1] === "progid")
                    continue;
                  return i3;
                }
                this.doubleColon(t6);
              }
              n3 = t6;
            }
            return false;
          }, t5.unclosedBracket = function(e24) {
            throw this.input.error("Unclosed bracket", e24[2], e24[3]);
          }, t5.unknownWord = function(e24) {
            throw this.input.error("Unknown word", e24[0][2], e24[0][3]);
          }, t5.unexpectedClose = function(e24) {
            throw this.input.error("Unexpected }", e24[2], e24[3]);
          }, t5.unclosedBlock = function() {
            var e24 = this.current.source.start;
            throw this.input.error("Unclosed block", e24.line, e24.column);
          }, t5.doubleColon = function(e24) {
            throw this.input.error("Double colon", e24[2], e24[3]);
          }, t5.unnamedAtrule = function(e24, t6) {
            throw this.input.error("At-rule without name", t6[2], t6[3]);
          }, t5.precheckMissedSemicolon = function() {
          }, t5.checkMissedSemicolon = function(e24) {
            var t6 = this.colon(e24);
            if (t6 !== false) {
              for (var r4, n3 = 0, o3 = t6 - 1; o3 >= 0 && ((r4 = e24[o3])[0] === "space" || (n3 += 1) !== 2); o3--)
                ;
              throw this.input.error("Missed semicolon", r4[2], r4[3]);
            }
          }, e23;
        }();
        t4.default = l2, e22.exports = t4.default;
      },
      3353: (e22, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2 = s2(r3(2447)), o2 = s2(r3(3974)), i2 = s2(r3(4940));
        function s2(e23) {
          return e23 && e23.__esModule ? e23 : { default: e23 };
        }
        var u2 = function() {
          function e23(e24, t6) {
            this.loadAnnotation(e24), this.inline = this.startWith(this.annotation, "data:");
            var r4 = t6.map ? t6.map.prev : void 0, n3 = this.loadMap(t6.from, r4);
            n3 && (this.text = n3);
          }
          var t5 = e23.prototype;
          return t5.consumer = function() {
            return this.consumerCache || (this.consumerCache = new n2.default.SourceMapConsumer(this.text)), this.consumerCache;
          }, t5.withContent = function() {
            return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
          }, t5.startWith = function(e24, t6) {
            return !!e24 && e24.substr(0, t6.length) === t6;
          }, t5.getAnnotationURL = function(e24) {
            return e24.match(/\/\*\s*# sourceMappingURL=((?:(?!sourceMappingURL=).)*)\*\//)[1].trim();
          }, t5.loadAnnotation = function(e24) {
            var t6 = e24.match(/\/\*\s*# sourceMappingURL=(?:(?!sourceMappingURL=).)*\*\//gm);
            if (t6 && t6.length > 0) {
              var r4 = t6[t6.length - 1];
              r4 && (this.annotation = this.getAnnotationURL(r4));
            }
          }, t5.decodeInline = function(e24) {
            var t6, r4 = "data:application/json,";
            if (this.startWith(e24, r4))
              return decodeURIComponent(e24.substr(r4.length));
            if (/^data:application\/json;charset=utf-?8;base64,/.test(e24) || /^data:application\/json;base64,/.test(e24))
              return t6 = e24.substr(RegExp.lastMatch.length), Buffer ? Buffer.from(t6, "base64").toString() : window.atob(t6);
            var n3 = e24.match(/data:application\/json;([^,]+),/)[1];
            throw new Error("Unsupported source map encoding " + n3);
          }, t5.loadMap = function(e24, t6) {
            if (t6 === false)
              return false;
            if (t6) {
              if (typeof t6 == "string")
                return t6;
              if (typeof t6 == "function") {
                var r4 = t6(e24);
                if (r4 && i2.default.existsSync && i2.default.existsSync(r4))
                  return i2.default.readFileSync(r4, "utf-8").toString().trim();
                throw new Error("Unable to load previous source map: " + r4.toString());
              }
              if (t6 instanceof n2.default.SourceMapConsumer)
                return n2.default.SourceMapGenerator.fromSourceMap(t6).toString();
              if (t6 instanceof n2.default.SourceMapGenerator)
                return t6.toString();
              if (this.isMap(t6))
                return JSON.stringify(t6);
              throw new Error("Unsupported previous source map format: " + t6.toString());
            }
            if (this.inline)
              return this.decodeInline(this.annotation);
            if (this.annotation) {
              var s3 = this.annotation;
              return e24 && (s3 = o2.default.join(o2.default.dirname(e24), s3)), this.root = o2.default.dirname(s3), !(!i2.default.existsSync || !i2.default.existsSync(s3)) && i2.default.readFileSync(s3, "utf-8").toString().trim();
            }
          }, t5.isMap = function(e24) {
            return typeof e24 == "object" && (typeof e24.mappings == "string" || typeof e24._mappings == "string");
          }, e23;
        }();
        t4.default = u2, e22.exports = t4.default;
      },
      9429: (e22, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2, o2 = (n2 = r3(6992)) && n2.__esModule ? n2 : { default: n2 };
        function i2(e23, t5) {
          var r4;
          if (typeof Symbol == "undefined" || e23[Symbol.iterator] == null) {
            if (Array.isArray(e23) || (r4 = function(e24, t6) {
              if (e24) {
                if (typeof e24 == "string")
                  return s2(e24, t6);
                var r5 = Object.prototype.toString.call(e24).slice(8, -1);
                return r5 === "Object" && e24.constructor && (r5 = e24.constructor.name), r5 === "Map" || r5 === "Set" ? Array.from(e24) : r5 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r5) ? s2(e24, t6) : void 0;
              }
            }(e23)) || t5 && e23 && typeof e23.length == "number") {
              r4 && (e23 = r4);
              var n3 = 0;
              return function() {
                return n3 >= e23.length ? { done: true } : { done: false, value: e23[n3++] };
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          return (r4 = e23[Symbol.iterator]()).next.bind(r4);
        }
        function s2(e23, t5) {
          (t5 == null || t5 > e23.length) && (t5 = e23.length);
          for (var r4 = 0, n3 = new Array(t5); r4 < t5; r4++)
            n3[r4] = e23[r4];
          return n3;
        }
        var u2 = function() {
          function e23(e24) {
            e24 === void 0 && (e24 = []), this.version = "7.0.36", this.plugins = this.normalize(e24);
          }
          var t5 = e23.prototype;
          return t5.use = function(e24) {
            return this.plugins = this.plugins.concat(this.normalize([e24])), this;
          }, t5.process = function(e24) {
            function t6(t7) {
              return e24.apply(this, arguments);
            }
            return t6.toString = function() {
              return e24.toString();
            }, t6;
          }(function(e24, t6) {
            return t6 === void 0 && (t6 = {}), this.plugins.length === 0 && (t6.parser, t6.stringifier), new o2.default(this, e24, t6);
          }), t5.normalize = function(e24) {
            for (var t6, r4 = [], n3 = i2(e24); !(t6 = n3()).done; ) {
              var o3 = t6.value;
              if (o3.postcss === true) {
                var s3 = o3();
                throw new Error("PostCSS plugin " + s3.postcssPlugin + " requires PostCSS 8.\nMigration guide for end-users:\nhttps://github.com/postcss/postcss/wiki/PostCSS-8-for-end-users");
              }
              if (o3.postcss && (o3 = o3.postcss), typeof o3 == "object" && Array.isArray(o3.plugins))
                r4 = r4.concat(o3.plugins);
              else if (typeof o3 == "function")
                r4.push(o3);
              else if (typeof o3 != "object" || !o3.parse && !o3.stringify)
                throw typeof o3 == "object" && o3.postcssPlugin ? new Error("PostCSS plugin " + o3.postcssPlugin + " requires PostCSS 8.\nMigration guide for end-users:\nhttps://github.com/postcss/postcss/wiki/PostCSS-8-for-end-users") : new Error(o3 + " is not a PostCSS plugin");
            }
            return r4;
          }, e23;
        }();
        t4.default = u2, e22.exports = t4.default;
      },
      6865: (e22, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2, o2 = (n2 = r3(1662)) && n2.__esModule ? n2 : { default: n2 };
        function i2(e23, t5) {
          for (var r4 = 0; r4 < t5.length; r4++) {
            var n3 = t5[r4];
            n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e23, n3.key, n3);
          }
        }
        var s2 = function() {
          function e23(e24, t6, r5) {
            this.processor = e24, this.messages = [], this.root = t6, this.opts = r5, this.css = void 0, this.map = void 0;
          }
          var t5, r4 = e23.prototype;
          return r4.toString = function() {
            return this.css;
          }, r4.warn = function(e24, t6) {
            t6 === void 0 && (t6 = {}), t6.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (t6.plugin = this.lastPlugin.postcssPlugin);
            var r5 = new o2.default(e24, t6);
            return this.messages.push(r5), r5;
          }, r4.warnings = function() {
            return this.messages.filter(function(e24) {
              return e24.type === "warning";
            });
          }, (t5 = [
            {
              key: "content",
              get: function() {
                return this.css;
              }
            }
          ]) && i2(e23.prototype, t5), e23;
        }();
        t4.default = s2, e22.exports = t4.default;
      },
      7563: (e22, t4, r3) => {
        var n2;
        function o2(e23, t5) {
          var r4;
          if (typeof Symbol == "undefined" || e23[Symbol.iterator] == null) {
            if (Array.isArray(e23) || (r4 = function(e24, t6) {
              if (e24) {
                if (typeof e24 == "string")
                  return i2(e24, t6);
                var r5 = Object.prototype.toString.call(e24).slice(8, -1);
                return r5 === "Object" && e24.constructor && (r5 = e24.constructor.name), r5 === "Map" || r5 === "Set" ? Array.from(e24) : r5 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r5) ? i2(e24, t6) : void 0;
              }
            }(e23)) || t5 && e23 && typeof e23.length == "number") {
              r4 && (e23 = r4);
              var n3 = 0;
              return function() {
                return n3 >= e23.length ? { done: true } : { done: false, value: e23[n3++] };
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          return (r4 = e23[Symbol.iterator]()).next.bind(r4);
        }
        function i2(e23, t5) {
          (t5 == null || t5 > e23.length) && (t5 = e23.length);
          for (var r4 = 0, n3 = new Array(t5); r4 < t5; r4++)
            n3[r4] = e23[r4];
          return n3;
        }
        t4.__esModule = true, t4.default = void 0;
        var s2 = function(e23) {
          var t5, n3;
          function i3(t6) {
            var r4;
            return (r4 = e23.call(this, t6) || this).type = "root", r4.nodes || (r4.nodes = []), r4;
          }
          n3 = e23, (t5 = i3).prototype = Object.create(n3.prototype), t5.prototype.constructor = t5, t5.__proto__ = n3;
          var s3 = i3.prototype;
          return s3.removeChild = function(t6, r4) {
            var n4 = this.index(t6);
            return !r4 && n4 === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[n4].raws.before), e23.prototype.removeChild.call(this, t6);
          }, s3.normalize = function(t6, r4, n4) {
            var i4 = e23.prototype.normalize.call(this, t6);
            if (r4) {
              if (n4 === "prepend")
                this.nodes.length > 1 ? r4.raws.before = this.nodes[1].raws.before : delete r4.raws.before;
              else if (this.first !== r4)
                for (var s4, u2 = o2(i4); !(s4 = u2()).done; )
                  s4.value.raws.before = r4.raws.before;
            }
            return i4;
          }, s3.toResult = function(e24) {
            return e24 === void 0 && (e24 = {}), new (r3(6992))(new (r3(9429))(), this, e24).stringify();
          }, i3;
        }(((n2 = r3(1204)) && n2.__esModule ? n2 : { default: n2 }).default);
        t4.default = s2, e22.exports = t4.default;
      },
      6621: (e22, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2 = i2(r3(1204)), o2 = i2(r3(6136));
        function i2(e23) {
          return e23 && e23.__esModule ? e23 : { default: e23 };
        }
        function s2(e23, t5) {
          for (var r4 = 0; r4 < t5.length; r4++) {
            var n3 = t5[r4];
            n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e23, n3.key, n3);
          }
        }
        var u2 = function(e23) {
          var t5, r4, n3;
          function i3(t6) {
            var r5;
            return (r5 = e23.call(this, t6) || this).type = "rule", r5.nodes || (r5.nodes = []), r5;
          }
          return r4 = e23, (t5 = i3).prototype = Object.create(r4.prototype), t5.prototype.constructor = t5, t5.__proto__ = r4, (n3 = [
            {
              key: "selectors",
              get: function() {
                return o2.default.comma(this.selector);
              },
              set: function(e24) {
                var t6 = this.selector ? this.selector.match(/,\s*/) : null, r5 = t6 ? t6[0] : "," + this.raw("between", "beforeOpen");
                this.selector = e24.join(r5);
              }
            }
          ]) && s2(i3.prototype, n3), i3;
        }(n2.default);
        t4.default = u2, e22.exports = t4.default;
      },
      5701: (e22, t4) => {
        t4.__esModule = true, t4.default = void 0;
        var r3 = {
          colon: ": ",
          indent: "    ",
          beforeDecl: "\n",
          beforeRule: "\n",
          beforeOpen: " ",
          beforeClose: "\n",
          beforeComment: "\n",
          after: "\n",
          emptyBody: "",
          commentLeft: " ",
          commentRight: " ",
          semicolon: false
        }, n2 = function() {
          function e23(e24) {
            this.builder = e24;
          }
          var t5 = e23.prototype;
          return t5.stringify = function(e24, t6) {
            this[e24.type](e24, t6);
          }, t5.root = function(e24) {
            this.body(e24), e24.raws.after && this.builder(e24.raws.after);
          }, t5.comment = function(e24) {
            var t6 = this.raw(e24, "left", "commentLeft"), r4 = this.raw(e24, "right", "commentRight");
            this.builder("/*" + t6 + e24.text + r4 + "*/", e24);
          }, t5.decl = function(e24, t6) {
            var r4 = this.raw(e24, "between", "colon"), n3 = e24.prop + r4 + this.rawValue(e24, "value");
            e24.important && (n3 += e24.raws.important || " !important"), t6 && (n3 += ";"), this.builder(n3, e24);
          }, t5.rule = function(e24) {
            this.block(e24, this.rawValue(e24, "selector")), e24.raws.ownSemicolon && this.builder(e24.raws.ownSemicolon, e24, "end");
          }, t5.atrule = function(e24, t6) {
            var r4 = "@" + e24.name, n3 = e24.params ? this.rawValue(e24, "params") : "";
            if (e24.raws.afterName !== void 0 ? r4 += e24.raws.afterName : n3 && (r4 += " "), e24.nodes)
              this.block(e24, r4 + n3);
            else {
              var o2 = (e24.raws.between || "") + (t6 ? ";" : "");
              this.builder(r4 + n3 + o2, e24);
            }
          }, t5.body = function(e24) {
            for (var t6 = e24.nodes.length - 1; t6 > 0 && e24.nodes[t6].type === "comment"; )
              t6 -= 1;
            for (var r4 = this.raw(e24, "semicolon"), n3 = 0; n3 < e24.nodes.length; n3++) {
              var o2 = e24.nodes[n3], i2 = this.raw(o2, "before");
              i2 && this.builder(i2), this.stringify(o2, t6 !== n3 || r4);
            }
          }, t5.block = function(e24, t6) {
            var r4, n3 = this.raw(e24, "between", "beforeOpen");
            this.builder(t6 + n3 + "{", e24, "start"), e24.nodes && e24.nodes.length ? (this.body(e24), r4 = this.raw(e24, "after")) : r4 = this.raw(e24, "after", "emptyBody"), r4 && this.builder(r4), this.builder("}", e24, "end");
          }, t5.raw = function(e24, t6, n3) {
            var o2;
            if (n3 || (n3 = t6), t6 && (o2 = e24.raws[t6]) !== void 0)
              return o2;
            var i2 = e24.parent;
            if (n3 === "before" && (!i2 || i2.type === "root" && i2.first === e24))
              return "";
            if (!i2)
              return r3[n3];
            var s2 = e24.root();
            if (s2.rawCache || (s2.rawCache = {}), s2.rawCache[n3] !== void 0)
              return s2.rawCache[n3];
            if (n3 === "before" || n3 === "after")
              return this.beforeAfter(e24, n3);
            var u2, a2 = "raw" + ((u2 = n3)[0].toUpperCase() + u2.slice(1));
            return this[a2] ? o2 = this[a2](s2, e24) : s2.walk(function(e25) {
              if ((o2 = e25.raws[t6]) !== void 0)
                return false;
            }), o2 === void 0 && (o2 = r3[n3]), s2.rawCache[n3] = o2, o2;
          }, t5.rawSemicolon = function(e24) {
            var t6;
            return e24.walk(function(e25) {
              if (e25.nodes && e25.nodes.length && e25.last.type === "decl" && (t6 = e25.raws.semicolon) !== void 0)
                return false;
            }), t6;
          }, t5.rawEmptyBody = function(e24) {
            var t6;
            return e24.walk(function(e25) {
              if (e25.nodes && e25.nodes.length === 0 && (t6 = e25.raws.after) !== void 0)
                return false;
            }), t6;
          }, t5.rawIndent = function(e24) {
            return e24.raws.indent ? e24.raws.indent : (e24.walk(function(r4) {
              var n3 = r4.parent;
              if (n3 && n3 !== e24 && n3.parent && n3.parent === e24 && r4.raws.before !== void 0) {
                var o2 = r4.raws.before.split("\n");
                return t6 = (t6 = o2[o2.length - 1]).replace(/[^\s]/g, ""), false;
              }
            }), t6);
            var t6;
          }, t5.rawBeforeComment = function(e24, t6) {
            var r4;
            return e24.walkComments(function(e25) {
              if (e25.raws.before !== void 0)
                return (r4 = e25.raws.before).indexOf("\n") !== -1 && (r4 = r4.replace(/[^\n]+$/, "")), false;
            }), r4 === void 0 ? r4 = this.raw(t6, null, "beforeDecl") : r4 && (r4 = r4.replace(/[^\s]/g, "")), r4;
          }, t5.rawBeforeDecl = function(e24, t6) {
            var r4;
            return e24.walkDecls(function(e25) {
              if (e25.raws.before !== void 0)
                return (r4 = e25.raws.before).indexOf("\n") !== -1 && (r4 = r4.replace(/[^\n]+$/, "")), false;
            }), r4 === void 0 ? r4 = this.raw(t6, null, "beforeRule") : r4 && (r4 = r4.replace(/[^\s]/g, "")), r4;
          }, t5.rawBeforeRule = function(e24) {
            var t6;
            return e24.walk(function(r4) {
              if (r4.nodes && (r4.parent !== e24 || e24.first !== r4) && r4.raws.before !== void 0)
                return (t6 = r4.raws.before).indexOf("\n") !== -1 && (t6 = t6.replace(/[^\n]+$/, "")), false;
            }), t6 && (t6 = t6.replace(/[^\s]/g, "")), t6;
          }, t5.rawBeforeClose = function(e24) {
            var t6;
            return e24.walk(function(e25) {
              if (e25.nodes && e25.nodes.length > 0 && e25.raws.after !== void 0)
                return (t6 = e25.raws.after).indexOf("\n") !== -1 && (t6 = t6.replace(/[^\n]+$/, "")), false;
            }), t6 && (t6 = t6.replace(/[^\s]/g, "")), t6;
          }, t5.rawBeforeOpen = function(e24) {
            var t6;
            return e24.walk(function(e25) {
              if (e25.type !== "decl" && (t6 = e25.raws.between) !== void 0)
                return false;
            }), t6;
          }, t5.rawColon = function(e24) {
            var t6;
            return e24.walkDecls(function(e25) {
              if (e25.raws.between !== void 0)
                return t6 = e25.raws.between.replace(/[^\s:]/g, ""), false;
            }), t6;
          }, t5.beforeAfter = function(e24, t6) {
            var r4;
            r4 = e24.type === "decl" ? this.raw(e24, null, "beforeDecl") : e24.type === "comment" ? this.raw(e24, null, "beforeComment") : t6 === "before" ? this.raw(e24, null, "beforeRule") : this.raw(e24, null, "beforeClose");
            for (var n3 = e24.parent, o2 = 0; n3 && n3.type !== "root"; )
              o2 += 1, n3 = n3.parent;
            if (r4.indexOf("\n") !== -1) {
              var i2 = this.raw(e24, null, "indent");
              if (i2.length)
                for (var s2 = 0; s2 < o2; s2++)
                  r4 += i2;
            }
            return r4;
          }, t5.rawValue = function(e24, t6) {
            var r4 = e24[t6], n3 = e24.raws[t6];
            return n3 && n3.value === r4 ? n3.raw : r4;
          }, e23;
        }();
        t4.default = n2, e22.exports = t4.default;
      },
      6157: (e22, t4, r3) => {
        t4.__esModule = true, t4.default = void 0;
        var n2, o2 = (n2 = r3(5701)) && n2.__esModule ? n2 : { default: n2 }, i2 = function(e23, t5) {
          new o2.default(t5).stringify(e23);
        };
        t4.default = i2, e22.exports = t4.default;
      },
      1157: (e22, t4) => {
        t4.__esModule = true, t4.default = function(e23, t5) {
          t5 === void 0 && (t5 = {});
          var x2, A2, k2, O2, _2, S2, T2, I2, N2, M2, R2, j2, L2, B2, P2 = e23.css.valueOf(), $2 = t5.ignoreErrors, U2 = P2.length, G2 = -1, W2 = 1, z2 = 0, V2 = [], q2 = [];
          function X2(t6) {
            throw e23.error("Unclosed " + t6, W2, z2 - G2);
          }
          return {
            back: function(e24) {
              q2.push(e24);
            },
            nextToken: function(e24) {
              if (q2.length)
                return q2.pop();
              if (!(z2 >= U2)) {
                var t6 = !!e24 && e24.ignoreUnclosed;
                switch (((x2 = P2.charCodeAt(z2)) === s2 || x2 === a2 || x2 === l2 && P2.charCodeAt(z2 + 1) !== s2) && (G2 = z2, W2 += 1), x2) {
                  case s2:
                  case u2:
                  case c2:
                  case l2:
                  case a2:
                    A2 = z2;
                    do {
                      A2 += 1, (x2 = P2.charCodeAt(A2)) === s2 && (G2 = A2, W2 += 1);
                    } while (x2 === u2 || x2 === s2 || x2 === c2 || x2 === l2 || x2 === a2);
                    B2 = [
                      "space",
                      P2.slice(z2, A2)
                    ], z2 = A2 - 1;
                    break;
                  case f2:
                  case p2:
                  case D2:
                  case g2:
                  case y2:
                  case m2:
                  case d2:
                    var J2 = String.fromCharCode(x2);
                    B2 = [J2, J2, W2, z2 - G2];
                    break;
                  case h2:
                    if (j2 = V2.length ? V2.pop()[1] : "", L2 = P2.charCodeAt(z2 + 1), j2 === "url" && L2 !== r3 && L2 !== n2 && L2 !== u2 && L2 !== s2 && L2 !== c2 && L2 !== a2 && L2 !== l2) {
                      A2 = z2;
                      do {
                        if (M2 = false, (A2 = P2.indexOf(")", A2 + 1)) === -1) {
                          if ($2 || t6) {
                            A2 = z2;
                            break;
                          }
                          X2("bracket");
                        }
                        for (R2 = A2; P2.charCodeAt(R2 - 1) === o2; )
                          R2 -= 1, M2 = !M2;
                      } while (M2);
                      B2 = [
                        "brackets",
                        P2.slice(z2, A2 + 1),
                        W2,
                        z2 - G2,
                        W2,
                        A2 - G2
                      ], z2 = A2;
                    } else
                      A2 = P2.indexOf(")", z2 + 1), S2 = P2.slice(z2, A2 + 1), A2 === -1 || E2.test(S2) ? B2 = [
                        "(",
                        "(",
                        W2,
                        z2 - G2
                      ] : (B2 = [
                        "brackets",
                        S2,
                        W2,
                        z2 - G2,
                        W2,
                        A2 - G2
                      ], z2 = A2);
                    break;
                  case r3:
                  case n2:
                    k2 = x2 === r3 ? "'" : '"', A2 = z2;
                    do {
                      if (M2 = false, (A2 = P2.indexOf(k2, A2 + 1)) === -1) {
                        if ($2 || t6) {
                          A2 = z2 + 1;
                          break;
                        }
                        X2("string");
                      }
                      for (R2 = A2; P2.charCodeAt(R2 - 1) === o2; )
                        R2 -= 1, M2 = !M2;
                    } while (M2);
                    S2 = P2.slice(z2, A2 + 1), O2 = S2.split("\n"), (_2 = O2.length - 1) > 0 ? (I2 = W2 + _2, N2 = A2 - O2[_2].length) : (I2 = W2, N2 = G2), B2 = [
                      "string",
                      P2.slice(z2, A2 + 1),
                      W2,
                      z2 - G2,
                      I2,
                      A2 - N2
                    ], G2 = N2, W2 = I2, z2 = A2;
                    break;
                  case w2:
                    b2.lastIndex = z2 + 1, b2.test(P2), A2 = b2.lastIndex === 0 ? P2.length - 1 : b2.lastIndex - 2, B2 = [
                      "at-word",
                      P2.slice(z2, A2 + 1),
                      W2,
                      z2 - G2,
                      W2,
                      A2 - G2
                    ], z2 = A2;
                    break;
                  case o2:
                    for (A2 = z2, T2 = true; P2.charCodeAt(A2 + 1) === o2; )
                      A2 += 1, T2 = !T2;
                    if (x2 = P2.charCodeAt(A2 + 1), T2 && x2 !== i2 && x2 !== u2 && x2 !== s2 && x2 !== c2 && x2 !== l2 && x2 !== a2 && (A2 += 1, F2.test(P2.charAt(A2)))) {
                      for (; F2.test(P2.charAt(A2 + 1)); )
                        A2 += 1;
                      P2.charCodeAt(A2 + 1) === u2 && (A2 += 1);
                    }
                    B2 = [
                      "word",
                      P2.slice(z2, A2 + 1),
                      W2,
                      z2 - G2,
                      W2,
                      A2 - G2
                    ], z2 = A2;
                    break;
                  default:
                    x2 === i2 && P2.charCodeAt(z2 + 1) === v2 ? ((A2 = P2.indexOf("*/", z2 + 2) + 1) === 0 && ($2 || t6 ? A2 = P2.length : X2("comment")), S2 = P2.slice(z2, A2 + 1), O2 = S2.split("\n"), (_2 = O2.length - 1) > 0 ? (I2 = W2 + _2, N2 = A2 - O2[_2].length) : (I2 = W2, N2 = G2), B2 = [
                      "comment",
                      S2,
                      W2,
                      z2 - G2,
                      I2,
                      A2 - N2
                    ], G2 = N2, W2 = I2, z2 = A2) : (C2.lastIndex = z2 + 1, C2.test(P2), A2 = C2.lastIndex === 0 ? P2.length - 1 : C2.lastIndex - 2, B2 = [
                      "word",
                      P2.slice(z2, A2 + 1),
                      W2,
                      z2 - G2,
                      W2,
                      A2 - G2
                    ], V2.push(B2), z2 = A2);
                }
                return z2++, B2;
              }
            },
            endOfFile: function() {
              return q2.length === 0 && z2 >= U2;
            },
            position: function() {
              return z2;
            }
          };
        };
        var r3 = "'".charCodeAt(0), n2 = '"'.charCodeAt(0), o2 = "\\".charCodeAt(0), i2 = "/".charCodeAt(0), s2 = "\n".charCodeAt(0), u2 = " ".charCodeAt(0), a2 = "\f".charCodeAt(0), c2 = "	".charCodeAt(0), l2 = "\r".charCodeAt(0), f2 = "[".charCodeAt(0), p2 = "]".charCodeAt(0), h2 = "(".charCodeAt(0), d2 = ")".charCodeAt(0), D2 = "{".charCodeAt(0), g2 = "}".charCodeAt(0), m2 = ";".charCodeAt(0), v2 = "*".charCodeAt(0), y2 = ":".charCodeAt(0), w2 = "@".charCodeAt(0), b2 = /[ \n\t\r\f{}()'"\\;/[\]#]/g, C2 = /[ \n\t\r\f(){}:;@!'"\\\][#]|\/(?=\*)/g, E2 = /.[\\/("'\n]/, F2 = /[a-f0-9]/i;
        e22.exports = t4.default;
      },
      6574: (e22, t4) => {
        t4.__esModule = true, t4.default = function(e23) {
          r3[e23] || (r3[e23] = true, typeof console != "undefined" && console.warn && console.warn(e23));
        };
        var r3 = {};
        e22.exports = t4.default;
      },
      1662: (e22, t4) => {
        t4.__esModule = true, t4.default = void 0;
        var r3 = function() {
          function e23(e24, t5) {
            if (t5 === void 0 && (t5 = {}), this.type = "warning", this.text = e24, t5.node && t5.node.source) {
              var r4 = t5.node.positionBy(t5);
              this.line = r4.line, this.column = r4.column;
            }
            for (var n2 in t5)
              this[n2] = t5[n2];
          }
          return e23.prototype.toString = function() {
            return this.node ? this.node.error(this.text, {
              plugin: this.plugin,
              index: this.index,
              word: this.word
            }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
          }, e23;
        }();
        t4.default = r3, e22.exports = t4.default;
      },
      6210: (e22, t4, r3) => {
        const n2 = r3(895), { MAX_LENGTH: o2, MAX_SAFE_INTEGER: i2 } = r3(8523), { re: s2, t: u2 } = r3(3443), a2 = r3(8077), { compareIdentifiers: c2 } = r3(8337);
        class l2 {
          constructor(e23, t5) {
            if (t5 = a2(t5), e23 instanceof l2) {
              if (e23.loose === !!t5.loose && e23.includePrerelease === !!t5.includePrerelease)
                return e23;
              e23 = e23.version;
            } else if (typeof e23 != "string")
              throw new TypeError(`Invalid Version: ${e23}`);
            if (e23.length > o2)
              throw new TypeError(`version is longer than ${o2} characters`);
            n2("SemVer", e23, t5), this.options = t5, this.loose = !!t5.loose, this.includePrerelease = !!t5.includePrerelease;
            const r4 = e23.trim().match(t5.loose ? s2[u2.LOOSE] : s2[u2.FULL]);
            if (!r4)
              throw new TypeError(`Invalid Version: ${e23}`);
            if (this.raw = e23, this.major = +r4[1], this.minor = +r4[2], this.patch = +r4[3], this.major > i2 || this.major < 0)
              throw new TypeError("Invalid major version");
            if (this.minor > i2 || this.minor < 0)
              throw new TypeError("Invalid minor version");
            if (this.patch > i2 || this.patch < 0)
              throw new TypeError("Invalid patch version");
            r4[4] ? this.prerelease = r4[4].split(".").map((e24) => {
              if (/^[0-9]+$/.test(e24)) {
                const t6 = +e24;
                if (t6 >= 0 && t6 < i2)
                  return t6;
              }
              return e24;
            }) : this.prerelease = [], this.build = r4[5] ? r4[5].split(".") : [], this.format();
          }
          format() {
            return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
          }
          toString() {
            return this.version;
          }
          compare(e23) {
            if (n2("SemVer.compare", this.version, this.options, e23), !(e23 instanceof l2)) {
              if (typeof e23 == "string" && e23 === this.version)
                return 0;
              e23 = new l2(e23, this.options);
            }
            return e23.version === this.version ? 0 : this.compareMain(e23) || this.comparePre(e23);
          }
          compareMain(e23) {
            return e23 instanceof l2 || (e23 = new l2(e23, this.options)), c2(this.major, e23.major) || c2(this.minor, e23.minor) || c2(this.patch, e23.patch);
          }
          comparePre(e23) {
            if (e23 instanceof l2 || (e23 = new l2(e23, this.options)), this.prerelease.length && !e23.prerelease.length)
              return -1;
            if (!this.prerelease.length && e23.prerelease.length)
              return 1;
            if (!this.prerelease.length && !e23.prerelease.length)
              return 0;
            let t5 = 0;
            do {
              const r4 = this.prerelease[t5], o3 = e23.prerelease[t5];
              if (n2("prerelease compare", t5, r4, o3), r4 === void 0 && o3 === void 0)
                return 0;
              if (o3 === void 0)
                return 1;
              if (r4 === void 0)
                return -1;
              if (r4 !== o3)
                return c2(r4, o3);
            } while (++t5);
          }
          compareBuild(e23) {
            e23 instanceof l2 || (e23 = new l2(e23, this.options));
            let t5 = 0;
            do {
              const r4 = this.build[t5], o3 = e23.build[t5];
              if (n2("prerelease compare", t5, r4, o3), r4 === void 0 && o3 === void 0)
                return 0;
              if (o3 === void 0)
                return 1;
              if (r4 === void 0)
                return -1;
              if (r4 !== o3)
                return c2(r4, o3);
            } while (++t5);
          }
          inc(e23, t5) {
            switch (e23) {
              case "premajor":
                this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t5);
                break;
              case "preminor":
                this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t5);
                break;
              case "prepatch":
                this.prerelease.length = 0, this.inc("patch", t5), this.inc("pre", t5);
                break;
              case "prerelease":
                this.prerelease.length === 0 && this.inc("patch", t5), this.inc("pre", t5);
                break;
              case "major":
                this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                break;
              case "minor":
                this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
                break;
              case "patch":
                this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                break;
              case "pre":
                if (this.prerelease.length === 0)
                  this.prerelease = [0];
                else {
                  let e24 = this.prerelease.length;
                  for (; --e24 >= 0; )
                    typeof this.prerelease[e24] == "number" && (this.prerelease[e24]++, e24 = -2);
                  e24 === -1 && this.prerelease.push(0);
                }
                t5 && (this.prerelease[0] === t5 ? isNaN(this.prerelease[1]) && (this.prerelease = [t5, 0]) : this.prerelease = [
                  t5,
                  0
                ]);
                break;
              default:
                throw new Error(`invalid increment argument: ${e23}`);
            }
            return this.format(), this.raw = this.version, this;
          }
        }
        e22.exports = l2;
      },
      2828: (e22, t4, r3) => {
        const n2 = r3(6210);
        e22.exports = (e23, t5, r4) => new n2(e23, r4).compare(new n2(t5, r4));
      },
      9195: (e22, t4, r3) => {
        const n2 = r3(2828);
        e22.exports = (e23, t5, r4) => n2(e23, t5, r4) >= 0;
      },
      3725: (e22, t4, r3) => {
        const n2 = r3(2828);
        e22.exports = (e23, t5, r4) => n2(e23, t5, r4) < 0;
      },
      8523: (e22) => {
        const t4 = Number.MAX_SAFE_INTEGER || 9007199254740991;
        e22.exports = {
          SEMVER_SPEC_VERSION: "2.0.0",
          MAX_LENGTH: 256,
          MAX_SAFE_INTEGER: t4,
          MAX_SAFE_COMPONENT_LENGTH: 16
        };
      },
      895: (e22) => {
        const t4 = typeof process == "object" && process.env && {}.NODE_DEBUG && /\bsemver\b/i.test({}.NODE_DEBUG) ? (...e23) => console.error("SEMVER", ...e23) : () => {
        };
        e22.exports = t4;
      },
      8337: (e22) => {
        const t4 = /^[0-9]+$/, r3 = (e23, r4) => {
          const n2 = t4.test(e23), o2 = t4.test(r4);
          return n2 && o2 && (e23 = +e23, r4 = +r4), e23 === r4 ? 0 : n2 && !o2 ? -1 : o2 && !n2 ? 1 : e23 < r4 ? -1 : 1;
        };
        e22.exports = {
          compareIdentifiers: r3,
          rcompareIdentifiers: (e23, t5) => r3(t5, e23)
        };
      },
      8077: (e22) => {
        const t4 = ["includePrerelease", "loose", "rtl"];
        e22.exports = (e23) => e23 ? typeof e23 != "object" ? { loose: true } : t4.filter((t5) => e23[t5]).reduce((e24, t5) => (e24[t5] = true, e24), {}) : {};
      },
      3443: (e22, t4, r3) => {
        const { MAX_SAFE_COMPONENT_LENGTH: n2 } = r3(8523), o2 = r3(895), i2 = (t4 = e22.exports = {}).re = [], s2 = t4.src = [], u2 = t4.t = {};
        let a2 = 0;
        const c2 = (e23, t5, r4) => {
          const n3 = a2++;
          o2(n3, t5), u2[e23] = n3, s2[n3] = t5, i2[n3] = new RegExp(t5, r4 ? "g" : void 0);
        };
        c2("NUMERICIDENTIFIER", "0|[1-9]\\d*"), c2("NUMERICIDENTIFIERLOOSE", "[0-9]+"), c2("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), c2("MAINVERSION", `(${s2[u2.NUMERICIDENTIFIER]})\\.(${s2[u2.NUMERICIDENTIFIER]})\\.(${s2[u2.NUMERICIDENTIFIER]})`), c2("MAINVERSIONLOOSE", `(${s2[u2.NUMERICIDENTIFIERLOOSE]})\\.(${s2[u2.NUMERICIDENTIFIERLOOSE]})\\.(${s2[u2.NUMERICIDENTIFIERLOOSE]})`), c2("PRERELEASEIDENTIFIER", `(?:${s2[u2.NUMERICIDENTIFIER]}|${s2[u2.NONNUMERICIDENTIFIER]})`), c2("PRERELEASEIDENTIFIERLOOSE", `(?:${s2[u2.NUMERICIDENTIFIERLOOSE]}|${s2[u2.NONNUMERICIDENTIFIER]})`), c2("PRERELEASE", `(?:-(${s2[u2.PRERELEASEIDENTIFIER]}(?:\\.${s2[u2.PRERELEASEIDENTIFIER]})*))`), c2("PRERELEASELOOSE", `(?:-?(${s2[u2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${s2[u2.PRERELEASEIDENTIFIERLOOSE]})*))`), c2("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), c2("BUILD", `(?:\\+(${s2[u2.BUILDIDENTIFIER]}(?:\\.${s2[u2.BUILDIDENTIFIER]})*))`), c2("FULLPLAIN", `v?${s2[u2.MAINVERSION]}${s2[u2.PRERELEASE]}?${s2[u2.BUILD]}?`), c2("FULL", `^${s2[u2.FULLPLAIN]}$`), c2("LOOSEPLAIN", `[v=\\s]*${s2[u2.MAINVERSIONLOOSE]}${s2[u2.PRERELEASELOOSE]}?${s2[u2.BUILD]}?`), c2("LOOSE", `^${s2[u2.LOOSEPLAIN]}$`), c2("GTLT", "((?:<|>)?=?)"), c2("XRANGEIDENTIFIERLOOSE", `${s2[u2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), c2("XRANGEIDENTIFIER", `${s2[u2.NUMERICIDENTIFIER]}|x|X|\\*`), c2("XRANGEPLAIN", `[v=\\s]*(${s2[u2.XRANGEIDENTIFIER]})(?:\\.(${s2[u2.XRANGEIDENTIFIER]})(?:\\.(${s2[u2.XRANGEIDENTIFIER]})(?:${s2[u2.PRERELEASE]})?${s2[u2.BUILD]}?)?)?`), c2("XRANGEPLAINLOOSE", `[v=\\s]*(${s2[u2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${s2[u2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${s2[u2.XRANGEIDENTIFIERLOOSE]})(?:${s2[u2.PRERELEASELOOSE]})?${s2[u2.BUILD]}?)?)?`), c2("XRANGE", `^${s2[u2.GTLT]}\\s*${s2[u2.XRANGEPLAIN]}$`), c2("XRANGELOOSE", `^${s2[u2.GTLT]}\\s*${s2[u2.XRANGEPLAINLOOSE]}$`), c2("COERCE", `(^|[^\\d])(\\d{1,${n2}})(?:\\.(\\d{1,${n2}}))?(?:\\.(\\d{1,${n2}}))?(?:$|[^\\d])`), c2("COERCERTL", s2[u2.COERCE], true), c2("LONETILDE", "(?:~>?)"), c2("TILDETRIM", `(\\s*)${s2[u2.LONETILDE]}\\s+`, true), t4.tildeTrimReplace = "$1~", c2("TILDE", `^${s2[u2.LONETILDE]}${s2[u2.XRANGEPLAIN]}$`), c2("TILDELOOSE", `^${s2[u2.LONETILDE]}${s2[u2.XRANGEPLAINLOOSE]}$`), c2("LONECARET", "(?:\\^)"), c2("CARETTRIM", `(\\s*)${s2[u2.LONECARET]}\\s+`, true), t4.caretTrimReplace = "$1^", c2("CARET", `^${s2[u2.LONECARET]}${s2[u2.XRANGEPLAIN]}$`), c2("CARETLOOSE", `^${s2[u2.LONECARET]}${s2[u2.XRANGEPLAINLOOSE]}$`), c2("COMPARATORLOOSE", `^${s2[u2.GTLT]}\\s*(${s2[u2.LOOSEPLAIN]})$|^$`), c2("COMPARATOR", `^${s2[u2.GTLT]}\\s*(${s2[u2.FULLPLAIN]})$|^$`), c2("COMPARATORTRIM", `(\\s*)${s2[u2.GTLT]}\\s*(${s2[u2.LOOSEPLAIN]}|${s2[u2.XRANGEPLAIN]})`, true), t4.comparatorTrimReplace = "$1$2$3", c2("HYPHENRANGE", `^\\s*(${s2[u2.XRANGEPLAIN]})\\s+-\\s+(${s2[u2.XRANGEPLAIN]})\\s*$`), c2("HYPHENRANGELOOSE", `^\\s*(${s2[u2.XRANGEPLAINLOOSE]})\\s+-\\s+(${s2[u2.XRANGEPLAINLOOSE]})\\s*$`), c2("STAR", "(<|>)?=?\\s*\\*"), c2("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), c2("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
      },
      6715: (e22, t4, r3) => {
        var n2 = r3(7837), o2 = Object.prototype.hasOwnProperty, i2 = typeof Map != "undefined";
        function s2() {
          this._array = [], this._set = i2 ? new Map() : Object.create(null);
        }
        s2.fromArray = function(e23, t5) {
          for (var r4 = new s2(), n3 = 0, o3 = e23.length; n3 < o3; n3++)
            r4.add(e23[n3], t5);
          return r4;
        }, s2.prototype.size = function() {
          return i2 ? this._set.size : Object.getOwnPropertyNames(this._set).length;
        }, s2.prototype.add = function(e23, t5) {
          var r4 = i2 ? e23 : n2.toSetString(e23), s3 = i2 ? this.has(e23) : o2.call(this._set, r4), u2 = this._array.length;
          s3 && !t5 || this._array.push(e23), s3 || (i2 ? this._set.set(e23, u2) : this._set[r4] = u2);
        }, s2.prototype.has = function(e23) {
          if (i2)
            return this._set.has(e23);
          var t5 = n2.toSetString(e23);
          return o2.call(this._set, t5);
        }, s2.prototype.indexOf = function(e23) {
          if (i2) {
            var t5 = this._set.get(e23);
            if (t5 >= 0)
              return t5;
          } else {
            var r4 = n2.toSetString(e23);
            if (o2.call(this._set, r4))
              return this._set[r4];
          }
          throw new Error('"' + e23 + '" is not in the set.');
        }, s2.prototype.at = function(e23) {
          if (e23 >= 0 && e23 < this._array.length)
            return this._array[e23];
          throw new Error("No element indexed by " + e23);
        }, s2.prototype.toArray = function() {
          return this._array.slice();
        }, t4.I = s2;
      },
      4886: (e22, t4, r3) => {
        var n2 = r3(4122);
        t4.encode = function(e23) {
          var t5, r4 = "", o2 = function(e24) {
            return e24 < 0 ? 1 + (-e24 << 1) : 0 + (e24 << 1);
          }(e23);
          do {
            t5 = 31 & o2, (o2 >>>= 5) > 0 && (t5 |= 32), r4 += n2.encode(t5);
          } while (o2 > 0);
          return r4;
        }, t4.decode = function(e23, t5, r4) {
          var o2, i2, s2, u2, a2 = e23.length, c2 = 0, l2 = 0;
          do {
            if (t5 >= a2)
              throw new Error("Expected more digits in base 64 VLQ value.");
            if ((i2 = n2.decode(e23.charCodeAt(t5++))) === -1)
              throw new Error("Invalid base64 digit: " + e23.charAt(t5 - 1));
            o2 = !!(32 & i2), c2 += (i2 &= 31) << l2, l2 += 5;
          } while (o2);
          r4.value = (u2 = (s2 = c2) >> 1, (1 & s2) == 1 ? -u2 : u2), r4.rest = t5;
        };
      },
      4122: (e22, t4) => {
        var r3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
        t4.encode = function(e23) {
          if (0 <= e23 && e23 < r3.length)
            return r3[e23];
          throw new TypeError("Must be between 0 and 63: " + e23);
        }, t4.decode = function(e23) {
          return 65 <= e23 && e23 <= 90 ? e23 - 65 : 97 <= e23 && e23 <= 122 ? e23 - 97 + 26 : 48 <= e23 && e23 <= 57 ? e23 - 48 + 52 : e23 == 43 ? 62 : e23 == 47 ? 63 : -1;
        };
      },
      8593: (e22, t4) => {
        function r3(e23, n2, o2, i2, s2, u2) {
          var a2 = Math.floor((n2 - e23) / 2) + e23, c2 = s2(o2, i2[a2], true);
          return c2 === 0 ? a2 : c2 > 0 ? n2 - a2 > 1 ? r3(a2, n2, o2, i2, s2, u2) : u2 == t4.LEAST_UPPER_BOUND ? n2 < i2.length ? n2 : -1 : a2 : a2 - e23 > 1 ? r3(e23, a2, o2, i2, s2, u2) : u2 == t4.LEAST_UPPER_BOUND ? a2 : e23 < 0 ? -1 : e23;
        }
        t4.GREATEST_LOWER_BOUND = 1, t4.LEAST_UPPER_BOUND = 2, t4.search = function(e23, n2, o2, i2) {
          if (n2.length === 0)
            return -1;
          var s2 = r3(-1, n2.length, e23, n2, o2, i2 || t4.GREATEST_LOWER_BOUND);
          if (s2 < 0)
            return -1;
          for (; s2 - 1 >= 0 && o2(n2[s2], n2[s2 - 1], true) === 0; )
            --s2;
          return s2;
        };
      },
      1028: (e22, t4, r3) => {
        r3(4070);
        var n2 = r3(7837);
        function o2() {
          this._array = [], this._sorted = true, this._last = {
            generatedLine: -1,
            generatedColumn: 0
          };
        }
        o2.prototype.unsortedForEach = function(e23, t5) {
          this._array.forEach(e23, t5);
        }, o2.prototype.add = function(e23) {
          var t5, r4, o3, i2, s2, u2;
          r4 = e23, o3 = (t5 = this._last).generatedLine, i2 = r4.generatedLine, s2 = t5.generatedColumn, u2 = r4.generatedColumn, i2 > o3 || i2 == o3 && u2 >= s2 || n2.compareByGeneratedPositionsInflated(t5, r4) <= 0 ? (this._last = e23, this._array.push(e23)) : (this._sorted = false, this._array.push(e23));
        }, o2.prototype.toArray = function() {
          return this._sorted || (this._array.sort(n2.compareByGeneratedPositionsInflated), this._sorted = true), this._array;
        }, t4.H = o2;
      },
      6711: (e22, t4) => {
        function r3(e23, t5, r4) {
          var n3 = e23[t5];
          e23[t5] = e23[r4], e23[r4] = n3;
        }
        function n2(e23, t5, o2, i2) {
          if (o2 < i2) {
            var s2 = o2 - 1;
            r3(e23, (l2 = o2, f2 = i2, Math.round(l2 + Math.random() * (f2 - l2))), i2);
            for (var u2 = e23[i2], a2 = o2; a2 < i2; a2++)
              t5(e23[a2], u2) <= 0 && r3(e23, s2 += 1, a2);
            r3(e23, s2 + 1, a2);
            var c2 = s2 + 1;
            n2(e23, t5, o2, c2 - 1), n2(e23, t5, c2 + 1, i2);
          }
          var l2, f2;
        }
        t4.U = function(e23, t5) {
          n2(e23, t5, 0, e23.length - 1);
        };
      },
      8985: (e22, t4, r3) => {
        var n2 = r3(7837), o2 = r3(8593), i2 = r3(6715).I, s2 = r3(4886), u2 = r3(6711).U;
        function a2(e23, t5) {
          var r4 = e23;
          return typeof e23 == "string" && (r4 = n2.parseSourceMapInput(e23)), r4.sections != null ? new f2(r4, t5) : new c2(r4, t5);
        }
        function c2(e23, t5) {
          var r4 = e23;
          typeof e23 == "string" && (r4 = n2.parseSourceMapInput(e23));
          var o3 = n2.getArg(r4, "version"), s3 = n2.getArg(r4, "sources"), u3 = n2.getArg(r4, "names", []), a3 = n2.getArg(r4, "sourceRoot", null), c3 = n2.getArg(r4, "sourcesContent", null), l3 = n2.getArg(r4, "mappings"), f3 = n2.getArg(r4, "file", null);
          if (o3 != this._version)
            throw new Error("Unsupported version: " + o3);
          a3 && (a3 = n2.normalize(a3)), s3 = s3.map(String).map(n2.normalize).map(function(e24) {
            return a3 && n2.isAbsolute(a3) && n2.isAbsolute(e24) ? n2.relative(a3, e24) : e24;
          }), this._names = i2.fromArray(u3.map(String), true), this._sources = i2.fromArray(s3, true), this._absoluteSources = this._sources.toArray().map(function(e24) {
            return n2.computeSourceURL(a3, e24, t5);
          }), this.sourceRoot = a3, this.sourcesContent = c3, this._mappings = l3, this._sourceMapURL = t5, this.file = f3;
        }
        function l2() {
          this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
        }
        function f2(e23, t5) {
          var r4 = e23;
          typeof e23 == "string" && (r4 = n2.parseSourceMapInput(e23));
          var o3 = n2.getArg(r4, "version"), s3 = n2.getArg(r4, "sections");
          if (o3 != this._version)
            throw new Error("Unsupported version: " + o3);
          this._sources = new i2(), this._names = new i2();
          var u3 = { line: -1, column: 0 };
          this._sections = s3.map(function(e24) {
            if (e24.url)
              throw new Error("Support for url field in sections not implemented.");
            var r5 = n2.getArg(e24, "offset"), o4 = n2.getArg(r5, "line"), i3 = n2.getArg(r5, "column");
            if (o4 < u3.line || o4 === u3.line && i3 < u3.column)
              throw new Error("Section offsets must be ordered and non-overlapping.");
            return u3 = r5, {
              generatedOffset: {
                generatedLine: o4 + 1,
                generatedColumn: i3 + 1
              },
              consumer: new a2(n2.getArg(e24, "map"), t5)
            };
          });
        }
        a2.fromSourceMap = function(e23, t5) {
          return c2.fromSourceMap(e23, t5);
        }, a2.prototype._version = 3, a2.prototype.__generatedMappings = null, Object.defineProperty(a2.prototype, "_generatedMappings", {
          configurable: true,
          enumerable: true,
          get: function() {
            return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings;
          }
        }), a2.prototype.__originalMappings = null, Object.defineProperty(a2.prototype, "_originalMappings", {
          configurable: true,
          enumerable: true,
          get: function() {
            return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings;
          }
        }), a2.prototype._charIsMappingSeparator = function(e23, t5) {
          var r4 = e23.charAt(t5);
          return r4 === ";" || r4 === ",";
        }, a2.prototype._parseMappings = function(e23, t5) {
          throw new Error("Subclasses must implement _parseMappings");
        }, a2.GENERATED_ORDER = 1, a2.ORIGINAL_ORDER = 2, a2.GREATEST_LOWER_BOUND = 1, a2.LEAST_UPPER_BOUND = 2, a2.prototype.eachMapping = function(e23, t5, r4) {
          var o3, i3 = t5 || null;
          switch (r4 || a2.GENERATED_ORDER) {
            case a2.GENERATED_ORDER:
              o3 = this._generatedMappings;
              break;
            case a2.ORIGINAL_ORDER:
              o3 = this._originalMappings;
              break;
            default:
              throw new Error("Unknown order of iteration.");
          }
          var s3 = this.sourceRoot;
          o3.map(function(e24) {
            var t6 = e24.source === null ? null : this._sources.at(e24.source);
            return {
              source: t6 = n2.computeSourceURL(s3, t6, this._sourceMapURL),
              generatedLine: e24.generatedLine,
              generatedColumn: e24.generatedColumn,
              originalLine: e24.originalLine,
              originalColumn: e24.originalColumn,
              name: e24.name === null ? null : this._names.at(e24.name)
            };
          }, this).forEach(e23, i3);
        }, a2.prototype.allGeneratedPositionsFor = function(e23) {
          var t5 = n2.getArg(e23, "line"), r4 = {
            source: n2.getArg(e23, "source"),
            originalLine: t5,
            originalColumn: n2.getArg(e23, "column", 0)
          };
          if (r4.source = this._findSourceIndex(r4.source), r4.source < 0)
            return [];
          var i3 = [], s3 = this._findMapping(r4, this._originalMappings, "originalLine", "originalColumn", n2.compareByOriginalPositions, o2.LEAST_UPPER_BOUND);
          if (s3 >= 0) {
            var u3 = this._originalMappings[s3];
            if (e23.column === void 0)
              for (var a3 = u3.originalLine; u3 && u3.originalLine === a3; )
                i3.push({
                  line: n2.getArg(u3, "generatedLine", null),
                  column: n2.getArg(u3, "generatedColumn", null),
                  lastColumn: n2.getArg(u3, "lastGeneratedColumn", null)
                }), u3 = this._originalMappings[++s3];
            else
              for (var c3 = u3.originalColumn; u3 && u3.originalLine === t5 && u3.originalColumn == c3; )
                i3.push({
                  line: n2.getArg(u3, "generatedLine", null),
                  column: n2.getArg(u3, "generatedColumn", null),
                  lastColumn: n2.getArg(u3, "lastGeneratedColumn", null)
                }), u3 = this._originalMappings[++s3];
          }
          return i3;
        }, t4.SourceMapConsumer = a2, c2.prototype = Object.create(a2.prototype), c2.prototype.consumer = a2, c2.prototype._findSourceIndex = function(e23) {
          var t5, r4 = e23;
          if (this.sourceRoot != null && (r4 = n2.relative(this.sourceRoot, r4)), this._sources.has(r4))
            return this._sources.indexOf(r4);
          for (t5 = 0; t5 < this._absoluteSources.length; ++t5)
            if (this._absoluteSources[t5] == e23)
              return t5;
          return -1;
        }, c2.fromSourceMap = function(e23, t5) {
          var r4 = Object.create(c2.prototype), o3 = r4._names = i2.fromArray(e23._names.toArray(), true), s3 = r4._sources = i2.fromArray(e23._sources.toArray(), true);
          r4.sourceRoot = e23._sourceRoot, r4.sourcesContent = e23._generateSourcesContent(r4._sources.toArray(), r4.sourceRoot), r4.file = e23._file, r4._sourceMapURL = t5, r4._absoluteSources = r4._sources.toArray().map(function(e24) {
            return n2.computeSourceURL(r4.sourceRoot, e24, t5);
          });
          for (var a3 = e23._mappings.toArray().slice(), f3 = r4.__generatedMappings = [], p2 = r4.__originalMappings = [], h2 = 0, d2 = a3.length; h2 < d2; h2++) {
            var D2 = a3[h2], g2 = new l2();
            g2.generatedLine = D2.generatedLine, g2.generatedColumn = D2.generatedColumn, D2.source && (g2.source = s3.indexOf(D2.source), g2.originalLine = D2.originalLine, g2.originalColumn = D2.originalColumn, D2.name && (g2.name = o3.indexOf(D2.name)), p2.push(g2)), f3.push(g2);
          }
          return u2(r4.__originalMappings, n2.compareByOriginalPositions), r4;
        }, c2.prototype._version = 3, Object.defineProperty(c2.prototype, "sources", {
          get: function() {
            return this._absoluteSources.slice();
          }
        }), c2.prototype._parseMappings = function(e23, t5) {
          for (var r4, o3, i3, a3, c3, f3 = 1, p2 = 0, h2 = 0, d2 = 0, D2 = 0, g2 = 0, m2 = e23.length, v2 = 0, y2 = {}, w2 = {}, b2 = [], C2 = []; v2 < m2; )
            if (e23.charAt(v2) === ";")
              f3++, v2++, p2 = 0;
            else if (e23.charAt(v2) === ",")
              v2++;
            else {
              for ((r4 = new l2()).generatedLine = f3, a3 = v2; a3 < m2 && !this._charIsMappingSeparator(e23, a3); a3++)
                ;
              if (i3 = y2[o3 = e23.slice(v2, a3)])
                v2 += o3.length;
              else {
                for (i3 = []; v2 < a3; )
                  s2.decode(e23, v2, w2), c3 = w2.value, v2 = w2.rest, i3.push(c3);
                if (i3.length === 2)
                  throw new Error("Found a source, but no line and column");
                if (i3.length === 3)
                  throw new Error("Found a source and line, but no column");
                y2[o3] = i3;
              }
              r4.generatedColumn = p2 + i3[0], p2 = r4.generatedColumn, i3.length > 1 && (r4.source = D2 + i3[1], D2 += i3[1], r4.originalLine = h2 + i3[2], h2 = r4.originalLine, r4.originalLine += 1, r4.originalColumn = d2 + i3[3], d2 = r4.originalColumn, i3.length > 4 && (r4.name = g2 + i3[4], g2 += i3[4])), C2.push(r4), typeof r4.originalLine == "number" && b2.push(r4);
            }
          u2(C2, n2.compareByGeneratedPositionsDeflated), this.__generatedMappings = C2, u2(b2, n2.compareByOriginalPositions), this.__originalMappings = b2;
        }, c2.prototype._findMapping = function(e23, t5, r4, n3, i3, s3) {
          if (e23[r4] <= 0)
            throw new TypeError("Line must be greater than or equal to 1, got " + e23[r4]);
          if (e23[n3] < 0)
            throw new TypeError("Column must be greater than or equal to 0, got " + e23[n3]);
          return o2.search(e23, t5, i3, s3);
        }, c2.prototype.computeColumnSpans = function() {
          for (var e23 = 0; e23 < this._generatedMappings.length; ++e23) {
            var t5 = this._generatedMappings[e23];
            if (e23 + 1 < this._generatedMappings.length) {
              var r4 = this._generatedMappings[e23 + 1];
              if (t5.generatedLine === r4.generatedLine) {
                t5.lastGeneratedColumn = r4.generatedColumn - 1;
                continue;
              }
            }
            t5.lastGeneratedColumn = 1 / 0;
          }
        }, c2.prototype.originalPositionFor = function(e23) {
          var t5 = {
            generatedLine: n2.getArg(e23, "line"),
            generatedColumn: n2.getArg(e23, "column")
          }, r4 = this._findMapping(t5, this._generatedMappings, "generatedLine", "generatedColumn", n2.compareByGeneratedPositionsDeflated, n2.getArg(e23, "bias", a2.GREATEST_LOWER_BOUND));
          if (r4 >= 0) {
            var o3 = this._generatedMappings[r4];
            if (o3.generatedLine === t5.generatedLine) {
              var i3 = n2.getArg(o3, "source", null);
              i3 !== null && (i3 = this._sources.at(i3), i3 = n2.computeSourceURL(this.sourceRoot, i3, this._sourceMapURL));
              var s3 = n2.getArg(o3, "name", null);
              return s3 !== null && (s3 = this._names.at(s3)), {
                source: i3,
                line: n2.getArg(o3, "originalLine", null),
                column: n2.getArg(o3, "originalColumn", null),
                name: s3
              };
            }
          }
          return {
            source: null,
            line: null,
            column: null,
            name: null
          };
        }, c2.prototype.hasContentsOfAllSources = function() {
          return !!this.sourcesContent && this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(e23) {
            return e23 == null;
          });
        }, c2.prototype.sourceContentFor = function(e23, t5) {
          if (!this.sourcesContent)
            return null;
          var r4 = this._findSourceIndex(e23);
          if (r4 >= 0)
            return this.sourcesContent[r4];
          var o3, i3 = e23;
          if (this.sourceRoot != null && (i3 = n2.relative(this.sourceRoot, i3)), this.sourceRoot != null && (o3 = n2.urlParse(this.sourceRoot))) {
            var s3 = i3.replace(/^file:\/\//, "");
            if (o3.scheme == "file" && this._sources.has(s3))
              return this.sourcesContent[this._sources.indexOf(s3)];
            if ((!o3.path || o3.path == "/") && this._sources.has("/" + i3))
              return this.sourcesContent[this._sources.indexOf("/" + i3)];
          }
          if (t5)
            return null;
          throw new Error('"' + i3 + '" is not in the SourceMap.');
        }, c2.prototype.generatedPositionFor = function(e23) {
          var t5 = n2.getArg(e23, "source");
          if ((t5 = this._findSourceIndex(t5)) < 0)
            return {
              line: null,
              column: null,
              lastColumn: null
            };
          var r4 = {
            source: t5,
            originalLine: n2.getArg(e23, "line"),
            originalColumn: n2.getArg(e23, "column")
          }, o3 = this._findMapping(r4, this._originalMappings, "originalLine", "originalColumn", n2.compareByOriginalPositions, n2.getArg(e23, "bias", a2.GREATEST_LOWER_BOUND));
          if (o3 >= 0) {
            var i3 = this._originalMappings[o3];
            if (i3.source === r4.source)
              return {
                line: n2.getArg(i3, "generatedLine", null),
                column: n2.getArg(i3, "generatedColumn", null),
                lastColumn: n2.getArg(i3, "lastGeneratedColumn", null)
              };
          }
          return {
            line: null,
            column: null,
            lastColumn: null
          };
        }, f2.prototype = Object.create(a2.prototype), f2.prototype.constructor = a2, f2.prototype._version = 3, Object.defineProperty(f2.prototype, "sources", {
          get: function() {
            for (var e23 = [], t5 = 0; t5 < this._sections.length; t5++)
              for (var r4 = 0; r4 < this._sections[t5].consumer.sources.length; r4++)
                e23.push(this._sections[t5].consumer.sources[r4]);
            return e23;
          }
        }), f2.prototype.originalPositionFor = function(e23) {
          var t5 = {
            generatedLine: n2.getArg(e23, "line"),
            generatedColumn: n2.getArg(e23, "column")
          }, r4 = o2.search(t5, this._sections, function(e24, t6) {
            return e24.generatedLine - t6.generatedOffset.generatedLine || e24.generatedColumn - t6.generatedOffset.generatedColumn;
          }), i3 = this._sections[r4];
          return i3 ? i3.consumer.originalPositionFor({
            line: t5.generatedLine - (i3.generatedOffset.generatedLine - 1),
            column: t5.generatedColumn - (i3.generatedOffset.generatedLine === t5.generatedLine ? i3.generatedOffset.generatedColumn - 1 : 0),
            bias: e23.bias
          }) : {
            source: null,
            line: null,
            column: null,
            name: null
          };
        }, f2.prototype.hasContentsOfAllSources = function() {
          return this._sections.every(function(e23) {
            return e23.consumer.hasContentsOfAllSources();
          });
        }, f2.prototype.sourceContentFor = function(e23, t5) {
          for (var r4 = 0; r4 < this._sections.length; r4++) {
            var n3 = this._sections[r4].consumer.sourceContentFor(e23, true);
            if (n3)
              return n3;
          }
          if (t5)
            return null;
          throw new Error('"' + e23 + '" is not in the SourceMap.');
        }, f2.prototype.generatedPositionFor = function(e23) {
          for (var t5 = 0; t5 < this._sections.length; t5++) {
            var r4 = this._sections[t5];
            if (r4.consumer._findSourceIndex(n2.getArg(e23, "source")) !== -1) {
              var o3 = r4.consumer.generatedPositionFor(e23);
              if (o3)
                return {
                  line: o3.line + (r4.generatedOffset.generatedLine - 1),
                  column: o3.column + (r4.generatedOffset.generatedLine === o3.line ? r4.generatedOffset.generatedColumn - 1 : 0)
                };
            }
          }
          return { line: null, column: null };
        }, f2.prototype._parseMappings = function(e23, t5) {
          this.__generatedMappings = [], this.__originalMappings = [];
          for (var r4 = 0; r4 < this._sections.length; r4++)
            for (var o3 = this._sections[r4], i3 = o3.consumer._generatedMappings, s3 = 0; s3 < i3.length; s3++) {
              var a3 = i3[s3], c3 = o3.consumer._sources.at(a3.source);
              c3 = n2.computeSourceURL(o3.consumer.sourceRoot, c3, this._sourceMapURL), this._sources.add(c3), c3 = this._sources.indexOf(c3);
              var l3 = null;
              a3.name && (l3 = o3.consumer._names.at(a3.name), this._names.add(l3), l3 = this._names.indexOf(l3));
              var f3 = {
                source: c3,
                generatedLine: a3.generatedLine + (o3.generatedOffset.generatedLine - 1),
                generatedColumn: a3.generatedColumn + (o3.generatedOffset.generatedLine === a3.generatedLine ? o3.generatedOffset.generatedColumn - 1 : 0),
                originalLine: a3.originalLine,
                originalColumn: a3.originalColumn,
                name: l3
              };
              this.__generatedMappings.push(f3), typeof f3.originalLine == "number" && this.__originalMappings.push(f3);
            }
          u2(this.__generatedMappings, n2.compareByGeneratedPositionsDeflated), u2(this.__originalMappings, n2.compareByOriginalPositions);
        };
      },
      2400: (e22, t4, r3) => {
        var n2 = r3(4886), o2 = r3(7837), i2 = r3(6715).I, s2 = r3(1028).H;
        function u2(e23) {
          e23 || (e23 = {}), this._file = o2.getArg(e23, "file", null), this._sourceRoot = o2.getArg(e23, "sourceRoot", null), this._skipValidation = o2.getArg(e23, "skipValidation", false), this._sources = new i2(), this._names = new i2(), this._mappings = new s2(), this._sourcesContents = null;
        }
        u2.prototype._version = 3, u2.fromSourceMap = function(e23) {
          var t5 = e23.sourceRoot, r4 = new u2({
            file: e23.file,
            sourceRoot: t5
          });
          return e23.eachMapping(function(e24) {
            var n3 = {
              generated: {
                line: e24.generatedLine,
                column: e24.generatedColumn
              }
            };
            e24.source != null && (n3.source = e24.source, t5 != null && (n3.source = o2.relative(t5, n3.source)), n3.original = {
              line: e24.originalLine,
              column: e24.originalColumn
            }, e24.name != null && (n3.name = e24.name)), r4.addMapping(n3);
          }), e23.sources.forEach(function(n3) {
            var i3 = n3;
            t5 !== null && (i3 = o2.relative(t5, n3)), r4._sources.has(i3) || r4._sources.add(i3);
            var s3 = e23.sourceContentFor(n3);
            s3 != null && r4.setSourceContent(n3, s3);
          }), r4;
        }, u2.prototype.addMapping = function(e23) {
          var t5 = o2.getArg(e23, "generated"), r4 = o2.getArg(e23, "original", null), n3 = o2.getArg(e23, "source", null), i3 = o2.getArg(e23, "name", null);
          this._skipValidation || this._validateMapping(t5, r4, n3, i3), n3 != null && (n3 = String(n3), this._sources.has(n3) || this._sources.add(n3)), i3 != null && (i3 = String(i3), this._names.has(i3) || this._names.add(i3)), this._mappings.add({
            generatedLine: t5.line,
            generatedColumn: t5.column,
            originalLine: r4 != null && r4.line,
            originalColumn: r4 != null && r4.column,
            source: n3,
            name: i3
          });
        }, u2.prototype.setSourceContent = function(e23, t5) {
          var r4 = e23;
          this._sourceRoot != null && (r4 = o2.relative(this._sourceRoot, r4)), t5 != null ? (this._sourcesContents || (this._sourcesContents = Object.create(null)), this._sourcesContents[o2.toSetString(r4)] = t5) : this._sourcesContents && (delete this._sourcesContents[o2.toSetString(r4)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
        }, u2.prototype.applySourceMap = function(e23, t5, r4) {
          var n3 = t5;
          if (t5 == null) {
            if (e23.file == null)
              throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
            n3 = e23.file;
          }
          var s3 = this._sourceRoot;
          s3 != null && (n3 = o2.relative(s3, n3));
          var u3 = new i2(), a2 = new i2();
          this._mappings.unsortedForEach(function(t6) {
            if (t6.source === n3 && t6.originalLine != null) {
              var i3 = e23.originalPositionFor({
                line: t6.originalLine,
                column: t6.originalColumn
              });
              i3.source != null && (t6.source = i3.source, r4 != null && (t6.source = o2.join(r4, t6.source)), s3 != null && (t6.source = o2.relative(s3, t6.source)), t6.originalLine = i3.line, t6.originalColumn = i3.column, i3.name != null && (t6.name = i3.name));
            }
            var c2 = t6.source;
            c2 == null || u3.has(c2) || u3.add(c2);
            var l2 = t6.name;
            l2 == null || a2.has(l2) || a2.add(l2);
          }, this), this._sources = u3, this._names = a2, e23.sources.forEach(function(t6) {
            var n4 = e23.sourceContentFor(t6);
            n4 != null && (r4 != null && (t6 = o2.join(r4, t6)), s3 != null && (t6 = o2.relative(s3, t6)), this.setSourceContent(t6, n4));
          }, this);
        }, u2.prototype._validateMapping = function(e23, t5, r4, n3) {
          if (t5 && typeof t5.line != "number" && typeof t5.column != "number")
            throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
          if ((!(e23 && "line" in e23 && "column" in e23 && e23.line > 0 && e23.column >= 0) || t5 || r4 || n3) && !(e23 && "line" in e23 && "column" in e23 && t5 && "line" in t5 && "column" in t5 && e23.line > 0 && e23.column >= 0 && t5.line > 0 && t5.column >= 0 && r4))
            throw new Error("Invalid mapping: " + JSON.stringify({
              generated: e23,
              source: r4,
              original: t5,
              name: n3
            }));
        }, u2.prototype._serializeMappings = function() {
          for (var e23, t5, r4, i3, s3 = 0, u3 = 1, a2 = 0, c2 = 0, l2 = 0, f2 = 0, p2 = "", h2 = this._mappings.toArray(), d2 = 0, D2 = h2.length; d2 < D2; d2++) {
            if (e23 = "", (t5 = h2[d2]).generatedLine !== u3)
              for (s3 = 0; t5.generatedLine !== u3; )
                e23 += ";", u3++;
            else if (d2 > 0) {
              if (!o2.compareByGeneratedPositionsInflated(t5, h2[d2 - 1]))
                continue;
              e23 += ",";
            }
            e23 += n2.encode(t5.generatedColumn - s3), s3 = t5.generatedColumn, t5.source != null && (i3 = this._sources.indexOf(t5.source), e23 += n2.encode(i3 - f2), f2 = i3, e23 += n2.encode(t5.originalLine - 1 - c2), c2 = t5.originalLine - 1, e23 += n2.encode(t5.originalColumn - a2), a2 = t5.originalColumn, t5.name != null && (r4 = this._names.indexOf(t5.name), e23 += n2.encode(r4 - l2), l2 = r4)), p2 += e23;
          }
          return p2;
        }, u2.prototype._generateSourcesContent = function(e23, t5) {
          return e23.map(function(e24) {
            if (!this._sourcesContents)
              return null;
            t5 != null && (e24 = o2.relative(t5, e24));
            var r4 = o2.toSetString(e24);
            return Object.prototype.hasOwnProperty.call(this._sourcesContents, r4) ? this._sourcesContents[r4] : null;
          }, this);
        }, u2.prototype.toJSON = function() {
          var e23 = {
            version: this._version,
            sources: this._sources.toArray(),
            names: this._names.toArray(),
            mappings: this._serializeMappings()
          };
          return this._file != null && (e23.file = this._file), this._sourceRoot != null && (e23.sourceRoot = this._sourceRoot), this._sourcesContents && (e23.sourcesContent = this._generateSourcesContent(e23.sources, e23.sourceRoot)), e23;
        }, u2.prototype.toString = function() {
          return JSON.stringify(this.toJSON());
        }, t4.SourceMapGenerator = u2;
      },
      6270: (e22, t4, r3) => {
        var n2 = r3(2400).SourceMapGenerator, o2 = r3(7837), i2 = /(\r?\n)/, s2 = "$$$isSourceNode$$$";
        function u2(e23, t5, r4, n3, o3) {
          this.children = [], this.sourceContents = {}, this.line = e23 == null ? null : e23, this.column = t5 == null ? null : t5, this.source = r4 == null ? null : r4, this.name = o3 == null ? null : o3, this[s2] = true, n3 != null && this.add(n3);
        }
        u2.fromStringWithSourceMap = function(e23, t5, r4) {
          var n3 = new u2(), s3 = e23.split(i2), a2 = 0, c2 = function() {
            return e24() + (e24() || "");
            function e24() {
              return a2 < s3.length ? s3[a2++] : void 0;
            }
          }, l2 = 1, f2 = 0, p2 = null;
          return t5.eachMapping(function(e24) {
            if (p2 !== null) {
              if (!(l2 < e24.generatedLine)) {
                var t6 = (r5 = s3[a2] || "").substr(0, e24.generatedColumn - f2);
                return s3[a2] = r5.substr(e24.generatedColumn - f2), f2 = e24.generatedColumn, h2(p2, t6), void (p2 = e24);
              }
              h2(p2, c2()), l2++, f2 = 0;
            }
            for (; l2 < e24.generatedLine; )
              n3.add(c2()), l2++;
            if (f2 < e24.generatedColumn) {
              var r5 = s3[a2] || "";
              n3.add(r5.substr(0, e24.generatedColumn)), s3[a2] = r5.substr(e24.generatedColumn), f2 = e24.generatedColumn;
            }
            p2 = e24;
          }, this), a2 < s3.length && (p2 && h2(p2, c2()), n3.add(s3.splice(a2).join(""))), t5.sources.forEach(function(e24) {
            var i3 = t5.sourceContentFor(e24);
            i3 != null && (r4 != null && (e24 = o2.join(r4, e24)), n3.setSourceContent(e24, i3));
          }), n3;
          function h2(e24, t6) {
            if (e24 === null || e24.source === void 0)
              n3.add(t6);
            else {
              var i3 = r4 ? o2.join(r4, e24.source) : e24.source;
              n3.add(new u2(e24.originalLine, e24.originalColumn, i3, t6, e24.name));
            }
          }
        }, u2.prototype.add = function(e23) {
          if (Array.isArray(e23))
            e23.forEach(function(e24) {
              this.add(e24);
            }, this);
          else {
            if (!e23[s2] && typeof e23 != "string")
              throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + e23);
            e23 && this.children.push(e23);
          }
          return this;
        }, u2.prototype.prepend = function(e23) {
          if (Array.isArray(e23))
            for (var t5 = e23.length - 1; t5 >= 0; t5--)
              this.prepend(e23[t5]);
          else {
            if (!e23[s2] && typeof e23 != "string")
              throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + e23);
            this.children.unshift(e23);
          }
          return this;
        }, u2.prototype.walk = function(e23) {
          for (var t5, r4 = 0, n3 = this.children.length; r4 < n3; r4++)
            (t5 = this.children[r4])[s2] ? t5.walk(e23) : t5 !== "" && e23(t5, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
        }, u2.prototype.join = function(e23) {
          var t5, r4, n3 = this.children.length;
          if (n3 > 0) {
            for (t5 = [], r4 = 0; r4 < n3 - 1; r4++)
              t5.push(this.children[r4]), t5.push(e23);
            t5.push(this.children[r4]), this.children = t5;
          }
          return this;
        }, u2.prototype.replaceRight = function(e23, t5) {
          var r4 = this.children[this.children.length - 1];
          return r4[s2] ? r4.replaceRight(e23, t5) : typeof r4 == "string" ? this.children[this.children.length - 1] = r4.replace(e23, t5) : this.children.push("".replace(e23, t5)), this;
        }, u2.prototype.setSourceContent = function(e23, t5) {
          this.sourceContents[o2.toSetString(e23)] = t5;
        }, u2.prototype.walkSourceContents = function(e23) {
          for (var t5 = 0, r4 = this.children.length; t5 < r4; t5++)
            this.children[t5][s2] && this.children[t5].walkSourceContents(e23);
          var n3 = Object.keys(this.sourceContents);
          for (t5 = 0, r4 = n3.length; t5 < r4; t5++)
            e23(o2.fromSetString(n3[t5]), this.sourceContents[n3[t5]]);
        }, u2.prototype.toString = function() {
          var e23 = "";
          return this.walk(function(t5) {
            e23 += t5;
          }), e23;
        }, u2.prototype.toStringWithSourceMap = function(e23) {
          var t5 = { code: "", line: 1, column: 0 }, r4 = new n2(e23), o3 = false, i3 = null, s3 = null, u3 = null, a2 = null;
          return this.walk(function(e24, n3) {
            t5.code += e24, n3.source !== null && n3.line !== null && n3.column !== null ? (i3 === n3.source && s3 === n3.line && u3 === n3.column && a2 === n3.name || r4.addMapping({
              source: n3.source,
              original: {
                line: n3.line,
                column: n3.column
              },
              generated: {
                line: t5.line,
                column: t5.column
              },
              name: n3.name
            }), i3 = n3.source, s3 = n3.line, u3 = n3.column, a2 = n3.name, o3 = true) : o3 && (r4.addMapping({
              generated: {
                line: t5.line,
                column: t5.column
              }
            }), i3 = null, o3 = false);
            for (var c2 = 0, l2 = e24.length; c2 < l2; c2++)
              e24.charCodeAt(c2) === 10 ? (t5.line++, t5.column = 0, c2 + 1 === l2 ? (i3 = null, o3 = false) : o3 && r4.addMapping({
                source: n3.source,
                original: {
                  line: n3.line,
                  column: n3.column
                },
                generated: {
                  line: t5.line,
                  column: t5.column
                },
                name: n3.name
              })) : t5.column++;
          }), this.walkSourceContents(function(e24, t6) {
            r4.setSourceContent(e24, t6);
          }), { code: t5.code, map: r4 };
        }, t4.SourceNode = u2;
      },
      7837: (e22, t4) => {
        t4.getArg = function(e23, t5, r4) {
          if (t5 in e23)
            return e23[t5];
          if (arguments.length === 3)
            return r4;
          throw new Error('"' + t5 + '" is a required argument.');
        };
        var r3 = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, n2 = /^data:.+\,.+$/;
        function o2(e23) {
          var t5 = e23.match(r3);
          return t5 ? {
            scheme: t5[1],
            auth: t5[2],
            host: t5[3],
            port: t5[4],
            path: t5[5]
          } : null;
        }
        function i2(e23) {
          var t5 = "";
          return e23.scheme && (t5 += e23.scheme + ":"), t5 += "//", e23.auth && (t5 += e23.auth + "@"), e23.host && (t5 += e23.host), e23.port && (t5 += ":" + e23.port), e23.path && (t5 += e23.path), t5;
        }
        function s2(e23) {
          var r4 = e23, n3 = o2(e23);
          if (n3) {
            if (!n3.path)
              return e23;
            r4 = n3.path;
          }
          for (var s3, u3 = t4.isAbsolute(r4), a3 = r4.split(/\/+/), c3 = 0, l3 = a3.length - 1; l3 >= 0; l3--)
            (s3 = a3[l3]) === "." ? a3.splice(l3, 1) : s3 === ".." ? c3++ : c3 > 0 && (s3 === "" ? (a3.splice(l3 + 1, c3), c3 = 0) : (a3.splice(l3, 2), c3--));
          return (r4 = a3.join("/")) === "" && (r4 = u3 ? "/" : "."), n3 ? (n3.path = r4, i2(n3)) : r4;
        }
        function u2(e23, t5) {
          e23 === "" && (e23 = "."), t5 === "" && (t5 = ".");
          var r4 = o2(t5), u3 = o2(e23);
          if (u3 && (e23 = u3.path || "/"), r4 && !r4.scheme)
            return u3 && (r4.scheme = u3.scheme), i2(r4);
          if (r4 || t5.match(n2))
            return t5;
          if (u3 && !u3.host && !u3.path)
            return u3.host = t5, i2(u3);
          var a3 = t5.charAt(0) === "/" ? t5 : s2(e23.replace(/\/+$/, "") + "/" + t5);
          return u3 ? (u3.path = a3, i2(u3)) : a3;
        }
        t4.urlParse = o2, t4.urlGenerate = i2, t4.normalize = s2, t4.join = u2, t4.isAbsolute = function(e23) {
          return e23.charAt(0) === "/" || r3.test(e23);
        }, t4.relative = function(e23, t5) {
          e23 === "" && (e23 = "."), e23 = e23.replace(/\/$/, "");
          for (var r4 = 0; t5.indexOf(e23 + "/") !== 0; ) {
            var n3 = e23.lastIndexOf("/");
            if (n3 < 0)
              return t5;
            if ((e23 = e23.slice(0, n3)).match(/^([^\/]+:\/)?\/*$/))
              return t5;
            ++r4;
          }
          return Array(r4 + 1).join("../") + t5.substr(e23.length + 1);
        };
        var a2 = !("__proto__" in Object.create(null));
        function c2(e23) {
          return e23;
        }
        function l2(e23) {
          if (!e23)
            return false;
          var t5 = e23.length;
          if (t5 < 9)
            return false;
          if (e23.charCodeAt(t5 - 1) !== 95 || e23.charCodeAt(t5 - 2) !== 95 || e23.charCodeAt(t5 - 3) !== 111 || e23.charCodeAt(t5 - 4) !== 116 || e23.charCodeAt(t5 - 5) !== 111 || e23.charCodeAt(t5 - 6) !== 114 || e23.charCodeAt(t5 - 7) !== 112 || e23.charCodeAt(t5 - 8) !== 95 || e23.charCodeAt(t5 - 9) !== 95)
            return false;
          for (var r4 = t5 - 10; r4 >= 0; r4--)
            if (e23.charCodeAt(r4) !== 36)
              return false;
          return true;
        }
        function f2(e23, t5) {
          return e23 === t5 ? 0 : e23 === null ? 1 : t5 === null ? -1 : e23 > t5 ? 1 : -1;
        }
        t4.toSetString = a2 ? c2 : function(e23) {
          return l2(e23) ? "$" + e23 : e23;
        }, t4.fromSetString = a2 ? c2 : function(e23) {
          return l2(e23) ? e23.slice(1) : e23;
        }, t4.compareByOriginalPositions = function(e23, t5, r4) {
          var n3 = f2(e23.source, t5.source);
          return n3 !== 0 || (n3 = e23.originalLine - t5.originalLine) != 0 || (n3 = e23.originalColumn - t5.originalColumn) != 0 || r4 || (n3 = e23.generatedColumn - t5.generatedColumn) != 0 || (n3 = e23.generatedLine - t5.generatedLine) != 0 ? n3 : f2(e23.name, t5.name);
        }, t4.compareByGeneratedPositionsDeflated = function(e23, t5, r4) {
          var n3 = e23.generatedLine - t5.generatedLine;
          return n3 !== 0 || (n3 = e23.generatedColumn - t5.generatedColumn) != 0 || r4 || (n3 = f2(e23.source, t5.source)) !== 0 || (n3 = e23.originalLine - t5.originalLine) != 0 || (n3 = e23.originalColumn - t5.originalColumn) != 0 ? n3 : f2(e23.name, t5.name);
        }, t4.compareByGeneratedPositionsInflated = function(e23, t5) {
          var r4 = e23.generatedLine - t5.generatedLine;
          return r4 !== 0 || (r4 = e23.generatedColumn - t5.generatedColumn) != 0 || (r4 = f2(e23.source, t5.source)) !== 0 || (r4 = e23.originalLine - t5.originalLine) != 0 || (r4 = e23.originalColumn - t5.originalColumn) != 0 ? r4 : f2(e23.name, t5.name);
        }, t4.parseSourceMapInput = function(e23) {
          return JSON.parse(e23.replace(/^\)]}'[^\n]*\n/, ""));
        }, t4.computeSourceURL = function(e23, t5, r4) {
          if (t5 = t5 || "", e23 && (e23[e23.length - 1] !== "/" && t5[0] !== "/" && (e23 += "/"), t5 = e23 + t5), r4) {
            var n3 = o2(r4);
            if (!n3)
              throw new Error("sourceMapURL could not be parsed");
            if (n3.path) {
              var a3 = n3.path.lastIndexOf("/");
              a3 >= 0 && (n3.path = n3.path.substring(0, a3 + 1));
            }
            t5 = u2(i2(n3), t5);
          }
          return s2(t5);
        };
      },
      2447: (e22, t4, r3) => {
        t4.SourceMapGenerator = r3(2400).SourceMapGenerator, t4.SourceMapConsumer = r3(8985).SourceMapConsumer, t4.SourceNode = r3(6270).SourceNode;
      },
      6549: (e22, t4, r3) => {
        const n2 = r3(9992), o2 = r3(8528), i2 = r3(541), s2 = (e23) => {
          if (typeof e23 != "string" || e23.length === 0)
            return 0;
          if ((e23 = n2(e23)).length === 0)
            return 0;
          e23 = e23.replace(i2(), "  ");
          let t5 = 0;
          for (let r4 = 0; r4 < e23.length; r4++) {
            const n3 = e23.codePointAt(r4);
            n3 <= 31 || n3 >= 127 && n3 <= 159 || n3 >= 768 && n3 <= 879 || (n3 > 65535 && r4++, t5 += o2(n3) ? 2 : 1);
          }
          return t5;
        };
        e22.exports = s2, e22.exports.default = s2;
      },
      9992: (e22, t4, r3) => {
        const n2 = r3(2426);
        e22.exports = (e23) => typeof e23 == "string" ? e23.replace(n2(), "") : e23;
      },
      3210: (e22, t4, r3) => {
        r3(4070), e22.exports = function(e23, t5, r4) {
          return e23.length === 0 ? e23 : t5 ? (r4 || e23.sort(t5), function(e24, t6) {
            for (var r5 = 1, n2 = e24.length, o2 = e24[0], i2 = e24[0], s2 = 1; s2 < n2; ++s2)
              if (i2 = o2, t6(o2 = e24[s2], i2)) {
                if (s2 === r5) {
                  r5++;
                  continue;
                }
                e24[r5++] = o2;
              }
            return e24.length = r5, e24;
          }(e23, t5)) : (r4 || e23.sort(), function(e24) {
            for (var t6 = 1, r5 = e24.length, n2 = e24[0], o2 = e24[0], i2 = 1; i2 < r5; ++i2, o2 = n2)
              if (o2 = n2, (n2 = e24[i2]) !== o2) {
                if (i2 === t6) {
                  t6++;
                  continue;
                }
                e24[t6++] = n2;
              }
            return e24.length = t6, e24;
          }(e23));
        };
      },
      7933: (e22) => {
        e22.exports = {
          guessEndOfLine: function(e23) {
            const t4 = e23.indexOf("\r");
            return t4 >= 0 ? e23.charAt(t4 + 1) === "\n" ? "crlf" : "cr" : "lf";
          },
          convertEndOfLineToChars: function(e23) {
            switch (e23) {
              case "cr":
                return "\r";
              case "crlf":
                return "\r\n";
              default:
                return "\n";
            }
          },
          countEndOfLineChars: function(e23, t4) {
            let r3;
            if (t4 === "\n")
              r3 = /\n/g;
            else if (t4 === "\r")
              r3 = /\r/g;
            else {
              if (t4 !== "\r\n")
                throw new Error(`Unexpected "eol" ${JSON.stringify(t4)}.`);
              r3 = /\r\n/g;
            }
            const n2 = e23.match(r3);
            return n2 ? n2.length : 0;
          },
          normalizeEndOfLine: function(e23) {
            return e23.replace(/\r\n?/g, "\n");
          }
        };
      },
      47: (e22) => {
        e22.exports = function(e23, t4) {
          const r3 = new SyntaxError(e23 + " (" + t4.start.line + ":" + t4.start.column + ")");
          return r3.loc = t4, r3;
        };
      },
      9428: (e22, t4, r3) => {
        const n2 = r3(6549), o2 = r3(2240), i2 = r3(4652), { getSupportInfo: s2 } = r3(7290), u2 = /[^\x20-\x7F]/;
        function a2(e23) {
          return (t5, r4, n3) => {
            const o3 = n3 && n3.backwards;
            if (r4 === false)
              return false;
            const { length: i3 } = t5;
            let s3 = r4;
            for (; s3 >= 0 && s3 < i3; ) {
              const r5 = t5.charAt(s3);
              if (e23 instanceof RegExp) {
                if (!e23.test(r5))
                  return s3;
              } else if (!e23.includes(r5))
                return s3;
              o3 ? s3-- : s3++;
            }
            return (s3 === -1 || s3 === i3) && s3;
          };
        }
        const c2 = a2(/\s/), l2 = a2(" 	"), f2 = a2(",; 	"), p2 = a2(/[^\n\r]/);
        function h2(e23, t5) {
          if (t5 === false)
            return false;
          if (e23.charAt(t5) === "/" && e23.charAt(t5 + 1) === "*") {
            for (let r4 = t5 + 2; r4 < e23.length; ++r4)
              if (e23.charAt(r4) === "*" && e23.charAt(r4 + 1) === "/")
                return r4 + 2;
          }
          return t5;
        }
        function d2(e23, t5) {
          return t5 !== false && (e23.charAt(t5) === "/" && e23.charAt(t5 + 1) === "/" ? p2(e23, t5) : t5);
        }
        function D2(e23, t5, r4) {
          const n3 = r4 && r4.backwards;
          if (t5 === false)
            return false;
          const o3 = e23.charAt(t5);
          if (n3) {
            if (e23.charAt(t5 - 1) === "\r" && o3 === "\n")
              return t5 - 2;
            if (o3 === "\n" || o3 === "\r" || o3 === "\u2028" || o3 === "\u2029")
              return t5 - 1;
          } else {
            if (o3 === "\r" && e23.charAt(t5 + 1) === "\n")
              return t5 + 2;
            if (o3 === "\n" || o3 === "\r" || o3 === "\u2028" || o3 === "\u2029")
              return t5 + 1;
          }
          return t5;
        }
        function g2(e23, t5, r4 = {}) {
          const n3 = l2(e23, r4.backwards ? t5 - 1 : t5, r4);
          return n3 !== D2(e23, n3, r4);
        }
        function m2(e23, t5) {
          let r4 = null, n3 = t5;
          for (; n3 !== r4; )
            r4 = n3, n3 = f2(e23, n3), n3 = h2(e23, n3), n3 = l2(e23, n3);
          return n3 = d2(e23, n3), n3 = D2(e23, n3), n3 !== false && g2(e23, n3);
        }
        function v2(e23, t5) {
          let r4 = null, n3 = t5;
          for (; n3 !== r4; )
            r4 = n3, n3 = l2(e23, n3), n3 = h2(e23, n3), n3 = d2(e23, n3), n3 = D2(e23, n3);
          return n3;
        }
        function y2(e23, t5, r4) {
          return v2(e23, r4(t5));
        }
        function w2(e23, t5, r4 = 0) {
          let n3 = 0;
          for (let o3 = r4; o3 < e23.length; ++o3)
            e23[o3] === "	" ? n3 = n3 + t5 - n3 % t5 : n3++;
          return n3;
        }
        function b2(e23, t5) {
          const r4 = e23.slice(1, -1), n3 = { quote: '"', regex: /"/g }, o3 = { quote: "'", regex: /'/g }, i3 = t5 === "'" ? o3 : n3, s3 = i3 === o3 ? n3 : o3;
          let u3 = i3.quote;
          return (r4.includes(i3.quote) || r4.includes(s3.quote)) && (u3 = (r4.match(i3.regex) || []).length > (r4.match(s3.regex) || []).length ? s3.quote : i3.quote), u3;
        }
        function C2(e23, t5, r4) {
          const n3 = t5 === '"' ? "'" : '"', o3 = e23.replace(/\\(.)|(["'])/gs, (e24, o4, i3) => o4 === n3 ? o4 : i3 === t5 ? "\\" + i3 : i3 || (r4 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(o4) ? o4 : "\\" + o4));
          return t5 + o3 + t5;
        }
        function E2(e23, t5) {
          (e23.comments || (e23.comments = [])).push(t5), t5.printed = false, t5.nodeDescription = function(e24) {
            const t6 = e24.type || e24.kind || "(unknown type)";
            let r4 = String(e24.name || e24.id && (typeof e24.id == "object" ? e24.id.name : e24.id) || e24.key && (typeof e24.key == "object" ? e24.key.name : e24.key) || e24.value && (typeof e24.value == "object" ? "" : String(e24.value)) || e24.operator || "");
            return r4.length > 20 && (r4 = r4.slice(0, 19) + "\u2026"), t6 + (r4 ? " " + r4 : "");
          }(e23);
        }
        e22.exports = {
          inferParserByLanguage: function(e23, t5) {
            const { languages: r4 } = s2({
              plugins: t5.plugins
            }), n3 = r4.find(({ name: t6 }) => t6.toLowerCase() === e23) || r4.find(({ aliases: t6 }) => Array.isArray(t6) && t6.includes(e23)) || r4.find(({ extensions: t6 }) => Array.isArray(t6) && t6.includes(`.${e23}`));
            return n3 && n3.parsers[0];
          },
          getStringWidth: function(e23) {
            return e23 ? u2.test(e23) ? n2(e23) : e23.length : 0;
          },
          getMaxContinuousCount: function(e23, t5) {
            const r4 = e23.match(new RegExp(`(${o2(t5)})+`, "g"));
            return r4 === null ? 0 : r4.reduce((e24, r5) => Math.max(e24, r5.length / t5.length), 0);
          },
          getMinNotPresentContinuousCount: function(e23, t5) {
            const r4 = e23.match(new RegExp(`(${o2(t5)})+`, "g"));
            if (r4 === null)
              return 0;
            const n3 = new Map();
            let i3 = 0;
            for (const e24 of r4) {
              const r5 = e24.length / t5.length;
              n3.set(r5, true), r5 > i3 && (i3 = r5);
            }
            for (let e24 = 1; e24 < i3; e24++)
              if (!n3.get(e24))
                return e24;
            return i3 + 1;
          },
          getPenultimate: (e23) => e23[e23.length - 2],
          getLast: i2,
          getNextNonSpaceNonCommentCharacterIndexWithStartIndex: v2,
          getNextNonSpaceNonCommentCharacterIndex: y2,
          getNextNonSpaceNonCommentCharacter: function(e23, t5, r4) {
            return e23.charAt(y2(e23, t5, r4));
          },
          skip: a2,
          skipWhitespace: c2,
          skipSpaces: l2,
          skipToLineEnd: f2,
          skipEverythingButNewLine: p2,
          skipInlineComment: h2,
          skipTrailingComment: d2,
          skipNewline: D2,
          isNextLineEmptyAfterIndex: m2,
          isNextLineEmpty: function(e23, t5, r4) {
            return m2(e23, r4(t5));
          },
          isPreviousLineEmpty: function(e23, t5, r4) {
            let n3 = r4(t5) - 1;
            return n3 = l2(e23, n3, { backwards: true }), n3 = D2(e23, n3, { backwards: true }), n3 = l2(e23, n3, { backwards: true }), n3 !== D2(e23, n3, { backwards: true });
          },
          hasNewline: g2,
          hasNewlineInRange: function(e23, t5, r4) {
            for (let n3 = t5; n3 < r4; ++n3)
              if (e23.charAt(n3) === "\n")
                return true;
            return false;
          },
          hasSpaces: function(e23, t5, r4 = {}) {
            return l2(e23, r4.backwards ? t5 - 1 : t5, r4) !== t5;
          },
          getAlignmentSize: w2,
          getIndentSize: function(e23, t5) {
            const r4 = e23.lastIndexOf("\n");
            return r4 === -1 ? 0 : w2(e23.slice(r4 + 1).match(/^[\t ]*/)[0], t5);
          },
          getPreferredQuote: b2,
          printString: function(e23, t5) {
            return C2(e23.slice(1, -1), t5.parser === "json" || t5.parser === "json5" && t5.quoteProps === "preserve" && !t5.singleQuote ? '"' : t5.__isInHtmlAttribute ? "'" : b2(e23, t5.singleQuote ? "'" : '"'), !(t5.parser === "css" || t5.parser === "less" || t5.parser === "scss" || t5.__embeddedInHtml));
          },
          printNumber: function(e23) {
            return e23.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
          },
          makeString: C2,
          addLeadingComment: function(e23, t5) {
            t5.leading = true, t5.trailing = false, E2(e23, t5);
          },
          addDanglingComment: function(e23, t5, r4) {
            t5.leading = false, t5.trailing = false, r4 && (t5.marker = r4), E2(e23, t5);
          },
          addTrailingComment: function(e23, t5) {
            t5.leading = false, t5.trailing = true, E2(e23, t5);
          },
          isFrontMatterNode: function(e23) {
            return e23 && e23.type === "front-matter";
          },
          getShebang: function(e23) {
            if (!e23.startsWith("#!"))
              return "";
            const t5 = e23.indexOf("\n");
            return t5 === -1 ? e23 : e23.slice(0, t5);
          },
          isNonEmptyArray: function(e23) {
            return Array.isArray(e23) && e23.length > 0;
          },
          createGroupIdMapper: function(e23) {
            const t5 = new WeakMap();
            return function(r4) {
              return t5.has(r4) || t5.set(r4, Symbol(e23)), t5.get(r4);
            };
          }
        };
      },
      9355: (e22, t4, r3) => {
        const n2 = r3(6920), { getLast: o2, skipEverythingButNewLine: i2 } = r3(9428);
        function s2(e23, t5) {
          return typeof e23.sourceIndex == "number" ? e23.sourceIndex : e23.source ? n2(e23.source.start, t5) - 1 : null;
        }
        function u2(e23, t5) {
          if (e23.type === "css-comment" && e23.inline)
            return i2(t5, e23.source.startOffset);
          const r4 = e23.nodes && o2(e23.nodes);
          return r4 && e23.source && !e23.source.end && (e23 = r4), e23.source && e23.source.end ? n2(e23.source.end, t5) : null;
        }
        function a2(e23, t5, r4) {
          e23.source && (e23.source.startOffset = s2(e23, r4) + t5, e23.source.endOffset = u2(e23, r4) + t5);
          for (const n3 in e23) {
            const o3 = e23[n3];
            n3 !== "source" && o3 && typeof o3 == "object" && a2(o3, t5, r4);
          }
        }
        function c2(e23) {
          let t5 = e23.source.startOffset;
          return typeof e23.prop == "string" && (t5 += e23.prop.length), e23.type === "css-atrule" && typeof e23.name == "string" && (t5 += 1 + e23.name.length + e23.raws.afterName.match(/^\s*:?\s*/)[0].length), e23.type !== "css-atrule" && e23.raws && typeof e23.raws.between == "string" && (t5 += e23.raws.between.length), t5;
        }
        e22.exports = {
          locStart: function(e23) {
            return e23.source.startOffset;
          },
          locEnd: function(e23) {
            return e23.source.endOffset;
          },
          calculateLoc: function e23(t5, r4) {
            t5.source && (t5.source.startOffset = s2(t5, r4), t5.source.endOffset = u2(t5, r4));
            for (const n3 in t5) {
              const o3 = t5[n3];
              n3 !== "source" && o3 && typeof o3 == "object" && (o3.type === "value-root" || o3.type === "value-unknown" ? a2(o3, c2(t5), o3.text || o3.value) : e23(o3, r4));
            }
          },
          replaceQuotesInInlineComments: function(e23) {
            let t5, r4 = "initial", n3 = "initial", o3 = false;
            const i3 = [];
            for (let s3 = 0; s3 < e23.length; s3++) {
              const u3 = e23[s3];
              switch (r4) {
                case "initial":
                  if (u3 === "'") {
                    r4 = "single-quotes";
                    continue;
                  }
                  if (u3 === '"') {
                    r4 = "double-quotes";
                    continue;
                  }
                  if ((u3 === "u" || u3 === "U") && e23.slice(s3, s3 + 4).toLowerCase() === "url(") {
                    r4 = "url", s3 += 3;
                    continue;
                  }
                  if (u3 === "*" && e23[s3 - 1] === "/") {
                    r4 = "comment-block";
                    continue;
                  }
                  if (u3 === "/" && e23[s3 - 1] === "/") {
                    r4 = "comment-inline", t5 = s3 - 1;
                    continue;
                  }
                  continue;
                case "single-quotes":
                  if (u3 === "'" && e23[s3 - 1] !== "\\" && (r4 = n3, n3 = "initial"), u3 === "\n" || u3 === "\r")
                    return e23;
                  continue;
                case "double-quotes":
                  if (u3 === '"' && e23[s3 - 1] !== "\\" && (r4 = n3, n3 = "initial"), u3 === "\n" || u3 === "\r")
                    return e23;
                  continue;
                case "url":
                  if (u3 === ")" && (r4 = "initial"), u3 === "\n" || u3 === "\r")
                    return e23;
                  if (u3 === "'") {
                    r4 = "single-quotes", n3 = "url";
                    continue;
                  }
                  if (u3 === '"') {
                    r4 = "double-quotes", n3 = "url";
                    continue;
                  }
                  continue;
                case "comment-block":
                  u3 === "/" && e23[s3 - 1] === "*" && (r4 = "initial");
                  continue;
                case "comment-inline":
                  u3 !== '"' && u3 !== "'" && u3 !== "*" || (o3 = true), u3 !== "\n" && u3 !== "\r" || (o3 && i3.push([t5, s3]), r4 = "initial", o3 = false);
                  continue;
              }
            }
            for (const [t6, r5] of i3)
              e23 = e23.slice(0, t6) + e23.slice(t6, r5).replace(/["'*]/g, " ") + e23.slice(r5);
            return e23;
          }
        };
      },
      738: (e22, t4, r3) => {
        const n2 = r3(47), o2 = r3(4652), i2 = r3(5115), { hasPragma: s2 } = r3(8850), {
          hasSCSSInterpolation: u2,
          hasStringOrFunction: a2,
          isLessParser: c2,
          isSCSS: l2,
          isSCSSNestedPropertyNode: f2,
          isSCSSVariable: p2,
          stringifyNode: h2,
          isModuleRuleName: d2
        } = r3(5244), { locStart: D2, locEnd: g2 } = r3(9355), {
          calculateLoc: m2,
          replaceQuotesInInlineComments: v2
        } = r3(9355), y2 = (e23) => {
          for (; e23.parent; )
            e23 = e23.parent;
          return e23;
        };
        function w2(e23, t5) {
          const { nodes: r4 } = e23;
          let n3 = {
            open: null,
            close: null,
            groups: [],
            type: "paren_group"
          };
          const i3 = [n3], s3 = n3;
          let c3 = { groups: [], type: "comma_group" };
          const f3 = [c3];
          for (let s4 = 0; s4 < r4.length; ++s4) {
            const d3 = r4[s4];
            if (l2(t5.parser, d3.value) && d3.type === "number" && d3.unit === ".." && o2(d3.value) === "." && (d3.value = d3.value.slice(0, -1), d3.unit = "..."), d3.type === "func" && d3.value === "selector" && (d3.group.groups = [
              A2(y2(e23).text.slice(d3.group.open.sourceIndex + 1, d3.group.close.sourceIndex))
            ]), d3.type === "func" && d3.value === "url") {
              const e24 = d3.group && d3.group.groups || [];
              let t6 = [];
              for (let r5 = 0; r5 < e24.length; r5++) {
                const n4 = e24[r5];
                n4.type === "comma_group" ? t6 = [...t6, ...n4.groups] : t6.push(n4);
              }
              if (u2(t6) || !a2(t6) && !p2(t6[0])) {
                const e25 = h2({
                  groups: d3.group.groups
                });
                d3.group.groups = [e25.trim()];
              }
            }
            if (d3.type === "paren" && d3.value === "(")
              n3 = {
                open: d3,
                close: null,
                groups: [],
                type: "paren_group"
              }, i3.push(n3), c3 = {
                groups: [],
                type: "comma_group"
              }, f3.push(c3);
            else if (d3.type === "paren" && d3.value === ")") {
              if (c3.groups.length > 0 && n3.groups.push(c3), n3.close = d3, f3.length === 1)
                throw new Error("Unbalanced parenthesis");
              f3.pop(), c3 = o2(f3), c3.groups.push(n3), i3.pop(), n3 = o2(i3);
            } else
              d3.type === "comma" ? (n3.groups.push(c3), c3 = {
                groups: [],
                type: "comma_group"
              }, f3[f3.length - 1] = c3) : c3.groups.push(d3);
          }
          return c3.groups.length > 0 && n3.groups.push(c3), s3;
        }
        function b2(e23) {
          return e23.type !== "paren_group" || e23.open || e23.close || e23.groups.length !== 1 ? e23.type === "comma_group" && e23.groups.length === 1 ? b2(e23.groups[0]) : e23.type === "paren_group" || e23.type === "comma_group" ? Object.assign(Object.assign({}, e23), {}, { groups: e23.groups.map(b2) }) : e23 : b2(e23.groups[0]);
        }
        function C2(e23, t5, r4) {
          if (e23 && typeof e23 == "object") {
            delete e23.parent;
            for (const n3 in e23)
              C2(e23[n3], t5, r4), n3 === "type" && typeof e23[n3] == "string" && (e23[n3].startsWith(t5) || r4 && r4.test(e23[n3]) || (e23[n3] = t5 + e23[n3]));
          }
          return e23;
        }
        function E2(e23) {
          if (e23 && typeof e23 == "object") {
            delete e23.parent;
            for (const t5 in e23)
              E2(e23[t5]);
            Array.isArray(e23) || !e23.value || e23.type || (e23.type = "unknown");
          }
          return e23;
        }
        function F2(e23, t5) {
          if (e23 && typeof e23 == "object") {
            for (const r4 in e23)
              r4 !== "parent" && (F2(e23[r4], t5), r4 === "nodes" && (e23.group = b2(w2(e23, t5)), delete e23[r4]));
            delete e23.parent;
          }
          return e23;
        }
        function x2(e23, t5) {
          const n3 = r3(9962);
          let o3 = null;
          try {
            o3 = n3(e23, { loose: true }).parse();
          } catch {
            return { type: "value-unknown", value: e23 };
          }
          return o3.text = e23, C2(F2(o3, t5), "value-", /^selector-/);
        }
        function A2(e23) {
          if (/\/\/|\/\*/.test(e23))
            return {
              type: "selector-unknown",
              value: e23.trim()
            };
          const t5 = r3(1264);
          let n3 = null;
          try {
            t5((e24) => {
              n3 = e24;
            }).process(e23);
          } catch {
            return {
              type: "selector-unknown",
              value: e23
            };
          }
          return C2(n3, "selector-");
        }
        function k2(e23) {
          const t5 = r3(8322).Z;
          let n3 = null;
          try {
            n3 = t5(e23);
          } catch {
            return {
              type: "selector-unknown",
              value: e23
            };
          }
          return C2(E2(n3), "media-");
        }
        const O2 = /(\s*?)(!default).*$/, _2 = /(\s*?)(!global).*$/;
        function S2(e23, t5) {
          if (e23 && typeof e23 == "object") {
            delete e23.parent;
            for (const r5 in e23)
              S2(e23[r5], t5);
            if (!e23.type)
              return e23;
            e23.raws || (e23.raws = {});
            let r4 = "";
            typeof e23.selector == "string" && (r4 = e23.raws.selector ? e23.raws.selector.scss ? e23.raws.selector.scss : e23.raws.selector.raw : e23.selector, e23.raws.between && e23.raws.between.trim().length > 0 && (r4 += e23.raws.between), e23.raws.selector = r4);
            let n3 = "";
            typeof e23.value == "string" && (n3 = e23.raws.value ? e23.raws.value.scss ? e23.raws.value.scss : e23.raws.value.raw : e23.value, n3 = n3.trim(), e23.raws.value = n3);
            let o3 = "";
            if (typeof e23.params == "string" && (o3 = e23.raws.params ? e23.raws.params.scss ? e23.raws.params.scss : e23.raws.params.raw : e23.params, e23.raws.afterName && e23.raws.afterName.trim().length > 0 && (o3 = e23.raws.afterName + o3), e23.raws.between && e23.raws.between.trim().length > 0 && (o3 += e23.raws.between), o3 = o3.trim(), e23.raws.params = o3), r4.trim().length > 0)
              return r4.startsWith("@") && r4.endsWith(":") ? e23 : e23.mixin ? (e23.selector = x2(r4, t5), e23) : (f2(e23) && (e23.isSCSSNesterProperty = true), e23.selector = A2(r4), e23);
            if (n3.length > 0) {
              const r5 = n3.match(O2);
              r5 && (n3 = n3.slice(0, r5.index), e23.scssDefault = true, r5[0].trim() !== "!default" && (e23.raws.scssDefault = r5[0]));
              const o4 = n3.match(_2);
              if (o4 && (n3 = n3.slice(0, o4.index), e23.scssGlobal = true, o4[0].trim() !== "!global" && (e23.raws.scssGlobal = o4[0])), n3.startsWith("progid:"))
                return {
                  type: "value-unknown",
                  value: n3
                };
              e23.value = x2(n3, t5);
            }
            if (c2(t5) && e23.type === "css-decl" && n3.startsWith("extend(") && (e23.extend || (e23.extend = e23.raws.between === ":"), e23.extend && !e23.selector && (delete e23.value, e23.selector = A2(n3.slice("extend(".length, -1)))), e23.type === "css-atrule") {
              if (c2(t5)) {
                if (e23.mixin) {
                  const t6 = e23.raws.identifier + e23.name + e23.raws.afterName + e23.raws.params;
                  return e23.selector = A2(t6), delete e23.params, e23;
                }
                if (e23.function)
                  return e23;
              }
              if (t5.parser === "css" && e23.name === "custom-selector") {
                const t6 = e23.params.match(/:--\S+?\s+/)[0].trim();
                return e23.customSelector = t6, e23.selector = A2(e23.params.slice(t6.length).trim()), delete e23.params, e23;
              }
              if (c2(t5)) {
                if (e23.name.includes(":") && !e23.params) {
                  e23.variable = true;
                  const r5 = e23.name.split(":");
                  e23.name = r5[0], e23.value = x2(r5.slice(1).join(":"), t5);
                }
                if (![
                  "page",
                  "nest",
                  "keyframes"
                ].includes(e23.name) && e23.params && e23.params[0] === ":" && (e23.variable = true, e23.value = x2(e23.params.slice(1), t5), e23.raws.afterName += ":"), e23.variable)
                  return delete e23.params, e23;
              }
            }
            if (e23.type === "css-atrule" && o3.length > 0) {
              const { name: r5 } = e23, n4 = e23.name.toLowerCase();
              return r5 === "warn" || r5 === "error" ? (e23.params = {
                type: "media-unknown",
                value: o3
              }, e23) : r5 === "extend" || r5 === "nest" ? (e23.selector = A2(o3), delete e23.params, e23) : r5 === "at-root" ? (/^\(\s*(?:without|with)\s*:.+\)$/s.test(o3) ? e23.params = x2(o3, t5) : (e23.selector = A2(o3), delete e23.params), e23) : d2(n4) ? (e23.import = true, delete e23.filename, e23.params = x2(o3, t5), e23) : [
                "namespace",
                "supports",
                "if",
                "else",
                "for",
                "each",
                "while",
                "debug",
                "mixin",
                "include",
                "function",
                "return",
                "define-mixin",
                "add-mixin"
              ].includes(r5) ? (o3 = o3.replace(/(\$\S+?)\s+?\.{3}/, "$1..."), o3 = o3.replace(/^(?!if)(\S+)\s+\(/, "$1("), e23.value = x2(o3, t5), delete e23.params, e23) : [
                "media",
                "custom-media"
              ].includes(n4) ? o3.includes("#{") ? {
                type: "media-unknown",
                value: o3
              } : (e23.params = k2(o3), e23) : (e23.params = o3, e23);
            }
          }
          return e23;
        }
        function T2(e23, t5, r4) {
          const o3 = i2(t5), { frontMatter: s3 } = o3;
          let u3;
          t5 = o3.content;
          try {
            u3 = e23(t5);
          } catch (e24) {
            const {
              name: t6,
              reason: r5,
              line: o4,
              column: i3
            } = e24;
            if (typeof o4 != "number")
              throw e24;
            throw n2(`${t6}: ${r5}`, {
              start: { line: o4, column: i3 }
            });
          }
          return u3 = S2(C2(u3, "css-"), r4), m2(u3, t5), s3 && (s3.source = {
            startOffset: 0,
            endOffset: s3.raw.length
          }, u3.nodes.unshift(s3)), u3;
        }
        function I2(e23, t5, n3) {
          const o3 = r3(7371);
          return T2((e24) => o3.parse(v2(e24)), e23, n3);
        }
        function N2(e23, t5, n3) {
          const { parse: o3 } = r3(304);
          return T2(o3, e23, n3);
        }
        const M2 = {
          astFormat: "postcss",
          hasPragma: s2,
          locStart: D2,
          locEnd: g2
        };
        e22.exports = {
          parsers: {
            css: Object.assign(Object.assign({}, M2), {}, {
              parse: function(e23, t5, r4) {
                const n3 = l2(r4.parser, e23) ? [N2, I2] : [I2, N2];
                let o3;
                for (const i3 of n3)
                  try {
                    return i3(e23, t5, r4);
                  } catch (e24) {
                    o3 = o3 || e24;
                  }
                if (o3)
                  throw o3;
              }
            }),
            less: Object.assign(Object.assign({}, M2), {}, { parse: I2 }),
            scss: Object.assign(Object.assign({}, M2), {}, { parse: N2 })
          }
        };
      },
      8850: (e22, t4, r3) => {
        const n2 = r3(3831), o2 = r3(5115);
        e22.exports = {
          hasPragma: function(e23) {
            return n2.hasPragma(o2(e23).content);
          },
          insertPragma: function(e23) {
            const { frontMatter: t5, content: r4 } = o2(e23);
            return (t5 ? t5.raw + "\n\n" : "") + n2.insertPragma(r4);
          }
        };
      },
      5244: (e22, t4, r3) => {
        const { isNonEmptyArray: n2 } = r3(9428), o2 = new Set([
          "red",
          "green",
          "blue",
          "alpha",
          "a",
          "rgb",
          "hue",
          "h",
          "saturation",
          "s",
          "lightness",
          "l",
          "whiteness",
          "w",
          "blackness",
          "b",
          "tint",
          "shade",
          "blend",
          "blenda",
          "contrast",
          "hsl",
          "hsla",
          "hwb",
          "hwba"
        ]), i2 = new Set(["import", "use", "forward"]);
        function s2(e23, t5) {
          const r4 = Array.isArray(t5) ? t5 : [t5];
          let n3, o3 = -1;
          for (; n3 = e23.getParentNode(++o3); )
            if (r4.includes(n3.type))
              return o3;
          return -1;
        }
        function u2(e23, t5) {
          const r4 = s2(e23, t5);
          return r4 === -1 ? null : e23.getParentNode(r4);
        }
        function a2(e23) {
          return e23.type === "value-operator" && e23.value === "*";
        }
        function c2(e23) {
          return e23.type === "value-operator" && e23.value === "/";
        }
        function l2(e23) {
          return e23.type === "value-operator" && e23.value === "+";
        }
        function f2(e23) {
          return e23.type === "value-operator" && e23.value === "-";
        }
        function p2(e23) {
          return e23.type === "value-operator" && e23.value === "%";
        }
        function h2(e23) {
          return e23.type === "value-comma_group" && e23.groups && e23.groups[1] && e23.groups[1].type === "value-colon";
        }
        function d2(e23) {
          return e23.type === "value-paren_group" && e23.groups && e23.groups[0] && h2(e23.groups[0]);
        }
        function D2(e23) {
          return e23 && e23.type === "value-colon";
        }
        e22.exports = {
          getAncestorCounter: s2,
          getAncestorNode: u2,
          getPropOfDeclNode: function(e23) {
            const t5 = u2(e23, "css-decl");
            return t5 && t5.prop && t5.prop.toLowerCase();
          },
          hasSCSSInterpolation: function(e23) {
            if (n2(e23)) {
              for (let t5 = e23.length - 1; t5 > 0; t5--)
                if (e23[t5].type === "word" && e23[t5].value === "{" && e23[t5 - 1].type === "word" && e23[t5 - 1].value.endsWith("#"))
                  return true;
            }
            return false;
          },
          hasStringOrFunction: function(e23) {
            if (n2(e23)) {
              for (let t5 = 0; t5 < e23.length; t5++)
                if (e23[t5].type === "string" || e23[t5].type === "func")
                  return true;
            }
            return false;
          },
          maybeToLowerCase: function(e23) {
            return e23.includes("$") || e23.includes("@") || e23.includes("#") || e23.startsWith("%") || e23.startsWith("--") || e23.startsWith(":--") || e23.includes("(") && e23.includes(")") ? e23 : e23.toLowerCase();
          },
          insideValueFunctionNode: function(e23, t5) {
            const r4 = u2(e23, "value-func");
            return r4 && r4.value && r4.value.toLowerCase() === t5;
          },
          insideICSSRuleNode: function(e23) {
            const t5 = u2(e23, "css-rule");
            return t5 && t5.raws && t5.raws.selector && (t5.raws.selector.startsWith(":import") || t5.raws.selector.startsWith(":export"));
          },
          insideAtRuleNode: function(e23, t5) {
            const r4 = Array.isArray(t5) ? t5 : [t5], n3 = u2(e23, "css-atrule");
            return n3 && r4.includes(n3.name.toLowerCase());
          },
          insideURLFunctionInImportAtRuleNode: function(e23) {
            const t5 = e23.getValue(), r4 = u2(e23, "css-atrule");
            return r4 && r4.name === "import" && t5.groups[0].value === "url" && t5.groups.length === 2;
          },
          isKeyframeAtRuleKeywords: function(e23, t5) {
            const r4 = u2(e23, "css-atrule");
            return r4 && r4.name && r4.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(t5.toLowerCase());
          },
          isWideKeywords: function(e23) {
            return [
              "initial",
              "inherit",
              "unset",
              "revert"
            ].includes(e23.toLowerCase());
          },
          isSCSS: function(e23, t5) {
            return e23 === "less" || e23 === "scss" ? e23 === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(t5);
          },
          isSCSSVariable: function(e23) {
            return Boolean(e23 && e23.type === "word" && e23.value.startsWith("$"));
          },
          isLastNode: function(e23, t5) {
            const r4 = e23.getParentNode();
            if (!r4)
              return false;
            const { nodes: n3 } = r4;
            return n3 && n3.indexOf(t5) === n3.length - 1;
          },
          isLessParser: function(e23) {
            return e23.parser === "css" || e23.parser === "less";
          },
          isSCSSControlDirectiveNode: function(e23) {
            return e23.type === "css-atrule" && [
              "if",
              "else",
              "for",
              "each",
              "while"
            ].includes(e23.name);
          },
          isDetachedRulesetDeclarationNode: function(e23) {
            return !!e23.selector && (typeof e23.selector == "string" && /^@.+:.*$/.test(e23.selector) || e23.selector.value && /^@.+:.*$/.test(e23.selector.value));
          },
          isRelationalOperatorNode: function(e23) {
            return e23.type === "value-word" && ["<", ">", "<=", ">="].includes(e23.value);
          },
          isEqualityOperatorNode: function(e23) {
            return e23.type === "value-word" && ["==", "!="].includes(e23.value);
          },
          isMultiplicationNode: a2,
          isDivisionNode: c2,
          isAdditionNode: l2,
          isSubtractionNode: f2,
          isModuloNode: p2,
          isMathOperatorNode: function(e23) {
            return a2(e23) || c2(e23) || l2(e23) || f2(e23) || p2(e23);
          },
          isEachKeywordNode: function(e23) {
            return e23.type === "value-word" && e23.value === "in";
          },
          isForKeywordNode: function(e23) {
            return e23.type === "value-word" && ["from", "through", "end"].includes(e23.value);
          },
          isURLFunctionNode: function(e23) {
            return e23.type === "value-func" && e23.value.toLowerCase() === "url";
          },
          isIfElseKeywordNode: function(e23) {
            return e23.type === "value-word" && ["and", "or", "not"].includes(e23.value);
          },
          hasComposesNode: function(e23) {
            return e23.value && e23.value.type === "value-root" && e23.value.group && e23.value.group.type === "value-value" && e23.prop.toLowerCase() === "composes";
          },
          hasParensAroundNode: function(e23) {
            return e23.value && e23.value.group && e23.value.group.group && e23.value.group.group.type === "value-paren_group" && e23.value.group.group.open !== null && e23.value.group.group.close !== null;
          },
          hasEmptyRawBefore: function(e23) {
            return e23.raws && e23.raws.before === "";
          },
          isSCSSNestedPropertyNode: function(e23) {
            return !!e23.selector && e23.selector.replace(/\/\*.*?\*\//, "").replace(/\/\/.*?\n/, "").trim().endsWith(":");
          },
          isDetachedRulesetCallNode: function(e23) {
            return e23.raws && e23.raws.params && /^\(\s*\)$/.test(e23.raws.params);
          },
          isTemplatePlaceholderNode: function(e23) {
            return e23.name.startsWith("prettier-placeholder");
          },
          isTemplatePropNode: function(e23) {
            return e23.prop.startsWith("@prettier-placeholder");
          },
          isPostcssSimpleVarNode: function(e23, t5) {
            return e23.value === "$$" && e23.type === "value-func" && t5 && t5.type === "value-word" && !t5.raws.before;
          },
          isKeyValuePairNode: h2,
          isKeyValuePairInParenGroupNode: d2,
          isKeyInValuePairNode: function(e23, t5) {
            if (!h2(t5))
              return false;
            const { groups: r4 } = t5, n3 = r4.indexOf(e23);
            return n3 !== -1 && D2(r4[n3 + 1]);
          },
          isSCSSMapItemNode: function(e23) {
            const t5 = e23.getValue();
            if (t5.groups.length === 0)
              return false;
            const r4 = e23.getParentNode(1);
            if (!(d2(t5) || r4 && d2(r4)))
              return false;
            const n3 = u2(e23, "css-decl");
            return !!(n3 && n3.prop && n3.prop.startsWith("$")) || !!d2(r4) || r4.type === "value-func";
          },
          isInlineValueCommentNode: function(e23) {
            return e23.type === "value-comment" && e23.inline;
          },
          isHashNode: function(e23) {
            return e23.type === "value-word" && e23.value === "#";
          },
          isLeftCurlyBraceNode: function(e23) {
            return e23.type === "value-word" && e23.value === "{";
          },
          isRightCurlyBraceNode: function(e23) {
            return e23.type === "value-word" && e23.value === "}";
          },
          isWordNode: function(e23) {
            return [
              "value-word",
              "value-atword"
            ].includes(e23.type);
          },
          isColonNode: D2,
          isMediaAndSupportsKeywords: function(e23) {
            return e23.value && ["not", "and", "or"].includes(e23.value.toLowerCase());
          },
          isColorAdjusterFuncNode: function(e23) {
            return e23.type === "value-func" && o2.has(e23.value.toLowerCase());
          },
          lastLineHasInlineComment: function(e23) {
            return /\/\//.test(e23.split(/[\n\r]/).pop());
          },
          stringifyNode: function e23(t5) {
            if (t5.groups)
              return (t5.open && t5.open.value ? t5.open.value : "") + t5.groups.reduce((r5, n4, o3) => r5 + e23(n4) + (t5.groups[0].type === "comma_group" && o3 !== t5.groups.length - 1 ? "," : ""), "") + (t5.close && t5.close.value ? t5.close.value : "");
            const r4 = t5.raws && t5.raws.before ? t5.raws.before : "", n3 = t5.raws && t5.raws.quote ? t5.raws.quote : "";
            return r4 + n3 + (t5.type === "atword" ? "@" : "") + (t5.value ? t5.value : "") + n3 + (t5.unit ? t5.unit : "") + (t5.group ? e23(t5.group) : "") + (t5.raws && t5.raws.after ? t5.raws.after : "");
          },
          isAtWordPlaceholderNode: function(e23) {
            return e23 && e23.type === "value-atword" && e23.value.startsWith("prettier-placeholder-");
          },
          isModuleRuleName: function(e23) {
            return i2.has(e23);
          }
        };
      },
      3831: (e22, t4, r3) => {
        const {
          parseWithComments: n2,
          strip: o2,
          extract: i2,
          print: s2
        } = r3(9234), { getShebang: u2 } = r3(9428), { normalizeEndOfLine: a2 } = r3(7933);
        function c2(e23) {
          const t5 = u2(e23);
          t5 && (e23 = e23.slice(t5.length + 1));
          const r4 = i2(e23), { pragmas: o3, comments: s3 } = n2(r4);
          return {
            shebang: t5,
            text: e23,
            pragmas: o3,
            comments: s3
          };
        }
        e22.exports = {
          hasPragma: function(e23) {
            const t5 = Object.keys(c2(e23).pragmas);
            return t5.includes("prettier") || t5.includes("format");
          },
          insertPragma: function(e23) {
            const {
              shebang: t5,
              text: r4,
              pragmas: n3,
              comments: i3
            } = c2(e23), u3 = o2(r4), l2 = s2({
              pragmas: Object.assign({ format: "" }, n3),
              comments: i3.trimStart()
            });
            return (t5 ? `${t5}
` : "") + a2(l2) + (u3.startsWith("\n") ? "\n" : "\n\n") + u3;
          }
        };
      },
      8988: (e22, t4, r3) => {
        const { outdent: n2 } = r3(5311), o2 = "Config", i2 = "Editor", s2 = "Other", u2 = "Global", a2 = "Special", c2 = {
          cursorOffset: {
            since: "1.4.0",
            category: a2,
            type: "int",
            default: -1,
            range: {
              start: -1,
              end: Number.POSITIVE_INFINITY,
              step: 1
            },
            description: n2`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `,
            cliCategory: i2
          },
          endOfLine: {
            since: "1.15.0",
            category: u2,
            type: "choice",
            default: [
              { since: "1.15.0", value: "auto" },
              { since: "2.0.0", value: "lf" }
            ],
            description: "Which end of line characters to apply.",
            choices: [
              {
                value: "lf",
                description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos"
              },
              {
                value: "crlf",
                description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows"
              },
              {
                value: "cr",
                description: "Carriage Return character only (\\r), used very rarely"
              },
              {
                value: "auto",
                description: n2`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        `
              }
            ]
          },
          filepath: {
            since: "1.4.0",
            category: a2,
            type: "path",
            description: "Specify the input filepath. This will be used to do parser inference.",
            cliName: "stdin-filepath",
            cliCategory: s2,
            cliDescription: "Path to the file to pretend that stdin comes from."
          },
          insertPragma: {
            since: "1.8.0",
            category: a2,
            type: "boolean",
            default: false,
            description: "Insert @format pragma into file's first docblock comment.",
            cliCategory: s2
          },
          parser: {
            since: "0.0.10",
            category: u2,
            type: "choice",
            default: [
              {
                since: "0.0.10",
                value: "babylon"
              },
              { since: "1.13.0", value: void 0 }
            ],
            description: "Which parser to use.",
            exception: (e23) => typeof e23 == "string" || typeof e23 == "function",
            choices: [
              {
                value: "flow",
                description: "Flow"
              },
              {
                value: "babel",
                since: "1.16.0",
                description: "JavaScript"
              },
              {
                value: "babel-flow",
                since: "1.16.0",
                description: "Flow"
              },
              {
                value: "babel-ts",
                since: "2.0.0",
                description: "TypeScript"
              },
              {
                value: "typescript",
                since: "1.4.0",
                description: "TypeScript"
              },
              {
                value: "espree",
                since: "2.2.0",
                description: "JavaScript"
              },
              {
                value: "meriyah",
                since: "2.2.0",
                description: "JavaScript"
              },
              {
                value: "css",
                since: "1.7.1",
                description: "CSS"
              },
              {
                value: "less",
                since: "1.7.1",
                description: "Less"
              },
              {
                value: "scss",
                since: "1.7.1",
                description: "SCSS"
              },
              {
                value: "json",
                since: "1.5.0",
                description: "JSON"
              },
              {
                value: "json5",
                since: "1.13.0",
                description: "JSON5"
              },
              {
                value: "json-stringify",
                since: "1.13.0",
                description: "JSON.stringify"
              },
              {
                value: "graphql",
                since: "1.5.0",
                description: "GraphQL"
              },
              {
                value: "markdown",
                since: "1.8.0",
                description: "Markdown"
              },
              {
                value: "mdx",
                since: "1.15.0",
                description: "MDX"
              },
              {
                value: "vue",
                since: "1.10.0",
                description: "Vue"
              },
              {
                value: "yaml",
                since: "1.14.0",
                description: "YAML"
              },
              {
                value: "glimmer",
                since: "2.3.0",
                description: "Ember / Handlebars"
              },
              {
                value: "html",
                since: "1.15.0",
                description: "HTML"
              },
              {
                value: "angular",
                since: "1.15.0",
                description: "Angular"
              },
              {
                value: "lwc",
                since: "1.17.0",
                description: "Lightning Web Components"
              }
            ]
          },
          plugins: {
            since: "1.10.0",
            type: "path",
            array: true,
            default: [{ value: [] }],
            category: u2,
            description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.",
            exception: (e23) => typeof e23 == "string" || typeof e23 == "object",
            cliName: "plugin",
            cliCategory: o2
          },
          pluginSearchDirs: {
            since: "1.13.0",
            type: "path",
            array: true,
            default: [{ value: [] }],
            category: u2,
            description: n2`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `,
            exception: (e23) => typeof e23 == "string" || typeof e23 == "object",
            cliName: "plugin-search-dir",
            cliCategory: o2
          },
          printWidth: {
            since: "0.0.0",
            category: u2,
            type: "int",
            default: 80,
            description: "The line length where Prettier will try wrap.",
            range: {
              start: 0,
              end: Number.POSITIVE_INFINITY,
              step: 1
            }
          },
          rangeEnd: {
            since: "1.4.0",
            category: a2,
            type: "int",
            default: Number.POSITIVE_INFINITY,
            range: {
              start: 0,
              end: Number.POSITIVE_INFINITY,
              step: 1
            },
            description: n2`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `,
            cliCategory: i2
          },
          rangeStart: {
            since: "1.4.0",
            category: a2,
            type: "int",
            default: 0,
            range: {
              start: 0,
              end: Number.POSITIVE_INFINITY,
              step: 1
            },
            description: n2`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `,
            cliCategory: i2
          },
          requirePragma: {
            since: "1.7.0",
            category: a2,
            type: "boolean",
            default: false,
            description: n2`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `,
            cliCategory: s2
          },
          tabWidth: {
            type: "int",
            category: u2,
            default: 2,
            description: "Number of spaces per indentation level.",
            range: {
              start: 0,
              end: Number.POSITIVE_INFINITY,
              step: 1
            }
          },
          useTabs: {
            since: "1.0.0",
            category: u2,
            type: "boolean",
            default: false,
            description: "Indent with tabs instead of spaces."
          },
          embeddedLanguageFormatting: {
            since: "2.1.0",
            category: u2,
            type: "choice",
            default: [
              { since: "2.1.0", value: "auto" }
            ],
            description: "Control how Prettier formats quoted code embedded in the file.",
            choices: [
              {
                value: "auto",
                description: "Format embedded code if Prettier can automatically identify it."
              },
              {
                value: "off",
                description: "Never automatically format embedded code."
              }
            ]
          }
        };
        e22.exports = {
          CATEGORY_CONFIG: o2,
          CATEGORY_EDITOR: i2,
          CATEGORY_FORMAT: "Format",
          CATEGORY_OTHER: s2,
          CATEGORY_OUTPUT: "Output",
          CATEGORY_GLOBAL: u2,
          CATEGORY_SPECIAL: a2,
          options: c2
        };
      },
      7290: (e22, t4, r3) => {
        const n2 = [
          "cliName",
          "cliCategory",
          "cliDescription"
        ];
        function o2(e23, t5) {
          if (e23 == null)
            return {};
          var r4, n3, o3 = function(e24, t6) {
            if (e24 == null)
              return {};
            var r5, n4, o4 = {}, i4 = Object.keys(e24);
            for (n4 = 0; n4 < i4.length; n4++)
              r5 = i4[n4], t6.indexOf(r5) >= 0 || (o4[r5] = e24[r5]);
            return o4;
          }(e23, t5);
          if (Object.getOwnPropertySymbols) {
            var i3 = Object.getOwnPropertySymbols(e23);
            for (n3 = 0; n3 < i3.length; n3++)
              r4 = i3[n3], t5.indexOf(r4) >= 0 || Object.prototype.propertyIsEnumerable.call(e23, r4) && (o3[r4] = e23[r4]);
          }
          return o3;
        }
        r3(4304), r3(4070), r3(2612);
        const i2 = {
          compare: r3(2828),
          lt: r3(3725),
          gte: r3(9195)
        }, s2 = r3(9077), u2 = r3(4147).i8, a2 = r3(8988).options;
        e22.exports = {
          getSupportInfo: function({
            plugins: e23 = [],
            showUnreleased: t5 = false,
            showDeprecated: r4 = false,
            showInternal: c2 = false
          } = {}) {
            const l2 = u2.split("-", 1)[0], f2 = e23.flatMap((e24) => e24.languages || []).filter(h2), p2 = s2(Object.assign({}, ...e23.map(({ options: e24 }) => e24), a2), "name").filter((e24) => h2(e24) && d2(e24)).sort((e24, t6) => e24.name === t6.name ? 0 : e24.name < t6.name ? -1 : 1).map(function(e24) {
              return c2 ? e24 : o2(e24, n2);
            }).map((t6) => {
              t6 = Object.assign({}, t6), Array.isArray(t6.default) && (t6.default = t6.default.length === 1 ? t6.default[0].value : t6.default.filter(h2).sort((e24, t7) => i2.compare(t7.since, e24.since))[0].value), Array.isArray(t6.choices) && (t6.choices = t6.choices.filter((e24) => h2(e24) && d2(e24)), t6.name === "parser" && function(e24, t7, r6) {
                const n3 = new Set(e24.choices.map((e25) => e25.value));
                for (const o3 of t7)
                  if (o3.parsers) {
                    for (const t8 of o3.parsers)
                      if (!n3.has(t8)) {
                        n3.add(t8);
                        const i3 = r6.find((e25) => e25.parsers && e25.parsers[t8]);
                        let s3 = o3.name;
                        i3 && i3.name && (s3 += ` (plugin: ${i3.name})`), e24.choices.push({
                          value: t8,
                          description: s3
                        });
                      }
                  }
              }(t6, f2, e23));
              const r5 = Object.fromEntries(e23.filter((e24) => e24.defaultOptions && e24.defaultOptions[t6.name] !== void 0).map((e24) => [
                e24.name,
                e24.defaultOptions[t6.name]
              ]));
              return Object.assign(Object.assign({}, t6), {}, { pluginDefaults: r5 });
            });
            return { languages: f2, options: p2 };
            function h2(e24) {
              return t5 || !("since" in e24) || e24.since && i2.gte(l2, e24.since);
            }
            function d2(e24) {
              return r4 || !("deprecated" in e24) || e24.deprecated && i2.lt(l2, e24.deprecated);
            }
          }
        };
      },
      9077: (e22) => {
        e22.exports = (e23, t4) => Object.entries(e23).map(([e24, r3]) => Object.assign({ [t4]: e24 }, r3));
      },
      5115: (e22) => {
        const t4 = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
        e22.exports = function(e23) {
          const r3 = e23.match(t4);
          if (!r3)
            return { content: e23 };
          const {
            startDelimiter: n2,
            language: o2,
            value: i2 = "",
            endDelimiter: s2
          } = r3.groups;
          let u2 = o2.trim() || "yaml";
          if (n2 === "+++" && (u2 = "toml"), u2 !== "yaml" && n2 !== s2)
            return { content: e23 };
          const [a2] = r3;
          return {
            frontMatter: {
              type: "front-matter",
              lang: u2,
              value: i2,
              startDelimiter: n2,
              endDelimiter: s2,
              raw: a2.replace(/\n$/, "")
            },
            content: a2.replace(/[^\n]/g, " ") + e23.slice(a2.length)
          };
        };
      },
      4652: (e22) => {
        e22.exports = (e23) => e23[e23.length - 1];
      },
      6920: (e22) => {
        e22.exports = function(e23, t4) {
          let r3 = 0;
          for (let n2 = 0; n2 < e23.line - 1; ++n2)
            r3 = t4.indexOf("\n", r3) + 1;
          return r3 + e23.column;
        };
      },
      8472: () => {
      },
      2868: () => {
      },
      3248: () => {
      },
      6083: () => {
      },
      4940: (e22, t4, r3) => {
        r3.r(t4), r3.d(t4, {
          existsSync: () => n2,
          readFileSync: () => o2,
          default: () => i2
        });
        const n2 = () => false, o2 = () => "", i2 = { existsSync: n2, readFileSync: o2 };
      },
      4372: (e22, t4, r3) => {
        r3.r(t4), r3.d(t4, { default: () => n2 });
        const n2 = {
          EOL: "\n",
          platform: () => "browser",
          cpus: () => [{ model: "Prettier" }]
        };
      },
      3974: (e22, t4, r3) => {
        r3.r(t4), r3.d(t4, { default: () => n2 });
        var n2 = r3(5724), o2 = {};
        for (const e23 in n2)
          e23 !== "default" && (o2[e23] = () => n2[e23]);
        r3.d(t4, o2);
      },
      4147: (e22) => {
        e22.exports = { i8: "2.4.1" };
      }
    }, t3 = {};
    function r2(n2) {
      var o2 = t3[n2];
      if (o2 !== void 0)
        return o2.exports;
      var i2 = t3[n2] = { id: n2, loaded: false, exports: {} };
      return e21[n2](i2, i2.exports, r2), i2.loaded = true, i2.exports;
    }
    return r2.d = (e22, t4) => {
      for (var n2 in t4)
        r2.o(t4, n2) && !r2.o(e22, n2) && Object.defineProperty(e22, n2, {
          enumerable: true,
          get: t4[n2]
        });
    }, r2.g = function() {
      if (typeof globalThis == "object")
        return globalThis;
      try {
        return this || new Function("return this")();
      } catch (e22) {
        if (typeof window == "object")
          return window;
      }
    }(), r2.hmd = (e22) => ((e22 = Object.create(e22)).children || (e22.children = []), Object.defineProperty(e22, "exports", {
      enumerable: true,
      set: () => {
        throw new Error("ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: " + e22.id);
      }
    }), e22), r2.o = (e22, t4) => Object.prototype.hasOwnProperty.call(e22, t4), r2.r = (e22) => {
      typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(e22, Symbol.toStringTag, {
        value: "Module"
      }), Object.defineProperty(e22, "__esModule", {
        value: true
      });
    }, r2(738);
  })();
}));
var __decorate$3 = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d2 = decorators[i2])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __awaiter$b = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e20) {
        reject(e20);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e20) {
        reject(e20);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
define$e();
class SCodeExample extends SLitComponent {
  constructor() {
    var _a2;
    super(__deepMerge$5({
      componentUtils: {
        interface: SCodeExampleInterface
      }
    }));
    this._$copy = void 0;
    this._items = [];
    this._activeTabId = void 0;
    const languages = Object.assign({
      html: xml,
      javascript,
      js: javascript,
      php,
      bash,
      shell: bash,
      css
    }, (_a2 = this.props.languages) !== null && _a2 !== void 0 ? _a2 : {});
    Object.keys(languages).forEach((lang2) => {
      core.registerLanguage(lang2, languages[lang2]);
    });
  }
  static get properties() {
    return SLitComponent.properties({}, SCodeExampleInterface);
  }
  static get styles() {
    return css$1`
            ${unsafeCSS(__css$6)}
        `;
  }
  firstUpdated() {
    var _a2, _b2, _c2;
    return __awaiter$b(this, void 0, void 0, function* () {
      this.$templates.forEach(($template) => {
        var _a3, _b3, _c3, _d2, _e2, _f3, _g2;
        if (!$template.getAttribute)
          return;
        let parser = "babel";
        switch ((_b3 = (_a3 = $template.getAttribute("id")) !== null && _a3 !== void 0 ? _a3 : $template.getAttribute("language")) !== null && _b3 !== void 0 ? _b3 : $template.getAttribute("lang")) {
          case "html":
          case "xml":
            parser = "html";
            break;
          case "css":
          case "postcss":
            parser = "postcss";
            break;
        }
        let rawCode = decodeHtmlEntities($template.tagName.toLowerCase() === "textarea" && $template.value ? $template.value : $template.innerHTML);
        let formatedCode = rawCode;
        try {
          formatedCode = VV.format(rawCode, {
            parser,
            plugins: [Ot, Bo, Uu]
          });
        } catch (e20) {
        }
        this._items = [
          ...this._items,
          {
            id: (_e2 = (_d2 = (_c3 = $template.getAttribute("id")) !== null && _c3 !== void 0 ? _c3 : $template.getAttribute("language")) !== null && _d2 !== void 0 ? _d2 : $template.getAttribute("lang")) !== null && _e2 !== void 0 ? _e2 : "html",
            lang: (_g2 = (_f3 = $template.getAttribute("language")) !== null && _f3 !== void 0 ? _f3 : $template.getAttribute("lang")) !== null && _g2 !== void 0 ? _g2 : "html",
            code: formatedCode
          }
        ];
        $template.remove();
      });
      if (this.active) {
        this.setActiveTab(this.active);
      } else {
        if (this._items[0]) {
          this.setActiveTab(this._items[0].id);
        }
      }
      yield wait(500);
      this._$content = (_a2 = this.shadowRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector(".s-code-example__content");
      this._$pre = (_b2 = this.shadowRoot) === null || _b2 === void 0 ? void 0 : _b2.querySelector(".s-code-example__code");
      this._$root = (_c2 = this.shadowRoot) === null || _c2 === void 0 ? void 0 : _c2.querySelector(".s-code-example");
      return true;
    });
  }
  setActiveTabByTab(e20) {
    this.setActiveTab(e20.target.id);
  }
  setActiveTab(id2) {
    return __awaiter$b(this, void 0, void 0, function* () {
      yield wait();
      this._activeTabId = id2;
      this.initPrismOnTab(id2);
    });
  }
  setMoreClass() {
    return __awaiter$b(this, void 0, void 0, function* () {
      yield wait(500);
      if (this._more) {
        this._$root.classList.add("s-code-example--more");
      } else {
        this._$root.classList.remove("s-code-example--more");
      }
    });
  }
  toggleMore() {
    this._more = !this._more;
    this.setMoreClass();
  }
  initPrismOnTab(id2) {
    var _a2;
    const $content = (_a2 = this.shadowRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector(`pre#${id2} code`);
    if ($content.hasAttribute("inited")) {
      this.setMoreClass();
      return;
    }
    $content.setAttribute("inited", "true");
    core.highlightElement($content);
    this.setMoreClass();
  }
  copy() {
    const id2 = this._activeTabId;
    const item = this._items.filter((i2) => i2.id === id2)[0];
    this.$copy.copy(item.code);
  }
  render() {
    var _a2, _b2, _c2, _d2, _e2, _f3, _g2;
    return html$2`
            <div
                class="${this.componentUtils.className()} ${this.props.more ? this.componentUtils.className("more") : ""}"
                ?lines="${this.lines}"
                ?mounted="${this.mounted}"
                ?bare="${this.bare}"
                toolbar-position="${this.toolbarPosition}"
            >
                <div class="templates">
                    <slot></slot>
                </div>

                <header class="${this.componentUtils.className("__nav")}">
                    <ol class="${this.componentUtils.className("__tabs", "s-tabs")}">
                        ${((_a2 = this._items) !== null && _a2 !== void 0 ? _a2 : []).map((item) => html$2`
                                <li
                                    class="${this.componentUtils.className("__tab")}"
                                    id="${item.id}"
                                    ?active="${this._activeTabId === item.id}"
                                    @click="${this.setActiveTabByTab}"
                                >
                                    ${item.lang}
                                </li>
                            `)}
                    </ol>
                    ${this.toolbarPosition === "nav" ? html$2`
                                  <div
                                      class="${this.componentUtils.className("__toolbar")}"
                                  >
                                      <s-clipboard-copy
                                          @click="${this.copy}"
                                      ></s-clipboard-copy>
                                  </div>
                              ` : ""}
                </header>
                <div
                    class="${this.componentUtils.className("__content")}"
                    style="--max-lines: ${(_b2 = this.props.lines) !== null && _b2 !== void 0 ? _b2 : 99999999};"
                >
                    ${this.toolbarPosition !== "nav" ? html$2`
                                  <div
                                      class="${this.componentUtils.className("__toolbar")}"
                                  >
                                      <s-clipboard-copy
                                          @click="${this.copy}"
                                      ></s-clipboard-copy>
                                  </div>
                              ` : ""}
                    ${((_c2 = this._items) !== null && _c2 !== void 0 ? _c2 : []).map((item) => {
      var _a3, _b3, _c3;
      return html$2`
                            <pre
                                class="${this.componentUtils.className("__code")}"
                                style="line-height:0;"
                                id="${(_a3 = item.id) !== null && _a3 !== void 0 ? _a3 : item.lang}"
                                ?active="${this._activeTabId === ((_b3 = item.id) !== null && _b3 !== void 0 ? _b3 : item.lang)}"
                            >
                            <code lang="${(_c3 = item.lang) !== null && _c3 !== void 0 ? _c3 : item.id}" class="language-${item.lang} ${item.lang} ${this.props.bare ? "" : "hljs"}">${item.code.trim()}</code>
                        </pre>
                        `;
    })}
                    <div class="${this.componentUtils.className("__more-bar")}">
                        ${this._moreAction === "toggle" ? html$2`
                                      <a
                                          class="${this.componentUtils.className("__more-button", "s-btn")}"
                                          @click="${this.toggleMore}"
                                      >
                                          ${this._more ? html$2`
                                                        ${(_d2 = this.props.lessLabel) !== null && _d2 !== void 0 ? _d2 : "Show less"}
                                                    ` : html$2`
                                                        ${(_e2 = this.props.moreLabel) !== null && _e2 !== void 0 ? _e2 : "Show more"}
                                                    `}
                                      </a>
                                  ` : html$2`
                                      <a
                                          class="${this.componentUtils.className("__more-button", "s-btn s-color--accent")}"
                                          href="${this._moreAction}"
                                      >
                                          ${this._more ? html$2`
                                                        ${(_f3 = this.props.lessLabel) !== null && _f3 !== void 0 ? _f3 : "Show less"}
                                                    ` : html$2`
                                                        ${(_g2 = this.props.moreLabel) !== null && _g2 !== void 0 ? _g2 : "Show more"}
                                                    `}
                                      </a>
                                  `}                        
                        </a>
                    </div>
                </div>
            </div>
        `;
  }
}
__decorate$3([property$1()], SCodeExample.prototype, "_items", void 0);
__decorate$3([property$1()], SCodeExample.prototype, "_activeTabId", void 0);
__decorate$3([
  property$1({
    type: String
  })
], SCodeExample.prototype, "active", void 0);
__decorate$3([property$1()], SCodeExample.prototype, "props", void 0);
__decorate$3([query("s-clipboard-copy")], SCodeExample.prototype, "$copy", void 0);
__decorate$3([query(".templates")], SCodeExample.prototype, "$templatesContainer", void 0);
__decorate$3([queryAssignedNodes()], SCodeExample.prototype, "$templates", void 0);
function define$d(props = {}, tagName = "s-code-example") {
  SLitComponent.setDefaultProps(tagName, props);
  customElements.define(tagName, SCodeExample);
}
function plainObject$4(object) {
  if (!object)
    return false;
  if (typeof object !== "object")
    return false;
  if (object.constructor && object.constructor.name !== "Object")
    return false;
  if (Object.prototype.toString.call(object) !== "[object Object]")
    return false;
  if (object !== Object(object))
    return false;
  return true;
}
function __deepMerge$4(...args) {
  function merge2(firstObj, secondObj) {
    const newObj = {};
    if (!firstObj && secondObj)
      return secondObj;
    if (!secondObj && firstObj)
      return firstObj;
    if (!firstObj && !secondObj)
      return {};
    const firstProps = Object.getOwnPropertyNames(firstObj);
    firstProps.forEach((key) => {
      const desc = Object.getOwnPropertyDescriptor(firstObj, key);
      if (desc.set || desc.get) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = firstObj[key];
      }
    });
    const secondProps = Object.getOwnPropertyNames(secondObj);
    secondProps.forEach((key) => {
      const desc = Object.getOwnPropertyDescriptor(secondObj, key);
      if (desc.set || desc.get) {
        Object.defineProperty(newObj, key, desc);
      } else if (plainObject$4(newObj[key]) && plainObject$4(secondObj[key])) {
        newObj[key] = merge2(newObj[key], secondObj[key]);
      } else {
        newObj[key] = secondObj[key];
      }
    });
    return newObj;
  }
  let currentObj = {};
  for (let i2 = 0; i2 < args.length; i2++) {
    const toMergeObj = args[i2];
    currentObj = merge2(currentObj, toMergeObj);
  }
  return currentObj;
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const standardProperty = (options, element) => {
  if (element.kind === "method" && element.descriptor && !("value" in element.descriptor)) {
    return __spreadProps(__spreadValues({}, element), {
      finisher(clazz) {
        clazz.createProperty(element.key, options);
      }
    });
  } else {
    return {
      kind: "field",
      key: Symbol(),
      placement: "own",
      descriptor: {},
      originalKey: element.key,
      initializer() {
        if (typeof element.initializer === "function") {
          this[element.key] = element.initializer.call(this);
        }
      },
      finisher(clazz) {
        clazz.createProperty(element.key, options);
      }
    };
  }
};
const legacyProperty = (options, proto2, name2) => {
  proto2.constructor.createProperty(name2, options);
};
function property(options) {
  return (protoOrDescriptor, name2) => name2 !== void 0 ? legacyProperty(options, protoOrDescriptor, name2) : standardProperty(options, protoOrDescriptor);
}
class SSidePanelComponentInterface extends SInterface {
}
SSidePanelComponentInterface.definition = {
  side: {
    type: "String",
    values: ["top", "left", "bottom", "right"],
    default: "left"
  },
  active: {
    type: "Boolean",
    default: false
  },
  overlay: {
    type: "Boolean",
    default: false
  },
  triggerer: {
    type: "String"
  },
  closeOn: {
    type: {
      type: "Array<String>",
      splitChars: [","]
    },
    values: ["click", "escape"],
    default: ["click", "escape"]
  }
};
/*!
* hotkeys-js v3.8.5
* A simple micro-library for defining and dispatching keyboard shortcuts. It has no dependencies.
* 
* Copyright (c) 2021 kenny wong <wowohoo@qq.com>
* http://jaywcjlove.github.io/hotkeys
* 
* Licensed under the MIT license.
*/
var isff$1 = typeof navigator !== "undefined" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : false;
function addEvent$1(object, event, method) {
  if (object.addEventListener) {
    object.addEventListener(event, method, false);
  } else if (object.attachEvent) {
    object.attachEvent("on".concat(event), function() {
      method(window.event);
    });
  }
}
function getMods$1(modifier, key) {
  var mods = key.slice(0, key.length - 1);
  for (var i2 = 0; i2 < mods.length; i2++) {
    mods[i2] = modifier[mods[i2].toLowerCase()];
  }
  return mods;
}
function getKeys$1(key) {
  if (typeof key !== "string")
    key = "";
  key = key.replace(/\s/g, "");
  var keys2 = key.split(",");
  var index = keys2.lastIndexOf("");
  for (; index >= 0; ) {
    keys2[index - 1] += ",";
    keys2.splice(index, 1);
    index = keys2.lastIndexOf("");
  }
  return keys2;
}
function compareArray$1(a1, a2) {
  var arr1 = a1.length >= a2.length ? a1 : a2;
  var arr2 = a1.length >= a2.length ? a2 : a1;
  var isIndex = true;
  for (var i2 = 0; i2 < arr1.length; i2++) {
    if (arr2.indexOf(arr1[i2]) === -1)
      isIndex = false;
  }
  return isIndex;
}
var _keyMap$1 = {
  backspace: 8,
  tab: 9,
  clear: 12,
  enter: 13,
  return: 13,
  esc: 27,
  escape: 27,
  space: 32,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  del: 46,
  delete: 46,
  ins: 45,
  insert: 45,
  home: 36,
  end: 35,
  pageup: 33,
  pagedown: 34,
  capslock: 20,
  num_0: 96,
  num_1: 97,
  num_2: 98,
  num_3: 99,
  num_4: 100,
  num_5: 101,
  num_6: 102,
  num_7: 103,
  num_8: 104,
  num_9: 105,
  num_multiply: 106,
  num_add: 107,
  num_enter: 108,
  num_subtract: 109,
  num_decimal: 110,
  num_divide: 111,
  "\u21EA": 20,
  ",": 188,
  ".": 190,
  "/": 191,
  "`": 192,
  "-": isff$1 ? 173 : 189,
  "=": isff$1 ? 61 : 187,
  ";": isff$1 ? 59 : 186,
  "'": 222,
  "[": 219,
  "]": 221,
  "\\": 220
};
var _modifier$1 = {
  "\u21E7": 16,
  shift: 16,
  "\u2325": 18,
  alt: 18,
  option: 18,
  "\u2303": 17,
  ctrl: 17,
  control: 17,
  "\u2318": 91,
  cmd: 91,
  command: 91
};
var modifierMap$1 = {
  16: "shiftKey",
  18: "altKey",
  17: "ctrlKey",
  91: "metaKey",
  shiftKey: 16,
  ctrlKey: 17,
  altKey: 18,
  metaKey: 91
};
var _mods$1 = {
  16: false,
  18: false,
  17: false,
  91: false
};
var _handlers$1 = {};
for (var k$1 = 1; k$1 < 20; k$1++) {
  _keyMap$1["f".concat(k$1)] = 111 + k$1;
}
var _downKeys$1 = [];
var _scope$1 = "all";
var elementHasBindEvent$1 = [];
var code$1 = function code2(x2) {
  return _keyMap$1[x2.toLowerCase()] || _modifier$1[x2.toLowerCase()] || x2.toUpperCase().charCodeAt(0);
};
function setScope$1(scope) {
  _scope$1 = scope || "all";
}
function getScope$1() {
  return _scope$1 || "all";
}
function getPressedKeyCodes$1() {
  return _downKeys$1.slice(0);
}
function filter$1(event) {
  var target = event.target || event.srcElement;
  var tagName = target.tagName;
  var flag = true;
  if (target.isContentEditable || (tagName === "INPUT" || tagName === "TEXTAREA" || tagName === "SELECT") && !target.readOnly) {
    flag = false;
  }
  return flag;
}
function isPressed$1(keyCode) {
  if (typeof keyCode === "string") {
    keyCode = code$1(keyCode);
  }
  return _downKeys$1.indexOf(keyCode) !== -1;
}
function deleteScope$1(scope, newScope) {
  var handlers;
  var i2;
  if (!scope)
    scope = getScope$1();
  for (var key in _handlers$1) {
    if (Object.prototype.hasOwnProperty.call(_handlers$1, key)) {
      handlers = _handlers$1[key];
      for (i2 = 0; i2 < handlers.length; ) {
        if (handlers[i2].scope === scope)
          handlers.splice(i2, 1);
        else
          i2++;
      }
    }
  }
  if (getScope$1() === scope)
    setScope$1(newScope || "all");
}
function clearModifier$1(event) {
  var key = event.keyCode || event.which || event.charCode;
  var i2 = _downKeys$1.indexOf(key);
  if (i2 >= 0) {
    _downKeys$1.splice(i2, 1);
  }
  if (event.key && event.key.toLowerCase() === "meta") {
    _downKeys$1.splice(0, _downKeys$1.length);
  }
  if (key === 93 || key === 224)
    key = 91;
  if (key in _mods$1) {
    _mods$1[key] = false;
    for (var k2 in _modifier$1) {
      if (_modifier$1[k2] === key)
        hotkeys$1[k2] = false;
    }
  }
}
function unbind$1(keysInfo) {
  if (!keysInfo) {
    Object.keys(_handlers$1).forEach(function(key) {
      return delete _handlers$1[key];
    });
  } else if (Array.isArray(keysInfo)) {
    keysInfo.forEach(function(info) {
      if (info.key)
        eachUnbind$1(info);
    });
  } else if (typeof keysInfo === "object") {
    if (keysInfo.key)
      eachUnbind$1(keysInfo);
  } else if (typeof keysInfo === "string") {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    var scope = args[0], method = args[1];
    if (typeof scope === "function") {
      method = scope;
      scope = "";
    }
    eachUnbind$1({
      key: keysInfo,
      scope,
      method,
      splitKey: "+"
    });
  }
}
var eachUnbind$1 = function eachUnbind2(_ref) {
  var key = _ref.key, scope = _ref.scope, method = _ref.method, _ref$splitKey = _ref.splitKey, splitKey = _ref$splitKey === void 0 ? "+" : _ref$splitKey;
  var multipleKeys = getKeys$1(key);
  multipleKeys.forEach(function(originKey) {
    var unbindKeys = originKey.split(splitKey);
    var len = unbindKeys.length;
    var lastKey = unbindKeys[len - 1];
    var keyCode = lastKey === "*" ? "*" : code$1(lastKey);
    if (!_handlers$1[keyCode])
      return;
    if (!scope)
      scope = getScope$1();
    var mods = len > 1 ? getMods$1(_modifier$1, unbindKeys) : [];
    _handlers$1[keyCode] = _handlers$1[keyCode].map(function(record) {
      var isMatchingMethod = method ? record.method === method : true;
      if (isMatchingMethod && record.scope === scope && compareArray$1(record.mods, mods)) {
        return {};
      }
      return record;
    });
  });
};
function eventHandler$1(event, handler, scope) {
  var modifiersMatch;
  if (handler.scope === scope || handler.scope === "all") {
    modifiersMatch = handler.mods.length > 0;
    for (var y2 in _mods$1) {
      if (Object.prototype.hasOwnProperty.call(_mods$1, y2)) {
        if (!_mods$1[y2] && handler.mods.indexOf(+y2) > -1 || _mods$1[y2] && handler.mods.indexOf(+y2) === -1) {
          modifiersMatch = false;
        }
      }
    }
    if (handler.mods.length === 0 && !_mods$1[16] && !_mods$1[18] && !_mods$1[17] && !_mods$1[91] || modifiersMatch || handler.shortcut === "*") {
      if (handler.method(event, handler) === false) {
        if (event.preventDefault)
          event.preventDefault();
        else
          event.returnValue = false;
        if (event.stopPropagation)
          event.stopPropagation();
        if (event.cancelBubble)
          event.cancelBubble = true;
      }
    }
  }
}
function dispatch$1(event) {
  var asterisk = _handlers$1["*"];
  var key = event.keyCode || event.which || event.charCode;
  if (!hotkeys$1.filter.call(this, event))
    return;
  if (key === 93 || key === 224)
    key = 91;
  if (_downKeys$1.indexOf(key) === -1 && key !== 229)
    _downKeys$1.push(key);
  ["ctrlKey", "altKey", "shiftKey", "metaKey"].forEach(function(keyName) {
    var keyNum = modifierMap$1[keyName];
    if (event[keyName] && _downKeys$1.indexOf(keyNum) === -1) {
      _downKeys$1.push(keyNum);
    } else if (!event[keyName] && _downKeys$1.indexOf(keyNum) > -1) {
      _downKeys$1.splice(_downKeys$1.indexOf(keyNum), 1);
    } else if (keyName === "metaKey" && event[keyName] && _downKeys$1.length === 3) {
      if (!(event.ctrlKey || event.shiftKey || event.altKey)) {
        _downKeys$1 = _downKeys$1.slice(_downKeys$1.indexOf(keyNum));
      }
    }
  });
  if (key in _mods$1) {
    _mods$1[key] = true;
    for (var k2 in _modifier$1) {
      if (_modifier$1[k2] === key)
        hotkeys$1[k2] = true;
    }
    if (!asterisk)
      return;
  }
  for (var e20 in _mods$1) {
    if (Object.prototype.hasOwnProperty.call(_mods$1, e20)) {
      _mods$1[e20] = event[modifierMap$1[e20]];
    }
  }
  if (event.getModifierState && !(event.altKey && !event.ctrlKey) && event.getModifierState("AltGraph")) {
    if (_downKeys$1.indexOf(17) === -1) {
      _downKeys$1.push(17);
    }
    if (_downKeys$1.indexOf(18) === -1) {
      _downKeys$1.push(18);
    }
    _mods$1[17] = true;
    _mods$1[18] = true;
  }
  var scope = getScope$1();
  if (asterisk) {
    for (var i2 = 0; i2 < asterisk.length; i2++) {
      if (asterisk[i2].scope === scope && (event.type === "keydown" && asterisk[i2].keydown || event.type === "keyup" && asterisk[i2].keyup)) {
        eventHandler$1(event, asterisk[i2], scope);
      }
    }
  }
  if (!(key in _handlers$1))
    return;
  for (var _i2 = 0; _i2 < _handlers$1[key].length; _i2++) {
    if (event.type === "keydown" && _handlers$1[key][_i2].keydown || event.type === "keyup" && _handlers$1[key][_i2].keyup) {
      if (_handlers$1[key][_i2].key) {
        var record = _handlers$1[key][_i2];
        var splitKey = record.splitKey;
        var keyShortcut = record.key.split(splitKey);
        var _downKeysCurrent = [];
        for (var a2 = 0; a2 < keyShortcut.length; a2++) {
          _downKeysCurrent.push(code$1(keyShortcut[a2]));
        }
        if (_downKeysCurrent.sort().join("") === _downKeys$1.sort().join("")) {
          eventHandler$1(event, record, scope);
        }
      }
    }
  }
}
function isElementBind$1(element) {
  return elementHasBindEvent$1.indexOf(element) > -1;
}
function hotkeys$1(key, option, method) {
  _downKeys$1 = [];
  var keys2 = getKeys$1(key);
  var mods = [];
  var scope = "all";
  var element = document;
  var i2 = 0;
  var keyup = false;
  var keydown = true;
  var splitKey = "+";
  if (method === void 0 && typeof option === "function") {
    method = option;
  }
  if (Object.prototype.toString.call(option) === "[object Object]") {
    if (option.scope)
      scope = option.scope;
    if (option.element)
      element = option.element;
    if (option.keyup)
      keyup = option.keyup;
    if (option.keydown !== void 0)
      keydown = option.keydown;
    if (typeof option.splitKey === "string")
      splitKey = option.splitKey;
  }
  if (typeof option === "string")
    scope = option;
  for (; i2 < keys2.length; i2++) {
    key = keys2[i2].split(splitKey);
    mods = [];
    if (key.length > 1)
      mods = getMods$1(_modifier$1, key);
    key = key[key.length - 1];
    key = key === "*" ? "*" : code$1(key);
    if (!(key in _handlers$1))
      _handlers$1[key] = [];
    _handlers$1[key].push({
      keyup,
      keydown,
      scope,
      mods,
      shortcut: keys2[i2],
      method,
      key: keys2[i2],
      splitKey
    });
  }
  if (typeof element !== "undefined" && !isElementBind$1(element) && window) {
    elementHasBindEvent$1.push(element);
    addEvent$1(element, "keydown", function(e20) {
      dispatch$1(e20);
    });
    addEvent$1(window, "focus", function() {
      _downKeys$1 = [];
    });
    addEvent$1(element, "keyup", function(e20) {
      dispatch$1(e20);
      clearModifier$1(e20);
    });
  }
}
var _api$1 = {
  setScope: setScope$1,
  getScope: getScope$1,
  deleteScope: deleteScope$1,
  getPressedKeyCodes: getPressedKeyCodes$1,
  isPressed: isPressed$1,
  filter: filter$1,
  unbind: unbind$1
};
for (var a$1 in _api$1) {
  if (Object.prototype.hasOwnProperty.call(_api$1, a$1)) {
    hotkeys$1[a$1] = _api$1[a$1];
  }
}
if (typeof window !== "undefined") {
  var _hotkeys$1 = window.hotkeys;
  hotkeys$1.noConflict = function(deep) {
    if (deep && window.hotkeys === hotkeys$1) {
      window.hotkeys = _hotkeys$1;
    }
    return hotkeys$1;
  };
  window.hotkeys = hotkeys$1;
}
var hotkeys_common$1 = hotkeys$1;
hotkeys_common$1.filter = function() {
  return true;
};
function hotkey$1(hotkey2, settings = {}) {
  return new SPromise(({ resolve: resolve2, reject, emit, cancel }) => {
    settings = Object.assign({ element: null, keyup: false, keydown: true, once: false, splitKey: "+" }, settings);
    hotkeys_common$1(hotkey2, settings, (e20, h2) => {
      emit("press", e20);
      if (settings.once)
        cancel();
    });
  }, {
    id: "hotkey"
  }).on("finally", () => {
    hotkeys_common$1.unbind(hotkey2);
  });
}
var __css$5 = "s-side-panel {\n    display: block;\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    z-index: 9999;\n    pointer-events: none;\n}\n\n    s-side-panel[active] {\n        pointer-events: all;\n    }\n\n    s-side-panel:not([mounted]) > * {\n        display: none;\n    }\n\n.s-side-panel__overlay {\n    position: absolute;\n    top: 0;\n    left: 0;\n    z-index: 0;\n    width: 100%;\n    height: 100%;\n}\n\n[default-style] .s-side-panel__overlay {\n        background: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-lightness-offset, 0)) * 1%),var(--s-theme-color-main-a, 0.3));\n        transition: var(--s-theme-transition-default, all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995));\n        opacity: 0;\n    }\n\n[default-style][active] .s-side-panel__overlay {\n        opacity: 1;\n    }\n\n.s-side-panel__container {\n    display: none;\n    position: absolute;\n    z-index: 1;\n}\n\n[mounted] .s-side-panel__container {\n        display: block;\n    }\n\n[default-style] .s-side-panel__container {\n        transition: var(--s-theme-transition-default, all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995));\n    }\n\n[side='left'] .s-side-panel__container {\n        left: 0;\n        top: 0;\n        height: 100%;\n        transform: translateX(-100%);\n    }\n\n[side='top'] .s-side-panel__container {\n        left: 0;\n        top: 0;\n        width: 100%;\n        min-height: 40px;\n        transform: translateY(-100%);\n    }\n\n[side='right'] .s-side-panel__container {\n        right: 0;\n        top: 0;\n        height: 100%;\n        min-width: 40px;\n        transform: translateX(100%);\n    }\n\n[side='bottom'] .s-side-panel__container {\n        left: 0;\n        bottom: 0;\n        width: 100%;\n        min-height: 40px;\n        transform: translateY(100%);\n    }\n\n[active] .s-side-panel__container {\n        transform: translateX(0) translateY(0);\n    }\n\n.s-side-panel {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    pointer-events: none;\n}\n\n.s-side-panel[active] {\n        pointer-events: all;\n    }\n";
var __decorate$2 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d2 = decorators[i2])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
class SSidePanel extends SLitComponent {
  constructor() {
    super(__deepMerge$4({
      litComponent: {
        shadowDom: false
      },
      componentUtils: {
        interface: SSidePanelComponentInterface
      }
    }));
    if (this.props.closeOn.indexOf("click") !== -1) {
      this.addEventListener("click", (e20) => {
        if (this._$container.contains(e20.target))
          return;
        if (this.constructor._activePanels.slice(-1)[0] !== this)
          return;
        this.constructor._activePanels.pop();
        this.active = false;
      });
    }
    if (this.props.closeOn.indexOf("escape") !== -1) {
      hotkey$1("escape").on("press", () => {
        if (this.constructor._activePanels.slice(-1)[0] !== this)
          return;
        this.constructor._activePanels.pop();
        this.active = false;
      });
    }
    this._$nodes = Array.from(this.children);
    if (this.props.triggerer) {
      const $triggerers = Array.from(document.querySelectorAll(this.props.triggerer));
      $triggerers.forEach(($triggerer) => {
        $triggerer.addEventListener("click", (e20) => {
          this.open();
        });
      });
    }
  }
  static get properties() {
    return SLitComponent.properties({}, SSidePanelComponentInterface);
  }
  static get styles() {
    return css$1`
            ${unsafeCSS(__css$5)}
        `;
  }
  set active(value) {
    this._active = value;
    if (value && this.constructor._activePanels.indexOf(this) === -1) {
      this.constructor._activePanels.push(this);
    }
    if (value) {
      this.setAttribute("active", true);
    } else
      this.removeAttribute("active");
    this.requestUpdate();
  }
  get active() {
    return this._active;
  }
  firstUpdated() {
    this._$container = this.querySelector(".s-side-panel__container");
    this._$nodes.forEach(($node) => {
      var _a2;
      (_a2 = this._$container) === null || _a2 === void 0 ? void 0 : _a2.appendChild($node);
    });
  }
  open() {
    this.active = true;
  }
  close() {
    this.active = false;
  }
  render() {
    return html$2`
            ${this.overlay ? html$2` <div class="${this.componentUtils.className("__overlay")}"></div> ` : ""}
            <div class="${this.componentUtils.className("__container")}"></div>
        `;
  }
}
SSidePanel._activePanels = [];
__decorate$2([
  property()
], SSidePanel.prototype, "overlay", void 0);
function define$c(props = {}, tagName = "s-side-panel") {
  SLitComponent.setDefaultProps(tagName, props);
  customElements.define(tagName, SSidePanel);
}
class SSugarConfig {
  static get(dotpath) {
    var _a2, _b2, _c2;
    return get$3((_c2 = (_b2 = (_a2 = window.env) === null || _a2 === void 0 ? void 0 : _a2.SUGAR) === null || _b2 === void 0 ? void 0 : _b2.config) !== null && _c2 !== void 0 ? _c2 : {}, dotpath);
  }
}
var pikaday = { exports: {} };
/*!
* Pikaday
*
* Copyright © 2014 David Bushell | BSD & MIT license | https://github.com/Pikaday/Pikaday
*/
(function(module2, exports) {
  (function(root, factory) {
    var moment;
    {
      try {
        moment = require("moment");
      } catch (e20) {
      }
      module2.exports = factory(moment);
    }
  })(commonjsGlobal, function(moment) {
    var hasMoment = typeof moment === "function", hasEventListeners = !!window.addEventListener, document2 = window.document, sto = window.setTimeout, addEvent2 = function(el2, e20, callback, capture) {
      if (hasEventListeners) {
        el2.addEventListener(e20, callback, !!capture);
      } else {
        el2.attachEvent("on" + e20, callback);
      }
    }, removeEvent = function(el2, e20, callback, capture) {
      if (hasEventListeners) {
        el2.removeEventListener(e20, callback, !!capture);
      } else {
        el2.detachEvent("on" + e20, callback);
      }
    }, trim2 = function(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }, hasClass = function(el2, cn2) {
      return (" " + el2.className + " ").indexOf(" " + cn2 + " ") !== -1;
    }, addClass = function(el2, cn2) {
      if (!hasClass(el2, cn2)) {
        el2.className = el2.className === "" ? cn2 : el2.className + " " + cn2;
      }
    }, removeClass = function(el2, cn2) {
      el2.className = trim2((" " + el2.className + " ").replace(" " + cn2 + " ", " "));
    }, isArray2 = function(obj2) {
      return /Array/.test(Object.prototype.toString.call(obj2));
    }, isDate2 = function(obj2) {
      return /Date/.test(Object.prototype.toString.call(obj2)) && !isNaN(obj2.getTime());
    }, isWeekend = function(date) {
      var day = date.getDay();
      return day === 0 || day === 6;
    }, isLeapYear2 = function(year) {
      return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }, getDaysInMonth2 = function(year, month) {
      return [31, isLeapYear2(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
    }, setToStartOfDay = function(date) {
      if (isDate2(date))
        date.setHours(0, 0, 0, 0);
    }, compareDates = function(a2, b2) {
      return a2.getTime() === b2.getTime();
    }, extend2 = function(to2, from2, overwrite) {
      var prop, hasProp;
      for (prop in from2) {
        hasProp = to2[prop] !== void 0;
        if (hasProp && typeof from2[prop] === "object" && from2[prop] !== null && from2[prop].nodeName === void 0) {
          if (isDate2(from2[prop])) {
            if (overwrite) {
              to2[prop] = new Date(from2[prop].getTime());
            }
          } else if (isArray2(from2[prop])) {
            if (overwrite) {
              to2[prop] = from2[prop].slice(0);
            }
          } else {
            to2[prop] = extend2({}, from2[prop], overwrite);
          }
        } else if (overwrite || !hasProp) {
          to2[prop] = from2[prop];
        }
      }
      return to2;
    }, fireEvent = function(el2, eventName, data) {
      var ev2;
      if (document2.createEvent) {
        ev2 = document2.createEvent("HTMLEvents");
        ev2.initEvent(eventName, true, false);
        ev2 = extend2(ev2, data);
        el2.dispatchEvent(ev2);
      } else if (document2.createEventObject) {
        ev2 = document2.createEventObject();
        ev2 = extend2(ev2, data);
        el2.fireEvent("on" + eventName, ev2);
      }
    }, adjustCalendar = function(calendar2) {
      if (calendar2.month < 0) {
        calendar2.year -= Math.ceil(Math.abs(calendar2.month) / 12);
        calendar2.month += 12;
      }
      if (calendar2.month > 11) {
        calendar2.year += Math.floor(Math.abs(calendar2.month) / 12);
        calendar2.month -= 12;
      }
      return calendar2;
    }, defaults2 = {
      field: null,
      bound: void 0,
      ariaLabel: "Use the arrow keys to pick a date",
      position: "bottom left",
      reposition: true,
      format: "YYYY-MM-DD",
      toString: null,
      parse: null,
      defaultDate: null,
      setDefaultDate: false,
      firstDay: 0,
      firstWeekOfYearMinDays: 4,
      formatStrict: false,
      minDate: null,
      maxDate: null,
      yearRange: 10,
      showWeekNumber: false,
      pickWholeWeek: false,
      minYear: 0,
      maxYear: 9999,
      minMonth: void 0,
      maxMonth: void 0,
      startRange: null,
      endRange: null,
      isRTL: false,
      yearSuffix: "",
      showMonthAfterYear: false,
      showDaysInNextAndPreviousMonths: false,
      enableSelectionDaysInNextAndPreviousMonths: false,
      numberOfMonths: 1,
      mainCalendar: "left",
      container: void 0,
      blurFieldOnSelect: true,
      i18n: {
        previousMonth: "Previous Month",
        nextMonth: "Next Month",
        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
      },
      theme: null,
      events: [],
      onSelect: null,
      onOpen: null,
      onClose: null,
      onDraw: null,
      keyboardInput: true
    }, renderDayName = function(opts, day, abbr) {
      day += opts.firstDay;
      while (day >= 7) {
        day -= 7;
      }
      return abbr ? opts.i18n.weekdaysShort[day] : opts.i18n.weekdays[day];
    }, renderDay = function(opts) {
      var arr = [];
      var ariaSelected = "false";
      if (opts.isEmpty) {
        if (opts.showDaysInNextAndPreviousMonths) {
          arr.push("is-outside-current-month");
          if (!opts.enableSelectionDaysInNextAndPreviousMonths) {
            arr.push("is-selection-disabled");
          }
        } else {
          return '<td class="is-empty"></td>';
        }
      }
      if (opts.isDisabled) {
        arr.push("is-disabled");
      }
      if (opts.isToday) {
        arr.push("is-today");
      }
      if (opts.isSelected) {
        arr.push("is-selected");
        ariaSelected = "true";
      }
      if (opts.hasEvent) {
        arr.push("has-event");
      }
      if (opts.isInRange) {
        arr.push("is-inrange");
      }
      if (opts.isStartRange) {
        arr.push("is-startrange");
      }
      if (opts.isEndRange) {
        arr.push("is-endrange");
      }
      return '<td data-day="' + opts.day + '" class="' + arr.join(" ") + '" aria-selected="' + ariaSelected + '"><button class="pika-button pika-day" type="button" data-pika-year="' + opts.year + '" data-pika-month="' + opts.month + '" data-pika-day="' + opts.day + '">' + opts.day + "</button></td>";
    }, isoWeek = function(date, firstWeekOfYearMinDays) {
      date.setHours(0, 0, 0, 0);
      var yearDay = date.getDate(), weekDay = date.getDay(), dayInFirstWeek = firstWeekOfYearMinDays, dayShift = dayInFirstWeek - 1, daysPerWeek = 7, prevWeekDay = function(day) {
        return (day + daysPerWeek - 1) % daysPerWeek;
      };
      date.setDate(yearDay + dayShift - prevWeekDay(weekDay));
      var jan4th = new Date(date.getFullYear(), 0, dayInFirstWeek), msPerDay = 24 * 60 * 60 * 1e3, daysBetween = (date.getTime() - jan4th.getTime()) / msPerDay, weekNum = 1 + Math.round((daysBetween - dayShift + prevWeekDay(jan4th.getDay())) / daysPerWeek);
      return weekNum;
    }, renderWeek = function(d2, m2, y2, firstWeekOfYearMinDays) {
      var date = new Date(y2, m2, d2), week = hasMoment ? moment(date).isoWeek() : isoWeek(date, firstWeekOfYearMinDays);
      return '<td class="pika-week">' + week + "</td>";
    }, renderRow = function(days2, isRTL, pickWholeWeek, isRowSelected) {
      return '<tr class="pika-row' + (pickWholeWeek ? " pick-whole-week" : "") + (isRowSelected ? " is-selected" : "") + '">' + (isRTL ? days2.reverse() : days2).join("") + "</tr>";
    }, renderBody = function(rows) {
      return "<tbody>" + rows.join("") + "</tbody>";
    }, renderHead = function(opts) {
      var i2, arr = [];
      if (opts.showWeekNumber) {
        arr.push("<th></th>");
      }
      for (i2 = 0; i2 < 7; i2++) {
        arr.push('<th scope="col"><abbr title="' + renderDayName(opts, i2) + '">' + renderDayName(opts, i2, true) + "</abbr></th>");
      }
      return "<thead><tr>" + (opts.isRTL ? arr.reverse() : arr).join("") + "</tr></thead>";
    }, renderTitle = function(instance, c2, year, month, refYear, randId) {
      var i2, j2, arr, opts = instance._o, isMinYear = year === opts.minYear, isMaxYear = year === opts.maxYear, html2 = '<div id="' + randId + '" class="pika-title" role="heading" aria-live="assertive">', monthHtml, yearHtml, prev = true, next = true;
      for (arr = [], i2 = 0; i2 < 12; i2++) {
        arr.push('<option value="' + (year === refYear ? i2 - c2 : 12 + i2 - c2) + '"' + (i2 === month ? ' selected="selected"' : "") + (isMinYear && i2 < opts.minMonth || isMaxYear && i2 > opts.maxMonth ? ' disabled="disabled"' : "") + ">" + opts.i18n.months[i2] + "</option>");
      }
      monthHtml = '<div class="pika-label">' + opts.i18n.months[month] + '<select class="pika-select pika-select-month" tabindex="-1">' + arr.join("") + "</select></div>";
      if (isArray2(opts.yearRange)) {
        i2 = opts.yearRange[0];
        j2 = opts.yearRange[1] + 1;
      } else {
        i2 = year - opts.yearRange;
        j2 = 1 + year + opts.yearRange;
      }
      for (arr = []; i2 < j2 && i2 <= opts.maxYear; i2++) {
        if (i2 >= opts.minYear) {
          arr.push('<option value="' + i2 + '"' + (i2 === year ? ' selected="selected"' : "") + ">" + i2 + "</option>");
        }
      }
      yearHtml = '<div class="pika-label">' + year + opts.yearSuffix + '<select class="pika-select pika-select-year" tabindex="-1">' + arr.join("") + "</select></div>";
      if (opts.showMonthAfterYear) {
        html2 += yearHtml + monthHtml;
      } else {
        html2 += monthHtml + yearHtml;
      }
      if (isMinYear && (month === 0 || opts.minMonth >= month)) {
        prev = false;
      }
      if (isMaxYear && (month === 11 || opts.maxMonth <= month)) {
        next = false;
      }
      if (c2 === 0) {
        html2 += '<button class="pika-prev' + (prev ? "" : " is-disabled") + '" type="button">' + opts.i18n.previousMonth + "</button>";
      }
      if (c2 === instance._o.numberOfMonths - 1) {
        html2 += '<button class="pika-next' + (next ? "" : " is-disabled") + '" type="button">' + opts.i18n.nextMonth + "</button>";
      }
      return html2 += "</div>";
    }, renderTable = function(opts, data, randId) {
      return '<table cellpadding="0" cellspacing="0" class="pika-table" role="grid" aria-labelledby="' + randId + '">' + renderHead(opts) + renderBody(data) + "</table>";
    }, Pikaday = function(options) {
      var self2 = this, opts = self2.config(options);
      self2._onMouseDown = function(e20) {
        if (!self2._v) {
          return;
        }
        e20 = e20 || window.event;
        var target = e20.target || e20.srcElement;
        if (!target) {
          return;
        }
        if (!hasClass(target, "is-disabled")) {
          if (hasClass(target, "pika-button") && !hasClass(target, "is-empty") && !hasClass(target.parentNode, "is-disabled")) {
            self2.setDate(new Date(target.getAttribute("data-pika-year"), target.getAttribute("data-pika-month"), target.getAttribute("data-pika-day")));
            if (opts.bound) {
              sto(function() {
                self2.hide();
                if (opts.blurFieldOnSelect && opts.field) {
                  opts.field.blur();
                }
              }, 100);
            }
          } else if (hasClass(target, "pika-prev")) {
            self2.prevMonth();
          } else if (hasClass(target, "pika-next")) {
            self2.nextMonth();
          }
        }
        if (!hasClass(target, "pika-select")) {
          if (e20.preventDefault) {
            e20.preventDefault();
          } else {
            e20.returnValue = false;
            return false;
          }
        } else {
          self2._c = true;
        }
      };
      self2._onChange = function(e20) {
        e20 = e20 || window.event;
        var target = e20.target || e20.srcElement;
        if (!target) {
          return;
        }
        if (hasClass(target, "pika-select-month")) {
          self2.gotoMonth(target.value);
        } else if (hasClass(target, "pika-select-year")) {
          self2.gotoYear(target.value);
        }
      };
      self2._onKeyChange = function(e20) {
        e20 = e20 || window.event;
        if (self2.isVisible()) {
          switch (e20.keyCode) {
            case 13:
            case 27:
              if (opts.field) {
                opts.field.blur();
              }
              break;
            case 37:
              self2.adjustDate("subtract", 1);
              break;
            case 38:
              self2.adjustDate("subtract", 7);
              break;
            case 39:
              self2.adjustDate("add", 1);
              break;
            case 40:
              self2.adjustDate("add", 7);
              break;
            case 8:
            case 46:
              self2.setDate(null);
              break;
          }
        }
      };
      self2._parseFieldValue = function() {
        if (opts.parse) {
          return opts.parse(opts.field.value, opts.format);
        } else if (hasMoment) {
          var date = moment(opts.field.value, opts.format, opts.formatStrict);
          return date && date.isValid() ? date.toDate() : null;
        } else {
          return new Date(Date.parse(opts.field.value));
        }
      };
      self2._onInputChange = function(e20) {
        var date;
        if (e20.firedBy === self2) {
          return;
        }
        date = self2._parseFieldValue();
        if (isDate2(date)) {
          self2.setDate(date);
        }
        if (!self2._v) {
          self2.show();
        }
      };
      self2._onInputFocus = function() {
        self2.show();
      };
      self2._onInputClick = function() {
        self2.show();
      };
      self2._onInputBlur = function() {
        var pEl = document2.activeElement;
        do {
          if (hasClass(pEl, "pika-single")) {
            return;
          }
        } while (pEl = pEl.parentNode);
        if (!self2._c) {
          self2._b = sto(function() {
            self2.hide();
          }, 50);
        }
        self2._c = false;
      };
      self2._onClick = function(e20) {
        e20 = e20 || window.event;
        var target = e20.target || e20.srcElement, pEl = target;
        if (!target) {
          return;
        }
        if (!hasEventListeners && hasClass(target, "pika-select")) {
          if (!target.onchange) {
            target.setAttribute("onchange", "return;");
            addEvent2(target, "change", self2._onChange);
          }
        }
        do {
          if (hasClass(pEl, "pika-single") || pEl === opts.trigger) {
            return;
          }
        } while (pEl = pEl.parentNode);
        if (self2._v && target !== opts.trigger && pEl !== opts.trigger) {
          self2.hide();
        }
      };
      self2.el = document2.createElement("div");
      self2.el.className = "pika-single" + (opts.isRTL ? " is-rtl" : "") + (opts.theme ? " " + opts.theme : "");
      addEvent2(self2.el, "mousedown", self2._onMouseDown, true);
      addEvent2(self2.el, "touchend", self2._onMouseDown, true);
      addEvent2(self2.el, "change", self2._onChange);
      if (opts.keyboardInput) {
        addEvent2(document2, "keydown", self2._onKeyChange);
      }
      if (opts.field) {
        if (opts.container) {
          opts.container.appendChild(self2.el);
        } else if (opts.bound) {
          document2.body.appendChild(self2.el);
        } else {
          opts.field.parentNode.insertBefore(self2.el, opts.field.nextSibling);
        }
        addEvent2(opts.field, "change", self2._onInputChange);
        if (!opts.defaultDate) {
          opts.defaultDate = self2._parseFieldValue();
          opts.setDefaultDate = true;
        }
      }
      var defDate = opts.defaultDate;
      if (isDate2(defDate)) {
        if (opts.setDefaultDate) {
          self2.setDate(defDate, true);
        } else {
          self2.gotoDate(defDate);
        }
      } else {
        self2.gotoDate(new Date());
      }
      if (opts.bound) {
        this.hide();
        self2.el.className += " is-bound";
        addEvent2(opts.trigger, "click", self2._onInputClick);
        addEvent2(opts.trigger, "focus", self2._onInputFocus);
        addEvent2(opts.trigger, "blur", self2._onInputBlur);
      } else {
        this.show();
      }
    };
    Pikaday.prototype = {
      config: function(options) {
        if (!this._o) {
          this._o = extend2({}, defaults2, true);
        }
        var opts = extend2(this._o, options, true);
        opts.isRTL = !!opts.isRTL;
        opts.field = opts.field && opts.field.nodeName ? opts.field : null;
        opts.theme = typeof opts.theme === "string" && opts.theme ? opts.theme : null;
        opts.bound = !!(opts.bound !== void 0 ? opts.field && opts.bound : opts.field);
        opts.trigger = opts.trigger && opts.trigger.nodeName ? opts.trigger : opts.field;
        opts.disableWeekends = !!opts.disableWeekends;
        opts.disableDayFn = typeof opts.disableDayFn === "function" ? opts.disableDayFn : null;
        var nom = parseInt(opts.numberOfMonths, 10) || 1;
        opts.numberOfMonths = nom > 4 ? 4 : nom;
        if (!isDate2(opts.minDate)) {
          opts.minDate = false;
        }
        if (!isDate2(opts.maxDate)) {
          opts.maxDate = false;
        }
        if (opts.minDate && opts.maxDate && opts.maxDate < opts.minDate) {
          opts.maxDate = opts.minDate = false;
        }
        if (opts.minDate) {
          this.setMinDate(opts.minDate);
        }
        if (opts.maxDate) {
          this.setMaxDate(opts.maxDate);
        }
        if (isArray2(opts.yearRange)) {
          var fallback = new Date().getFullYear() - 10;
          opts.yearRange[0] = parseInt(opts.yearRange[0], 10) || fallback;
          opts.yearRange[1] = parseInt(opts.yearRange[1], 10) || fallback;
        } else {
          opts.yearRange = Math.abs(parseInt(opts.yearRange, 10)) || defaults2.yearRange;
          if (opts.yearRange > 100) {
            opts.yearRange = 100;
          }
        }
        return opts;
      },
      toString: function(format2) {
        format2 = format2 || this._o.format;
        if (!isDate2(this._d)) {
          return "";
        }
        if (this._o.toString) {
          return this._o.toString(this._d, format2);
        }
        if (hasMoment) {
          return moment(this._d).format(format2);
        }
        return this._d.toDateString();
      },
      getMoment: function() {
        return hasMoment ? moment(this._d) : null;
      },
      setMoment: function(date, preventOnSelect) {
        if (hasMoment && moment.isMoment(date)) {
          this.setDate(date.toDate(), preventOnSelect);
        }
      },
      getDate: function() {
        return isDate2(this._d) ? new Date(this._d.getTime()) : null;
      },
      setDate: function(date, preventOnSelect) {
        if (!date) {
          this._d = null;
          if (this._o.field) {
            this._o.field.value = "";
            fireEvent(this._o.field, "change", { firedBy: this });
          }
          return this.draw();
        }
        if (typeof date === "string") {
          date = new Date(Date.parse(date));
        }
        if (!isDate2(date)) {
          return;
        }
        var min2 = this._o.minDate, max2 = this._o.maxDate;
        if (isDate2(min2) && date < min2) {
          date = min2;
        } else if (isDate2(max2) && date > max2) {
          date = max2;
        }
        this._d = new Date(date.getTime());
        setToStartOfDay(this._d);
        this.gotoDate(this._d);
        if (this._o.field) {
          this._o.field.value = this.toString();
          fireEvent(this._o.field, "change", { firedBy: this });
        }
        if (!preventOnSelect && typeof this._o.onSelect === "function") {
          this._o.onSelect.call(this, this.getDate());
        }
      },
      clear: function() {
        this.setDate(null);
      },
      gotoDate: function(date) {
        var newCalendar = true;
        if (!isDate2(date)) {
          return;
        }
        if (this.calendars) {
          var firstVisibleDate = new Date(this.calendars[0].year, this.calendars[0].month, 1), lastVisibleDate = new Date(this.calendars[this.calendars.length - 1].year, this.calendars[this.calendars.length - 1].month, 1), visibleDate = date.getTime();
          lastVisibleDate.setMonth(lastVisibleDate.getMonth() + 1);
          lastVisibleDate.setDate(lastVisibleDate.getDate() - 1);
          newCalendar = visibleDate < firstVisibleDate.getTime() || lastVisibleDate.getTime() < visibleDate;
        }
        if (newCalendar) {
          this.calendars = [{
            month: date.getMonth(),
            year: date.getFullYear()
          }];
          if (this._o.mainCalendar === "right") {
            this.calendars[0].month += 1 - this._o.numberOfMonths;
          }
        }
        this.adjustCalendars();
      },
      adjustDate: function(sign2, days2) {
        var day = this.getDate() || new Date();
        var difference = parseInt(days2) * 24 * 60 * 60 * 1e3;
        var newDay;
        if (sign2 === "add") {
          newDay = new Date(day.valueOf() + difference);
        } else if (sign2 === "subtract") {
          newDay = new Date(day.valueOf() - difference);
        }
        this.setDate(newDay);
      },
      adjustCalendars: function() {
        this.calendars[0] = adjustCalendar(this.calendars[0]);
        for (var c2 = 1; c2 < this._o.numberOfMonths; c2++) {
          this.calendars[c2] = adjustCalendar({
            month: this.calendars[0].month + c2,
            year: this.calendars[0].year
          });
        }
        this.draw();
      },
      gotoToday: function() {
        this.gotoDate(new Date());
      },
      gotoMonth: function(month) {
        if (!isNaN(month)) {
          this.calendars[0].month = parseInt(month, 10);
          this.adjustCalendars();
        }
      },
      nextMonth: function() {
        this.calendars[0].month++;
        this.adjustCalendars();
      },
      prevMonth: function() {
        this.calendars[0].month--;
        this.adjustCalendars();
      },
      gotoYear: function(year) {
        if (!isNaN(year)) {
          this.calendars[0].year = parseInt(year, 10);
          this.adjustCalendars();
        }
      },
      setMinDate: function(value) {
        if (value instanceof Date) {
          setToStartOfDay(value);
          this._o.minDate = value;
          this._o.minYear = value.getFullYear();
          this._o.minMonth = value.getMonth();
        } else {
          this._o.minDate = defaults2.minDate;
          this._o.minYear = defaults2.minYear;
          this._o.minMonth = defaults2.minMonth;
          this._o.startRange = defaults2.startRange;
        }
        this.draw();
      },
      setMaxDate: function(value) {
        if (value instanceof Date) {
          setToStartOfDay(value);
          this._o.maxDate = value;
          this._o.maxYear = value.getFullYear();
          this._o.maxMonth = value.getMonth();
        } else {
          this._o.maxDate = defaults2.maxDate;
          this._o.maxYear = defaults2.maxYear;
          this._o.maxMonth = defaults2.maxMonth;
          this._o.endRange = defaults2.endRange;
        }
        this.draw();
      },
      setStartRange: function(value) {
        this._o.startRange = value;
      },
      setEndRange: function(value) {
        this._o.endRange = value;
      },
      draw: function(force) {
        if (!this._v && !force) {
          return;
        }
        var opts = this._o, minYear = opts.minYear, maxYear = opts.maxYear, minMonth = opts.minMonth, maxMonth = opts.maxMonth, html2 = "", randId;
        if (this._y <= minYear) {
          this._y = minYear;
          if (!isNaN(minMonth) && this._m < minMonth) {
            this._m = minMonth;
          }
        }
        if (this._y >= maxYear) {
          this._y = maxYear;
          if (!isNaN(maxMonth) && this._m > maxMonth) {
            this._m = maxMonth;
          }
        }
        for (var c2 = 0; c2 < opts.numberOfMonths; c2++) {
          randId = "pika-title-" + Math.random().toString(36).replace(/[^a-z]+/g, "").substr(0, 2);
          html2 += '<div class="pika-lendar">' + renderTitle(this, c2, this.calendars[c2].year, this.calendars[c2].month, this.calendars[0].year, randId) + this.render(this.calendars[c2].year, this.calendars[c2].month, randId) + "</div>";
        }
        this.el.innerHTML = html2;
        if (opts.bound) {
          if (opts.field.type !== "hidden") {
            sto(function() {
              opts.trigger.focus();
            }, 1);
          }
        }
        if (typeof this._o.onDraw === "function") {
          this._o.onDraw(this);
        }
        if (opts.bound) {
          opts.field.setAttribute("aria-label", opts.ariaLabel);
        }
      },
      adjustPosition: function() {
        var field, pEl, width, height, viewportWidth, viewportHeight, scrollTop2, left2, top, clientRect, leftAligned, bottomAligned;
        if (this._o.container)
          return;
        this.el.style.position = "absolute";
        field = this._o.trigger;
        pEl = field;
        width = this.el.offsetWidth;
        height = this.el.offsetHeight;
        viewportWidth = window.innerWidth || document2.documentElement.clientWidth;
        viewportHeight = window.innerHeight || document2.documentElement.clientHeight;
        scrollTop2 = window.pageYOffset || document2.body.scrollTop || document2.documentElement.scrollTop;
        leftAligned = true;
        bottomAligned = true;
        if (typeof field.getBoundingClientRect === "function") {
          clientRect = field.getBoundingClientRect();
          left2 = clientRect.left + window.pageXOffset;
          top = clientRect.bottom + window.pageYOffset;
        } else {
          left2 = pEl.offsetLeft;
          top = pEl.offsetTop + pEl.offsetHeight;
          while (pEl = pEl.offsetParent) {
            left2 += pEl.offsetLeft;
            top += pEl.offsetTop;
          }
        }
        if (this._o.reposition && left2 + width > viewportWidth || this._o.position.indexOf("right") > -1 && left2 - width + field.offsetWidth > 0) {
          left2 = left2 - width + field.offsetWidth;
          leftAligned = false;
        }
        if (this._o.reposition && top + height > viewportHeight + scrollTop2 || this._o.position.indexOf("top") > -1 && top - height - field.offsetHeight > 0) {
          top = top - height - field.offsetHeight;
          bottomAligned = false;
        }
        this.el.style.left = left2 + "px";
        this.el.style.top = top + "px";
        addClass(this.el, leftAligned ? "left-aligned" : "right-aligned");
        addClass(this.el, bottomAligned ? "bottom-aligned" : "top-aligned");
        removeClass(this.el, !leftAligned ? "left-aligned" : "right-aligned");
        removeClass(this.el, !bottomAligned ? "bottom-aligned" : "top-aligned");
      },
      render: function(year, month, randId) {
        var opts = this._o, now2 = new Date(), days2 = getDaysInMonth2(year, month), before = new Date(year, month, 1).getDay(), data = [], row = [];
        setToStartOfDay(now2);
        if (opts.firstDay > 0) {
          before -= opts.firstDay;
          if (before < 0) {
            before += 7;
          }
        }
        var previousMonth = month === 0 ? 11 : month - 1, nextMonth = month === 11 ? 0 : month + 1, yearOfPreviousMonth = month === 0 ? year - 1 : year, yearOfNextMonth = month === 11 ? year + 1 : year, daysInPreviousMonth = getDaysInMonth2(yearOfPreviousMonth, previousMonth);
        var cells = days2 + before, after = cells;
        while (after > 7) {
          after -= 7;
        }
        cells += 7 - after;
        var isWeekSelected = false;
        for (var i2 = 0, r2 = 0; i2 < cells; i2++) {
          var day = new Date(year, month, 1 + (i2 - before)), isSelected = isDate2(this._d) ? compareDates(day, this._d) : false, isToday = compareDates(day, now2), hasEvent = opts.events.indexOf(day.toDateString()) !== -1 ? true : false, isEmpty = i2 < before || i2 >= days2 + before, dayNumber = 1 + (i2 - before), monthNumber = month, yearNumber = year, isStartRange = opts.startRange && compareDates(opts.startRange, day), isEndRange = opts.endRange && compareDates(opts.endRange, day), isInRange = opts.startRange && opts.endRange && opts.startRange < day && day < opts.endRange, isDisabled = opts.minDate && day < opts.minDate || opts.maxDate && day > opts.maxDate || opts.disableWeekends && isWeekend(day) || opts.disableDayFn && opts.disableDayFn(day);
          if (isEmpty) {
            if (i2 < before) {
              dayNumber = daysInPreviousMonth + dayNumber;
              monthNumber = previousMonth;
              yearNumber = yearOfPreviousMonth;
            } else {
              dayNumber = dayNumber - days2;
              monthNumber = nextMonth;
              yearNumber = yearOfNextMonth;
            }
          }
          var dayConfig = {
            day: dayNumber,
            month: monthNumber,
            year: yearNumber,
            hasEvent,
            isSelected,
            isToday,
            isDisabled,
            isEmpty,
            isStartRange,
            isEndRange,
            isInRange,
            showDaysInNextAndPreviousMonths: opts.showDaysInNextAndPreviousMonths,
            enableSelectionDaysInNextAndPreviousMonths: opts.enableSelectionDaysInNextAndPreviousMonths
          };
          if (opts.pickWholeWeek && isSelected) {
            isWeekSelected = true;
          }
          row.push(renderDay(dayConfig));
          if (++r2 === 7) {
            if (opts.showWeekNumber) {
              row.unshift(renderWeek(i2 - before, month, year, opts.firstWeekOfYearMinDays));
            }
            data.push(renderRow(row, opts.isRTL, opts.pickWholeWeek, isWeekSelected));
            row = [];
            r2 = 0;
            isWeekSelected = false;
          }
        }
        return renderTable(opts, data, randId);
      },
      isVisible: function() {
        return this._v;
      },
      show: function() {
        if (!this.isVisible()) {
          this._v = true;
          this.draw();
          removeClass(this.el, "is-hidden");
          if (this._o.bound) {
            addEvent2(document2, "click", this._onClick);
            this.adjustPosition();
          }
          if (typeof this._o.onOpen === "function") {
            this._o.onOpen.call(this);
          }
        }
      },
      hide: function() {
        var v2 = this._v;
        if (v2 !== false) {
          if (this._o.bound) {
            removeEvent(document2, "click", this._onClick);
          }
          if (!this._o.container) {
            this.el.style.position = "static";
            this.el.style.left = "auto";
            this.el.style.top = "auto";
          }
          addClass(this.el, "is-hidden");
          this._v = false;
          if (v2 !== void 0 && typeof this._o.onClose === "function") {
            this._o.onClose.call(this);
          }
        }
      },
      destroy: function() {
        var opts = this._o;
        this.hide();
        removeEvent(this.el, "mousedown", this._onMouseDown, true);
        removeEvent(this.el, "touchend", this._onMouseDown, true);
        removeEvent(this.el, "change", this._onChange);
        if (opts.keyboardInput) {
          removeEvent(document2, "keydown", this._onKeyChange);
        }
        if (opts.field) {
          removeEvent(opts.field, "change", this._onInputChange);
          if (opts.bound) {
            removeEvent(opts.trigger, "click", this._onInputClick);
            removeEvent(opts.trigger, "focus", this._onInputFocus);
            removeEvent(opts.trigger, "blur", this._onInputBlur);
          }
        }
        if (this.el.parentNode) {
          this.el.parentNode.removeChild(this.el);
        }
      }
    };
    return Pikaday;
  });
})(pikaday);
var __pikaday = pikaday.exports;
//! moment.js
//! version : 2.29.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
var hookCallback;
function hooks() {
  return hookCallback.apply(null, arguments);
}
function setHookCallback(callback) {
  hookCallback = callback;
}
function isArray$2(input) {
  return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
}
function isObject(input) {
  return input != null && Object.prototype.toString.call(input) === "[object Object]";
}
function hasOwnProp(a2, b2) {
  return Object.prototype.hasOwnProperty.call(a2, b2);
}
function isObjectEmpty(obj2) {
  if (Object.getOwnPropertyNames) {
    return Object.getOwnPropertyNames(obj2).length === 0;
  } else {
    var k2;
    for (k2 in obj2) {
      if (hasOwnProp(obj2, k2)) {
        return false;
      }
    }
    return true;
  }
}
function isUndefined(input) {
  return input === void 0;
}
function isNumber(input) {
  return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
}
function isDate(input) {
  return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
}
function map(arr, fn2) {
  var res = [], i2;
  for (i2 = 0; i2 < arr.length; ++i2) {
    res.push(fn2(arr[i2], i2));
  }
  return res;
}
function extend(a2, b2) {
  for (var i2 in b2) {
    if (hasOwnProp(b2, i2)) {
      a2[i2] = b2[i2];
    }
  }
  if (hasOwnProp(b2, "toString")) {
    a2.toString = b2.toString;
  }
  if (hasOwnProp(b2, "valueOf")) {
    a2.valueOf = b2.valueOf;
  }
  return a2;
}
function createUTC(input, format2, locale2, strict) {
  return createLocalOrUTC(input, format2, locale2, strict, true).utc();
}
function defaultParsingFlags() {
  return {
    empty: false,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: false,
    invalidEra: null,
    invalidMonth: null,
    invalidFormat: false,
    userInvalidated: false,
    iso: false,
    parsedDateParts: [],
    era: null,
    meridiem: null,
    rfc2822: false,
    weekdayMismatch: false
  };
}
function getParsingFlags(m2) {
  if (m2._pf == null) {
    m2._pf = defaultParsingFlags();
  }
  return m2._pf;
}
var some;
if (Array.prototype.some) {
  some = Array.prototype.some;
} else {
  some = function(fun) {
    var t2 = Object(this), len = t2.length >>> 0, i2;
    for (i2 = 0; i2 < len; i2++) {
      if (i2 in t2 && fun.call(this, t2[i2], i2, t2)) {
        return true;
      }
    }
    return false;
  };
}
function isValid(m2) {
  if (m2._isValid == null) {
    var flags = getParsingFlags(m2), parsedParts = some.call(flags.parsedDateParts, function(i2) {
      return i2 != null;
    }), isNowValid = !isNaN(m2._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
    if (m2._strict) {
      isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
    }
    if (Object.isFrozen == null || !Object.isFrozen(m2)) {
      m2._isValid = isNowValid;
    } else {
      return isNowValid;
    }
  }
  return m2._isValid;
}
function createInvalid(flags) {
  var m2 = createUTC(NaN);
  if (flags != null) {
    extend(getParsingFlags(m2), flags);
  } else {
    getParsingFlags(m2).userInvalidated = true;
  }
  return m2;
}
var momentProperties = hooks.momentProperties = [], updateInProgress = false;
function copyConfig(to2, from2) {
  var i2, prop, val;
  if (!isUndefined(from2._isAMomentObject)) {
    to2._isAMomentObject = from2._isAMomentObject;
  }
  if (!isUndefined(from2._i)) {
    to2._i = from2._i;
  }
  if (!isUndefined(from2._f)) {
    to2._f = from2._f;
  }
  if (!isUndefined(from2._l)) {
    to2._l = from2._l;
  }
  if (!isUndefined(from2._strict)) {
    to2._strict = from2._strict;
  }
  if (!isUndefined(from2._tzm)) {
    to2._tzm = from2._tzm;
  }
  if (!isUndefined(from2._isUTC)) {
    to2._isUTC = from2._isUTC;
  }
  if (!isUndefined(from2._offset)) {
    to2._offset = from2._offset;
  }
  if (!isUndefined(from2._pf)) {
    to2._pf = getParsingFlags(from2);
  }
  if (!isUndefined(from2._locale)) {
    to2._locale = from2._locale;
  }
  if (momentProperties.length > 0) {
    for (i2 = 0; i2 < momentProperties.length; i2++) {
      prop = momentProperties[i2];
      val = from2[prop];
      if (!isUndefined(val)) {
        to2[prop] = val;
      }
    }
  }
  return to2;
}
function Moment(config) {
  copyConfig(this, config);
  this._d = new Date(config._d != null ? config._d.getTime() : NaN);
  if (!this.isValid()) {
    this._d = new Date(NaN);
  }
  if (updateInProgress === false) {
    updateInProgress = true;
    hooks.updateOffset(this);
    updateInProgress = false;
  }
}
function isMoment(obj2) {
  return obj2 instanceof Moment || obj2 != null && obj2._isAMomentObject != null;
}
function warn(msg) {
  if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
    console.warn("Deprecation warning: " + msg);
  }
}
function deprecate(msg, fn2) {
  var firstTime = true;
  return extend(function() {
    if (hooks.deprecationHandler != null) {
      hooks.deprecationHandler(null, msg);
    }
    if (firstTime) {
      var args = [], arg, i2, key;
      for (i2 = 0; i2 < arguments.length; i2++) {
        arg = "";
        if (typeof arguments[i2] === "object") {
          arg += "\n[" + i2 + "] ";
          for (key in arguments[0]) {
            if (hasOwnProp(arguments[0], key)) {
              arg += key + ": " + arguments[0][key] + ", ";
            }
          }
          arg = arg.slice(0, -2);
        } else {
          arg = arguments[i2];
        }
        args.push(arg);
      }
      warn(msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack);
      firstTime = false;
    }
    return fn2.apply(this, arguments);
  }, fn2);
}
var deprecations = {};
function deprecateSimple(name2, msg) {
  if (hooks.deprecationHandler != null) {
    hooks.deprecationHandler(name2, msg);
  }
  if (!deprecations[name2]) {
    warn(msg);
    deprecations[name2] = true;
  }
}
hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;
function isFunction(input) {
  return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
}
function set$1(config) {
  var prop, i2;
  for (i2 in config) {
    if (hasOwnProp(config, i2)) {
      prop = config[i2];
      if (isFunction(prop)) {
        this[i2] = prop;
      } else {
        this["_" + i2] = prop;
      }
    }
  }
  this._config = config;
  this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
}
function mergeConfigs(parentConfig, childConfig) {
  var res = extend({}, parentConfig), prop;
  for (prop in childConfig) {
    if (hasOwnProp(childConfig, prop)) {
      if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
        res[prop] = {};
        extend(res[prop], parentConfig[prop]);
        extend(res[prop], childConfig[prop]);
      } else if (childConfig[prop] != null) {
        res[prop] = childConfig[prop];
      } else {
        delete res[prop];
      }
    }
  }
  for (prop in parentConfig) {
    if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
      res[prop] = extend({}, res[prop]);
    }
  }
  return res;
}
function Locale(config) {
  if (config != null) {
    this.set(config);
  }
}
var keys;
if (Object.keys) {
  keys = Object.keys;
} else {
  keys = function(obj2) {
    var i2, res = [];
    for (i2 in obj2) {
      if (hasOwnProp(obj2, i2)) {
        res.push(i2);
      }
    }
    return res;
  };
}
var defaultCalendar = {
  sameDay: "[Today at] LT",
  nextDay: "[Tomorrow at] LT",
  nextWeek: "dddd [at] LT",
  lastDay: "[Yesterday at] LT",
  lastWeek: "[Last] dddd [at] LT",
  sameElse: "L"
};
function calendar(key, mom, now2) {
  var output = this._calendar[key] || this._calendar["sameElse"];
  return isFunction(output) ? output.call(mom, now2) : output;
}
function zeroFill(number, targetLength, forceSign) {
  var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
  return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}
var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
function addFormatToken(token2, padded, ordinal2, callback) {
  var func = callback;
  if (typeof callback === "string") {
    func = function() {
      return this[callback]();
    };
  }
  if (token2) {
    formatTokenFunctions[token2] = func;
  }
  if (padded) {
    formatTokenFunctions[padded[0]] = function() {
      return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
    };
  }
  if (ordinal2) {
    formatTokenFunctions[ordinal2] = function() {
      return this.localeData().ordinal(func.apply(this, arguments), token2);
    };
  }
}
function removeFormattingTokens(input) {
  if (input.match(/\[[\s\S]/)) {
    return input.replace(/^\[|\]$/g, "");
  }
  return input.replace(/\\/g, "");
}
function makeFormatFunction(format2) {
  var array = format2.match(formattingTokens), i2, length;
  for (i2 = 0, length = array.length; i2 < length; i2++) {
    if (formatTokenFunctions[array[i2]]) {
      array[i2] = formatTokenFunctions[array[i2]];
    } else {
      array[i2] = removeFormattingTokens(array[i2]);
    }
  }
  return function(mom) {
    var output = "", i3;
    for (i3 = 0; i3 < length; i3++) {
      output += isFunction(array[i3]) ? array[i3].call(mom, format2) : array[i3];
    }
    return output;
  };
}
function formatMoment(m2, format2) {
  if (!m2.isValid()) {
    return m2.localeData().invalidDate();
  }
  format2 = expandFormat(format2, m2.localeData());
  formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
  return formatFunctions[format2](m2);
}
function expandFormat(format2, locale2) {
  var i2 = 5;
  function replaceLongDateFormatTokens(input) {
    return locale2.longDateFormat(input) || input;
  }
  localFormattingTokens.lastIndex = 0;
  while (i2 >= 0 && localFormattingTokens.test(format2)) {
    format2 = format2.replace(localFormattingTokens, replaceLongDateFormatTokens);
    localFormattingTokens.lastIndex = 0;
    i2 -= 1;
  }
  return format2;
}
var defaultLongDateFormat = {
  LTS: "h:mm:ss A",
  LT: "h:mm A",
  L: "MM/DD/YYYY",
  LL: "MMMM D, YYYY",
  LLL: "MMMM D, YYYY h:mm A",
  LLLL: "dddd, MMMM D, YYYY h:mm A"
};
function longDateFormat(key) {
  var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
  if (format2 || !formatUpper) {
    return format2;
  }
  this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
    if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
      return tok.slice(1);
    }
    return tok;
  }).join("");
  return this._longDateFormat[key];
}
var defaultInvalidDate = "Invalid date";
function invalidDate() {
  return this._invalidDate;
}
var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
function ordinal(number) {
  return this._ordinal.replace("%d", number);
}
var defaultRelativeTime = {
  future: "in %s",
  past: "%s ago",
  s: "a few seconds",
  ss: "%d seconds",
  m: "a minute",
  mm: "%d minutes",
  h: "an hour",
  hh: "%d hours",
  d: "a day",
  dd: "%d days",
  w: "a week",
  ww: "%d weeks",
  M: "a month",
  MM: "%d months",
  y: "a year",
  yy: "%d years"
};
function relativeTime(number, withoutSuffix, string2, isFuture) {
  var output = this._relativeTime[string2];
  return isFunction(output) ? output(number, withoutSuffix, string2, isFuture) : output.replace(/%d/i, number);
}
function pastFuture(diff2, output) {
  var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
  return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
}
var aliases = {};
function addUnitAlias(unit, shorthand) {
  var lowerCase2 = unit.toLowerCase();
  aliases[lowerCase2] = aliases[lowerCase2 + "s"] = aliases[shorthand] = unit;
}
function normalizeUnits(units) {
  return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
}
function normalizeObjectUnits(inputObject) {
  var normalizedInput = {}, normalizedProp, prop;
  for (prop in inputObject) {
    if (hasOwnProp(inputObject, prop)) {
      normalizedProp = normalizeUnits(prop);
      if (normalizedProp) {
        normalizedInput[normalizedProp] = inputObject[prop];
      }
    }
  }
  return normalizedInput;
}
var priorities = {};
function addUnitPriority(unit, priority) {
  priorities[unit] = priority;
}
function getPrioritizedUnits(unitsObj) {
  var units = [], u2;
  for (u2 in unitsObj) {
    if (hasOwnProp(unitsObj, u2)) {
      units.push({ unit: u2, priority: priorities[u2] });
    }
  }
  units.sort(function(a2, b2) {
    return a2.priority - b2.priority;
  });
  return units;
}
function isLeapYear(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
}
function absFloor(number) {
  if (number < 0) {
    return Math.ceil(number) || 0;
  } else {
    return Math.floor(number);
  }
}
function toInt(argumentForCoercion) {
  var coercedNumber = +argumentForCoercion, value = 0;
  if (coercedNumber !== 0 && isFinite(coercedNumber)) {
    value = absFloor(coercedNumber);
  }
  return value;
}
function makeGetSet(unit, keepTime) {
  return function(value) {
    if (value != null) {
      set$1$1(this, unit, value);
      hooks.updateOffset(this, keepTime);
      return this;
    } else {
      return get(this, unit);
    }
  };
}
function get(mom, unit) {
  return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
}
function set$1$1(mom, unit, value) {
  if (mom.isValid() && !isNaN(value)) {
    if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
      value = toInt(value);
      mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value, mom.month(), daysInMonth(value, mom.month()));
    } else {
      mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
    }
  }
}
function stringGet(units) {
  units = normalizeUnits(units);
  if (isFunction(this[units])) {
    return this[units]();
  }
  return this;
}
function stringSet(units, value) {
  if (typeof units === "object") {
    units = normalizeObjectUnits(units);
    var prioritized = getPrioritizedUnits(units), i2;
    for (i2 = 0; i2 < prioritized.length; i2++) {
      this[prioritized[i2].unit](units[prioritized[i2].unit]);
    }
  } else {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
      return this[units](value);
    }
  }
  return this;
}
var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
regexes = {};
function addRegexToken(token2, regex, strictRegex) {
  regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
    return isStrict && strictRegex ? strictRegex : regex;
  };
}
function getParseRegexForToken(token2, config) {
  if (!hasOwnProp(regexes, token2)) {
    return new RegExp(unescapeFormat(token2));
  }
  return regexes[token2](config._strict, config._locale);
}
function unescapeFormat(s2) {
  return regexEscape(s2.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
    return p1 || p2 || p3 || p4;
  }));
}
function regexEscape(s2) {
  return s2.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
var tokens = {};
function addParseToken(token2, callback) {
  var i2, func = callback;
  if (typeof token2 === "string") {
    token2 = [token2];
  }
  if (isNumber(callback)) {
    func = function(input, array) {
      array[callback] = toInt(input);
    };
  }
  for (i2 = 0; i2 < token2.length; i2++) {
    tokens[token2[i2]] = func;
  }
}
function addWeekParseToken(token2, callback) {
  addParseToken(token2, function(input, array, config, token3) {
    config._w = config._w || {};
    callback(input, config._w, config, token3);
  });
}
function addTimeToArrayFromToken(token2, input, config) {
  if (input != null && hasOwnProp(tokens, token2)) {
    tokens[token2](input, config._a, config, token2);
  }
}
var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
function mod(n2, x2) {
  return (n2 % x2 + x2) % x2;
}
var indexOf;
if (Array.prototype.indexOf) {
  indexOf = Array.prototype.indexOf;
} else {
  indexOf = function(o2) {
    var i2;
    for (i2 = 0; i2 < this.length; ++i2) {
      if (this[i2] === o2) {
        return i2;
      }
    }
    return -1;
  };
}
function daysInMonth(year, month) {
  if (isNaN(year) || isNaN(month)) {
    return NaN;
  }
  var modMonth = mod(month, 12);
  year += (month - modMonth) / 12;
  return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
}
addFormatToken("M", ["MM", 2], "Mo", function() {
  return this.month() + 1;
});
addFormatToken("MMM", 0, 0, function(format2) {
  return this.localeData().monthsShort(this, format2);
});
addFormatToken("MMMM", 0, 0, function(format2) {
  return this.localeData().months(this, format2);
});
addUnitAlias("month", "M");
addUnitPriority("month", 8);
addRegexToken("M", match1to2);
addRegexToken("MM", match1to2, match2);
addRegexToken("MMM", function(isStrict, locale2) {
  return locale2.monthsShortRegex(isStrict);
});
addRegexToken("MMMM", function(isStrict, locale2) {
  return locale2.monthsRegex(isStrict);
});
addParseToken(["M", "MM"], function(input, array) {
  array[MONTH] = toInt(input) - 1;
});
addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
  var month = config._locale.monthsParse(input, token2, config._strict);
  if (month != null) {
    array[MONTH] = month;
  } else {
    getParsingFlags(config).invalidMonth = input;
  }
});
var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
function localeMonths(m2, format2) {
  if (!m2) {
    return isArray$2(this._months) ? this._months : this._months["standalone"];
  }
  return isArray$2(this._months) ? this._months[m2.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m2.month()];
}
function localeMonthsShort(m2, format2) {
  if (!m2) {
    return isArray$2(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
  }
  return isArray$2(this._monthsShort) ? this._monthsShort[m2.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m2.month()];
}
function handleStrictParse(monthName, format2, strict) {
  var i2, ii2, mom, llc = monthName.toLocaleLowerCase();
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
    for (i2 = 0; i2 < 12; ++i2) {
      mom = createUTC([2e3, i2]);
      this._shortMonthsParse[i2] = this.monthsShort(mom, "").toLocaleLowerCase();
      this._longMonthsParse[i2] = this.months(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format2 === "MMM") {
      ii2 = indexOf.call(this._shortMonthsParse, llc);
      return ii2 !== -1 ? ii2 : null;
    } else {
      ii2 = indexOf.call(this._longMonthsParse, llc);
      return ii2 !== -1 ? ii2 : null;
    }
  } else {
    if (format2 === "MMM") {
      ii2 = indexOf.call(this._shortMonthsParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf.call(this._longMonthsParse, llc);
      return ii2 !== -1 ? ii2 : null;
    } else {
      ii2 = indexOf.call(this._longMonthsParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf.call(this._shortMonthsParse, llc);
      return ii2 !== -1 ? ii2 : null;
    }
  }
}
function localeMonthsParse(monthName, format2, strict) {
  var i2, mom, regex;
  if (this._monthsParseExact) {
    return handleStrictParse.call(this, monthName, format2, strict);
  }
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
  }
  for (i2 = 0; i2 < 12; i2++) {
    mom = createUTC([2e3, i2]);
    if (strict && !this._longMonthsParse[i2]) {
      this._longMonthsParse[i2] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i");
      this._shortMonthsParse[i2] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i");
    }
    if (!strict && !this._monthsParse[i2]) {
      regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
      this._monthsParse[i2] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format2 === "MMMM" && this._longMonthsParse[i2].test(monthName)) {
      return i2;
    } else if (strict && format2 === "MMM" && this._shortMonthsParse[i2].test(monthName)) {
      return i2;
    } else if (!strict && this._monthsParse[i2].test(monthName)) {
      return i2;
    }
  }
}
function setMonth(mom, value) {
  var dayOfMonth;
  if (!mom.isValid()) {
    return mom;
  }
  if (typeof value === "string") {
    if (/^\d+$/.test(value)) {
      value = toInt(value);
    } else {
      value = mom.localeData().monthsParse(value);
      if (!isNumber(value)) {
        return mom;
      }
    }
  }
  dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
  mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
  return mom;
}
function getSetMonth(value) {
  if (value != null) {
    setMonth(this, value);
    hooks.updateOffset(this, true);
    return this;
  } else {
    return get(this, "Month");
  }
}
function getDaysInMonth() {
  return daysInMonth(this.year(), this.month());
}
function monthsShortRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsShortStrictRegex;
    } else {
      return this._monthsShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsShortRegex")) {
      this._monthsShortRegex = defaultMonthsShortRegex;
    }
    return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
  }
}
function monthsRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsStrictRegex;
    } else {
      return this._monthsRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsRegex")) {
      this._monthsRegex = defaultMonthsRegex;
    }
    return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
  }
}
function computeMonthsParse() {
  function cmpLenRev(a2, b2) {
    return b2.length - a2.length;
  }
  var shortPieces = [], longPieces = [], mixedPieces = [], i2, mom;
  for (i2 = 0; i2 < 12; i2++) {
    mom = createUTC([2e3, i2]);
    shortPieces.push(this.monthsShort(mom, ""));
    longPieces.push(this.months(mom, ""));
    mixedPieces.push(this.months(mom, ""));
    mixedPieces.push(this.monthsShort(mom, ""));
  }
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  for (i2 = 0; i2 < 12; i2++) {
    shortPieces[i2] = regexEscape(shortPieces[i2]);
    longPieces[i2] = regexEscape(longPieces[i2]);
  }
  for (i2 = 0; i2 < 24; i2++) {
    mixedPieces[i2] = regexEscape(mixedPieces[i2]);
  }
  this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._monthsShortRegex = this._monthsRegex;
  this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
  this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
}
addFormatToken("Y", 0, 0, function() {
  var y2 = this.year();
  return y2 <= 9999 ? zeroFill(y2, 4) : "+" + y2;
});
addFormatToken(0, ["YY", 2], 0, function() {
  return this.year() % 100;
});
addFormatToken(0, ["YYYY", 4], 0, "year");
addFormatToken(0, ["YYYYY", 5], 0, "year");
addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
addUnitAlias("year", "y");
addUnitPriority("year", 1);
addRegexToken("Y", matchSigned);
addRegexToken("YY", match1to2, match2);
addRegexToken("YYYY", match1to4, match4);
addRegexToken("YYYYY", match1to6, match6);
addRegexToken("YYYYYY", match1to6, match6);
addParseToken(["YYYYY", "YYYYYY"], YEAR);
addParseToken("YYYY", function(input, array) {
  array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken("YY", function(input, array) {
  array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken("Y", function(input, array) {
  array[YEAR] = parseInt(input, 10);
});
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
hooks.parseTwoDigitYear = function(input) {
  return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
};
var getSetYear = makeGetSet("FullYear", true);
function getIsLeapYear() {
  return isLeapYear(this.year());
}
function createDate(y2, m2, d2, h2, M2, s2, ms2) {
  var date;
  if (y2 < 100 && y2 >= 0) {
    date = new Date(y2 + 400, m2, d2, h2, M2, s2, ms2);
    if (isFinite(date.getFullYear())) {
      date.setFullYear(y2);
    }
  } else {
    date = new Date(y2, m2, d2, h2, M2, s2, ms2);
  }
  return date;
}
function createUTCDate(y2) {
  var date, args;
  if (y2 < 100 && y2 >= 0) {
    args = Array.prototype.slice.call(arguments);
    args[0] = y2 + 400;
    date = new Date(Date.UTC.apply(null, args));
    if (isFinite(date.getUTCFullYear())) {
      date.setUTCFullYear(y2);
    }
  } else {
    date = new Date(Date.UTC.apply(null, arguments));
  }
  return date;
}
function firstWeekOffset(year, dow, doy) {
  var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
  return -fwdlw + fwd - 1;
}
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
  var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
  if (dayOfYear <= 0) {
    resYear = year - 1;
    resDayOfYear = daysInYear(resYear) + dayOfYear;
  } else if (dayOfYear > daysInYear(year)) {
    resYear = year + 1;
    resDayOfYear = dayOfYear - daysInYear(year);
  } else {
    resYear = year;
    resDayOfYear = dayOfYear;
  }
  return {
    year: resYear,
    dayOfYear: resDayOfYear
  };
}
function weekOfYear(mom, dow, doy) {
  var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
  if (week < 1) {
    resYear = mom.year() - 1;
    resWeek = week + weeksInYear(resYear, dow, doy);
  } else if (week > weeksInYear(mom.year(), dow, doy)) {
    resWeek = week - weeksInYear(mom.year(), dow, doy);
    resYear = mom.year() + 1;
  } else {
    resYear = mom.year();
    resWeek = week;
  }
  return {
    week: resWeek,
    year: resYear
  };
}
function weeksInYear(year, dow, doy) {
  var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
  return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}
addFormatToken("w", ["ww", 2], "wo", "week");
addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
addUnitAlias("week", "w");
addUnitAlias("isoWeek", "W");
addUnitPriority("week", 5);
addUnitPriority("isoWeek", 5);
addRegexToken("w", match1to2);
addRegexToken("ww", match1to2, match2);
addRegexToken("W", match1to2);
addRegexToken("WW", match1to2, match2);
addWeekParseToken(["w", "ww", "W", "WW"], function(input, week, config, token2) {
  week[token2.substr(0, 1)] = toInt(input);
});
function localeWeek(mom) {
  return weekOfYear(mom, this._week.dow, this._week.doy).week;
}
var defaultLocaleWeek = {
  dow: 0,
  doy: 6
};
function localeFirstDayOfWeek() {
  return this._week.dow;
}
function localeFirstDayOfYear() {
  return this._week.doy;
}
function getSetWeek(input) {
  var week = this.localeData().week(this);
  return input == null ? week : this.add((input - week) * 7, "d");
}
function getSetISOWeek(input) {
  var week = weekOfYear(this, 1, 4).week;
  return input == null ? week : this.add((input - week) * 7, "d");
}
addFormatToken("d", 0, "do", "day");
addFormatToken("dd", 0, 0, function(format2) {
  return this.localeData().weekdaysMin(this, format2);
});
addFormatToken("ddd", 0, 0, function(format2) {
  return this.localeData().weekdaysShort(this, format2);
});
addFormatToken("dddd", 0, 0, function(format2) {
  return this.localeData().weekdays(this, format2);
});
addFormatToken("e", 0, 0, "weekday");
addFormatToken("E", 0, 0, "isoWeekday");
addUnitAlias("day", "d");
addUnitAlias("weekday", "e");
addUnitAlias("isoWeekday", "E");
addUnitPriority("day", 11);
addUnitPriority("weekday", 11);
addUnitPriority("isoWeekday", 11);
addRegexToken("d", match1to2);
addRegexToken("e", match1to2);
addRegexToken("E", match1to2);
addRegexToken("dd", function(isStrict, locale2) {
  return locale2.weekdaysMinRegex(isStrict);
});
addRegexToken("ddd", function(isStrict, locale2) {
  return locale2.weekdaysShortRegex(isStrict);
});
addRegexToken("dddd", function(isStrict, locale2) {
  return locale2.weekdaysRegex(isStrict);
});
addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
  var weekday = config._locale.weekdaysParse(input, token2, config._strict);
  if (weekday != null) {
    week.d = weekday;
  } else {
    getParsingFlags(config).invalidWeekday = input;
  }
});
addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
  week[token2] = toInt(input);
});
function parseWeekday(input, locale2) {
  if (typeof input !== "string") {
    return input;
  }
  if (!isNaN(input)) {
    return parseInt(input, 10);
  }
  input = locale2.weekdaysParse(input);
  if (typeof input === "number") {
    return input;
  }
  return null;
}
function parseIsoWeekday(input, locale2) {
  if (typeof input === "string") {
    return locale2.weekdaysParse(input) % 7 || 7;
  }
  return isNaN(input) ? null : input;
}
function shiftWeekdays(ws2, n2) {
  return ws2.slice(n2, 7).concat(ws2.slice(0, n2));
}
var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
function localeWeekdays(m2, format2) {
  var weekdays = isArray$2(this._weekdays) ? this._weekdays : this._weekdays[m2 && m2 !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
  return m2 === true ? shiftWeekdays(weekdays, this._week.dow) : m2 ? weekdays[m2.day()] : weekdays;
}
function localeWeekdaysShort(m2) {
  return m2 === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m2 ? this._weekdaysShort[m2.day()] : this._weekdaysShort;
}
function localeWeekdaysMin(m2) {
  return m2 === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m2 ? this._weekdaysMin[m2.day()] : this._weekdaysMin;
}
function handleStrictParse$1(weekdayName, format2, strict) {
  var i2, ii2, mom, llc = weekdayName.toLocaleLowerCase();
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._minWeekdaysParse = [];
    for (i2 = 0; i2 < 7; ++i2) {
      mom = createUTC([2e3, 1]).day(i2);
      this._minWeekdaysParse[i2] = this.weekdaysMin(mom, "").toLocaleLowerCase();
      this._shortWeekdaysParse[i2] = this.weekdaysShort(mom, "").toLocaleLowerCase();
      this._weekdaysParse[i2] = this.weekdays(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format2 === "dddd") {
      ii2 = indexOf.call(this._weekdaysParse, llc);
      return ii2 !== -1 ? ii2 : null;
    } else if (format2 === "ddd") {
      ii2 = indexOf.call(this._shortWeekdaysParse, llc);
      return ii2 !== -1 ? ii2 : null;
    } else {
      ii2 = indexOf.call(this._minWeekdaysParse, llc);
      return ii2 !== -1 ? ii2 : null;
    }
  } else {
    if (format2 === "dddd") {
      ii2 = indexOf.call(this._weekdaysParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf.call(this._minWeekdaysParse, llc);
      return ii2 !== -1 ? ii2 : null;
    } else if (format2 === "ddd") {
      ii2 = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf.call(this._weekdaysParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf.call(this._minWeekdaysParse, llc);
      return ii2 !== -1 ? ii2 : null;
    } else {
      ii2 = indexOf.call(this._minWeekdaysParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf.call(this._weekdaysParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf.call(this._shortWeekdaysParse, llc);
      return ii2 !== -1 ? ii2 : null;
    }
  }
}
function localeWeekdaysParse(weekdayName, format2, strict) {
  var i2, mom, regex;
  if (this._weekdaysParseExact) {
    return handleStrictParse$1.call(this, weekdayName, format2, strict);
  }
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._minWeekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._fullWeekdaysParse = [];
  }
  for (i2 = 0; i2 < 7; i2++) {
    mom = createUTC([2e3, 1]).day(i2);
    if (strict && !this._fullWeekdaysParse[i2]) {
      this._fullWeekdaysParse[i2] = new RegExp("^" + this.weekdays(mom, "").replace(".", "\\.?") + "$", "i");
      this._shortWeekdaysParse[i2] = new RegExp("^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$", "i");
      this._minWeekdaysParse[i2] = new RegExp("^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$", "i");
    }
    if (!this._weekdaysParse[i2]) {
      regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
      this._weekdaysParse[i2] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format2 === "dddd" && this._fullWeekdaysParse[i2].test(weekdayName)) {
      return i2;
    } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i2].test(weekdayName)) {
      return i2;
    } else if (strict && format2 === "dd" && this._minWeekdaysParse[i2].test(weekdayName)) {
      return i2;
    } else if (!strict && this._weekdaysParse[i2].test(weekdayName)) {
      return i2;
    }
  }
}
function getSetDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
  if (input != null) {
    input = parseWeekday(input, this.localeData());
    return this.add(input - day, "d");
  } else {
    return day;
  }
}
function getSetLocaleDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
  return input == null ? weekday : this.add(input - weekday, "d");
}
function getSetISODayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    var weekday = parseIsoWeekday(input, this.localeData());
    return this.day(this.day() % 7 ? weekday : weekday - 7);
  } else {
    return this.day() || 7;
  }
}
function weekdaysRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysStrictRegex;
    } else {
      return this._weekdaysRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      this._weekdaysRegex = defaultWeekdaysRegex;
    }
    return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
  }
}
function weekdaysShortRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysShortStrictRegex;
    } else {
      return this._weekdaysShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysShortRegex")) {
      this._weekdaysShortRegex = defaultWeekdaysShortRegex;
    }
    return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
  }
}
function weekdaysMinRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysMinStrictRegex;
    } else {
      return this._weekdaysMinRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysMinRegex")) {
      this._weekdaysMinRegex = defaultWeekdaysMinRegex;
    }
    return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
  }
}
function computeWeekdaysParse() {
  function cmpLenRev(a2, b2) {
    return b2.length - a2.length;
  }
  var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i2, mom, minp, shortp, longp;
  for (i2 = 0; i2 < 7; i2++) {
    mom = createUTC([2e3, 1]).day(i2);
    minp = regexEscape(this.weekdaysMin(mom, ""));
    shortp = regexEscape(this.weekdaysShort(mom, ""));
    longp = regexEscape(this.weekdays(mom, ""));
    minPieces.push(minp);
    shortPieces.push(shortp);
    longPieces.push(longp);
    mixedPieces.push(minp);
    mixedPieces.push(shortp);
    mixedPieces.push(longp);
  }
  minPieces.sort(cmpLenRev);
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._weekdaysShortRegex = this._weekdaysRegex;
  this._weekdaysMinRegex = this._weekdaysRegex;
  this._weekdaysStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
  this._weekdaysShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
  this._weekdaysMinStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i");
}
function hFormat() {
  return this.hours() % 12 || 12;
}
function kFormat() {
  return this.hours() || 24;
}
addFormatToken("H", ["HH", 2], 0, "hour");
addFormatToken("h", ["hh", 2], 0, hFormat);
addFormatToken("k", ["kk", 2], 0, kFormat);
addFormatToken("hmm", 0, 0, function() {
  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});
addFormatToken("hmmss", 0, 0, function() {
  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});
addFormatToken("Hmm", 0, 0, function() {
  return "" + this.hours() + zeroFill(this.minutes(), 2);
});
addFormatToken("Hmmss", 0, 0, function() {
  return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});
function meridiem(token2, lowercase) {
  addFormatToken(token2, 0, 0, function() {
    return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
  });
}
meridiem("a", true);
meridiem("A", false);
addUnitAlias("hour", "h");
addUnitPriority("hour", 13);
function matchMeridiem(isStrict, locale2) {
  return locale2._meridiemParse;
}
addRegexToken("a", matchMeridiem);
addRegexToken("A", matchMeridiem);
addRegexToken("H", match1to2);
addRegexToken("h", match1to2);
addRegexToken("k", match1to2);
addRegexToken("HH", match1to2, match2);
addRegexToken("hh", match1to2, match2);
addRegexToken("kk", match1to2, match2);
addRegexToken("hmm", match3to4);
addRegexToken("hmmss", match5to6);
addRegexToken("Hmm", match3to4);
addRegexToken("Hmmss", match5to6);
addParseToken(["H", "HH"], HOUR);
addParseToken(["k", "kk"], function(input, array, config) {
  var kInput = toInt(input);
  array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(["a", "A"], function(input, array, config) {
  config._isPm = config._locale.isPM(input);
  config._meridiem = input;
});
addParseToken(["h", "hh"], function(input, array, config) {
  array[HOUR] = toInt(input);
  getParsingFlags(config).bigHour = true;
});
addParseToken("hmm", function(input, array, config) {
  var pos = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos));
  array[MINUTE] = toInt(input.substr(pos));
  getParsingFlags(config).bigHour = true;
});
addParseToken("hmmss", function(input, array, config) {
  var pos1 = input.length - 4, pos2 = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos1));
  array[MINUTE] = toInt(input.substr(pos1, 2));
  array[SECOND] = toInt(input.substr(pos2));
  getParsingFlags(config).bigHour = true;
});
addParseToken("Hmm", function(input, array, config) {
  var pos = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos));
  array[MINUTE] = toInt(input.substr(pos));
});
addParseToken("Hmmss", function(input, array, config) {
  var pos1 = input.length - 4, pos2 = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos1));
  array[MINUTE] = toInt(input.substr(pos1, 2));
  array[SECOND] = toInt(input.substr(pos2));
});
function localeIsPM(input) {
  return (input + "").toLowerCase().charAt(0) === "p";
}
var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
function localeMeridiem(hours2, minutes2, isLower) {
  if (hours2 > 11) {
    return isLower ? "pm" : "PM";
  } else {
    return isLower ? "am" : "AM";
  }
}
var baseConfig = {
  calendar: defaultCalendar,
  longDateFormat: defaultLongDateFormat,
  invalidDate: defaultInvalidDate,
  ordinal: defaultOrdinal,
  dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
  relativeTime: defaultRelativeTime,
  months: defaultLocaleMonths,
  monthsShort: defaultLocaleMonthsShort,
  week: defaultLocaleWeek,
  weekdays: defaultLocaleWeekdays,
  weekdaysMin: defaultLocaleWeekdaysMin,
  weekdaysShort: defaultLocaleWeekdaysShort,
  meridiemParse: defaultLocaleMeridiemParse
};
var locales = {}, localeFamilies = {}, globalLocale;
function commonPrefix(arr1, arr2) {
  var i2, minl = Math.min(arr1.length, arr2.length);
  for (i2 = 0; i2 < minl; i2 += 1) {
    if (arr1[i2] !== arr2[i2]) {
      return i2;
    }
  }
  return minl;
}
function normalizeLocale(key) {
  return key ? key.toLowerCase().replace("_", "-") : key;
}
function chooseLocale(names) {
  var i2 = 0, j2, next, locale2, split;
  while (i2 < names.length) {
    split = normalizeLocale(names[i2]).split("-");
    j2 = split.length;
    next = normalizeLocale(names[i2 + 1]);
    next = next ? next.split("-") : null;
    while (j2 > 0) {
      locale2 = loadLocale(split.slice(0, j2).join("-"));
      if (locale2) {
        return locale2;
      }
      if (next && next.length >= j2 && commonPrefix(split, next) >= j2 - 1) {
        break;
      }
      j2--;
    }
    i2++;
  }
  return globalLocale;
}
function loadLocale(name2) {
  var oldLocale = null, aliasedRequire;
  if (locales[name2] === void 0 && typeof module !== "undefined" && module && module.exports) {
    try {
      oldLocale = globalLocale._abbr;
      aliasedRequire = require;
      aliasedRequire("./locale/" + name2);
      getSetGlobalLocale(oldLocale);
    } catch (e20) {
      locales[name2] = null;
    }
  }
  return locales[name2];
}
function getSetGlobalLocale(key, values) {
  var data;
  if (key) {
    if (isUndefined(values)) {
      data = getLocale(key);
    } else {
      data = defineLocale(key, values);
    }
    if (data) {
      globalLocale = data;
    } else {
      if (typeof console !== "undefined" && console.warn) {
        console.warn("Locale " + key + " not found. Did you forget to load it?");
      }
    }
  }
  return globalLocale._abbr;
}
function defineLocale(name2, config) {
  if (config !== null) {
    var locale2, parentConfig = baseConfig;
    config.abbr = name2;
    if (locales[name2] != null) {
      deprecateSimple("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info.");
      parentConfig = locales[name2]._config;
    } else if (config.parentLocale != null) {
      if (locales[config.parentLocale] != null) {
        parentConfig = locales[config.parentLocale]._config;
      } else {
        locale2 = loadLocale(config.parentLocale);
        if (locale2 != null) {
          parentConfig = locale2._config;
        } else {
          if (!localeFamilies[config.parentLocale]) {
            localeFamilies[config.parentLocale] = [];
          }
          localeFamilies[config.parentLocale].push({
            name: name2,
            config
          });
          return null;
        }
      }
    }
    locales[name2] = new Locale(mergeConfigs(parentConfig, config));
    if (localeFamilies[name2]) {
      localeFamilies[name2].forEach(function(x2) {
        defineLocale(x2.name, x2.config);
      });
    }
    getSetGlobalLocale(name2);
    return locales[name2];
  } else {
    delete locales[name2];
    return null;
  }
}
function updateLocale(name2, config) {
  if (config != null) {
    var locale2, tmpLocale, parentConfig = baseConfig;
    if (locales[name2] != null && locales[name2].parentLocale != null) {
      locales[name2].set(mergeConfigs(locales[name2]._config, config));
    } else {
      tmpLocale = loadLocale(name2);
      if (tmpLocale != null) {
        parentConfig = tmpLocale._config;
      }
      config = mergeConfigs(parentConfig, config);
      if (tmpLocale == null) {
        config.abbr = name2;
      }
      locale2 = new Locale(config);
      locale2.parentLocale = locales[name2];
      locales[name2] = locale2;
    }
    getSetGlobalLocale(name2);
  } else {
    if (locales[name2] != null) {
      if (locales[name2].parentLocale != null) {
        locales[name2] = locales[name2].parentLocale;
        if (name2 === getSetGlobalLocale()) {
          getSetGlobalLocale(name2);
        }
      } else if (locales[name2] != null) {
        delete locales[name2];
      }
    }
  }
  return locales[name2];
}
function getLocale(key) {
  var locale2;
  if (key && key._locale && key._locale._abbr) {
    key = key._locale._abbr;
  }
  if (!key) {
    return globalLocale;
  }
  if (!isArray$2(key)) {
    locale2 = loadLocale(key);
    if (locale2) {
      return locale2;
    }
    key = [key];
  }
  return chooseLocale(key);
}
function listLocales() {
  return keys(locales);
}
function checkOverflow(m2) {
  var overflow, a2 = m2._a;
  if (a2 && getParsingFlags(m2).overflow === -2) {
    overflow = a2[MONTH] < 0 || a2[MONTH] > 11 ? MONTH : a2[DATE] < 1 || a2[DATE] > daysInMonth(a2[YEAR], a2[MONTH]) ? DATE : a2[HOUR] < 0 || a2[HOUR] > 24 || a2[HOUR] === 24 && (a2[MINUTE] !== 0 || a2[SECOND] !== 0 || a2[MILLISECOND] !== 0) ? HOUR : a2[MINUTE] < 0 || a2[MINUTE] > 59 ? MINUTE : a2[SECOND] < 0 || a2[SECOND] > 59 ? SECOND : a2[MILLISECOND] < 0 || a2[MILLISECOND] > 999 ? MILLISECOND : -1;
    if (getParsingFlags(m2)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
      overflow = DATE;
    }
    if (getParsingFlags(m2)._overflowWeeks && overflow === -1) {
      overflow = WEEK;
    }
    if (getParsingFlags(m2)._overflowWeekday && overflow === -1) {
      overflow = WEEKDAY;
    }
    getParsingFlags(m2).overflow = overflow;
  }
  return m2;
}
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
  ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
  ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
  ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
  ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
  ["YYYY-DDD", /\d{4}-\d{3}/],
  ["YYYY-MM", /\d{4}-\d\d/, false],
  ["YYYYYYMMDD", /[+-]\d{10}/],
  ["YYYYMMDD", /\d{8}/],
  ["GGGG[W]WWE", /\d{4}W\d{3}/],
  ["GGGG[W]WW", /\d{4}W\d{2}/, false],
  ["YYYYDDD", /\d{7}/],
  ["YYYYMM", /\d{6}/, false],
  ["YYYY", /\d{4}/, false]
], isoTimes = [
  ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
  ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
  ["HH:mm:ss", /\d\d:\d\d:\d\d/],
  ["HH:mm", /\d\d:\d\d/],
  ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
  ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
  ["HHmmss", /\d\d\d\d\d\d/],
  ["HHmm", /\d\d\d\d/],
  ["HH", /\d\d/]
], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
  UT: 0,
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function configFromISO(config) {
  var i2, l2, string2 = config._i, match5 = extendedIsoRegex.exec(string2) || basicIsoRegex.exec(string2), allowTime, dateFormat, timeFormat, tzFormat;
  if (match5) {
    getParsingFlags(config).iso = true;
    for (i2 = 0, l2 = isoDates.length; i2 < l2; i2++) {
      if (isoDates[i2][1].exec(match5[1])) {
        dateFormat = isoDates[i2][0];
        allowTime = isoDates[i2][2] !== false;
        break;
      }
    }
    if (dateFormat == null) {
      config._isValid = false;
      return;
    }
    if (match5[3]) {
      for (i2 = 0, l2 = isoTimes.length; i2 < l2; i2++) {
        if (isoTimes[i2][1].exec(match5[3])) {
          timeFormat = (match5[2] || " ") + isoTimes[i2][0];
          break;
        }
      }
      if (timeFormat == null) {
        config._isValid = false;
        return;
      }
    }
    if (!allowTime && timeFormat != null) {
      config._isValid = false;
      return;
    }
    if (match5[4]) {
      if (tzRegex.exec(match5[4])) {
        tzFormat = "Z";
      } else {
        config._isValid = false;
        return;
      }
    }
    config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
    configFromStringAndFormat(config);
  } else {
    config._isValid = false;
  }
}
function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  var result = [
    untruncateYear(yearStr),
    defaultLocaleMonthsShort.indexOf(monthStr),
    parseInt(dayStr, 10),
    parseInt(hourStr, 10),
    parseInt(minuteStr, 10)
  ];
  if (secondStr) {
    result.push(parseInt(secondStr, 10));
  }
  return result;
}
function untruncateYear(yearStr) {
  var year = parseInt(yearStr, 10);
  if (year <= 49) {
    return 2e3 + year;
  } else if (year <= 999) {
    return 1900 + year;
  }
  return year;
}
function preprocessRFC2822(s2) {
  return s2.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function checkWeekday(weekdayStr, parsedInput, config) {
  if (weekdayStr) {
    var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
    if (weekdayProvided !== weekdayActual) {
      getParsingFlags(config).weekdayMismatch = true;
      config._isValid = false;
      return false;
    }
  }
  return true;
}
function calculateOffset(obsOffset, militaryOffset, numOffset) {
  if (obsOffset) {
    return obsOffsets[obsOffset];
  } else if (militaryOffset) {
    return 0;
  } else {
    var hm2 = parseInt(numOffset, 10), m2 = hm2 % 100, h2 = (hm2 - m2) / 100;
    return h2 * 60 + m2;
  }
}
function configFromRFC2822(config) {
  var match5 = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
  if (match5) {
    parsedArray = extractFromRFC2822Strings(match5[4], match5[3], match5[2], match5[5], match5[6], match5[7]);
    if (!checkWeekday(match5[1], parsedArray, config)) {
      return;
    }
    config._a = parsedArray;
    config._tzm = calculateOffset(match5[8], match5[9], match5[10]);
    config._d = createUTCDate.apply(null, config._a);
    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    getParsingFlags(config).rfc2822 = true;
  } else {
    config._isValid = false;
  }
}
function configFromString(config) {
  var matched = aspNetJsonRegex.exec(config._i);
  if (matched !== null) {
    config._d = new Date(+matched[1]);
    return;
  }
  configFromISO(config);
  if (config._isValid === false) {
    delete config._isValid;
  } else {
    return;
  }
  configFromRFC2822(config);
  if (config._isValid === false) {
    delete config._isValid;
  } else {
    return;
  }
  if (config._strict) {
    config._isValid = false;
  } else {
    hooks.createFromInputFallback(config);
  }
}
hooks.createFromInputFallback = deprecate("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(config) {
  config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
});
function defaults(a2, b2, c2) {
  if (a2 != null) {
    return a2;
  }
  if (b2 != null) {
    return b2;
  }
  return c2;
}
function currentDateArray(config) {
  var nowValue = new Date(hooks.now());
  if (config._useUTC) {
    return [
      nowValue.getUTCFullYear(),
      nowValue.getUTCMonth(),
      nowValue.getUTCDate()
    ];
  }
  return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}
function configFromArray(config) {
  var i2, date, input = [], currentDate, expectedWeekday, yearToUse;
  if (config._d) {
    return;
  }
  currentDate = currentDateArray(config);
  if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
    dayOfYearFromWeekInfo(config);
  }
  if (config._dayOfYear != null) {
    yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
    if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
      getParsingFlags(config)._overflowDayOfYear = true;
    }
    date = createUTCDate(yearToUse, 0, config._dayOfYear);
    config._a[MONTH] = date.getUTCMonth();
    config._a[DATE] = date.getUTCDate();
  }
  for (i2 = 0; i2 < 3 && config._a[i2] == null; ++i2) {
    config._a[i2] = input[i2] = currentDate[i2];
  }
  for (; i2 < 7; i2++) {
    config._a[i2] = input[i2] = config._a[i2] == null ? i2 === 2 ? 1 : 0 : config._a[i2];
  }
  if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
    config._nextDay = true;
    config._a[HOUR] = 0;
  }
  config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
  expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
  if (config._tzm != null) {
    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
  }
  if (config._nextDay) {
    config._a[HOUR] = 24;
  }
  if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
    getParsingFlags(config).weekdayMismatch = true;
  }
}
function dayOfYearFromWeekInfo(config) {
  var w2, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
  w2 = config._w;
  if (w2.GG != null || w2.W != null || w2.E != null) {
    dow = 1;
    doy = 4;
    weekYear = defaults(w2.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
    week = defaults(w2.W, 1);
    weekday = defaults(w2.E, 1);
    if (weekday < 1 || weekday > 7) {
      weekdayOverflow = true;
    }
  } else {
    dow = config._locale._week.dow;
    doy = config._locale._week.doy;
    curWeek = weekOfYear(createLocal(), dow, doy);
    weekYear = defaults(w2.gg, config._a[YEAR], curWeek.year);
    week = defaults(w2.w, curWeek.week);
    if (w2.d != null) {
      weekday = w2.d;
      if (weekday < 0 || weekday > 6) {
        weekdayOverflow = true;
      }
    } else if (w2.e != null) {
      weekday = w2.e + dow;
      if (w2.e < 0 || w2.e > 6) {
        weekdayOverflow = true;
      }
    } else {
      weekday = dow;
    }
  }
  if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
    getParsingFlags(config)._overflowWeeks = true;
  } else if (weekdayOverflow != null) {
    getParsingFlags(config)._overflowWeekday = true;
  } else {
    temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
    config._a[YEAR] = temp.year;
    config._dayOfYear = temp.dayOfYear;
  }
}
hooks.ISO_8601 = function() {
};
hooks.RFC_2822 = function() {
};
function configFromStringAndFormat(config) {
  if (config._f === hooks.ISO_8601) {
    configFromISO(config);
    return;
  }
  if (config._f === hooks.RFC_2822) {
    configFromRFC2822(config);
    return;
  }
  config._a = [];
  getParsingFlags(config).empty = true;
  var string2 = "" + config._i, i2, parsedInput, tokens2, token2, skipped, stringLength = string2.length, totalParsedInputLength = 0, era;
  tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
  for (i2 = 0; i2 < tokens2.length; i2++) {
    token2 = tokens2[i2];
    parsedInput = (string2.match(getParseRegexForToken(token2, config)) || [])[0];
    if (parsedInput) {
      skipped = string2.substr(0, string2.indexOf(parsedInput));
      if (skipped.length > 0) {
        getParsingFlags(config).unusedInput.push(skipped);
      }
      string2 = string2.slice(string2.indexOf(parsedInput) + parsedInput.length);
      totalParsedInputLength += parsedInput.length;
    }
    if (formatTokenFunctions[token2]) {
      if (parsedInput) {
        getParsingFlags(config).empty = false;
      } else {
        getParsingFlags(config).unusedTokens.push(token2);
      }
      addTimeToArrayFromToken(token2, parsedInput, config);
    } else if (config._strict && !parsedInput) {
      getParsingFlags(config).unusedTokens.push(token2);
    }
  }
  getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
  if (string2.length > 0) {
    getParsingFlags(config).unusedInput.push(string2);
  }
  if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
    getParsingFlags(config).bigHour = void 0;
  }
  getParsingFlags(config).parsedDateParts = config._a.slice(0);
  getParsingFlags(config).meridiem = config._meridiem;
  config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
  era = getParsingFlags(config).era;
  if (era !== null) {
    config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
  }
  configFromArray(config);
  checkOverflow(config);
}
function meridiemFixWrap(locale2, hour, meridiem2) {
  var isPm;
  if (meridiem2 == null) {
    return hour;
  }
  if (locale2.meridiemHour != null) {
    return locale2.meridiemHour(hour, meridiem2);
  } else if (locale2.isPM != null) {
    isPm = locale2.isPM(meridiem2);
    if (isPm && hour < 12) {
      hour += 12;
    }
    if (!isPm && hour === 12) {
      hour = 0;
    }
    return hour;
  } else {
    return hour;
  }
}
function configFromStringAndArray(config) {
  var tempConfig, bestMoment, scoreToBeat, i2, currentScore, validFormatFound, bestFormatIsValid = false;
  if (config._f.length === 0) {
    getParsingFlags(config).invalidFormat = true;
    config._d = new Date(NaN);
    return;
  }
  for (i2 = 0; i2 < config._f.length; i2++) {
    currentScore = 0;
    validFormatFound = false;
    tempConfig = copyConfig({}, config);
    if (config._useUTC != null) {
      tempConfig._useUTC = config._useUTC;
    }
    tempConfig._f = config._f[i2];
    configFromStringAndFormat(tempConfig);
    if (isValid(tempConfig)) {
      validFormatFound = true;
    }
    currentScore += getParsingFlags(tempConfig).charsLeftOver;
    currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
    getParsingFlags(tempConfig).score = currentScore;
    if (!bestFormatIsValid) {
      if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
        if (validFormatFound) {
          bestFormatIsValid = true;
        }
      }
    } else {
      if (currentScore < scoreToBeat) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
      }
    }
  }
  extend(config, bestMoment || tempConfig);
}
function configFromObject(config) {
  if (config._d) {
    return;
  }
  var i2 = normalizeObjectUnits(config._i), dayOrDate = i2.day === void 0 ? i2.date : i2.day;
  config._a = map([i2.year, i2.month, dayOrDate, i2.hour, i2.minute, i2.second, i2.millisecond], function(obj2) {
    return obj2 && parseInt(obj2, 10);
  });
  configFromArray(config);
}
function createFromConfig(config) {
  var res = new Moment(checkOverflow(prepareConfig(config)));
  if (res._nextDay) {
    res.add(1, "d");
    res._nextDay = void 0;
  }
  return res;
}
function prepareConfig(config) {
  var input = config._i, format2 = config._f;
  config._locale = config._locale || getLocale(config._l);
  if (input === null || format2 === void 0 && input === "") {
    return createInvalid({ nullInput: true });
  }
  if (typeof input === "string") {
    config._i = input = config._locale.preparse(input);
  }
  if (isMoment(input)) {
    return new Moment(checkOverflow(input));
  } else if (isDate(input)) {
    config._d = input;
  } else if (isArray$2(format2)) {
    configFromStringAndArray(config);
  } else if (format2) {
    configFromStringAndFormat(config);
  } else {
    configFromInput(config);
  }
  if (!isValid(config)) {
    config._d = null;
  }
  return config;
}
function configFromInput(config) {
  var input = config._i;
  if (isUndefined(input)) {
    config._d = new Date(hooks.now());
  } else if (isDate(input)) {
    config._d = new Date(input.valueOf());
  } else if (typeof input === "string") {
    configFromString(config);
  } else if (isArray$2(input)) {
    config._a = map(input.slice(0), function(obj2) {
      return parseInt(obj2, 10);
    });
    configFromArray(config);
  } else if (isObject(input)) {
    configFromObject(config);
  } else if (isNumber(input)) {
    config._d = new Date(input);
  } else {
    hooks.createFromInputFallback(config);
  }
}
function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
  var c2 = {};
  if (format2 === true || format2 === false) {
    strict = format2;
    format2 = void 0;
  }
  if (locale2 === true || locale2 === false) {
    strict = locale2;
    locale2 = void 0;
  }
  if (isObject(input) && isObjectEmpty(input) || isArray$2(input) && input.length === 0) {
    input = void 0;
  }
  c2._isAMomentObject = true;
  c2._useUTC = c2._isUTC = isUTC;
  c2._l = locale2;
  c2._i = input;
  c2._f = format2;
  c2._strict = strict;
  return createFromConfig(c2);
}
function createLocal(input, format2, locale2, strict) {
  return createLocalOrUTC(input, format2, locale2, strict, false);
}
var prototypeMin = deprecate("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
  var other = createLocal.apply(null, arguments);
  if (this.isValid() && other.isValid()) {
    return other < this ? this : other;
  } else {
    return createInvalid();
  }
}), prototypeMax = deprecate("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
  var other = createLocal.apply(null, arguments);
  if (this.isValid() && other.isValid()) {
    return other > this ? this : other;
  } else {
    return createInvalid();
  }
});
function pickBy(fn2, moments) {
  var res, i2;
  if (moments.length === 1 && isArray$2(moments[0])) {
    moments = moments[0];
  }
  if (!moments.length) {
    return createLocal();
  }
  res = moments[0];
  for (i2 = 1; i2 < moments.length; ++i2) {
    if (!moments[i2].isValid() || moments[i2][fn2](res)) {
      res = moments[i2];
    }
  }
  return res;
}
function min() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isBefore", args);
}
function max() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isAfter", args);
}
var now = function() {
  return Date.now ? Date.now() : +new Date();
};
var ordering = [
  "year",
  "quarter",
  "month",
  "week",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
function isDurationValid(m2) {
  var key, unitHasDecimal = false, i2;
  for (key in m2) {
    if (hasOwnProp(m2, key) && !(indexOf.call(ordering, key) !== -1 && (m2[key] == null || !isNaN(m2[key])))) {
      return false;
    }
  }
  for (i2 = 0; i2 < ordering.length; ++i2) {
    if (m2[ordering[i2]]) {
      if (unitHasDecimal) {
        return false;
      }
      if (parseFloat(m2[ordering[i2]]) !== toInt(m2[ordering[i2]])) {
        unitHasDecimal = true;
      }
    }
  }
  return true;
}
function isValid$1() {
  return this._isValid;
}
function createInvalid$1() {
  return createDuration(NaN);
}
function Duration(duration) {
  var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
  this._isValid = isDurationValid(normalizedInput);
  this._milliseconds = +milliseconds2 + seconds2 * 1e3 + minutes2 * 6e4 + hours2 * 1e3 * 60 * 60;
  this._days = +days2 + weeks2 * 7;
  this._months = +months2 + quarters * 3 + years2 * 12;
  this._data = {};
  this._locale = getLocale();
  this._bubble();
}
function isDuration(obj2) {
  return obj2 instanceof Duration;
}
function absRound(number) {
  if (number < 0) {
    return Math.round(-1 * number) * -1;
  } else {
    return Math.round(number);
  }
}
function compareArrays(array1, array2, dontConvert) {
  var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i2;
  for (i2 = 0; i2 < len; i2++) {
    if (dontConvert && array1[i2] !== array2[i2] || !dontConvert && toInt(array1[i2]) !== toInt(array2[i2])) {
      diffs++;
    }
  }
  return diffs + lengthDiff;
}
function offset$1(token2, separator) {
  addFormatToken(token2, 0, 0, function() {
    var offset2 = this.utcOffset(), sign2 = "+";
    if (offset2 < 0) {
      offset2 = -offset2;
      sign2 = "-";
    }
    return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
  });
}
offset$1("Z", ":");
offset$1("ZZ", "");
addRegexToken("Z", matchShortOffset);
addRegexToken("ZZ", matchShortOffset);
addParseToken(["Z", "ZZ"], function(input, array, config) {
  config._useUTC = true;
  config._tzm = offsetFromString(matchShortOffset, input);
});
var chunkOffset = /([\+\-]|\d\d)/gi;
function offsetFromString(matcher, string2) {
  var matches2 = (string2 || "").match(matcher), chunk, parts, minutes2;
  if (matches2 === null) {
    return null;
  }
  chunk = matches2[matches2.length - 1] || [];
  parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
  minutes2 = +(parts[1] * 60) + toInt(parts[2]);
  return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
}
function cloneWithOffset(input, model) {
  var res, diff2;
  if (model._isUTC) {
    res = model.clone();
    diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
    res._d.setTime(res._d.valueOf() + diff2);
    hooks.updateOffset(res, false);
    return res;
  } else {
    return createLocal(input).local();
  }
}
function getDateOffset(m2) {
  return -Math.round(m2._d.getTimezoneOffset());
}
hooks.updateOffset = function() {
};
function getSetOffset(input, keepLocalTime, keepMinutes) {
  var offset2 = this._offset || 0, localAdjust;
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    if (typeof input === "string") {
      input = offsetFromString(matchShortOffset, input);
      if (input === null) {
        return this;
      }
    } else if (Math.abs(input) < 16 && !keepMinutes) {
      input = input * 60;
    }
    if (!this._isUTC && keepLocalTime) {
      localAdjust = getDateOffset(this);
    }
    this._offset = input;
    this._isUTC = true;
    if (localAdjust != null) {
      this.add(localAdjust, "m");
    }
    if (offset2 !== input) {
      if (!keepLocalTime || this._changeInProgress) {
        addSubtract(this, createDuration(input - offset2, "m"), 1, false);
      } else if (!this._changeInProgress) {
        this._changeInProgress = true;
        hooks.updateOffset(this, true);
        this._changeInProgress = null;
      }
    }
    return this;
  } else {
    return this._isUTC ? offset2 : getDateOffset(this);
  }
}
function getSetZone(input, keepLocalTime) {
  if (input != null) {
    if (typeof input !== "string") {
      input = -input;
    }
    this.utcOffset(input, keepLocalTime);
    return this;
  } else {
    return -this.utcOffset();
  }
}
function setOffsetToUTC(keepLocalTime) {
  return this.utcOffset(0, keepLocalTime);
}
function setOffsetToLocal(keepLocalTime) {
  if (this._isUTC) {
    this.utcOffset(0, keepLocalTime);
    this._isUTC = false;
    if (keepLocalTime) {
      this.subtract(getDateOffset(this), "m");
    }
  }
  return this;
}
function setOffsetToParsedOffset() {
  if (this._tzm != null) {
    this.utcOffset(this._tzm, false, true);
  } else if (typeof this._i === "string") {
    var tZone = offsetFromString(matchOffset, this._i);
    if (tZone != null) {
      this.utcOffset(tZone);
    } else {
      this.utcOffset(0, true);
    }
  }
  return this;
}
function hasAlignedHourOffset(input) {
  if (!this.isValid()) {
    return false;
  }
  input = input ? createLocal(input).utcOffset() : 0;
  return (this.utcOffset() - input) % 60 === 0;
}
function isDaylightSavingTime() {
  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}
function isDaylightSavingTimeShifted() {
  if (!isUndefined(this._isDSTShifted)) {
    return this._isDSTShifted;
  }
  var c2 = {}, other;
  copyConfig(c2, this);
  c2 = prepareConfig(c2);
  if (c2._a) {
    other = c2._isUTC ? createUTC(c2._a) : createLocal(c2._a);
    this._isDSTShifted = this.isValid() && compareArrays(c2._a, other.toArray()) > 0;
  } else {
    this._isDSTShifted = false;
  }
  return this._isDSTShifted;
}
function isLocal() {
  return this.isValid() ? !this._isUTC : false;
}
function isUtcOffset() {
  return this.isValid() ? this._isUTC : false;
}
function isUtc() {
  return this.isValid() ? this._isUTC && this._offset === 0 : false;
}
var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function createDuration(input, key) {
  var duration = input, match5 = null, sign2, ret, diffRes;
  if (isDuration(input)) {
    duration = {
      ms: input._milliseconds,
      d: input._days,
      M: input._months
    };
  } else if (isNumber(input) || !isNaN(+input)) {
    duration = {};
    if (key) {
      duration[key] = +input;
    } else {
      duration.milliseconds = +input;
    }
  } else if (match5 = aspNetRegex.exec(input)) {
    sign2 = match5[1] === "-" ? -1 : 1;
    duration = {
      y: 0,
      d: toInt(match5[DATE]) * sign2,
      h: toInt(match5[HOUR]) * sign2,
      m: toInt(match5[MINUTE]) * sign2,
      s: toInt(match5[SECOND]) * sign2,
      ms: toInt(absRound(match5[MILLISECOND] * 1e3)) * sign2
    };
  } else if (match5 = isoRegex.exec(input)) {
    sign2 = match5[1] === "-" ? -1 : 1;
    duration = {
      y: parseIso(match5[2], sign2),
      M: parseIso(match5[3], sign2),
      w: parseIso(match5[4], sign2),
      d: parseIso(match5[5], sign2),
      h: parseIso(match5[6], sign2),
      m: parseIso(match5[7], sign2),
      s: parseIso(match5[8], sign2)
    };
  } else if (duration == null) {
    duration = {};
  } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
    diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
    duration = {};
    duration.ms = diffRes.milliseconds;
    duration.M = diffRes.months;
  }
  ret = new Duration(duration);
  if (isDuration(input) && hasOwnProp(input, "_locale")) {
    ret._locale = input._locale;
  }
  if (isDuration(input) && hasOwnProp(input, "_isValid")) {
    ret._isValid = input._isValid;
  }
  return ret;
}
createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;
function parseIso(inp, sign2) {
  var res = inp && parseFloat(inp.replace(",", "."));
  return (isNaN(res) ? 0 : res) * sign2;
}
function positiveMomentsDifference(base, other) {
  var res = {};
  res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
  if (base.clone().add(res.months, "M").isAfter(other)) {
    --res.months;
  }
  res.milliseconds = +other - +base.clone().add(res.months, "M");
  return res;
}
function momentsDifference(base, other) {
  var res;
  if (!(base.isValid() && other.isValid())) {
    return { milliseconds: 0, months: 0 };
  }
  other = cloneWithOffset(other, base);
  if (base.isBefore(other)) {
    res = positiveMomentsDifference(base, other);
  } else {
    res = positiveMomentsDifference(other, base);
    res.milliseconds = -res.milliseconds;
    res.months = -res.months;
  }
  return res;
}
function createAdder(direction, name2) {
  return function(val, period) {
    var dur, tmp2;
    if (period !== null && !isNaN(+period)) {
      deprecateSimple(name2, "moment()." + name2 + "(period, number) is deprecated. Please use moment()." + name2 + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.");
      tmp2 = val;
      val = period;
      period = tmp2;
    }
    dur = createDuration(val, period);
    addSubtract(this, dur, direction);
    return this;
  };
}
function addSubtract(mom, duration, isAdding, updateOffset) {
  var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
  if (!mom.isValid()) {
    return;
  }
  updateOffset = updateOffset == null ? true : updateOffset;
  if (months2) {
    setMonth(mom, get(mom, "Month") + months2 * isAdding);
  }
  if (days2) {
    set$1$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
  }
  if (milliseconds2) {
    mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
  }
  if (updateOffset) {
    hooks.updateOffset(mom, days2 || months2);
  }
}
var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
function isString(input) {
  return typeof input === "string" || input instanceof String;
}
function isMomentInput(input) {
  return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
}
function isMomentInputObject(input) {
  var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
    "years",
    "year",
    "y",
    "months",
    "month",
    "M",
    "days",
    "day",
    "d",
    "dates",
    "date",
    "D",
    "hours",
    "hour",
    "h",
    "minutes",
    "minute",
    "m",
    "seconds",
    "second",
    "s",
    "milliseconds",
    "millisecond",
    "ms"
  ], i2, property2;
  for (i2 = 0; i2 < properties.length; i2 += 1) {
    property2 = properties[i2];
    propertyTest = propertyTest || hasOwnProp(input, property2);
  }
  return objectTest && propertyTest;
}
function isNumberOrStringArray(input) {
  var arrayTest = isArray$2(input), dataTypeTest = false;
  if (arrayTest) {
    dataTypeTest = input.filter(function(item) {
      return !isNumber(item) && isString(input);
    }).length === 0;
  }
  return arrayTest && dataTypeTest;
}
function isCalendarSpec(input) {
  var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
    "sameDay",
    "nextDay",
    "lastDay",
    "nextWeek",
    "lastWeek",
    "sameElse"
  ], i2, property2;
  for (i2 = 0; i2 < properties.length; i2 += 1) {
    property2 = properties[i2];
    propertyTest = propertyTest || hasOwnProp(input, property2);
  }
  return objectTest && propertyTest;
}
function getCalendarFormat(myMoment, now2) {
  var diff2 = myMoment.diff(now2, "days", true);
  return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
}
function calendar$1(time, formats) {
  if (arguments.length === 1) {
    if (!arguments[0]) {
      time = void 0;
      formats = void 0;
    } else if (isMomentInput(arguments[0])) {
      time = arguments[0];
      formats = void 0;
    } else if (isCalendarSpec(arguments[0])) {
      formats = arguments[0];
      time = void 0;
    }
  }
  var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
  return this.format(output || this.localeData().calendar(format2, this, createLocal(now2)));
}
function clone$1() {
  return new Moment(this);
}
function isAfter(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() > localInput.valueOf();
  } else {
    return localInput.valueOf() < this.clone().startOf(units).valueOf();
  }
}
function isBefore(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() < localInput.valueOf();
  } else {
    return this.clone().endOf(units).valueOf() < localInput.valueOf();
  }
}
function isBetween(from2, to2, units, inclusivity) {
  var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
  if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
    return false;
  }
  inclusivity = inclusivity || "()";
  return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
}
function isSame(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input), inputMs;
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() === localInput.valueOf();
  } else {
    inputMs = localInput.valueOf();
    return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
  }
}
function isSameOrAfter(input, units) {
  return this.isSame(input, units) || this.isAfter(input, units);
}
function isSameOrBefore(input, units) {
  return this.isSame(input, units) || this.isBefore(input, units);
}
function diff(input, units, asFloat) {
  var that, zoneDelta, output;
  if (!this.isValid()) {
    return NaN;
  }
  that = cloneWithOffset(input, this);
  if (!that.isValid()) {
    return NaN;
  }
  zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
  units = normalizeUnits(units);
  switch (units) {
    case "year":
      output = monthDiff(this, that) / 12;
      break;
    case "month":
      output = monthDiff(this, that);
      break;
    case "quarter":
      output = monthDiff(this, that) / 3;
      break;
    case "second":
      output = (this - that) / 1e3;
      break;
    case "minute":
      output = (this - that) / 6e4;
      break;
    case "hour":
      output = (this - that) / 36e5;
      break;
    case "day":
      output = (this - that - zoneDelta) / 864e5;
      break;
    case "week":
      output = (this - that - zoneDelta) / 6048e5;
      break;
    default:
      output = this - that;
  }
  return asFloat ? output : absFloor(output);
}
function monthDiff(a2, b2) {
  if (a2.date() < b2.date()) {
    return -monthDiff(b2, a2);
  }
  var wholeMonthDiff = (b2.year() - a2.year()) * 12 + (b2.month() - a2.month()), anchor = a2.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
  if (b2 - anchor < 0) {
    anchor2 = a2.clone().add(wholeMonthDiff - 1, "months");
    adjust = (b2 - anchor) / (anchor - anchor2);
  } else {
    anchor2 = a2.clone().add(wholeMonthDiff + 1, "months");
    adjust = (b2 - anchor) / (anchor2 - anchor);
  }
  return -(wholeMonthDiff + adjust) || 0;
}
hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
function toString$2() {
  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
}
function toISOString(keepOffset) {
  if (!this.isValid()) {
    return null;
  }
  var utc = keepOffset !== true, m2 = utc ? this.clone().utc() : this;
  if (m2.year() < 0 || m2.year() > 9999) {
    return formatMoment(m2, utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ");
  }
  if (isFunction(Date.prototype.toISOString)) {
    if (utc) {
      return this.toDate().toISOString();
    } else {
      return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m2, "Z"));
    }
  }
  return formatMoment(m2, utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
}
function inspect() {
  if (!this.isValid()) {
    return "moment.invalid(/* " + this._i + " */)";
  }
  var func = "moment", zone = "", prefix, year, datetime, suffix;
  if (!this.isLocal()) {
    func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
    zone = "Z";
  }
  prefix = "[" + func + '("]';
  year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
  datetime = "-MM-DD[T]HH:mm:ss.SSS";
  suffix = zone + '[")]';
  return this.format(prefix + year + datetime + suffix);
}
function format$1(inputString) {
  if (!inputString) {
    inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
  }
  var output = formatMoment(this, inputString);
  return this.localeData().postformat(output);
}
function from(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function fromNow(withoutSuffix) {
  return this.from(createLocal(), withoutSuffix);
}
function to(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function toNow(withoutSuffix) {
  return this.to(createLocal(), withoutSuffix);
}
function locale(key) {
  var newLocaleData;
  if (key === void 0) {
    return this._locale._abbr;
  } else {
    newLocaleData = getLocale(key);
    if (newLocaleData != null) {
      this._locale = newLocaleData;
    }
    return this;
  }
}
var lang = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key) {
  if (key === void 0) {
    return this.localeData();
  } else {
    return this.locale(key);
  }
});
function localeData() {
  return this._locale;
}
var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
function mod$1(dividend, divisor) {
  return (dividend % divisor + divisor) % divisor;
}
function localStartOfDate(y2, m2, d2) {
  if (y2 < 100 && y2 >= 0) {
    return new Date(y2 + 400, m2, d2) - MS_PER_400_YEARS;
  } else {
    return new Date(y2, m2, d2).valueOf();
  }
}
function utcStartOfDate(y2, m2, d2) {
  if (y2 < 100 && y2 >= 0) {
    return Date.UTC(y2 + 400, m2, d2) - MS_PER_400_YEARS;
  } else {
    return Date.UTC(y2, m2, d2);
  }
}
function startOf(units) {
  var time, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year(), 0, 1);
      break;
    case "quarter":
      time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
      break;
    case "month":
      time = startOfDate(this.year(), this.month(), 1);
      break;
    case "week":
      time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
      break;
    case "isoWeek":
      time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date());
      break;
    case "hour":
      time = this._d.valueOf();
      time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
      break;
    case "minute":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_MINUTE);
      break;
    case "second":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_SECOND);
      break;
  }
  this._d.setTime(time);
  hooks.updateOffset(this, true);
  return this;
}
function endOf(units) {
  var time, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year() + 1, 0, 1) - 1;
      break;
    case "quarter":
      time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
      break;
    case "month":
      time = startOfDate(this.year(), this.month() + 1, 1) - 1;
      break;
    case "week":
      time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
      break;
    case "isoWeek":
      time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
      break;
    case "hour":
      time = this._d.valueOf();
      time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
      break;
    case "minute":
      time = this._d.valueOf();
      time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
      break;
    case "second":
      time = this._d.valueOf();
      time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
      break;
  }
  this._d.setTime(time);
  hooks.updateOffset(this, true);
  return this;
}
function valueOf() {
  return this._d.valueOf() - (this._offset || 0) * 6e4;
}
function unix() {
  return Math.floor(this.valueOf() / 1e3);
}
function toDate() {
  return new Date(this.valueOf());
}
function toArray() {
  var m2 = this;
  return [
    m2.year(),
    m2.month(),
    m2.date(),
    m2.hour(),
    m2.minute(),
    m2.second(),
    m2.millisecond()
  ];
}
function toObject() {
  var m2 = this;
  return {
    years: m2.year(),
    months: m2.month(),
    date: m2.date(),
    hours: m2.hours(),
    minutes: m2.minutes(),
    seconds: m2.seconds(),
    milliseconds: m2.milliseconds()
  };
}
function toJSON$2() {
  return this.isValid() ? this.toISOString() : null;
}
function isValid$2() {
  return isValid(this);
}
function parsingFlags() {
  return extend({}, getParsingFlags(this));
}
function invalidAt() {
  return getParsingFlags(this).overflow;
}
function creationData() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict
  };
}
addFormatToken("N", 0, 0, "eraAbbr");
addFormatToken("NN", 0, 0, "eraAbbr");
addFormatToken("NNN", 0, 0, "eraAbbr");
addFormatToken("NNNN", 0, 0, "eraName");
addFormatToken("NNNNN", 0, 0, "eraNarrow");
addFormatToken("y", ["y", 1], "yo", "eraYear");
addFormatToken("y", ["yy", 2], 0, "eraYear");
addFormatToken("y", ["yyy", 3], 0, "eraYear");
addFormatToken("y", ["yyyy", 4], 0, "eraYear");
addRegexToken("N", matchEraAbbr);
addRegexToken("NN", matchEraAbbr);
addRegexToken("NNN", matchEraAbbr);
addRegexToken("NNNN", matchEraName);
addRegexToken("NNNNN", matchEraNarrow);
addParseToken(["N", "NN", "NNN", "NNNN", "NNNNN"], function(input, array, config, token2) {
  var era = config._locale.erasParse(input, token2, config._strict);
  if (era) {
    getParsingFlags(config).era = era;
  } else {
    getParsingFlags(config).invalidEra = input;
  }
});
addRegexToken("y", matchUnsigned);
addRegexToken("yy", matchUnsigned);
addRegexToken("yyy", matchUnsigned);
addRegexToken("yyyy", matchUnsigned);
addRegexToken("yo", matchEraYearOrdinal);
addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
addParseToken(["yo"], function(input, array, config, token2) {
  var match5;
  if (config._locale._eraYearOrdinalRegex) {
    match5 = input.match(config._locale._eraYearOrdinalRegex);
  }
  if (config._locale.eraYearOrdinalParse) {
    array[YEAR] = config._locale.eraYearOrdinalParse(input, match5);
  } else {
    array[YEAR] = parseInt(input, 10);
  }
});
function localeEras(m2, format2) {
  var i2, l2, date, eras = this._eras || getLocale("en")._eras;
  for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
    switch (typeof eras[i2].since) {
      case "string":
        date = hooks(eras[i2].since).startOf("day");
        eras[i2].since = date.valueOf();
        break;
    }
    switch (typeof eras[i2].until) {
      case "undefined":
        eras[i2].until = Infinity;
        break;
      case "string":
        date = hooks(eras[i2].until).startOf("day").valueOf();
        eras[i2].until = date.valueOf();
        break;
    }
  }
  return eras;
}
function localeErasParse(eraName, format2, strict) {
  var i2, l2, eras = this.eras(), name2, abbr, narrow;
  eraName = eraName.toUpperCase();
  for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
    name2 = eras[i2].name.toUpperCase();
    abbr = eras[i2].abbr.toUpperCase();
    narrow = eras[i2].narrow.toUpperCase();
    if (strict) {
      switch (format2) {
        case "N":
        case "NN":
        case "NNN":
          if (abbr === eraName) {
            return eras[i2];
          }
          break;
        case "NNNN":
          if (name2 === eraName) {
            return eras[i2];
          }
          break;
        case "NNNNN":
          if (narrow === eraName) {
            return eras[i2];
          }
          break;
      }
    } else if ([name2, abbr, narrow].indexOf(eraName) >= 0) {
      return eras[i2];
    }
  }
}
function localeErasConvertYear(era, year) {
  var dir = era.since <= era.until ? 1 : -1;
  if (year === void 0) {
    return hooks(era.since).year();
  } else {
    return hooks(era.since).year() + (year - era.offset) * dir;
  }
}
function getEraName() {
  var i2, l2, val, eras = this.localeData().eras();
  for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i2].since <= val && val <= eras[i2].until) {
      return eras[i2].name;
    }
    if (eras[i2].until <= val && val <= eras[i2].since) {
      return eras[i2].name;
    }
  }
  return "";
}
function getEraNarrow() {
  var i2, l2, val, eras = this.localeData().eras();
  for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i2].since <= val && val <= eras[i2].until) {
      return eras[i2].narrow;
    }
    if (eras[i2].until <= val && val <= eras[i2].since) {
      return eras[i2].narrow;
    }
  }
  return "";
}
function getEraAbbr() {
  var i2, l2, val, eras = this.localeData().eras();
  for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i2].since <= val && val <= eras[i2].until) {
      return eras[i2].abbr;
    }
    if (eras[i2].until <= val && val <= eras[i2].since) {
      return eras[i2].abbr;
    }
  }
  return "";
}
function getEraYear() {
  var i2, l2, dir, val, eras = this.localeData().eras();
  for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
    dir = eras[i2].since <= eras[i2].until ? 1 : -1;
    val = this.clone().startOf("day").valueOf();
    if (eras[i2].since <= val && val <= eras[i2].until || eras[i2].until <= val && val <= eras[i2].since) {
      return (this.year() - hooks(eras[i2].since).year()) * dir + eras[i2].offset;
    }
  }
  return this.year();
}
function erasNameRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNameRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNameRegex : this._erasRegex;
}
function erasAbbrRegex(isStrict) {
  if (!hasOwnProp(this, "_erasAbbrRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasAbbrRegex : this._erasRegex;
}
function erasNarrowRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNarrowRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNarrowRegex : this._erasRegex;
}
function matchEraAbbr(isStrict, locale2) {
  return locale2.erasAbbrRegex(isStrict);
}
function matchEraName(isStrict, locale2) {
  return locale2.erasNameRegex(isStrict);
}
function matchEraNarrow(isStrict, locale2) {
  return locale2.erasNarrowRegex(isStrict);
}
function matchEraYearOrdinal(isStrict, locale2) {
  return locale2._eraYearOrdinalRegex || matchUnsigned;
}
function computeErasParse() {
  var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i2, l2, eras = this.eras();
  for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
    namePieces.push(regexEscape(eras[i2].name));
    abbrPieces.push(regexEscape(eras[i2].abbr));
    narrowPieces.push(regexEscape(eras[i2].narrow));
    mixedPieces.push(regexEscape(eras[i2].name));
    mixedPieces.push(regexEscape(eras[i2].abbr));
    mixedPieces.push(regexEscape(eras[i2].narrow));
  }
  this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
  this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
  this._erasNarrowRegex = new RegExp("^(" + narrowPieces.join("|") + ")", "i");
}
addFormatToken(0, ["gg", 2], 0, function() {
  return this.weekYear() % 100;
});
addFormatToken(0, ["GG", 2], 0, function() {
  return this.isoWeekYear() % 100;
});
function addWeekYearFormatToken(token2, getter) {
  addFormatToken(0, [token2, token2.length], 0, getter);
}
addWeekYearFormatToken("gggg", "weekYear");
addWeekYearFormatToken("ggggg", "weekYear");
addWeekYearFormatToken("GGGG", "isoWeekYear");
addWeekYearFormatToken("GGGGG", "isoWeekYear");
addUnitAlias("weekYear", "gg");
addUnitAlias("isoWeekYear", "GG");
addUnitPriority("weekYear", 1);
addUnitPriority("isoWeekYear", 1);
addRegexToken("G", matchSigned);
addRegexToken("g", matchSigned);
addRegexToken("GG", match1to2, match2);
addRegexToken("gg", match1to2, match2);
addRegexToken("GGGG", match1to4, match4);
addRegexToken("gggg", match1to4, match4);
addRegexToken("GGGGG", match1to6, match6);
addRegexToken("ggggg", match1to6, match6);
addWeekParseToken(["gggg", "ggggg", "GGGG", "GGGGG"], function(input, week, config, token2) {
  week[token2.substr(0, 2)] = toInt(input);
});
addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
  week[token2] = hooks.parseTwoDigitYear(input);
});
function getSetWeekYear(input) {
  return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
}
function getSetISOWeekYear(input) {
  return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
}
function getISOWeeksInYear() {
  return weeksInYear(this.year(), 1, 4);
}
function getISOWeeksInISOWeekYear() {
  return weeksInYear(this.isoWeekYear(), 1, 4);
}
function getWeeksInYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}
function getWeeksInWeekYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
}
function getSetWeekYearHelper(input, week, weekday, dow, doy) {
  var weeksTarget;
  if (input == null) {
    return weekOfYear(this, dow, doy).year;
  } else {
    weeksTarget = weeksInYear(input, dow, doy);
    if (week > weeksTarget) {
      week = weeksTarget;
    }
    return setWeekAll.call(this, input, week, weekday, dow, doy);
  }
}
function setWeekAll(weekYear, week, weekday, dow, doy) {
  var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
  this.year(date.getUTCFullYear());
  this.month(date.getUTCMonth());
  this.date(date.getUTCDate());
  return this;
}
addFormatToken("Q", 0, "Qo", "quarter");
addUnitAlias("quarter", "Q");
addUnitPriority("quarter", 7);
addRegexToken("Q", match1);
addParseToken("Q", function(input, array) {
  array[MONTH] = (toInt(input) - 1) * 3;
});
function getSetQuarter(input) {
  return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}
addFormatToken("D", ["DD", 2], "Do", "date");
addUnitAlias("date", "D");
addUnitPriority("date", 9);
addRegexToken("D", match1to2);
addRegexToken("DD", match1to2, match2);
addRegexToken("Do", function(isStrict, locale2) {
  return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
});
addParseToken(["D", "DD"], DATE);
addParseToken("Do", function(input, array) {
  array[DATE] = toInt(input.match(match1to2)[0]);
});
var getSetDayOfMonth = makeGetSet("Date", true);
addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
addUnitAlias("dayOfYear", "DDD");
addUnitPriority("dayOfYear", 4);
addRegexToken("DDD", match1to3);
addRegexToken("DDDD", match3);
addParseToken(["DDD", "DDDD"], function(input, array, config) {
  config._dayOfYear = toInt(input);
});
function getSetDayOfYear(input) {
  var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
  return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
}
addFormatToken("m", ["mm", 2], 0, "minute");
addUnitAlias("minute", "m");
addUnitPriority("minute", 14);
addRegexToken("m", match1to2);
addRegexToken("mm", match1to2, match2);
addParseToken(["m", "mm"], MINUTE);
var getSetMinute = makeGetSet("Minutes", false);
addFormatToken("s", ["ss", 2], 0, "second");
addUnitAlias("second", "s");
addUnitPriority("second", 15);
addRegexToken("s", match1to2);
addRegexToken("ss", match1to2, match2);
addParseToken(["s", "ss"], SECOND);
var getSetSecond = makeGetSet("Seconds", false);
addFormatToken("S", 0, 0, function() {
  return ~~(this.millisecond() / 100);
});
addFormatToken(0, ["SS", 2], 0, function() {
  return ~~(this.millisecond() / 10);
});
addFormatToken(0, ["SSS", 3], 0, "millisecond");
addFormatToken(0, ["SSSS", 4], 0, function() {
  return this.millisecond() * 10;
});
addFormatToken(0, ["SSSSS", 5], 0, function() {
  return this.millisecond() * 100;
});
addFormatToken(0, ["SSSSSS", 6], 0, function() {
  return this.millisecond() * 1e3;
});
addFormatToken(0, ["SSSSSSS", 7], 0, function() {
  return this.millisecond() * 1e4;
});
addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
  return this.millisecond() * 1e5;
});
addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
  return this.millisecond() * 1e6;
});
addUnitAlias("millisecond", "ms");
addUnitPriority("millisecond", 16);
addRegexToken("S", match1to3, match1);
addRegexToken("SS", match1to3, match2);
addRegexToken("SSS", match1to3, match3);
var token, getSetMillisecond;
for (token = "SSSS"; token.length <= 9; token += "S") {
  addRegexToken(token, matchUnsigned);
}
function parseMs(input, array) {
  array[MILLISECOND] = toInt(("0." + input) * 1e3);
}
for (token = "S"; token.length <= 9; token += "S") {
  addParseToken(token, parseMs);
}
getSetMillisecond = makeGetSet("Milliseconds", false);
addFormatToken("z", 0, 0, "zoneAbbr");
addFormatToken("zz", 0, 0, "zoneName");
function getZoneAbbr() {
  return this._isUTC ? "UTC" : "";
}
function getZoneName() {
  return this._isUTC ? "Coordinated Universal Time" : "";
}
var proto = Moment.prototype;
proto.add = add;
proto.calendar = calendar$1;
proto.clone = clone$1;
proto.diff = diff;
proto.endOf = endOf;
proto.format = format$1;
proto.from = from;
proto.fromNow = fromNow;
proto.to = to;
proto.toNow = toNow;
proto.get = stringGet;
proto.invalidAt = invalidAt;
proto.isAfter = isAfter;
proto.isBefore = isBefore;
proto.isBetween = isBetween;
proto.isSame = isSame;
proto.isSameOrAfter = isSameOrAfter;
proto.isSameOrBefore = isSameOrBefore;
proto.isValid = isValid$2;
proto.lang = lang;
proto.locale = locale;
proto.localeData = localeData;
proto.max = prototypeMax;
proto.min = prototypeMin;
proto.parsingFlags = parsingFlags;
proto.set = stringSet;
proto.startOf = startOf;
proto.subtract = subtract;
proto.toArray = toArray;
proto.toObject = toObject;
proto.toDate = toDate;
proto.toISOString = toISOString;
proto.inspect = inspect;
if (typeof Symbol !== "undefined" && Symbol.for != null) {
  proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
    return "Moment<" + this.format() + ">";
  };
}
proto.toJSON = toJSON$2;
proto.toString = toString$2;
proto.unix = unix;
proto.valueOf = valueOf;
proto.creationData = creationData;
proto.eraName = getEraName;
proto.eraNarrow = getEraNarrow;
proto.eraAbbr = getEraAbbr;
proto.eraYear = getEraYear;
proto.year = getSetYear;
proto.isLeapYear = getIsLeapYear;
proto.weekYear = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;
proto.quarter = proto.quarters = getSetQuarter;
proto.month = getSetMonth;
proto.daysInMonth = getDaysInMonth;
proto.week = proto.weeks = getSetWeek;
proto.isoWeek = proto.isoWeeks = getSetISOWeek;
proto.weeksInYear = getWeeksInYear;
proto.weeksInWeekYear = getWeeksInWeekYear;
proto.isoWeeksInYear = getISOWeeksInYear;
proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
proto.date = getSetDayOfMonth;
proto.day = proto.days = getSetDayOfWeek;
proto.weekday = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear = getSetDayOfYear;
proto.hour = proto.hours = getSetHour;
proto.minute = proto.minutes = getSetMinute;
proto.second = proto.seconds = getSetSecond;
proto.millisecond = proto.milliseconds = getSetMillisecond;
proto.utcOffset = getSetOffset;
proto.utc = setOffsetToUTC;
proto.local = setOffsetToLocal;
proto.parseZone = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST = isDaylightSavingTime;
proto.isLocal = isLocal;
proto.isUtcOffset = isUtcOffset;
proto.isUtc = isUtc;
proto.isUTC = isUtc;
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;
proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth);
proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth);
proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear);
proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", getSetZone);
proto.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", isDaylightSavingTimeShifted);
function createUnix(input) {
  return createLocal(input * 1e3);
}
function createInZone() {
  return createLocal.apply(null, arguments).parseZone();
}
function preParsePostFormat(string2) {
  return string2;
}
var proto$1 = Locale.prototype;
proto$1.calendar = calendar;
proto$1.longDateFormat = longDateFormat;
proto$1.invalidDate = invalidDate;
proto$1.ordinal = ordinal;
proto$1.preparse = preParsePostFormat;
proto$1.postformat = preParsePostFormat;
proto$1.relativeTime = relativeTime;
proto$1.pastFuture = pastFuture;
proto$1.set = set$1;
proto$1.eras = localeEras;
proto$1.erasParse = localeErasParse;
proto$1.erasConvertYear = localeErasConvertYear;
proto$1.erasAbbrRegex = erasAbbrRegex;
proto$1.erasNameRegex = erasNameRegex;
proto$1.erasNarrowRegex = erasNarrowRegex;
proto$1.months = localeMonths;
proto$1.monthsShort = localeMonthsShort;
proto$1.monthsParse = localeMonthsParse;
proto$1.monthsRegex = monthsRegex;
proto$1.monthsShortRegex = monthsShortRegex;
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;
proto$1.weekdays = localeWeekdays;
proto$1.weekdaysMin = localeWeekdaysMin;
proto$1.weekdaysShort = localeWeekdaysShort;
proto$1.weekdaysParse = localeWeekdaysParse;
proto$1.weekdaysRegex = weekdaysRegex;
proto$1.weekdaysShortRegex = weekdaysShortRegex;
proto$1.weekdaysMinRegex = weekdaysMinRegex;
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;
function get$1(format2, index, field, setter) {
  var locale2 = getLocale(), utc = createUTC().set(setter, index);
  return locale2[field](utc, format2);
}
function listMonthsImpl(format2, index, field) {
  if (isNumber(format2)) {
    index = format2;
    format2 = void 0;
  }
  format2 = format2 || "";
  if (index != null) {
    return get$1(format2, index, field, "month");
  }
  var i2, out = [];
  for (i2 = 0; i2 < 12; i2++) {
    out[i2] = get$1(format2, i2, field, "month");
  }
  return out;
}
function listWeekdaysImpl(localeSorted, format2, index, field) {
  if (typeof localeSorted === "boolean") {
    if (isNumber(format2)) {
      index = format2;
      format2 = void 0;
    }
    format2 = format2 || "";
  } else {
    format2 = localeSorted;
    index = format2;
    localeSorted = false;
    if (isNumber(format2)) {
      index = format2;
      format2 = void 0;
    }
    format2 = format2 || "";
  }
  var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i2, out = [];
  if (index != null) {
    return get$1(format2, (index + shift) % 7, field, "day");
  }
  for (i2 = 0; i2 < 7; i2++) {
    out[i2] = get$1(format2, (i2 + shift) % 7, field, "day");
  }
  return out;
}
function listMonths(format2, index) {
  return listMonthsImpl(format2, index, "months");
}
function listMonthsShort(format2, index) {
  return listMonthsImpl(format2, index, "monthsShort");
}
function listWeekdays(localeSorted, format2, index) {
  return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
}
function listWeekdaysShort(localeSorted, format2, index) {
  return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
}
function listWeekdaysMin(localeSorted, format2, index) {
  return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
}
getSetGlobalLocale("en", {
  eras: [
    {
      since: "0001-01-01",
      until: Infinity,
      offset: 1,
      name: "Anno Domini",
      narrow: "AD",
      abbr: "AD"
    },
    {
      since: "0000-12-31",
      until: -Infinity,
      offset: 1,
      name: "Before Christ",
      narrow: "BC",
      abbr: "BC"
    }
  ],
  dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
  ordinal: function(number) {
    var b2 = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b2 === 1 ? "st" : b2 === 2 ? "nd" : b2 === 3 ? "rd" : "th";
    return number + output;
  }
});
hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale);
hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
var mathAbs = Math.abs;
function abs() {
  var data = this._data;
  this._milliseconds = mathAbs(this._milliseconds);
  this._days = mathAbs(this._days);
  this._months = mathAbs(this._months);
  data.milliseconds = mathAbs(data.milliseconds);
  data.seconds = mathAbs(data.seconds);
  data.minutes = mathAbs(data.minutes);
  data.hours = mathAbs(data.hours);
  data.months = mathAbs(data.months);
  data.years = mathAbs(data.years);
  return this;
}
function addSubtract$1(duration, input, value, direction) {
  var other = createDuration(input, value);
  duration._milliseconds += direction * other._milliseconds;
  duration._days += direction * other._days;
  duration._months += direction * other._months;
  return duration._bubble();
}
function add$1(input, value) {
  return addSubtract$1(this, input, value, 1);
}
function subtract$1(input, value) {
  return addSubtract$1(this, input, value, -1);
}
function absCeil(number) {
  if (number < 0) {
    return Math.floor(number);
  } else {
    return Math.ceil(number);
  }
}
function bubble() {
  var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
  if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
    milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
    days2 = 0;
    months2 = 0;
  }
  data.milliseconds = milliseconds2 % 1e3;
  seconds2 = absFloor(milliseconds2 / 1e3);
  data.seconds = seconds2 % 60;
  minutes2 = absFloor(seconds2 / 60);
  data.minutes = minutes2 % 60;
  hours2 = absFloor(minutes2 / 60);
  data.hours = hours2 % 24;
  days2 += absFloor(hours2 / 24);
  monthsFromDays = absFloor(daysToMonths(days2));
  months2 += monthsFromDays;
  days2 -= absCeil(monthsToDays(monthsFromDays));
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  data.days = days2;
  data.months = months2;
  data.years = years2;
  return this;
}
function daysToMonths(days2) {
  return days2 * 4800 / 146097;
}
function monthsToDays(months2) {
  return months2 * 146097 / 4800;
}
function as(units) {
  if (!this.isValid()) {
    return NaN;
  }
  var days2, months2, milliseconds2 = this._milliseconds;
  units = normalizeUnits(units);
  if (units === "month" || units === "quarter" || units === "year") {
    days2 = this._days + milliseconds2 / 864e5;
    months2 = this._months + daysToMonths(days2);
    switch (units) {
      case "month":
        return months2;
      case "quarter":
        return months2 / 3;
      case "year":
        return months2 / 12;
    }
  } else {
    days2 = this._days + Math.round(monthsToDays(this._months));
    switch (units) {
      case "week":
        return days2 / 7 + milliseconds2 / 6048e5;
      case "day":
        return days2 + milliseconds2 / 864e5;
      case "hour":
        return days2 * 24 + milliseconds2 / 36e5;
      case "minute":
        return days2 * 1440 + milliseconds2 / 6e4;
      case "second":
        return days2 * 86400 + milliseconds2 / 1e3;
      case "millisecond":
        return Math.floor(days2 * 864e5) + milliseconds2;
      default:
        throw new Error("Unknown unit " + units);
    }
  }
}
function valueOf$1() {
  if (!this.isValid()) {
    return NaN;
  }
  return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
}
function makeAs(alias) {
  return function() {
    return this.as(alias);
  };
}
var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
function clone$1$1() {
  return createDuration(this);
}
function get$2(units) {
  units = normalizeUnits(units);
  return this.isValid() ? this[units + "s"]() : NaN;
}
function makeGetter(name2) {
  return function() {
    return this.isValid() ? this._data[name2] : NaN;
  };
}
var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
function weeks() {
  return absFloor(this.days() / 7);
}
var round = Math.round, thresholds = {
  ss: 44,
  s: 45,
  m: 45,
  h: 22,
  d: 26,
  w: null,
  M: 11
};
function substituteTimeAgo(string2, number, withoutSuffix, isFuture, locale2) {
  return locale2.relativeTime(number || 1, !!withoutSuffix, string2, isFuture);
}
function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
  var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a2 = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
  if (thresholds2.w != null) {
    a2 = a2 || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
  }
  a2 = a2 || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
  a2[2] = withoutSuffix;
  a2[3] = +posNegDuration > 0;
  a2[4] = locale2;
  return substituteTimeAgo.apply(null, a2);
}
function getSetRelativeTimeRounding(roundingFunction) {
  if (roundingFunction === void 0) {
    return round;
  }
  if (typeof roundingFunction === "function") {
    round = roundingFunction;
    return true;
  }
  return false;
}
function getSetRelativeTimeThreshold(threshold, limit) {
  if (thresholds[threshold] === void 0) {
    return false;
  }
  if (limit === void 0) {
    return thresholds[threshold];
  }
  thresholds[threshold] = limit;
  if (threshold === "s") {
    thresholds.ss = limit - 1;
  }
  return true;
}
function humanize(argWithSuffix, argThresholds) {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var withSuffix = false, th2 = thresholds, locale2, output;
  if (typeof argWithSuffix === "object") {
    argThresholds = argWithSuffix;
    argWithSuffix = false;
  }
  if (typeof argWithSuffix === "boolean") {
    withSuffix = argWithSuffix;
  }
  if (typeof argThresholds === "object") {
    th2 = Object.assign({}, thresholds, argThresholds);
    if (argThresholds.s != null && argThresholds.ss == null) {
      th2.ss = argThresholds.s - 1;
    }
  }
  locale2 = this.localeData();
  output = relativeTime$1(this, !withSuffix, th2, locale2);
  if (withSuffix) {
    output = locale2.pastFuture(+this, output);
  }
  return locale2.postformat(output);
}
var abs$1 = Math.abs;
function sign$1(x2) {
  return (x2 > 0) - (x2 < 0) || +x2;
}
function toISOString$1() {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s2, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
  if (!total) {
    return "P0D";
  }
  minutes2 = absFloor(seconds2 / 60);
  hours2 = absFloor(minutes2 / 60);
  seconds2 %= 60;
  minutes2 %= 60;
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  s2 = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
  totalSign = total < 0 ? "-" : "";
  ymSign = sign$1(this._months) !== sign$1(total) ? "-" : "";
  daysSign = sign$1(this._days) !== sign$1(total) ? "-" : "";
  hmsSign = sign$1(this._milliseconds) !== sign$1(total) ? "-" : "";
  return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s2 + "S" : "");
}
var proto$2 = Duration.prototype;
proto$2.isValid = isValid$1;
proto$2.abs = abs;
proto$2.add = add$1;
proto$2.subtract = subtract$1;
proto$2.as = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds = asSeconds;
proto$2.asMinutes = asMinutes;
proto$2.asHours = asHours;
proto$2.asDays = asDays;
proto$2.asWeeks = asWeeks;
proto$2.asMonths = asMonths;
proto$2.asQuarters = asQuarters;
proto$2.asYears = asYears;
proto$2.valueOf = valueOf$1;
proto$2._bubble = bubble;
proto$2.clone = clone$1$1;
proto$2.get = get$2;
proto$2.milliseconds = milliseconds;
proto$2.seconds = seconds;
proto$2.minutes = minutes;
proto$2.hours = hours;
proto$2.days = days;
proto$2.weeks = weeks;
proto$2.months = months;
proto$2.years = years;
proto$2.humanize = humanize;
proto$2.toISOString = toISOString$1;
proto$2.toString = toISOString$1;
proto$2.toJSON = toISOString$1;
proto$2.locale = locale;
proto$2.localeData = localeData;
proto$2.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString$1);
proto$2.lang = lang;
addFormatToken("X", 0, 0, "unix");
addFormatToken("x", 0, 0, "valueOf");
addRegexToken("x", matchSigned);
addRegexToken("X", matchTimestamp);
addParseToken("X", function(input, array, config) {
  config._d = new Date(parseFloat(input) * 1e3);
});
addParseToken("x", function(input, array, config) {
  config._d = new Date(toInt(input));
});
//! moment.js
hooks.version = "2.29.1";
setHookCallback(createLocal);
hooks.fn = proto;
hooks.min = min;
hooks.max = max;
hooks.now = now;
hooks.utc = createUTC;
hooks.unix = createUnix;
hooks.months = listMonths;
hooks.isDate = isDate;
hooks.locale = getSetGlobalLocale;
hooks.invalid = createInvalid;
hooks.duration = createDuration;
hooks.isMoment = isMoment;
hooks.weekdays = listWeekdays;
hooks.parseZone = createInZone;
hooks.localeData = getLocale;
hooks.isDuration = isDuration;
hooks.monthsShort = listMonthsShort;
hooks.weekdaysMin = listWeekdaysMin;
hooks.defineLocale = defineLocale;
hooks.updateLocale = updateLocale;
hooks.locales = listLocales;
hooks.weekdaysShort = listWeekdaysShort;
hooks.normalizeUnits = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat = getCalendarFormat;
hooks.prototype = proto;
hooks.HTML5_FMT = {
  DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
  DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
  DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
  DATE: "YYYY-MM-DD",
  TIME: "HH:mm",
  TIME_SECONDS: "HH:mm:ss",
  TIME_MS: "HH:mm:ss.SSS",
  WEEK: "GGGG-[W]WW",
  MONTH: "YYYY-MM"
};
/**
* @license
* Copyright 2017 Google LLC
* SPDX-License-Identifier: BSD-3-Clause
*/
var _a$1, _b$1, _c$1, _d$1, _e;
var _f;
{
  console.warn("lit-html is in dev mode. Not recommended for production!");
}
const wrap$2 = ((_a$1 = window.ShadyDOM) === null || _a$1 === void 0 ? void 0 : _a$1.inUse) && ((_b$1 = window.ShadyDOM) === null || _b$1 === void 0 ? void 0 : _b$1.noPatch) === true ? window.ShadyDOM.wrap : (node) => node;
const trustedTypes$1 = globalThis.trustedTypes;
const policy$1 = trustedTypes$1 ? trustedTypes$1.createPolicy("lit-html", {
  createHTML: (s2) => s2
}) : void 0;
const identityFunction$1 = (value) => value;
const noopSanitizer$1 = (_node, _name, _type) => identityFunction$1;
const createSanitizer$1 = (node, name2, type) => {
  return sanitizerFactoryInternal$1();
};
const boundAttributeSuffix$1 = "$lit$";
const marker$1 = `lit$${String(Math.random()).slice(9)}$`;
const markerMatch$1 = "?" + marker$1;
const nodeMarker$1 = `<${markerMatch$1}>`;
const d$1 = document;
const createMarker$1 = (v2 = "") => d$1.createComment(v2);
const isPrimitive$1 = (value) => value === null || typeof value != "object" && typeof value != "function";
const isArray$1 = Array.isArray;
const isIterable$1 = (value) => {
  var _a2;
  return isArray$1(value) || typeof ((_a2 = value) === null || _a2 === void 0 ? void 0 : _a2[Symbol.iterator]) === "function";
};
const SPACE_CHAR$1 = `[ 	
\f\r]`;
const ATTR_VALUE_CHAR$1 = `[^ 	
\f\r"'\`<>=]`;
const NAME_CHAR$1 = `[^\\s"'>=/]`;
const textEndRegex$1 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
const COMMENT_START$1 = 1;
const TAG_NAME$1 = 2;
const DYNAMIC_TAG_NAME$1 = 3;
const commentEndRegex$1 = /-->/g;
const comment2EndRegex$1 = />/g;
const tagEndRegex$1 = new RegExp(`>|${SPACE_CHAR$1}(?:(${NAME_CHAR$1}+)(${SPACE_CHAR$1}*=${SPACE_CHAR$1}*(?:${ATTR_VALUE_CHAR$1}|("|')|))|$)`, "g");
const ENTIRE_MATCH$1 = 0;
const ATTRIBUTE_NAME$1 = 1;
const SPACES_AND_EQUALS$1 = 2;
const QUOTE_CHAR$1 = 3;
const singleQuoteAttrEndRegex$1 = /'/g;
const doubleQuoteAttrEndRegex$1 = /"/g;
const rawTextElement$1 = /^(?:script|style|textarea)$/i;
const HTML_RESULT$1 = 1;
const SVG_RESULT$1 = 2;
const ATTRIBUTE_PART$1 = 1;
const CHILD_PART$1 = 2;
const PROPERTY_PART$1 = 3;
const BOOLEAN_ATTRIBUTE_PART$1 = 4;
const EVENT_PART$1 = 5;
const ELEMENT_PART$1 = 6;
const COMMENT_PART$1 = 7;
const tag$1 = (type) => (strings, ...values) => {
  if (strings.some((s2) => s2 === void 0)) {
    console.warn("Some template strings are undefined.\nThis is probably caused by illegal octal escape sequences.");
  }
  return {
    ["_$litType$"]: type,
    strings,
    values
  };
};
const html$1 = tag$1(HTML_RESULT$1);
const noChange$1 = Symbol.for("lit-noChange");
const nothing$1 = Symbol.for("lit-nothing");
const templateCache$1 = new WeakMap();
const walker$1 = d$1.createTreeWalker(d$1, 129, null, false);
let sanitizerFactoryInternal$1 = noopSanitizer$1;
const getTemplateHtml$1 = (strings, type) => {
  const l2 = strings.length - 1;
  const attrNames = [];
  let html2 = type === SVG_RESULT$1 ? "<svg>" : "";
  let rawTextEndRegex;
  let regex = textEndRegex$1;
  for (let i2 = 0; i2 < l2; i2++) {
    const s2 = strings[i2];
    let attrNameEndIndex = -1;
    let attrName;
    let lastIndex = 0;
    let match5;
    while (lastIndex < s2.length) {
      regex.lastIndex = lastIndex;
      match5 = regex.exec(s2);
      if (match5 === null) {
        break;
      }
      lastIndex = regex.lastIndex;
      if (regex === textEndRegex$1) {
        if (match5[COMMENT_START$1] === "!--") {
          regex = commentEndRegex$1;
        } else if (match5[COMMENT_START$1] !== void 0) {
          regex = comment2EndRegex$1;
        } else if (match5[TAG_NAME$1] !== void 0) {
          if (rawTextElement$1.test(match5[TAG_NAME$1])) {
            rawTextEndRegex = new RegExp(`</${match5[TAG_NAME$1]}`, "g");
          }
          regex = tagEndRegex$1;
        } else if (match5[DYNAMIC_TAG_NAME$1] !== void 0) {
          regex = tagEndRegex$1;
        }
      } else if (regex === tagEndRegex$1) {
        if (match5[ENTIRE_MATCH$1] === ">") {
          regex = rawTextEndRegex !== null && rawTextEndRegex !== void 0 ? rawTextEndRegex : textEndRegex$1;
          attrNameEndIndex = -1;
        } else if (match5[ATTRIBUTE_NAME$1] === void 0) {
          attrNameEndIndex = -2;
        } else {
          attrNameEndIndex = regex.lastIndex - match5[SPACES_AND_EQUALS$1].length;
          attrName = match5[ATTRIBUTE_NAME$1];
          regex = match5[QUOTE_CHAR$1] === void 0 ? tagEndRegex$1 : match5[QUOTE_CHAR$1] === '"' ? doubleQuoteAttrEndRegex$1 : singleQuoteAttrEndRegex$1;
        }
      } else if (regex === doubleQuoteAttrEndRegex$1 || regex === singleQuoteAttrEndRegex$1) {
        regex = tagEndRegex$1;
      } else if (regex === commentEndRegex$1 || regex === comment2EndRegex$1) {
        regex = textEndRegex$1;
      } else {
        regex = tagEndRegex$1;
        rawTextEndRegex = void 0;
      }
    }
    {
      console.assert(attrNameEndIndex === -1 || regex === tagEndRegex$1 || regex === singleQuoteAttrEndRegex$1 || regex === doubleQuoteAttrEndRegex$1, "unexpected parse state B");
    }
    const end = regex === tagEndRegex$1 && strings[i2 + 1].startsWith("/>") ? " " : "";
    html2 += regex === textEndRegex$1 ? s2 + nodeMarker$1 : attrNameEndIndex >= 0 ? (attrNames.push(attrName), s2.slice(0, attrNameEndIndex) + boundAttributeSuffix$1 + s2.slice(attrNameEndIndex)) + marker$1 + end : s2 + marker$1 + (attrNameEndIndex === -2 ? (attrNames.push(void 0), i2) : end);
  }
  const htmlResult = html2 + (strings[l2] || "<?>") + (type === SVG_RESULT$1 ? "</svg>" : "");
  return [policy$1 !== void 0 ? policy$1.createHTML(htmlResult) : htmlResult, attrNames];
};
class Template$1 {
  constructor({ strings, ["_$litType$"]: type }, options) {
    this.parts = [];
    let node;
    let nodeIndex = 0;
    let attrNameIndex = 0;
    const partCount = strings.length - 1;
    const parts = this.parts;
    const [html2, attrNames] = getTemplateHtml$1(strings, type);
    this.el = Template$1.createElement(html2, options);
    walker$1.currentNode = this.el.content;
    if (type === SVG_RESULT$1) {
      const content = this.el.content;
      const svgElement = content.firstChild;
      svgElement.remove();
      content.append(...svgElement.childNodes);
    }
    while ((node = walker$1.nextNode()) !== null && parts.length < partCount) {
      if (node.nodeType === 1) {
        if (node.hasAttributes()) {
          const attrsToRemove = [];
          for (const name2 of node.getAttributeNames()) {
            if (name2.endsWith(boundAttributeSuffix$1) || name2.startsWith(marker$1)) {
              const realName = attrNames[attrNameIndex++];
              attrsToRemove.push(name2);
              if (realName !== void 0) {
                const value = node.getAttribute(realName.toLowerCase() + boundAttributeSuffix$1);
                const statics = value.split(marker$1);
                const m2 = /([.?@])?(.*)/.exec(realName);
                parts.push({
                  type: ATTRIBUTE_PART$1,
                  index: nodeIndex,
                  name: m2[2],
                  strings: statics,
                  ctor: m2[1] === "." ? PropertyPart$1 : m2[1] === "?" ? BooleanAttributePart$1 : m2[1] === "@" ? EventPart$1 : AttributePart$1
                });
              } else {
                parts.push({
                  type: ELEMENT_PART$1,
                  index: nodeIndex
                });
              }
            }
          }
          for (const name2 of attrsToRemove) {
            node.removeAttribute(name2);
          }
        }
        if (rawTextElement$1.test(node.tagName)) {
          const strings2 = node.textContent.split(marker$1);
          const lastIndex = strings2.length - 1;
          if (lastIndex > 0) {
            node.textContent = trustedTypes$1 ? trustedTypes$1.emptyScript : "";
            for (let i2 = 0; i2 < lastIndex; i2++) {
              node.append(strings2[i2], createMarker$1());
              walker$1.nextNode();
              parts.push({ type: CHILD_PART$1, index: ++nodeIndex });
            }
            node.append(strings2[lastIndex], createMarker$1());
          }
        }
      } else if (node.nodeType === 8) {
        const data = node.data;
        if (data === markerMatch$1) {
          parts.push({ type: CHILD_PART$1, index: nodeIndex });
        } else {
          let i2 = -1;
          while ((i2 = node.data.indexOf(marker$1, i2 + 1)) !== -1) {
            parts.push({ type: COMMENT_PART$1, index: nodeIndex });
            i2 += marker$1.length - 1;
          }
        }
      }
      nodeIndex++;
    }
  }
  static createElement(html2, _options) {
    const el2 = d$1.createElement("template");
    el2.innerHTML = html2;
    return el2;
  }
}
function resolveDirective$1(part, value, parent = part, attributeIndex) {
  var _a2, _b2, _c2;
  var _d2;
  if (value === noChange$1) {
    return value;
  }
  let currentDirective = attributeIndex !== void 0 ? (_a2 = parent.__directives) === null || _a2 === void 0 ? void 0 : _a2[attributeIndex] : parent.__directive;
  const nextDirectiveConstructor = isPrimitive$1(value) ? void 0 : value["_$litDirective$"];
  if ((currentDirective === null || currentDirective === void 0 ? void 0 : currentDirective.constructor) !== nextDirectiveConstructor) {
    (_b2 = currentDirective === null || currentDirective === void 0 ? void 0 : currentDirective["_$notifyDirectiveConnectionChanged"]) === null || _b2 === void 0 ? void 0 : _b2.call(currentDirective, false);
    if (nextDirectiveConstructor === void 0) {
      currentDirective = void 0;
    } else {
      currentDirective = new nextDirectiveConstructor(part);
      currentDirective._$initialize(part, parent, attributeIndex);
    }
    if (attributeIndex !== void 0) {
      ((_c2 = (_d2 = parent).__directives) !== null && _c2 !== void 0 ? _c2 : _d2.__directives = [])[attributeIndex] = currentDirective;
    } else {
      parent.__directive = currentDirective;
    }
  }
  if (currentDirective !== void 0) {
    value = resolveDirective$1(part, currentDirective._$resolve(part, value.values), currentDirective, attributeIndex);
  }
  return value;
}
class TemplateInstance$1 {
  constructor(template2, parent) {
    this._parts = [];
    this._$disconnectableChildren = void 0;
    this._$template = template2;
    this._$parent = parent;
  }
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  _clone(options) {
    var _a2;
    const {
      el: { content },
      parts
    } = this._$template;
    const fragment2 = ((_a2 = options === null || options === void 0 ? void 0 : options.creationScope) !== null && _a2 !== void 0 ? _a2 : d$1).importNode(content, true);
    walker$1.currentNode = fragment2;
    let node = walker$1.nextNode();
    let nodeIndex = 0;
    let partIndex = 0;
    let templatePart = parts[0];
    while (templatePart !== void 0) {
      if (nodeIndex === templatePart.index) {
        let part;
        if (templatePart.type === CHILD_PART$1) {
          part = new ChildPart$1(node, node.nextSibling, this, options);
        } else if (templatePart.type === ATTRIBUTE_PART$1) {
          part = new templatePart.ctor(node, templatePart.name, templatePart.strings, this, options);
        } else if (templatePart.type === ELEMENT_PART$1) {
          part = new ElementPart$1(node, this, options);
        }
        this._parts.push(part);
        templatePart = parts[++partIndex];
      }
      if (nodeIndex !== (templatePart === null || templatePart === void 0 ? void 0 : templatePart.index)) {
        node = walker$1.nextNode();
        nodeIndex++;
      }
    }
    return fragment2;
  }
  _update(values) {
    let i2 = 0;
    for (const part of this._parts) {
      if (part !== void 0) {
        if (part.strings !== void 0) {
          part._$setValue(values, part, i2);
          i2 += part.strings.length - 2;
        } else {
          part._$setValue(values[i2]);
        }
      }
      i2++;
    }
  }
}
class ChildPart$1 {
  constructor(startNode, endNode, parent, options) {
    this.type = CHILD_PART$1;
    this.__isConnected = true;
    this._$disconnectableChildren = void 0;
    this._$startNode = startNode;
    this._$endNode = endNode;
    this._$parent = parent;
    this.options = options;
    {
      this._textSanitizer = void 0;
    }
  }
  get _$isConnected() {
    var _a2, _b2;
    return (_b2 = (_a2 = this._$parent) === null || _a2 === void 0 ? void 0 : _a2._$isConnected) !== null && _b2 !== void 0 ? _b2 : this.__isConnected;
  }
  get parentNode() {
    return wrap$2(this._$startNode).parentNode;
  }
  get startNode() {
    return this._$startNode;
  }
  get endNode() {
    return this._$endNode;
  }
  _$setValue(value, directiveParent = this) {
    value = resolveDirective$1(this, value, directiveParent);
    if (isPrimitive$1(value)) {
      if (value === nothing$1 || value == null || value === "") {
        if (this._$committedValue !== nothing$1) {
          this._$clear();
        }
        this._$committedValue = nothing$1;
      } else if (value !== this._$committedValue && value !== noChange$1) {
        this._commitText(value);
      }
    } else if (value["_$litType$"] !== void 0) {
      this._commitTemplateResult(value);
    } else if (value.nodeType !== void 0) {
      this._commitNode(value);
    } else if (isIterable$1(value)) {
      this._commitIterable(value);
    } else {
      this._commitText(value);
    }
  }
  _insert(node, ref = this._$endNode) {
    return wrap$2(wrap$2(this._$startNode).parentNode).insertBefore(node, ref);
  }
  _commitNode(value) {
    var _a2;
    if (this._$committedValue !== value) {
      this._$clear();
      if (sanitizerFactoryInternal$1 !== noopSanitizer$1) {
        const parentNodeName = (_a2 = this._$startNode.parentNode) === null || _a2 === void 0 ? void 0 : _a2.nodeName;
        if (parentNodeName === "STYLE" || parentNodeName === "SCRIPT") {
          this._insert(new Text("/* lit-html will not write TemplateResults to scripts and styles */"));
          return;
        }
      }
      this._$committedValue = this._insert(value);
    }
  }
  _commitText(value) {
    const node = wrap$2(this._$startNode).nextSibling;
    if (node !== null && node.nodeType === 3 && (this._$endNode === null ? wrap$2(node).nextSibling === null : node === wrap$2(this._$endNode).previousSibling)) {
      {
        if (this._textSanitizer === void 0) {
          this._textSanitizer = createSanitizer$1();
        }
        value = this._textSanitizer(value);
      }
      node.data = value;
    } else {
      {
        const textNode = document.createTextNode("");
        this._commitNode(textNode);
        if (this._textSanitizer === void 0) {
          this._textSanitizer = createSanitizer$1();
        }
        value = this._textSanitizer(value);
        textNode.data = value;
      }
    }
    this._$committedValue = value;
  }
  _commitTemplateResult(result) {
    var _a2;
    const { values, ["_$litType$"]: type } = result;
    const template2 = typeof type === "number" ? this._$getTemplate(result) : (type.el === void 0 && (type.el = Template$1.createElement(type.h, this.options)), type);
    if (((_a2 = this._$committedValue) === null || _a2 === void 0 ? void 0 : _a2._$template) === template2) {
      this._$committedValue._update(values);
    } else {
      const instance = new TemplateInstance$1(template2, this);
      const fragment2 = instance._clone(this.options);
      instance._update(values);
      this._commitNode(fragment2);
      this._$committedValue = instance;
    }
  }
  _$getTemplate(result) {
    let template2 = templateCache$1.get(result.strings);
    if (template2 === void 0) {
      templateCache$1.set(result.strings, template2 = new Template$1(result));
    }
    return template2;
  }
  _commitIterable(value) {
    if (!isArray$1(this._$committedValue)) {
      this._$committedValue = [];
      this._$clear();
    }
    const itemParts = this._$committedValue;
    let partIndex = 0;
    let itemPart;
    for (const item of value) {
      if (partIndex === itemParts.length) {
        itemParts.push(itemPart = new ChildPart$1(this._insert(createMarker$1()), this._insert(createMarker$1()), this, this.options));
      } else {
        itemPart = itemParts[partIndex];
      }
      itemPart._$setValue(item);
      partIndex++;
    }
    if (partIndex < itemParts.length) {
      this._$clear(itemPart && wrap$2(itemPart._$endNode).nextSibling, partIndex);
      itemParts.length = partIndex;
    }
  }
  _$clear(start = wrap$2(this._$startNode).nextSibling, from2) {
    var _a2;
    (_a2 = this._$notifyConnectionChanged) === null || _a2 === void 0 ? void 0 : _a2.call(this, false, true, from2);
    while (start && start !== this._$endNode) {
      const n2 = wrap$2(start).nextSibling;
      wrap$2(start).remove();
      start = n2;
    }
  }
  setConnected(isConnected) {
    var _a2;
    if (this._$parent === void 0) {
      this.__isConnected = isConnected;
      (_a2 = this._$notifyConnectionChanged) === null || _a2 === void 0 ? void 0 : _a2.call(this, isConnected);
    } else {
      throw new Error("part.setConnected() may only be called on a RootPart returned from render().");
    }
  }
}
class AttributePart$1 {
  constructor(element, name2, strings, parent, options) {
    this.type = ATTRIBUTE_PART$1;
    this._$committedValue = nothing$1;
    this._$disconnectableChildren = void 0;
    this.element = element;
    this.name = name2;
    this._$parent = parent;
    this.options = options;
    if (strings.length > 2 || strings[0] !== "" || strings[1] !== "") {
      this._$committedValue = new Array(strings.length - 1).fill(nothing$1);
      this.strings = strings;
    } else {
      this._$committedValue = nothing$1;
    }
    {
      this._sanitizer = void 0;
    }
  }
  get tagName() {
    return this.element.tagName;
  }
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  _$setValue(value, directiveParent = this, valueIndex, noCommit) {
    const strings = this.strings;
    let change = false;
    if (strings === void 0) {
      value = resolveDirective$1(this, value, directiveParent, 0);
      change = !isPrimitive$1(value) || value !== this._$committedValue && value !== noChange$1;
      if (change) {
        this._$committedValue = value;
      }
    } else {
      const values = value;
      value = strings[0];
      let i2, v2;
      for (i2 = 0; i2 < strings.length - 1; i2++) {
        v2 = resolveDirective$1(this, values[valueIndex + i2], directiveParent, i2);
        if (v2 === noChange$1) {
          v2 = this._$committedValue[i2];
        }
        change || (change = !isPrimitive$1(v2) || v2 !== this._$committedValue[i2]);
        if (v2 === nothing$1) {
          value = nothing$1;
        } else if (value !== nothing$1) {
          value += (v2 !== null && v2 !== void 0 ? v2 : "") + strings[i2 + 1];
        }
        this._$committedValue[i2] = v2;
      }
    }
    if (change && !noCommit) {
      this._commitValue(value);
    }
  }
  _commitValue(value) {
    if (value === nothing$1) {
      wrap$2(this.element).removeAttribute(this.name);
    } else {
      {
        if (this._sanitizer === void 0) {
          this._sanitizer = sanitizerFactoryInternal$1(this.element, this.name);
        }
        value = this._sanitizer(value !== null && value !== void 0 ? value : "");
      }
      wrap$2(this.element).setAttribute(this.name, value !== null && value !== void 0 ? value : "");
    }
  }
}
class PropertyPart$1 extends AttributePart$1 {
  constructor() {
    super(...arguments);
    this.type = PROPERTY_PART$1;
  }
  _commitValue(value) {
    {
      if (this._sanitizer === void 0) {
        this._sanitizer = sanitizerFactoryInternal$1(this.element, this.name);
      }
      value = this._sanitizer(value);
    }
    this.element[this.name] = value === nothing$1 ? void 0 : value;
  }
}
class BooleanAttributePart$1 extends AttributePart$1 {
  constructor() {
    super(...arguments);
    this.type = BOOLEAN_ATTRIBUTE_PART$1;
  }
  _commitValue(value) {
    if (value && value !== nothing$1) {
      wrap$2(this.element).setAttribute(this.name, "");
    } else {
      wrap$2(this.element).removeAttribute(this.name);
    }
  }
}
class EventPart$1 extends AttributePart$1 {
  constructor() {
    super(...arguments);
    this.type = EVENT_PART$1;
  }
  _$setValue(newListener, directiveParent = this) {
    var _a2;
    newListener = (_a2 = resolveDirective$1(this, newListener, directiveParent, 0)) !== null && _a2 !== void 0 ? _a2 : nothing$1;
    if (newListener === noChange$1) {
      return;
    }
    const oldListener = this._$committedValue;
    const shouldRemoveListener = newListener === nothing$1 && oldListener !== nothing$1 || newListener.capture !== oldListener.capture || newListener.once !== oldListener.once || newListener.passive !== oldListener.passive;
    const shouldAddListener = newListener !== nothing$1 && (oldListener === nothing$1 || shouldRemoveListener);
    if (shouldRemoveListener) {
      this.element.removeEventListener(this.name, this, oldListener);
    }
    if (shouldAddListener) {
      this.element.addEventListener(this.name, this, newListener);
    }
    this._$committedValue = newListener;
  }
  handleEvent(event) {
    var _a2, _b2;
    if (typeof this._$committedValue === "function") {
      this._$committedValue.call((_b2 = (_a2 = this.options) === null || _a2 === void 0 ? void 0 : _a2.host) !== null && _b2 !== void 0 ? _b2 : this.element, event);
    } else {
      this._$committedValue.handleEvent(event);
    }
  }
}
class ElementPart$1 {
  constructor(element, parent, options) {
    this.element = element;
    this.type = ELEMENT_PART$1;
    this._$disconnectableChildren = void 0;
    this._$parent = parent;
    this.options = options;
  }
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  _$setValue(value) {
    resolveDirective$1(this, value);
  }
}
(_d$1 = (_c$1 = globalThis)["litHtmlPlatformSupport"]) === null || _d$1 === void 0 ? void 0 : _d$1.call(_c$1, Template$1, ChildPart$1);
((_e = (_f = globalThis)["litHtmlVersions"]) !== null && _e !== void 0 ? _e : _f["litHtmlVersions"] = []).push("2.0.0-rc.4");
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const stringsCache = new Map();
const withStatic = (coreTag) => (strings, ...values) => {
  var _a2;
  const l2 = values.length;
  let staticValue;
  let dynamicValue;
  const staticStrings = [];
  const dynamicValues = [];
  let i2 = 0;
  let hasStatics = false;
  let s2;
  while (i2 < l2) {
    s2 = strings[i2];
    while (i2 < l2 && (dynamicValue = values[i2], staticValue = (_a2 = dynamicValue) === null || _a2 === void 0 ? void 0 : _a2["_$litStatic$"]) !== void 0) {
      s2 += staticValue + strings[++i2];
      hasStatics = true;
    }
    dynamicValues.push(dynamicValue);
    staticStrings.push(s2);
    i2++;
  }
  if (i2 === l2) {
    staticStrings.push(strings[l2]);
  }
  if (hasStatics) {
    const key = staticStrings.join("$$lit$$");
    strings = stringsCache.get(key);
    if (strings === void 0) {
      stringsCache.set(key, strings = staticStrings);
    }
    values = dynamicValues;
  }
  return coreTag(strings, ...values);
};
const html = withStatic(html$1);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const decorateProperty = ({ finisher, descriptor: descriptor2 }) => (protoOrDescriptor, name2) => {
  var _a2;
  if (name2 !== void 0) {
    const ctor = protoOrDescriptor.constructor;
    if (descriptor2 !== void 0) {
      Object.defineProperty(protoOrDescriptor, name2, descriptor2(name2));
    }
    finisher === null || finisher === void 0 ? void 0 : finisher(ctor, name2);
  } else {
    const key = (_a2 = protoOrDescriptor.originalKey) !== null && _a2 !== void 0 ? _a2 : protoOrDescriptor.key;
    const info = descriptor2 != void 0 ? {
      kind: "method",
      placement: "prototype",
      key,
      descriptor: descriptor2(protoOrDescriptor.key)
    } : __spreadProps(__spreadValues({}, protoOrDescriptor), { key });
    if (finisher != void 0) {
      info.finisher = function(ctor) {
        finisher(ctor, key);
      };
    }
    return info;
  }
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function queryAsync(selector) {
  return decorateProperty({
    descriptor: (_name) => ({
      async get() {
        var _a2;
        await this.updateComplete;
        return (_a2 = this.renderRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector(selector);
      },
      enumerable: true,
      configurable: true
    })
  });
}
var __isNode = () => {
  return typeof process !== "undefined" && process.release && process.release.name === "node";
};
var _a$2, _b$2, _c$2;
class SDatePickerComponentInterface extends SInterface {
}
SDatePickerComponentInterface.definition = {
  name: {
    type: "String",
    required: true
  },
  value: {
    type: "String"
  },
  placeholder: {
    type: "String"
  },
  format: {
    type: "String",
    default: (_a$2 = SSugarConfig.get("datetime.dateFormat")) !== null && _a$2 !== void 0 ? _a$2 : "YYYY-MM-DD"
  },
  firstDay: {
    type: "Number",
    description: "Specify the first day of the week. 0 is sunday, 1 monday, etc...",
    default: 1
  },
  minDate: {
    type: "String",
    description: "the minimum/earliest date that can be selected (this should be a native Date object - e.g. new Date() or moment().toDate())"
  },
  maxDate: {
    type: "String",
    description: "the maximum/latest date that can be selected (this should be a native Date object - e.g. new Date() or moment().toDate())"
  },
  disableWeekends: {
    type: "Boolean",
    description: "disallow selection of Saturdays or Sundays",
    default: false
  },
  yearRange: {
    type: {
      type: "Array<Number>",
      splitChars: [","]
    },
    description: "number of years either side (e.g. 10) or array of upper/lower range (e.g. [1900,2015])"
  },
  rtl: {
    type: "Boolean",
    description: "reverse the calendar for right-to-left languages",
    default: !__isNode() ? ((_b$2 = document.querySelector("html")) === null || _b$2 === void 0 ? void 0 : _b$2.getAttribute("dir")) === "rtl" : false
  },
  i18n: {
    type: "String",
    description: "language defaults for month and weekday names",
    default: (_c$2 = SSugarConfig.get("datetime.i18n")) !== null && _c$2 !== void 0 ? _c$2 : {
      previousMonth: "Previous Month",
      nextMonth: "Next Month",
      months: [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
      ],
      weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
    }
  },
  numberOfMonths: {
    type: "Number",
    description: "number of visible calendars",
    default: 1
  },
  events: {
    type: {
      type: "Array<String>",
      splitChars: [","]
    },
    description: `array of dates that you would like to differentiate from regular days (e.g. ['Sat Jun 28 2017', 'Sun Jun 29 2017', 'Tue Jul 01 2017',])`,
    default: []
  },
  button: {
    type: "Boolean",
    default: true
  },
  arrowIcon: {
    type: "String",
    default: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M8.122 24l-4.122-4 8-8-8-8 4.122-4 11.878 12z"/></svg>'
  },
  calendarIcon: {
    type: "String",
    default: '<svg aria-hidden="true" focusable="false" data-prefix="far" data-icon="calendar-alt" class="svg-inline--fa fa-calendar-alt fa-w-14" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M148 288h-40c-6.6 0-12-5.4-12-12v-40c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12zm108-12v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm-96 96v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm-96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm192 0v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm96-260v352c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h48V12c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v52h128V12c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v52h48c26.5 0 48 21.5 48 48zm-48 346V160H48v298c0 3.3 2.7 6 6 6h340c3.3 0 6-2.7 6-6z"></path></svg>'
  }
};
function plainObject$3(object) {
  if (!object)
    return false;
  if (typeof object !== "object")
    return false;
  if (object.constructor && object.constructor.name !== "Object")
    return false;
  if (Object.prototype.toString.call(object) !== "[object Object]")
    return false;
  if (object !== Object(object))
    return false;
  return true;
}
function __deepMerge$3(...args) {
  function merge2(firstObj, secondObj) {
    const newObj = {};
    if (!firstObj && secondObj)
      return secondObj;
    if (!secondObj && firstObj)
      return firstObj;
    if (!firstObj && !secondObj)
      return {};
    const firstProps = Object.getOwnPropertyNames(firstObj);
    firstProps.forEach((key) => {
      const desc = Object.getOwnPropertyDescriptor(firstObj, key);
      if (desc.set || desc.get) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = firstObj[key];
      }
    });
    const secondProps = Object.getOwnPropertyNames(secondObj);
    secondProps.forEach((key) => {
      const desc = Object.getOwnPropertyDescriptor(secondObj, key);
      if (desc.set || desc.get) {
        Object.defineProperty(newObj, key, desc);
      } else if (plainObject$3(newObj[key]) && plainObject$3(secondObj[key])) {
        newObj[key] = merge2(newObj[key], secondObj[key]);
      } else {
        newObj[key] = secondObj[key];
      }
    });
    return newObj;
  }
  let currentObj = {};
  for (let i2 = 0; i2 < args.length; i2++) {
    const toMergeObj = args[i2];
    currentObj = merge2(currentObj, toMergeObj);
  }
  return currentObj;
}
function whenInteract(elm, settings) {
  return new Promise((resolve2, reject) => {
    settings = __deepMerge$3({
      mouse: {
        over: true,
        out: true,
        click: true
      },
      touch: {
        start: true,
        end: true
      },
      focus: true
    }, settings !== null && settings !== void 0 ? settings : {});
    function interacted(interaction) {
      resolve2(interaction);
      elm.removeEventListener("mouseover", mouseover);
      elm.removeEventListener("mouseout", mouseout);
      elm.removeEventListener("click", click);
      elm.removeEventListener("touchstart", touchstart);
      elm.removeEventListener("touchend", touchend);
      elm.removeEventListener("focus", focus);
      elm.removeEventListener("focusin", focus);
    }
    function mouseover(e20) {
      interacted("mouseover");
    }
    if (settings.mouse === true || settings.mouse.over) {
      elm.addEventListener("mouseover", mouseover);
    }
    function mouseout(e20) {
      interacted("mouseout");
    }
    if (settings.mouse === true || settings.mouse.out) {
      elm.addEventListener("mouseout", mouseout);
    }
    function click(e20) {
      interacted("click");
    }
    if (settings.mouse === true || settings.mouse.click) {
      elm.addEventListener("click", click);
    }
    function touchstart(e20) {
      interacted("touchstart");
    }
    if (settings.touch === true || settings.touch.start) {
      elm.addEventListener("touchstart", touchstart);
    }
    function touchend(e20) {
      interacted("touchend");
    }
    if (settings.touch === true || settings.touch.start) {
      elm.addEventListener("touchend", touchend);
    }
    function focus(e20) {
      interacted("focus");
    }
    if (settings.focus === true) {
      elm.addEventListener("focus", focus);
      elm.addEventListener("focusin", focus);
    }
  });
}
var __css$4 = "s-date-picker {\n    display: inline-block;\n}\n.s-date-picker {\n    display: flex;\n    width: 100%;\n}\n\n.s-date-picker__input {\n    flex-grow: 1;\n    padding-inline: calc(var(--s-theme-ui-datePicker-paddingInline, 0.75em) * var(--s-scale, 1));\n    padding-block: calc(var(--s-theme-ui-datePicker-paddingBlock, 0.375em) * var(--s-scale, 1));\n}\n.s-date-picker__button {\n    padding-inline: calc(var(--s-theme-ui-datePicker-paddingInline, 0.75em) * var(--s-scale, 1));\n    padding-block: calc(var(--s-theme-ui-datePicker-paddingBlock, 0.375em) * var(--s-scale, 1));\n}\n\ns-date-picker[default-style]:not([rtl]) .s-date-picker__input {\n            border-top-right-radius: 0;\n            border-bottom-right-radius: 0;\n        }\n\ns-date-picker[default-style]:not([rtl]) .s-date-picker__button {\n            border-top-left-radius: 0;\n            border-bottom-left-radius: 0;\n        }\n\ns-date-picker[default-style][rtl] .s-date-picker__button {\n            border-top-right-radius: 0;\n            border-bottom-right-radius: 0;\n            order: 0;\n        }\n\ns-date-picker[default-style][rtl] .s-date-picker__input {\n            border-top-left-radius: 0;\n            border-bottom-left-radius: 0;\n            order: 1;\n        }\n\n.s-date-picker__button svg {\n        height: 1em;\n    }\n\n.s-date-picker__button svg,\n        .s-date-picker__button svg > * {\n            box-shadow: 0px 0px 3px 0 hsla(calc(var(--s-theme-color-ui-h, 0) + var(--s-theme-color-ui-spin ,0)),calc((var(--s-theme-color-ui-s, 0) + var(--s-theme-color-ui-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-ui-l, 0) + -10) * 1%),var(--s-theme-color-ui-a, 1));\n        }\n";
var __themeCss = "/**\n * This theme is an example to show how you can create your own.\n */\n\n.pika-lendar {\n    width: auto;\n}\n\n.pika-single.s-pikaday {\n    color: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-foreground-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-foreground-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-foreground-lightness-offset, 0)) * 1%),var(--s-theme-color-main-foreground-a, 1));\n    background: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-surface-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-surface-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-surface-lightness-offset, 0)) * 1%),var(--s-theme-color-main-surface-a, 1));\n    border: 1px solid hsla(calc(var(--s-theme-color-ui-h, 0) + var(--s-theme-color-ui-border-spin ,0)),calc((var(--s-theme-color-ui-s, 0) + var(--s-theme-color-ui-border-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-ui-l, 0) + var(--s-theme-color-ui-border-lightness-offset, 0)) * 1%),var(--s-theme-color-ui-border-a, 1));box-shadow: var(--s-theme-depth-100, 0);\n    border-radius: var(--s-theme-ui-colorPicker-borderRadius, 6px);\n    padding-inline: calc(var(--s-theme-ui-colorPicker-paddingInline, 0.75em) * var(--s-scale, 1));\n    padding-block: calc(var(--s-theme-ui-colorPicker-paddingBlock, 0.375em) * var(--s-scale, 1));\n}\n\n.s-pikaday .pika-label {\n    background-color: transparent;\n    color: hsla(calc(var(--s-theme-color-ui-h, 0) + var(--s-theme-color-ui-spin ,0)),calc((var(--s-theme-color-ui-s, 0) + var(--s-theme-color-ui-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-ui-l, 0) + var(--s-theme-color-ui-lightness-offset, 0)) * 1%),var(--s-theme-color-ui-a, 1));\n    top: -0.5em;\n}\n\n.s-pikaday .pika-prev,\n.s-pikaday .is-rtl .pika-next,\n.s-pikaday .pika-next,\n.s-pikaday .is-rtl .pika-prev {\n    background: none;\n    position: relative;\n    display: inline-block;\n    font-size: 0;\n    color: hsla(calc(var(--s-theme-color-ui-h, 0) + var(--s-theme-color-ui-spin ,0)),calc((var(--s-theme-color-ui-s, 0) + var(--s-theme-color-ui-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-ui-l, 0) + var(--s-theme-color-ui-lightness-offset, 0)) * 1%),var(--s-theme-color-ui-a, 1));\n    overflow: visible;\n    background: red;\n    opacity: 1;\n    width: 1em;\n    height: 1em;\n    opacity: 0.7;\n}\n\n.s-pikaday .pika-prev:hover,\n    .s-pikaday .pika-prev:focus,\n    .s-pikaday .is-rtl .pika-next:hover,\n    .s-pikaday .is-rtl .pika-next:focus,\n    .s-pikaday .pika-next:hover,\n    .s-pikaday .pika-next:focus,\n    .s-pikaday .is-rtl .pika-prev:hover,\n    .s-pikaday .is-rtl .pika-prev:focus {\n        opacity: 1;\n    }\n\n.s-pikaday .pika-prev:after, .s-pikaday .is-rtl .pika-next:after, .s-pikaday .pika-next:after, .s-pikaday .is-rtl .pika-prev:after {\n        content: '\u276F';\n        color: inherit;\n        font-size: 1rem;\n        position: absolute;\n        top: 0;\n        left: -2.2em;\n    }\n.s-pikaday .pika-prev:after, .s-pikaday.is-rtl .pika-next:after {\n        transform: rotate(180deg);\n        left: 1em;\n    }\n.s-pikaday.is-rtl .pika-prev:after {\n        transform: rotate(0deg) !important;\n        left: -2em;\n    }\n\n.s-pikaday .pika-table {\n    background: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-background-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-background-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-background-lightness-offset, 0)) * 1%),var(--s-theme-color-main-background-a, 1));\n    border-radius: var(--s-theme-ui-colorPicker-borderRadius, 6px);\n    padding-inline: calc(var(--s-theme-ui-colorPicker-paddingInline, 0.75em) * var(--s-scale, 1));\n    padding-block: calc(var(--s-theme-ui-colorPicker-paddingBlock, 0.375em) * var(--s-scale, 1));\n}\n\n.s-pikaday .pika-table th * {\n    text-decoration: none;\n    color: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-text-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-text-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-text-lightness-offset, 0)) * 1%),var(--s-theme-color-main-text-a, 1));\n}\n\n.s-pikaday .pika-button {\n    background: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-background-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-background-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-background-lightness-offset, 0)) * 1%),var(--s-theme-color-main-background-a, 1));\n    color: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-text-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-text-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-text-lightness-offset, 0)) * 1%),var(--s-theme-color-main-text-a, 1));\n    padding-inline: calc(var(--s-theme-ui-colorPicker-paddingInline, 0.75em) * var(--s-scale, 1));\n    padding-block: calc(var(--s-theme-ui-colorPicker-paddingBlock, 0.375em) * var(--s-scale, 1));\n}\n\n.s-pikaday .pika-week {\n    text-decoration: none;\n}\n\n.s-pikaday .is-today .pika-button {\n    color: hsla(calc(var(--s-theme-color-ui-h, 0) + var(--s-theme-color-ui-spin ,0)),calc((var(--s-theme-color-ui-s, 0) + var(--s-theme-color-ui-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-ui-l, 0) + var(--s-theme-color-ui-lightness-offset, 0)) * 1%),var(--s-theme-color-ui-a, 1));\n    outline: none;\n}\n\n.s-pikaday .is-selected .pika-button {\n    color: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-text-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-text-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-text-lightness-offset, 0)) * 1%),var(--s-theme-color-main-text-a, 1));\n    background: hsla(calc(var(--s-theme-color-ui-h, 0) + var(--s-theme-color-ui-spin ,0)),calc((var(--s-theme-color-ui-s, 0) + var(--s-theme-color-ui-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-ui-l, 0) + var(--s-theme-color-ui-lightness-offset, 0)) * 1%),var(--s-theme-color-ui-a, 0.5));\n    box-shadow: none !important;\n}\n\n.s-pikaday .is-disabled .pika-button {\n    color: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-text-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-text-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-text-lightness-offset, 0)) * 1%),var(--s-theme-color-main-text-a, 1));\n    opacity: 0.3;\n}\n\n.s-pikaday .pika-button:hover {\n    color: hsla(calc(var(--s-theme-color-ui-h, 0) + var(--s-theme-color-ui-foreground-spin ,0)),calc((var(--s-theme-color-ui-s, 0) + var(--s-theme-color-ui-foreground-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-ui-l, 0) + var(--s-theme-color-ui-foreground-lightness-offset, 0)) * 1%),var(--s-theme-color-ui-foreground-a, 1)) !important;\n    background: hsla(calc(var(--s-theme-color-ui-h, 0) + var(--s-theme-color-ui-spin ,0)),calc((var(--s-theme-color-ui-s, 0) + var(--s-theme-color-ui-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-ui-l, 0) + var(--s-theme-color-ui-lightness-offset, 0)) * 1%),var(--s-theme-color-ui-a, 1)) !important;\n}\n";
var __baseCss$1 = `@charset "UTF-8";

/*!
 * Pikaday
 * Copyright \xA9 2014 David Bushell | BSD & MIT license | https://dbushell.com/
 */

.pika-single {
    z-index: 9999;
    display: block;
    position: relative;
    color: #333;
    background: #fff;
    border: 1px solid #ccc;
    border-bottom-color: #bbb;
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
}

/*
clear child float (pika-lendar), using the famous micro clearfix hack
http://nicolasgallagher.com/micro-clearfix-hack/
*/
.pika-single:before,
.pika-single:after {
    content: " ";
    display: table;
}
.pika-single:after { clear: both }

.pika-single.is-hidden {
    display: none;
}

.pika-single.is-bound {
    position: absolute;
    box-shadow: 0 5px 15px -5px rgba(0,0,0,.5);
}

.pika-lendar {
    float: left;
    width: 240px;
    margin: 8px;
}

.pika-title {
    position: relative;
    text-align: center;
}

.pika-label {
    display: inline-block;
    position: relative;
    z-index: 9999;
    overflow: hidden;
    margin: 0;
    padding: 5px 3px;
    font-size: 14px;
    line-height: 20px;
    font-weight: bold;
    background-color: #fff;
}
.pika-title select {
    cursor: pointer;
    position: absolute;
    z-index: 9998;
    margin: 0;
    left: 0;
    top: 5px;
    opacity: 0;
}

.pika-prev,
.pika-next {
    display: block;
    cursor: pointer;
    position: relative;
    outline: none;
    border: 0;
    padding: 0;
    width: 20px;
    height: 30px;
    /* hide text using text-indent trick, using width value (it's enough) */
    text-indent: 20px;
    white-space: nowrap;
    overflow: hidden;
    background-color: transparent;
    background-position: center center;
    background-repeat: no-repeat;
    background-size: 75% 75%;
    opacity: .5;
}

.pika-prev:hover,
.pika-next:hover {
    opacity: 1;
}

.pika-prev,
.is-rtl .pika-next {
    float: left;
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAeCAYAAAAsEj5rAAAAUklEQVR42u3VMQoAIBADQf8Pgj+OD9hG2CtONJB2ymQkKe0HbwAP0xucDiQWARITIDEBEnMgMQ8S8+AqBIl6kKgHiXqQqAeJepBo/z38J/U0uAHlaBkBl9I4GwAAAABJRU5ErkJggg==');
}

.pika-next,
.is-rtl .pika-prev {
    float: right;
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAeCAYAAAAsEj5rAAAAU0lEQVR42u3VOwoAMAgE0dwfAnNjU26bYkBCFGwfiL9VVWoO+BJ4Gf3gtsEKKoFBNTCoCAYVwaAiGNQGMUHMkjGbgjk2mIONuXo0nC8XnCf1JXgArVIZAQh5TKYAAAAASUVORK5CYII=');
}

.pika-prev.is-disabled,
.pika-next.is-disabled {
    cursor: default;
    opacity: .2;
}

.pika-select {
    display: inline-block;
}

.pika-table {
    width: 100%;
    border-collapse: collapse;
    border-spacing: 0;
    border: 0;
}

.pika-table th,
.pika-table td {
    width: 14.285714285714286%;
    padding: 0;
}

.pika-table th {
    color: #999;
    font-size: 12px;
    line-height: 25px;
    font-weight: bold;
    text-align: center;
}

.pika-button {
    cursor: pointer;
    display: block;
    box-sizing: border-box;
    -moz-box-sizing: border-box;
    outline: none;
    border: 0;
    margin: 0;
    width: 100%;
    padding: 5px;
    color: #666;
    font-size: 12px;
    line-height: 15px;
    text-align: right;
    background: #f5f5f5;
    height: initial;
}

.pika-week {
    font-size: 11px;
    color: #999;
}

.is-today .pika-button {
    color: #33aaff;
    font-weight: bold;
}

.is-selected .pika-button,
.has-event .pika-button {
    color: #fff;
    font-weight: bold;
    background: #33aaff;
    box-shadow: inset 0 1px 3px #178fe5;
    border-radius: 3px;
}

.has-event .pika-button {
    background: #005da9;
    box-shadow: inset 0 1px 3px #0076c9;
}

.is-disabled .pika-button,
.is-inrange .pika-button {
    background: #D5E9F7;
}

.is-startrange .pika-button {
    color: #fff;
    background: #6CB31D;
    box-shadow: none;
    border-radius: 3px;
}

.is-endrange .pika-button {
    color: #fff;
    background: #33aaff;
    box-shadow: none;
    border-radius: 3px;
}

.is-disabled .pika-button {
    pointer-events: none;
    cursor: default;
    color: #999;
    opacity: .3;
}

.is-outside-current-month .pika-button {
    color: #999;
    opacity: .3;
}

.is-selection-disabled {
    pointer-events: none;
    cursor: default;
}

.pika-button:hover,
.pika-row.pick-whole-week:hover .pika-button {
    color: #fff;
    background: #ff8000;
    box-shadow: none;
    border-radius: 3px;
}

/* styling for abbr */
.pika-table abbr {
    border-bottom: none;
    cursor: help;
}
`;
var __decorate$1 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d2 = decorators[i2])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __awaiter$a = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e20) {
        reject(e20);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e20) {
        reject(e20);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SDatePicker extends SLitComponent {
  constructor() {
    super({
      litComponent: {
        shadowDom: false
      },
      componentUtils: {
        interface: SDatePickerComponentInterface
      }
    });
  }
  static get properties() {
    return SLitComponent.properties({}, SDatePickerComponentInterface);
  }
  static get styles() {
    return css$1`
            ${unsafeCSS(`
                ${__baseCss$1}
                ${__css$4}
                ${__themeCss}
            `)}
        `;
  }
  firstUpdated() {
    return __awaiter$a(this, void 0, void 0, function* () {
      const $input = yield this._$input;
      let $button;
      if (this.props.button)
        $button = yield this._$button;
      yield whenInteract(this);
      const _this = this;
      this._picker = new __pikaday({
        field: $input,
        format: this.props.format,
        trigger: $button,
        firstDay: this.props.firstDay,
        minDate: this.parseDate(this.props.minDate),
        maxDate: this.parseDate(this.props.maxDate),
        disableWeekends: this.props.disableWeekends,
        yearRange: this.props.yearRange,
        isRTL: this.props.rtl,
        i18n: this.props.i18n,
        numberOfMonths: this.props.numberOfMonths,
        events: this.props.events,
        defaultDate: this.props.value,
        theme: this.props.defaultStyle ? "s-pikaday" : "",
        toString(date, format2) {
          return _this.dateToString(date, format2);
        },
        parse(dateString, format2) {
          return _this.parseDate(dateString, format2);
        },
        onSelect: () => {
          this._dispatchEvent("select");
        },
        onOpen: () => {
          this._dispatchEvent("open");
        },
        onClose: () => {
          this._dispatchEvent("close");
        },
        onDraw: () => {
          this._dispatchEvent("draw");
        }
      });
      Array.from(this.classList).forEach((cls2) => {
        if (cls2.match(/^s-cs/))
          this._picker.el.classList.add(cls2);
      });
      [
        "toString",
        "getDate",
        "setDate",
        "getMoment",
        "clear",
        "gotoDate",
        "gotoToday",
        "gotoMonth",
        "nextMonth",
        "prevMonth",
        "gotoYear",
        "setMinDate",
        "setMaxDate",
        "setStartRange",
        "setEndRange",
        "isVisible",
        "show",
        "adjustPosition",
        "hide",
        "destroy"
      ].forEach((key) => {
        this[key] = this._picker[key].bind(this._picker);
      });
    });
  }
  parseDate(dateString, format2 = this.props.format) {
    return hooks(dateString, format2).toDate();
  }
  dateToString(date, format2 = this.props.format) {
    return hooks(date).format(format2);
  }
  _dispatchEvent(eventName) {
    const event = new CustomEvent(eventName, {
      detail: {
        dateStr: this._picker.toString(),
        date: this._picker.getDate()
      }
    });
    this.dispatchEvent(event);
  }
  render() {
    return html$2`
            <div class="${this.componentUtils.className("")}">
                <input
                    class="${this.componentUtils.className("__input", "s-input")}"
                    type="text"
                    name="${this.name}"
                    ?rtl="${this.rtl}"
                    placeholder="${this.placeholder}"
                    autocomplete="off"
                />
                ${this.button ? html$2`
                          <button onclick="return false" class="${this.componentUtils.className("__button", "s-btn")}">
                              ${html([this.calendarIcon])}
                          </button>
                      ` : ""}
            </div>
        `;
  }
}
__decorate$1([queryAsync("input")], SDatePicker.prototype, "_$input", void 0);
__decorate$1([queryAsync("button")], SDatePicker.prototype, "_$button", void 0);
function define$b(props = {}, tagName = "s-date-picker") {
  SLitComponent.setDefaultProps(tagName, props);
  customElements.define(tagName, SDatePicker);
}
var pickr_min = { exports: {} };
/*! Pickr 1.8.2 MIT | https://github.com/Simonwep/pickr */
(function(module2, exports) {
  !function(t2, e20) {
    module2.exports = e20();
  }(self, function() {
    return (() => {
      var t2 = { d: (e21, o3) => {
        for (var n3 in o3)
          t2.o(o3, n3) && !t2.o(e21, n3) && Object.defineProperty(e21, n3, { enumerable: true, get: o3[n3] });
      }, o: (t3, e21) => Object.prototype.hasOwnProperty.call(t3, e21), r: (t3) => {
        typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(t3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t3, "__esModule", { value: true });
      } }, e20 = {};
      t2.d(e20, { default: () => L2 });
      var o2 = {};
      function n2(t3, e21, o3, n3, i3 = {}) {
        e21 instanceof HTMLCollection || e21 instanceof NodeList ? e21 = Array.from(e21) : Array.isArray(e21) || (e21 = [e21]), Array.isArray(o3) || (o3 = [o3]);
        for (const s3 of e21)
          for (const e22 of o3)
            s3[t3](e22, n3, __spreadValues({ capture: false }, i3));
        return Array.prototype.slice.call(arguments, 1);
      }
      t2.r(o2), t2.d(o2, { adjustableInputNumbers: () => p2, createElementFromString: () => r2, createFromTemplate: () => a2, eventPath: () => l2, off: () => s2, on: () => i2, resolveElement: () => c2 });
      const i2 = n2.bind(null, "addEventListener"), s2 = n2.bind(null, "removeEventListener");
      function r2(t3) {
        const e21 = document.createElement("div");
        return e21.innerHTML = t3.trim(), e21.firstElementChild;
      }
      function a2(t3) {
        const e21 = (t4, e22) => {
          const o4 = t4.getAttribute(e22);
          return t4.removeAttribute(e22), o4;
        }, o3 = (t4, n3 = {}) => {
          const i3 = e21(t4, ":obj"), s3 = e21(t4, ":ref"), r3 = i3 ? n3[i3] = {} : n3;
          s3 && (n3[s3] = t4);
          for (const n4 of Array.from(t4.children)) {
            const t5 = e21(n4, ":arr"), i4 = o3(n4, t5 ? {} : r3);
            t5 && (r3[t5] || (r3[t5] = [])).push(Object.keys(i4).length ? i4 : n4);
          }
          return n3;
        };
        return o3(r2(t3));
      }
      function l2(t3) {
        let e21 = t3.path || t3.composedPath && t3.composedPath();
        if (e21)
          return e21;
        let o3 = t3.target.parentElement;
        for (e21 = [t3.target, o3]; o3 = o3.parentElement; )
          e21.push(o3);
        return e21.push(document, window), e21;
      }
      function c2(t3) {
        return t3 instanceof Element ? t3 : typeof t3 == "string" ? t3.split(/>>/g).reduce((t4, e21, o3, n3) => (t4 = t4.querySelector(e21), o3 < n3.length - 1 ? t4.shadowRoot : t4), document) : null;
      }
      function p2(t3, e21 = (t4) => t4) {
        function o3(o4) {
          const n3 = [1e-3, 0.01, 0.1][Number(o4.shiftKey || 2 * o4.ctrlKey)] * (o4.deltaY < 0 ? 1 : -1);
          let i3 = 0, s3 = t3.selectionStart;
          t3.value = t3.value.replace(/[\d.]+/g, (t4, o5) => o5 <= s3 && o5 + t4.length >= s3 ? (s3 = o5, e21(Number(t4), n3, i3)) : (i3++, t4)), t3.focus(), t3.setSelectionRange(s3, s3), o4.preventDefault(), t3.dispatchEvent(new Event("input"));
        }
        i2(t3, "focus", () => i2(window, "wheel", o3, { passive: false })), i2(t3, "blur", () => s2(window, "wheel", o3));
      }
      const { min: u2, max: h2, floor: d2, round: m2 } = Math;
      function f2(t3, e21, o3) {
        e21 /= 100, o3 /= 100;
        const n3 = d2(t3 = t3 / 360 * 6), i3 = t3 - n3, s3 = o3 * (1 - e21), r3 = o3 * (1 - i3 * e21), a3 = o3 * (1 - (1 - i3) * e21), l3 = n3 % 6;
        return [255 * [o3, r3, s3, s3, a3, o3][l3], 255 * [a3, o3, o3, r3, s3, s3][l3], 255 * [s3, s3, a3, o3, o3, r3][l3]];
      }
      function v2(t3, e21, o3) {
        const n3 = (2 - (e21 /= 100)) * (o3 /= 100) / 2;
        return n3 !== 0 && (e21 = n3 === 1 ? 0 : n3 < 0.5 ? e21 * o3 / (2 * n3) : e21 * o3 / (2 - 2 * n3)), [t3, 100 * e21, 100 * n3];
      }
      function b2(t3, e21, o3) {
        const n3 = u2(t3 /= 255, e21 /= 255, o3 /= 255), i3 = h2(t3, e21, o3), s3 = i3 - n3;
        let r3, a3;
        if (s3 === 0)
          r3 = a3 = 0;
        else {
          a3 = s3 / i3;
          const n4 = ((i3 - t3) / 6 + s3 / 2) / s3, l3 = ((i3 - e21) / 6 + s3 / 2) / s3, c3 = ((i3 - o3) / 6 + s3 / 2) / s3;
          t3 === i3 ? r3 = c3 - l3 : e21 === i3 ? r3 = 1 / 3 + n4 - c3 : o3 === i3 && (r3 = 2 / 3 + l3 - n4), r3 < 0 ? r3 += 1 : r3 > 1 && (r3 -= 1);
        }
        return [360 * r3, 100 * a3, 100 * i3];
      }
      function y2(t3, e21, o3, n3) {
        e21 /= 100, o3 /= 100;
        return [...b2(255 * (1 - u2(1, (t3 /= 100) * (1 - (n3 /= 100)) + n3)), 255 * (1 - u2(1, e21 * (1 - n3) + n3)), 255 * (1 - u2(1, o3 * (1 - n3) + n3)))];
      }
      function g2(t3, e21, o3) {
        e21 /= 100;
        const n3 = 2 * (e21 *= (o3 /= 100) < 0.5 ? o3 : 1 - o3) / (o3 + e21) * 100, i3 = 100 * (o3 + e21);
        return [t3, isNaN(n3) ? 0 : n3, i3];
      }
      function _2(t3) {
        return b2(...t3.match(/.{2}/g).map((t4) => parseInt(t4, 16)));
      }
      function w2(t3) {
        t3 = t3.match(/^[a-zA-Z]+$/) ? function(t4) {
          if (t4.toLowerCase() === "black")
            return "#000";
          const e22 = document.createElement("canvas").getContext("2d");
          return e22.fillStyle = t4, e22.fillStyle === "#000" ? null : e22.fillStyle;
        }(t3) : t3;
        const e21 = { cmyk: /^cmyk[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)/i, rgba: /^((rgba)|rgb)[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)[\D]*?([\d.]+|$)/i, hsla: /^((hsla)|hsl)[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)[\D]*?([\d.]+|$)/i, hsva: /^((hsva)|hsv)[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)[\D]*?([\d.]+|$)/i, hexa: /^#?(([\dA-Fa-f]{3,4})|([\dA-Fa-f]{6})|([\dA-Fa-f]{8}))$/i }, o3 = (t4) => t4.map((t5) => /^(|\d+)\.\d+|\d+$/.test(t5) ? Number(t5) : void 0);
        let n3;
        t:
          for (const i3 in e21) {
            if (!(n3 = e21[i3].exec(t3)))
              continue;
            const s3 = (t4) => !!n3[2] == (typeof t4 == "number");
            switch (i3) {
              case "cmyk": {
                const [, t4, e22, s4, r3] = o3(n3);
                if (t4 > 100 || e22 > 100 || s4 > 100 || r3 > 100)
                  break t;
                return { values: y2(t4, e22, s4, r3), type: i3 };
              }
              case "rgba": {
                const [, , , t4, e22, r3, a3] = o3(n3);
                if (t4 > 255 || e22 > 255 || r3 > 255 || a3 < 0 || a3 > 1 || !s3(a3))
                  break t;
                return { values: [...b2(t4, e22, r3), a3], a: a3, type: i3 };
              }
              case "hexa": {
                let [, t4] = n3;
                t4.length !== 4 && t4.length !== 3 || (t4 = t4.split("").map((t5) => t5 + t5).join(""));
                const e22 = t4.substring(0, 6);
                let o4 = t4.substring(6);
                return o4 = o4 ? parseInt(o4, 16) / 255 : void 0, { values: [..._2(e22), o4], a: o4, type: i3 };
              }
              case "hsla": {
                const [, , , t4, e22, r3, a3] = o3(n3);
                if (t4 > 360 || e22 > 100 || r3 > 100 || a3 < 0 || a3 > 1 || !s3(a3))
                  break t;
                return { values: [...g2(t4, e22, r3), a3], a: a3, type: i3 };
              }
              case "hsva": {
                const [, , , t4, e22, r3, a3] = o3(n3);
                if (t4 > 360 || e22 > 100 || r3 > 100 || a3 < 0 || a3 > 1 || !s3(a3))
                  break t;
                return { values: [t4, e22, r3, a3], a: a3, type: i3 };
              }
            }
          }
        return { values: null, type: null };
      }
      function A2(t3 = 0, e21 = 0, o3 = 0, n3 = 1) {
        const i3 = (t4, e22) => (o4 = -1) => e22(~o4 ? t4.map((t5) => Number(t5.toFixed(o4))) : t4), s3 = { h: t3, s: e21, v: o3, a: n3, toHSVA() {
          const t4 = [s3.h, s3.s, s3.v, s3.a];
          return t4.toString = i3(t4, (t5) => `hsva(${t5[0]}, ${t5[1]}%, ${t5[2]}%, ${s3.a})`), t4;
        }, toHSLA() {
          const t4 = [...v2(s3.h, s3.s, s3.v), s3.a];
          return t4.toString = i3(t4, (t5) => `hsla(${t5[0]}, ${t5[1]}%, ${t5[2]}%, ${s3.a})`), t4;
        }, toRGBA() {
          const t4 = [...f2(s3.h, s3.s, s3.v), s3.a];
          return t4.toString = i3(t4, (t5) => `rgba(${t5[0]}, ${t5[1]}, ${t5[2]}, ${s3.a})`), t4;
        }, toCMYK() {
          const t4 = function(t5, e22, o4) {
            const n4 = f2(t5, e22, o4), i4 = n4[0] / 255, s4 = n4[1] / 255, r3 = n4[2] / 255, a3 = u2(1 - i4, 1 - s4, 1 - r3);
            return [100 * (a3 === 1 ? 0 : (1 - i4 - a3) / (1 - a3)), 100 * (a3 === 1 ? 0 : (1 - s4 - a3) / (1 - a3)), 100 * (a3 === 1 ? 0 : (1 - r3 - a3) / (1 - a3)), 100 * a3];
          }(s3.h, s3.s, s3.v);
          return t4.toString = i3(t4, (t5) => `cmyk(${t5[0]}%, ${t5[1]}%, ${t5[2]}%, ${t5[3]}%)`), t4;
        }, toHEXA() {
          const t4 = function(t5, e23, o4) {
            return f2(t5, e23, o4).map((t6) => m2(t6).toString(16).padStart(2, "0"));
          }(s3.h, s3.s, s3.v), e22 = s3.a >= 1 ? "" : Number((255 * s3.a).toFixed(0)).toString(16).toUpperCase().padStart(2, "0");
          return e22 && t4.push(e22), t4.toString = () => `#${t4.join("").toUpperCase()}`, t4;
        }, clone: () => A2(s3.h, s3.s, s3.v, s3.a) };
        return s3;
      }
      const C2 = (t3) => Math.max(Math.min(t3, 1), 0);
      function $2(t3) {
        const e21 = { options: Object.assign({ lock: null, onchange: () => 0, onstop: () => 0 }, t3), _keyboard(t4) {
          const { options: o4 } = e21, { type: n4, key: i3 } = t4;
          if (document.activeElement === o4.wrapper) {
            const { lock: o5 } = e21.options, s3 = i3 === "ArrowUp", r4 = i3 === "ArrowRight", a3 = i3 === "ArrowDown", l3 = i3 === "ArrowLeft";
            if (n4 === "keydown" && (s3 || r4 || a3 || l3)) {
              let n5 = 0, i4 = 0;
              o5 === "v" ? n5 = s3 || r4 ? 1 : -1 : o5 === "h" ? n5 = s3 || r4 ? -1 : 1 : (i4 = s3 ? -1 : a3 ? 1 : 0, n5 = l3 ? -1 : r4 ? 1 : 0), e21.update(C2(e21.cache.x + 0.01 * n5), C2(e21.cache.y + 0.01 * i4)), t4.preventDefault();
            } else
              i3.startsWith("Arrow") && (e21.options.onstop(), t4.preventDefault());
          }
        }, _tapstart(t4) {
          i2(document, ["mouseup", "touchend", "touchcancel"], e21._tapstop), i2(document, ["mousemove", "touchmove"], e21._tapmove), t4.cancelable && t4.preventDefault(), e21._tapmove(t4);
        }, _tapmove(t4) {
          const { options: o4, cache: n4 } = e21, { lock: i3, element: s3, wrapper: r4 } = o4, a3 = r4.getBoundingClientRect();
          let l3 = 0, c3 = 0;
          if (t4) {
            const e22 = t4 && t4.touches && t4.touches[0];
            l3 = t4 ? (e22 || t4).clientX : 0, c3 = t4 ? (e22 || t4).clientY : 0, l3 < a3.left ? l3 = a3.left : l3 > a3.left + a3.width && (l3 = a3.left + a3.width), c3 < a3.top ? c3 = a3.top : c3 > a3.top + a3.height && (c3 = a3.top + a3.height), l3 -= a3.left, c3 -= a3.top;
          } else
            n4 && (l3 = n4.x * a3.width, c3 = n4.y * a3.height);
          i3 !== "h" && (s3.style.left = `calc(${l3 / a3.width * 100}% - ${s3.offsetWidth / 2}px)`), i3 !== "v" && (s3.style.top = `calc(${c3 / a3.height * 100}% - ${s3.offsetHeight / 2}px)`), e21.cache = { x: l3 / a3.width, y: c3 / a3.height };
          const p3 = C2(l3 / a3.width), u3 = C2(c3 / a3.height);
          switch (i3) {
            case "v":
              return o4.onchange(p3);
            case "h":
              return o4.onchange(u3);
            default:
              return o4.onchange(p3, u3);
          }
        }, _tapstop() {
          e21.options.onstop(), s2(document, ["mouseup", "touchend", "touchcancel"], e21._tapstop), s2(document, ["mousemove", "touchmove"], e21._tapmove);
        }, trigger() {
          e21._tapmove();
        }, update(t4 = 0, o4 = 0) {
          const { left: n4, top: i3, width: s3, height: r4 } = e21.options.wrapper.getBoundingClientRect();
          e21.options.lock === "h" && (o4 = t4), e21._tapmove({ clientX: n4 + s3 * t4, clientY: i3 + r4 * o4 });
        }, destroy() {
          const { options: t4, _tapstart: o4, _keyboard: n4 } = e21;
          s2(document, ["keydown", "keyup"], n4), s2([t4.wrapper, t4.element], "mousedown", o4), s2([t4.wrapper, t4.element], "touchstart", o4, { passive: false });
        } }, { options: o3, _tapstart: n3, _keyboard: r3 } = e21;
        return i2([o3.wrapper, o3.element], "mousedown", n3), i2([o3.wrapper, o3.element], "touchstart", n3, { passive: false }), i2(document, ["keydown", "keyup"], r3), e21;
      }
      function k2(t3 = {}) {
        t3 = Object.assign({ onchange: () => 0, className: "", elements: [] }, t3);
        const e21 = i2(t3.elements, "click", (e22) => {
          t3.elements.forEach((o3) => o3.classList[e22.target === o3 ? "add" : "remove"](t3.className)), t3.onchange(e22), e22.stopPropagation();
        });
        return { destroy: () => s2(...e21) };
      }
      const S2 = { variantFlipOrder: { start: "sme", middle: "mse", end: "ems" }, positionFlipOrder: { top: "tbrl", right: "rltb", bottom: "btrl", left: "lrbt" }, position: "bottom", margin: 8 }, O2 = (t3, e21, o3) => {
        const { container: n3, margin: i3, position: s3, variantFlipOrder: r3, positionFlipOrder: a3 } = __spreadValues(__spreadValues({ container: document.documentElement.getBoundingClientRect() }, S2), o3), { left: l3, top: c3 } = e21.style;
        e21.style.left = "0", e21.style.top = "0";
        const p3 = t3.getBoundingClientRect(), u3 = e21.getBoundingClientRect(), h3 = { t: p3.top - u3.height - i3, b: p3.bottom + i3, r: p3.right + i3, l: p3.left - u3.width - i3 }, d3 = { vs: p3.left, vm: p3.left + p3.width / 2 + -u3.width / 2, ve: p3.left + p3.width - u3.width, hs: p3.top, hm: p3.bottom - p3.height / 2 - u3.height / 2, he: p3.bottom - u3.height }, [m3, f3 = "middle"] = s3.split("-"), v3 = a3[m3], b3 = r3[f3], { top: y3, left: g3, bottom: _3, right: w3 } = n3;
        for (const t4 of v3) {
          const o4 = t4 === "t" || t4 === "b", n4 = h3[t4], [i4, s4] = o4 ? ["top", "left"] : ["left", "top"], [r4, a4] = o4 ? [u3.height, u3.width] : [u3.width, u3.height], [l4, c4] = o4 ? [_3, w3] : [w3, _3], [p4, m4] = o4 ? [y3, g3] : [g3, y3];
          if (!(n4 < p4 || n4 + r4 > l4))
            for (const r5 of b3) {
              const l5 = d3[(o4 ? "v" : "h") + r5];
              if (!(l5 < m4 || l5 + a4 > c4))
                return e21.style[s4] = l5 - u3[s4] + "px", e21.style[i4] = n4 - u3[i4] + "px", t4 + r5;
            }
        }
        return e21.style.left = l3, e21.style.top = c3, null;
      };
      function E2(t3, e21, o3) {
        return e21 in t3 ? Object.defineProperty(t3, e21, { value: o3, enumerable: true, configurable: true, writable: true }) : t3[e21] = o3, t3;
      }
      class L2 {
        constructor(t3) {
          E2(this, "_initializingActive", true), E2(this, "_recalc", true), E2(this, "_nanopop", null), E2(this, "_root", null), E2(this, "_color", A2()), E2(this, "_lastColor", A2()), E2(this, "_swatchColors", []), E2(this, "_setupAnimationFrame", null), E2(this, "_eventListener", { init: [], save: [], hide: [], show: [], clear: [], change: [], changestop: [], cancel: [], swatchselect: [] }), this.options = t3 = Object.assign(__spreadValues({}, L2.DEFAULT_OPTIONS), t3);
          const { swatches: e21, components: o3, theme: n3, sliders: i3, lockOpacity: s3, padding: r3 } = t3;
          ["nano", "monolith"].includes(n3) && !i3 && (t3.sliders = "h"), o3.interaction || (o3.interaction = {});
          const { preview: a3, opacity: l3, hue: c3, palette: p3 } = o3;
          o3.opacity = !s3 && l3, o3.palette = p3 || a3 || l3 || c3, this._preBuild(), this._buildComponents(), this._bindEvents(), this._finalBuild(), e21 && e21.length && e21.forEach((t4) => this.addSwatch(t4));
          const { button: u3, app: h3 } = this._root;
          this._nanopop = ((t4, e22, o4) => {
            const n4 = typeof t4 != "object" || t4 instanceof HTMLElement ? __spreadValues({ reference: t4, popper: e22 }, o4) : t4;
            return { update(t5 = n4) {
              const { reference: e23, popper: o5 } = Object.assign(n4, t5);
              if (!o5 || !e23)
                throw new Error("Popper- or reference-element missing.");
              return O2(e23, o5, n4);
            } };
          })(u3, h3, { margin: r3 }), u3.setAttribute("role", "button"), u3.setAttribute("aria-label", this._t("btn:toggle"));
          const d3 = this;
          this._setupAnimationFrame = requestAnimationFrame(function e22() {
            if (!h3.offsetWidth)
              return requestAnimationFrame(e22);
            d3.setColor(t3.default), d3._rePositioningPicker(), t3.defaultRepresentation && (d3._representation = t3.defaultRepresentation, d3.setColorRepresentation(d3._representation)), t3.showAlways && d3.show(), d3._initializingActive = false, d3._emit("init");
          });
        }
        _preBuild() {
          const { options: t3 } = this;
          for (const e21 of ["el", "container"])
            t3[e21] = c2(t3[e21]);
          this._root = ((t4) => {
            const { components: e21, useAsButton: o3, inline: n3, appClass: i3, theme: s3, lockOpacity: r3 } = t4.options, l3 = (t5) => t5 ? "" : 'style="display:none" hidden', c3 = (e22) => t4._t(e22), p3 = a2(`
      <div :ref="root" class="pickr">

        ${o3 ? "" : '<button type="button" :ref="button" class="pcr-button"></button>'}

        <div :ref="app" class="pcr-app ${i3 || ""}" data-theme="${s3}" ${n3 ? 'style="position: unset"' : ""} aria-label="${c3("ui:dialog")}" role="window">
          <div class="pcr-selection" ${l3(e21.palette)}>
            <div :obj="preview" class="pcr-color-preview" ${l3(e21.preview)}>
              <button type="button" :ref="lastColor" class="pcr-last-color" aria-label="${c3("btn:last-color")}"></button>
              <div :ref="currentColor" class="pcr-current-color"></div>
            </div>

            <div :obj="palette" class="pcr-color-palette">
              <div :ref="picker" class="pcr-picker"></div>
              <div :ref="palette" class="pcr-palette" tabindex="0" aria-label="${c3("aria:palette")}" role="listbox"></div>
            </div>

            <div :obj="hue" class="pcr-color-chooser" ${l3(e21.hue)}>
              <div :ref="picker" class="pcr-picker"></div>
              <div :ref="slider" class="pcr-hue pcr-slider" tabindex="0" aria-label="${c3("aria:hue")}" role="slider"></div>
            </div>

            <div :obj="opacity" class="pcr-color-opacity" ${l3(e21.opacity)}>
              <div :ref="picker" class="pcr-picker"></div>
              <div :ref="slider" class="pcr-opacity pcr-slider" tabindex="0" aria-label="${c3("aria:opacity")}" role="slider"></div>
            </div>
          </div>

          <div class="pcr-swatches ${e21.palette ? "" : "pcr-last"}" :ref="swatches"></div>

          <div :obj="interaction" class="pcr-interaction" ${l3(Object.keys(e21.interaction).length)}>
            <input :ref="result" class="pcr-result" type="text" spellcheck="false" ${l3(e21.interaction.input)} aria-label="${c3("aria:input")}">

            <input :arr="options" class="pcr-type" data-type="HEXA" value="${r3 ? "HEX" : "HEXA"}" type="button" ${l3(e21.interaction.hex)}>
            <input :arr="options" class="pcr-type" data-type="RGBA" value="${r3 ? "RGB" : "RGBA"}" type="button" ${l3(e21.interaction.rgba)}>
            <input :arr="options" class="pcr-type" data-type="HSLA" value="${r3 ? "HSL" : "HSLA"}" type="button" ${l3(e21.interaction.hsla)}>
            <input :arr="options" class="pcr-type" data-type="HSVA" value="${r3 ? "HSV" : "HSVA"}" type="button" ${l3(e21.interaction.hsva)}>
            <input :arr="options" class="pcr-type" data-type="CMYK" value="CMYK" type="button" ${l3(e21.interaction.cmyk)}>

            <input :ref="save" class="pcr-save" value="${c3("btn:save")}" type="button" ${l3(e21.interaction.save)} aria-label="${c3("aria:btn:save")}">
            <input :ref="cancel" class="pcr-cancel" value="${c3("btn:cancel")}" type="button" ${l3(e21.interaction.cancel)} aria-label="${c3("aria:btn:cancel")}">
            <input :ref="clear" class="pcr-clear" value="${c3("btn:clear")}" type="button" ${l3(e21.interaction.clear)} aria-label="${c3("aria:btn:clear")}">
          </div>
        </div>
      </div>
    `), u3 = p3.interaction;
            return u3.options.find((t5) => !t5.hidden && !t5.classList.add("active")), u3.type = () => u3.options.find((t5) => t5.classList.contains("active")), p3;
          })(this), t3.useAsButton && (this._root.button = t3.el), t3.container.appendChild(this._root.root);
        }
        _finalBuild() {
          const t3 = this.options, e21 = this._root;
          if (t3.container.removeChild(e21.root), t3.inline) {
            const o3 = t3.el.parentElement;
            t3.el.nextSibling ? o3.insertBefore(e21.app, t3.el.nextSibling) : o3.appendChild(e21.app);
          } else
            t3.container.appendChild(e21.app);
          t3.useAsButton ? t3.inline && t3.el.remove() : t3.el.parentNode.replaceChild(e21.root, t3.el), t3.disabled && this.disable(), t3.comparison || (e21.button.style.transition = "none", t3.useAsButton || (e21.preview.lastColor.style.transition = "none")), this.hide();
        }
        _buildComponents() {
          const t3 = this, e21 = this.options.components, o3 = (t3.options.sliders || "v").repeat(2), [n3, i3] = o3.match(/^[vh]+$/g) ? o3 : [], s3 = () => this._color || (this._color = this._lastColor.clone()), r3 = { palette: $2({ element: t3._root.palette.picker, wrapper: t3._root.palette.palette, onstop: () => t3._emit("changestop", "slider", t3), onchange(o4, n4) {
            if (!e21.palette)
              return;
            const i4 = s3(), { _root: r4, options: a3 } = t3, { lastColor: l3, currentColor: c3 } = r4.preview;
            t3._recalc && (i4.s = 100 * o4, i4.v = 100 - 100 * n4, i4.v < 0 && (i4.v = 0), t3._updateOutput("slider"));
            const p3 = i4.toRGBA().toString(0);
            this.element.style.background = p3, this.wrapper.style.background = `
                        linear-gradient(to top, rgba(0, 0, 0, ${i4.a}), transparent),
                        linear-gradient(to left, hsla(${i4.h}, 100%, 50%, ${i4.a}), rgba(255, 255, 255, ${i4.a}))
                    `, a3.comparison ? a3.useAsButton || t3._lastColor || l3.style.setProperty("--pcr-color", p3) : (r4.button.style.setProperty("--pcr-color", p3), r4.button.classList.remove("clear"));
            const u3 = i4.toHEXA().toString();
            for (const { el: e22, color: o5 } of t3._swatchColors)
              e22.classList[u3 === o5.toHEXA().toString() ? "add" : "remove"]("pcr-active");
            c3.style.setProperty("--pcr-color", p3);
          } }), hue: $2({ lock: i3 === "v" ? "h" : "v", element: t3._root.hue.picker, wrapper: t3._root.hue.slider, onstop: () => t3._emit("changestop", "slider", t3), onchange(o4) {
            if (!e21.hue || !e21.palette)
              return;
            const n4 = s3();
            t3._recalc && (n4.h = 360 * o4), this.element.style.backgroundColor = `hsl(${n4.h}, 100%, 50%)`, r3.palette.trigger();
          } }), opacity: $2({ lock: n3 === "v" ? "h" : "v", element: t3._root.opacity.picker, wrapper: t3._root.opacity.slider, onstop: () => t3._emit("changestop", "slider", t3), onchange(o4) {
            if (!e21.opacity || !e21.palette)
              return;
            const n4 = s3();
            t3._recalc && (n4.a = Math.round(100 * o4) / 100), this.element.style.background = `rgba(0, 0, 0, ${n4.a})`, r3.palette.trigger();
          } }), selectable: k2({ elements: t3._root.interaction.options, className: "active", onchange(e22) {
            t3._representation = e22.target.getAttribute("data-type").toUpperCase(), t3._recalc && t3._updateOutput("swatch");
          } }) };
          this._components = r3;
        }
        _bindEvents() {
          const { _root: t3, options: e21 } = this, o3 = [i2(t3.interaction.clear, "click", () => this._clearColor()), i2([t3.interaction.cancel, t3.preview.lastColor], "click", () => {
            this.setHSVA(...(this._lastColor || this._color).toHSVA(), true), this._emit("cancel");
          }), i2(t3.interaction.save, "click", () => {
            !this.applyColor() && !e21.showAlways && this.hide();
          }), i2(t3.interaction.result, ["keyup", "input"], (t4) => {
            this.setColor(t4.target.value, true) && !this._initializingActive && (this._emit("change", this._color, "input", this), this._emit("changestop", "input", this)), t4.stopImmediatePropagation();
          }), i2(t3.interaction.result, ["focus", "blur"], (t4) => {
            this._recalc = t4.type === "blur", this._recalc && this._updateOutput(null);
          }), i2([t3.palette.palette, t3.palette.picker, t3.hue.slider, t3.hue.picker, t3.opacity.slider, t3.opacity.picker], ["mousedown", "touchstart"], () => this._recalc = true, { passive: true })];
          if (!e21.showAlways) {
            const n3 = e21.closeWithKey;
            o3.push(i2(t3.button, "click", () => this.isOpen() ? this.hide() : this.show()), i2(document, "keyup", (t4) => this.isOpen() && (t4.key === n3 || t4.code === n3) && this.hide()), i2(document, ["touchstart", "mousedown"], (e22) => {
              this.isOpen() && !l2(e22).some((e23) => e23 === t3.app || e23 === t3.button) && this.hide();
            }, { capture: true }));
          }
          if (e21.adjustableNumbers) {
            const e22 = { rgba: [255, 255, 255, 1], hsva: [360, 100, 100, 1], hsla: [360, 100, 100, 1], cmyk: [100, 100, 100, 100] };
            p2(t3.interaction.result, (t4, o4, n3) => {
              const i3 = e22[this.getColorRepresentation().toLowerCase()];
              if (i3) {
                const e23 = i3[n3], s3 = t4 + (e23 >= 100 ? 1e3 * o4 : o4);
                return s3 <= 0 ? 0 : Number((s3 < e23 ? s3 : e23).toPrecision(3));
              }
              return t4;
            });
          }
          if (e21.autoReposition && !e21.inline) {
            let t4 = null;
            const n3 = this;
            o3.push(i2(window, ["scroll", "resize"], () => {
              n3.isOpen() && (e21.closeOnScroll && n3.hide(), t4 === null ? (t4 = setTimeout(() => t4 = null, 100), requestAnimationFrame(function e22() {
                n3._rePositioningPicker(), t4 !== null && requestAnimationFrame(e22);
              })) : (clearTimeout(t4), t4 = setTimeout(() => t4 = null, 100)));
            }, { capture: true }));
          }
          this._eventBindings = o3;
        }
        _rePositioningPicker() {
          const { options: t3 } = this;
          if (!t3.inline) {
            if (!this._nanopop.update({ container: document.body.getBoundingClientRect(), position: t3.position })) {
              const t4 = this._root.app, e21 = t4.getBoundingClientRect();
              t4.style.top = (window.innerHeight - e21.height) / 2 + "px", t4.style.left = (window.innerWidth - e21.width) / 2 + "px";
            }
          }
        }
        _updateOutput(t3) {
          const { _root: e21, _color: o3, options: n3 } = this;
          if (e21.interaction.type()) {
            const t4 = `to${e21.interaction.type().getAttribute("data-type")}`;
            e21.interaction.result.value = typeof o3[t4] == "function" ? o3[t4]().toString(n3.outputPrecision) : "";
          }
          !this._initializingActive && this._recalc && this._emit("change", o3, t3, this);
        }
        _clearColor(t3 = false) {
          const { _root: e21, options: o3 } = this;
          o3.useAsButton || e21.button.style.setProperty("--pcr-color", "rgba(0, 0, 0, 0.15)"), e21.button.classList.add("clear"), o3.showAlways || this.hide(), this._lastColor = null, this._initializingActive || t3 || (this._emit("save", null), this._emit("clear"));
        }
        _parseLocalColor(t3) {
          const { values: e21, type: o3, a: n3 } = w2(t3), { lockOpacity: i3 } = this.options, s3 = n3 !== void 0 && n3 !== 1;
          return e21 && e21.length === 3 && (e21[3] = void 0), { values: !e21 || i3 && s3 ? null : e21, type: o3 };
        }
        _t(t3) {
          return this.options.i18n[t3] || L2.I18N_DEFAULTS[t3];
        }
        _emit(t3, ...e21) {
          this._eventListener[t3].forEach((t4) => t4(...e21, this));
        }
        on(t3, e21) {
          return this._eventListener[t3].push(e21), this;
        }
        off(t3, e21) {
          const o3 = this._eventListener[t3] || [], n3 = o3.indexOf(e21);
          return ~n3 && o3.splice(n3, 1), this;
        }
        addSwatch(t3) {
          const { values: e21 } = this._parseLocalColor(t3);
          if (e21) {
            const { _swatchColors: t4, _root: o3 } = this, n3 = A2(...e21), s3 = r2(`<button type="button" style="--pcr-color: ${n3.toRGBA().toString(0)}" aria-label="${this._t("btn:swatch")}"/>`);
            return o3.swatches.appendChild(s3), t4.push({ el: s3, color: n3 }), this._eventBindings.push(i2(s3, "click", () => {
              this.setHSVA(...n3.toHSVA(), true), this._emit("swatchselect", n3), this._emit("change", n3, "swatch", this);
            })), true;
          }
          return false;
        }
        removeSwatch(t3) {
          const e21 = this._swatchColors[t3];
          if (e21) {
            const { el: o3 } = e21;
            return this._root.swatches.removeChild(o3), this._swatchColors.splice(t3, 1), true;
          }
          return false;
        }
        applyColor(t3 = false) {
          const { preview: e21, button: o3 } = this._root, n3 = this._color.toRGBA().toString(0);
          return e21.lastColor.style.setProperty("--pcr-color", n3), this.options.useAsButton || o3.style.setProperty("--pcr-color", n3), o3.classList.remove("clear"), this._lastColor = this._color.clone(), this._initializingActive || t3 || this._emit("save", this._color), this;
        }
        destroy() {
          cancelAnimationFrame(this._setupAnimationFrame), this._eventBindings.forEach((t3) => s2(...t3)), Object.keys(this._components).forEach((t3) => this._components[t3].destroy());
        }
        destroyAndRemove() {
          this.destroy();
          const { root: t3, app: e21 } = this._root;
          t3.parentElement && t3.parentElement.removeChild(t3), e21.parentElement.removeChild(e21), Object.keys(this).forEach((t4) => this[t4] = null);
        }
        hide() {
          return !!this.isOpen() && (this._root.app.classList.remove("visible"), this._emit("hide"), true);
        }
        show() {
          return !this.options.disabled && !this.isOpen() && (this._root.app.classList.add("visible"), this._rePositioningPicker(), this._emit("show", this._color), this);
        }
        isOpen() {
          return this._root.app.classList.contains("visible");
        }
        setHSVA(t3 = 360, e21 = 0, o3 = 0, n3 = 1, i3 = false) {
          const s3 = this._recalc;
          if (this._recalc = false, t3 < 0 || t3 > 360 || e21 < 0 || e21 > 100 || o3 < 0 || o3 > 100 || n3 < 0 || n3 > 1)
            return false;
          this._color = A2(t3, e21, o3, n3);
          const { hue: r3, opacity: a3, palette: l3 } = this._components;
          return r3.update(t3 / 360), a3.update(n3), l3.update(e21 / 100, 1 - o3 / 100), i3 || this.applyColor(), s3 && this._updateOutput(), this._recalc = s3, true;
        }
        setColor(t3, e21 = false) {
          if (t3 === null)
            return this._clearColor(e21), true;
          const { values: o3, type: n3 } = this._parseLocalColor(t3);
          if (o3) {
            const t4 = n3.toUpperCase(), { options: i3 } = this._root.interaction, s3 = i3.find((e22) => e22.getAttribute("data-type") === t4);
            if (s3 && !s3.hidden)
              for (const t5 of i3)
                t5.classList[t5 === s3 ? "add" : "remove"]("active");
            return !!this.setHSVA(...o3, e21) && this.setColorRepresentation(t4);
          }
          return false;
        }
        setColorRepresentation(t3) {
          return t3 = t3.toUpperCase(), !!this._root.interaction.options.find((e21) => e21.getAttribute("data-type").startsWith(t3) && !e21.click());
        }
        getColorRepresentation() {
          return this._representation;
        }
        getColor() {
          return this._color;
        }
        getSelectedColor() {
          return this._lastColor;
        }
        getRoot() {
          return this._root;
        }
        disable() {
          return this.hide(), this.options.disabled = true, this._root.button.classList.add("disabled"), this;
        }
        enable() {
          return this.options.disabled = false, this._root.button.classList.remove("disabled"), this;
        }
      }
      return E2(L2, "utils", o2), E2(L2, "version", "1.8.2"), E2(L2, "I18N_DEFAULTS", { "ui:dialog": "color picker dialog", "btn:toggle": "toggle color picker dialog", "btn:swatch": "color swatch", "btn:last-color": "use previous color", "btn:save": "Save", "btn:cancel": "Cancel", "btn:clear": "Clear", "aria:btn:save": "save and close", "aria:btn:cancel": "cancel and close", "aria:btn:clear": "clear and close", "aria:input": "color input field", "aria:palette": "color selection area", "aria:hue": "hue selection slider", "aria:opacity": "selection slider" }), E2(L2, "DEFAULT_OPTIONS", { appClass: null, theme: "classic", useAsButton: false, padding: 8, disabled: false, comparison: true, closeOnScroll: false, outputPrecision: 0, lockOpacity: false, autoReposition: true, container: "body", components: { interaction: {} }, i18n: {}, swatches: null, inline: false, sliders: null, default: "#42445a", defaultRepresentation: null, position: "bottom-middle", adjustableNumbers: true, showAlways: false, closeWithKey: "Escape" }), E2(L2, "create", (t3) => new L2(t3)), e20 = e20.default;
    })();
  });
})(pickr_min);
var __Pickr = /* @__PURE__ */ getDefaultExportFromCjs(pickr_min.exports);
function plainObject$2(object) {
  if (!object)
    return false;
  if (typeof object !== "object")
    return false;
  if (object.constructor && object.constructor.name !== "Object")
    return false;
  if (Object.prototype.toString.call(object) !== "[object Object]")
    return false;
  if (object !== Object(object))
    return false;
  return true;
}
function __deepMerge$2(...args) {
  function merge2(firstObj, secondObj) {
    const newObj = {};
    if (!firstObj && secondObj)
      return secondObj;
    if (!secondObj && firstObj)
      return firstObj;
    if (!firstObj && !secondObj)
      return {};
    const firstProps = Object.getOwnPropertyNames(firstObj);
    firstProps.forEach((key) => {
      const desc = Object.getOwnPropertyDescriptor(firstObj, key);
      if (desc.set || desc.get) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = firstObj[key];
      }
    });
    const secondProps = Object.getOwnPropertyNames(secondObj);
    secondProps.forEach((key) => {
      const desc = Object.getOwnPropertyDescriptor(secondObj, key);
      if (desc.set || desc.get) {
        Object.defineProperty(newObj, key, desc);
      } else if (plainObject$2(newObj[key]) && plainObject$2(secondObj[key])) {
        newObj[key] = merge2(newObj[key], secondObj[key]);
      } else {
        newObj[key] = secondObj[key];
      }
    });
    return newObj;
  }
  let currentObj = {};
  for (let i2 = 0; i2 < args.length; i2++) {
    const toMergeObj = args[i2];
    currentObj = merge2(currentObj, toMergeObj);
  }
  return currentObj;
}
var __baseCss = `/*! Pickr 1.8.1 MIT | https://github.com/Simonwep/pickr */.pickr{position:relative;overflow:visible;transform:translateY(0)}.pickr *{box-sizing:border-box;outline:none;border:none;-webkit-appearance:none}.pickr .pcr-button{position:relative;height:2em;width:2em;padding:.5em;cursor:pointer;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,sans-serif;border-radius:.15em;background:url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" stroke="%2342445A" stroke-width="5px" stroke-linecap="round"><path d="M45,45L5,5"></path><path d="M45,5L5,45"></path></svg>') no-repeat 50%;background-size:0;transition:all .3s}.pickr .pcr-button:before{background:url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2 2"><path fill="white" d="M1,0H2V1H1V0ZM0,1H1V2H0V1Z"/><path fill="gray" d="M0,0H1V1H0V0ZM1,1H2V2H1V1Z"/></svg>');background-size:.5em;z-index:-1;z-index:auto}.pickr .pcr-button:after,.pickr .pcr-button:before{position:absolute;content:"";top:0;left:0;width:100%;height:100%;border-radius:.15em}.pickr .pcr-button:after{transition:background .3s;background:var(--pcr-color)}.pickr .pcr-button.clear{background-size:70%}.pickr .pcr-button.clear:before{opacity:0}.pickr .pcr-button.clear:focus{box-shadow:0 0 0 1px hsla(0,0%,100%,.85),0 0 0 3px var(--pcr-color)}.pickr .pcr-button.disabled{cursor:not-allowed}.pcr-app *,.pickr *{box-sizing:border-box;outline:none;border:none;-webkit-appearance:none}.pcr-app button.pcr-active,.pcr-app button:focus,.pcr-app input.pcr-active,.pcr-app input:focus,.pickr button.pcr-active,.pickr button:focus,.pickr input.pcr-active,.pickr input:focus{box-shadow:0 0 0 1px hsla(0,0%,100%,.85),0 0 0 3px var(--pcr-color)}.pcr-app .pcr-palette,.pcr-app .pcr-slider,.pickr .pcr-palette,.pickr .pcr-slider{transition:box-shadow .3s}.pcr-app .pcr-palette:focus,.pcr-app .pcr-slider:focus,.pickr .pcr-palette:focus,.pickr .pcr-slider:focus{box-shadow:0 0 0 1px hsla(0,0%,100%,.85),0 0 0 3px rgba(0,0,0,.25)}.pcr-app{position:fixed;display:flex;flex-direction:column;z-index:10000;border-radius:.1em;background:#fff;opacity:0;visibility:hidden;transition:opacity .3s,visibility 0s .3s;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,sans-serif;box-shadow:0 .15em 1.5em 0 rgba(0,0,0,.1),0 0 1em 0 rgba(0,0,0,.03);left:0;top:0}.pcr-app.visible{transition:opacity .3s;visibility:visible;opacity:1}.pcr-app .pcr-swatches{display:flex;flex-wrap:wrap;margin-top:.75em}.pcr-app .pcr-swatches.pcr-last{margin:0}@supports (display:grid){.pcr-app .pcr-swatches{display:grid;align-items:center;grid-template-columns:repeat(auto-fit,1.75em)}}.pcr-app .pcr-swatches>button{font-size:1em;position:relative;width:calc(1.75em - 5px);height:calc(1.75em - 5px);border-radius:.15em;cursor:pointer;margin:2.5px;flex-shrink:0;justify-self:center;transition:all .15s;overflow:hidden;background:transparent;z-index:1}.pcr-app .pcr-swatches>button:before{position:absolute;content:"";top:0;left:0;width:100%;height:100%;background:url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2 2"><path fill="white" d="M1,0H2V1H1V0ZM0,1H1V2H0V1Z"/><path fill="gray" d="M0,0H1V1H0V0ZM1,1H2V2H1V1Z"/></svg>');background-size:6px;border-radius:.15em;z-index:-1}.pcr-app .pcr-swatches>button:after{content:"";position:absolute;top:0;left:0;width:100%;height:100%;background:var(--pcr-color);border:1px solid rgba(0,0,0,.05);border-radius:.15em;box-sizing:border-box}.pcr-app .pcr-swatches>button:hover{filter:brightness(1.05)}.pcr-app .pcr-swatches>button:not(.pcr-active){box-shadow:none}.pcr-app .pcr-interaction{display:flex;flex-wrap:wrap;align-items:center;margin:0 -.2em}.pcr-app .pcr-interaction>*{margin:0 .2em}.pcr-app .pcr-interaction input{letter-spacing:.07em;font-size:.75em;text-align:center;cursor:pointer;color:#75797e;background:#f1f3f4;border-radius:.15em;transition:all .15s;padding:.45em .5em;margin-top:.75em}.pcr-app .pcr-interaction input:hover{filter:brightness(.975)}.pcr-app .pcr-interaction input:focus{box-shadow:0 0 0 1px hsla(0,0%,100%,.85),0 0 0 3px rgba(66,133,244,.75)}.pcr-app .pcr-interaction .pcr-result{color:#75797e;text-align:left;flex:1 1 8em;min-width:8em;transition:all .2s;border-radius:.15em;background:#f1f3f4;cursor:text}.pcr-app .pcr-interaction .pcr-result::-moz-selection{background:#4285f4;color:#fff}.pcr-app .pcr-interaction .pcr-result::selection{background:#4285f4;color:#fff}.pcr-app .pcr-interaction .pcr-type.active{color:#fff;background:#4285f4}.pcr-app .pcr-interaction .pcr-cancel,.pcr-app .pcr-interaction .pcr-clear,.pcr-app .pcr-interaction .pcr-save{width:auto;color:#fff}.pcr-app .pcr-interaction .pcr-cancel:hover,.pcr-app .pcr-interaction .pcr-clear:hover,.pcr-app .pcr-interaction .pcr-save:hover{filter:brightness(.925)}.pcr-app .pcr-interaction .pcr-save{background:#4285f4}.pcr-app .pcr-interaction .pcr-cancel,.pcr-app .pcr-interaction .pcr-clear{background:#f44250}.pcr-app .pcr-interaction .pcr-cancel:focus,.pcr-app .pcr-interaction .pcr-clear:focus{box-shadow:0 0 0 1px hsla(0,0%,100%,.85),0 0 0 3px rgba(244,66,80,.75)}.pcr-app .pcr-selection .pcr-picker{position:absolute;height:18px;width:18px;border:2px solid #fff;border-radius:100%;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.pcr-app .pcr-selection .pcr-color-chooser,.pcr-app .pcr-selection .pcr-color-opacity,.pcr-app .pcr-selection .pcr-color-palette{position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:flex;flex-direction:column;cursor:grab;cursor:-webkit-grab}.pcr-app .pcr-selection .pcr-color-chooser:active,.pcr-app .pcr-selection .pcr-color-opacity:active,.pcr-app .pcr-selection .pcr-color-palette:active{cursor:grabbing;cursor:-webkit-grabbing}.pcr-app[data-theme=nano]{width:14.25em;max-width:95vw}.pcr-app[data-theme=nano] .pcr-swatches{margin-top:.6em;padding:0 .6em}.pcr-app[data-theme=nano] .pcr-interaction{padding:0 .6em .6em}.pcr-app[data-theme=nano] .pcr-selection{display:grid;grid-gap:.6em;grid-template-columns:1fr 4fr;grid-template-rows:5fr auto auto;align-items:center;height:10.5em;width:100%;align-self:flex-start}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-preview{grid-area:2/1/4/1;height:100%;width:100%;display:flex;flex-direction:row;justify-content:center;margin-left:.6em}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-preview .pcr-last-color{display:none}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-preview .pcr-current-color{position:relative;background:var(--pcr-color);width:2em;height:2em;border-radius:50em;overflow:hidden}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-preview .pcr-current-color:before{position:absolute;content:"";top:0;left:0;width:100%;height:100%;background:url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2 2"><path fill="white" d="M1,0H2V1H1V0ZM0,1H1V2H0V1Z"/><path fill="gray" d="M0,0H1V1H0V0ZM1,1H2V2H1V1Z"/></svg>');background-size:.5em;border-radius:.15em;z-index:-1}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-palette{grid-area:1/1/2/3;width:100%;height:100%;z-index:1}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-palette .pcr-palette{border-radius:.15em;width:100%;height:100%}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-palette .pcr-palette:before{position:absolute;content:"";top:0;left:0;width:100%;height:100%;background:url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2 2"><path fill="white" d="M1,0H2V1H1V0ZM0,1H1V2H0V1Z"/><path fill="gray" d="M0,0H1V1H0V0ZM1,1H2V2H1V1Z"/></svg>');background-size:.5em;border-radius:.15em;z-index:-1}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-chooser{grid-area:2/2/2/2}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-opacity{grid-area:3/2/3/2}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-chooser,.pcr-app[data-theme=nano] .pcr-selection .pcr-color-opacity{height:.5em;margin:0 .6em}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-chooser .pcr-picker,.pcr-app[data-theme=nano] .pcr-selection .pcr-color-opacity .pcr-picker{top:50%;transform:translateY(-50%)}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-chooser .pcr-slider,.pcr-app[data-theme=nano] .pcr-selection .pcr-color-opacity .pcr-slider{flex-grow:1;border-radius:50em}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-chooser .pcr-slider{background:linear-gradient(90deg,red,#ff0,#0f0,#0ff,#00f,#f0f,red)}.pcr-app[data-theme=nano] .pcr-selection .pcr-color-opacity .pcr-slider{background:linear-gradient(90deg,transparent,#000),url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2 2"><path fill="white" d="M1,0H2V1H1V0ZM0,1H1V2H0V1Z"/><path fill="gray" d="M0,0H1V1H0V0ZM1,1H2V2H1V1Z"/></svg>');background-size:100%,.25em}`;
var __css$3 = ".s-color-picker[default-style] {\n}\n\ns-color-picker:not([mounted]) > * {\n        display: none;\n    }\n\n[default-style] .s-color-picker__picker {\n        background: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-surface-spin ,0)),calc((var(--s-theme-color-current-s, 0) + var(--s-theme-color-current-surface-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-current-l, 0) + var(--s-theme-color-current-surface-lightness-offset, 0)) * 1%),var(--s-theme-color-current-surface-a, 1));\n        overflow: hidden;box-shadow: var(--s-theme-ui-colorPicker-depth, 0);\n        border-radius: var(--s-theme-ui-colorPicker-borderRadius, 10px);\n        padding-inline: var(--s-theme-ui-colorPicker-paddingInline, 0.75em);\n        padding-block: var(--s-theme-ui-colorPicker-paddingBlock, 0.375em);\n    }\n\n.pickr.s-color-picker__preview {\n    display: inline-block;\n    outline: none;\n    border-radius: 0 !important;\n}\n\n[default-style] .pickr.s-color-picker__preview {\n        transition: var(--s-theme-transition-fast, all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995));\n    }\n\n.pickr.s-color-picker__preview button:focus {\n        display: none;\n    }\n\n.pickr.s-color-picker__preview button {\n        width: 1em;\n        height: 1em;\n        border-radius: 0 !important;\n    }\n\n.pickr.s-color-picker__preview button:before,\n        .pickr.s-color-picker__preview button:after {\n            border-radius: 0 !important;\n        }\n";
class SColorPickerComponentInterface extends SInterface {
}
SColorPickerComponentInterface.definition = {
  value: {
    type: "String",
    default: "#ff0000"
  }
};
class SColorPicker extends SLitComponent {
  static get properties() {
    return SLitComponent.properties({}, SColorPickerComponentInterface);
  }
  static get styles() {
    return css$1`
            ${unsafeCSS(`
            ${__baseCss}
            ${__css$3}
        `)}
        `;
  }
  constructor() {
    super(__deepMerge$2({
      litComponent: {},
      componentUtils: {
        interface: SColorPickerComponentInterface
      }
    }));
  }
  firstUpdated() {
    var _a2, _b2, _c2, _d2;
    const pickr = __Pickr.create({
      el: (_a2 = this.shadowRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector(".s-color-picker__preview"),
      theme: "nano",
      container: (_b2 = this.shadowRoot) === null || _b2 === void 0 ? void 0 : _b2.querySelector(".s-color-picker__picker-wrapper"),
      default: this.props.value,
      comparison: false,
      swatches: [],
      components: {
        preview: true,
        opacity: true,
        hue: true,
        interaction: {
          hex: true,
          rgba: true,
          hsla: true,
          input: true,
          clear: true
        }
      }
    });
    function getPickrState() {
      const color2 = pickr.getColor();
      const hsla = color2.toHSLA(), hsva = color2.toHSVA(), rgba = color2.toRGBA(), hex = color2.toHEXA(), cmyk = color2.toCMYK();
      return {
        isOpened: pickr.isOpen(),
        hsla: {
          h: hsla[0],
          s: hsla[1],
          l: hsla[2],
          a: hsla[3],
          string: `hsla(${hsla[0]},${hsla[1]},${hsla[2]},${hsla[3]})`
        },
        hsva: {
          h: hsva[0],
          s: hsva[1],
          v: hsva[2],
          a: hsva[3],
          string: `hsva(${hsva[0]},${hsva[1]},${hsva[2]},${hsva[3]})`
        },
        rgba: {
          r: rgba[0],
          g: rgba[1],
          b: rgba[2],
          a: rgba[3],
          string: `rgba(${rgba[0]},${rgba[1]},${rgba[2]},${rgba[3]})`
        },
        hex: hex.toString(),
        cmyk: {
          c: cmyk[0],
          m: cmyk[1],
          y: cmyk[2],
          k: cmyk[3],
          string: `cmyk(${cmyk[0]},${cmyk[1]},${cmyk[2]},${cmyk[3]})`
        }
      };
    }
    pickr.on("change", () => {
      pickr.applyColor();
      const detail = getPickrState();
      const change = new CustomEvent("change", {
        detail
      });
      this.dispatchEvent(change);
    });
    pickr.on("show", () => {
      const detail = getPickrState();
      const change = new CustomEvent("show", {
        detail
      });
      this.dispatchEvent(change);
    });
    pickr.on("hide", () => {
      const detail = getPickrState();
      const change = new CustomEvent("hide", {
        detail
      });
      this.dispatchEvent(change);
    });
    pickr.on("cancel", () => {
      const detail = getPickrState();
      const change = new CustomEvent("cancel", {
        detail
      });
      this.dispatchEvent(change);
    });
    const $app = (_c2 = this.shadowRoot) === null || _c2 === void 0 ? void 0 : _c2.querySelector(".pcr-app");
    $app === null || $app === void 0 ? void 0 : $app.classList.add(this.componentUtils.className("__picker"));
    const $preview = (_d2 = this.shadowRoot) === null || _d2 === void 0 ? void 0 : _d2.querySelector(".pickr");
    $preview === null || $preview === void 0 ? void 0 : $preview.classList.add(this.componentUtils.className("__preview"));
  }
  render() {
    return html$2`
            <div class="${this.componentUtils.className("")}">
                <div
                    class="${this.componentUtils.className("__picker-wrapper")}"
                ></div>
                <div
                    class="${this.componentUtils.className("__preview")}"
                ></div>
            </div>
        `;
  }
}
function define$a(props = {}, tagName = "s-color-picker") {
  SLitComponent.setDefaultProps(tagName, props);
  customElements.define(tagName, SColorPicker);
}
class SRangeComponentInterface extends SInterface {
}
SRangeComponentInterface.definition = {
  name: {
    type: "String",
    description: 'Specify the name to assign to the internal input[type="range"]'
  },
  value: {
    type: "String",
    description: "Specify the initial range value"
  },
  min: {
    type: "Number",
    description: "Specify the minimal value or the range",
    default: 0
  },
  max: {
    type: "Number",
    description: "Specify the maximal value of the range",
    default: 100
  },
  step: {
    type: "Number",
    description: "Specify the steps between each values"
  },
  target: {
    type: "String",
    description: "Specify a css selector of any HTMLElement or HTMLInputElement in which to inject the value when the range is updated"
  },
  tooltip: {
    type: "Boolean",
    description: "Specify if you want to display the value inside a tooltip on top of the thumb",
    default: false
  }
};
var __css$2 = "s-range {\n    display: block;\n    width: 100%;\n}\n\n    s-range:not([mounted]) > * {\n        display: none;\n    }\n.s-range {\n    display: flex;\n    width: 100%;\n}\n\n.s-range__input {\n    flex-grow: 1;\n}\n\n.s-range__tooltip {\n    transition: none;\n}\n\ns-range[default-style] {\n}\n";
function plainObject$1(object) {
  if (!object)
    return false;
  if (typeof object !== "object")
    return false;
  if (object.constructor && object.constructor.name !== "Object")
    return false;
  if (Object.prototype.toString.call(object) !== "[object Object]")
    return false;
  if (object !== Object(object))
    return false;
  return true;
}
function __deepMerge$1(...args) {
  function merge2(firstObj, secondObj) {
    const newObj = {};
    if (!firstObj && secondObj)
      return secondObj;
    if (!secondObj && firstObj)
      return firstObj;
    if (!firstObj && !secondObj)
      return {};
    const firstProps = Object.getOwnPropertyNames(firstObj);
    firstProps.forEach((key) => {
      const desc = Object.getOwnPropertyDescriptor(firstObj, key);
      if (desc.set || desc.get) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = firstObj[key];
      }
    });
    const secondProps = Object.getOwnPropertyNames(secondObj);
    secondProps.forEach((key) => {
      const desc = Object.getOwnPropertyDescriptor(secondObj, key);
      if (desc.set || desc.get) {
        Object.defineProperty(newObj, key, desc);
      } else if (plainObject$1(newObj[key]) && plainObject$1(secondObj[key])) {
        newObj[key] = merge2(newObj[key], secondObj[key]);
      } else {
        newObj[key] = secondObj[key];
      }
    });
    return newObj;
  }
  let currentObj = {};
  for (let i2 = 0; i2 < args.length; i2++) {
    const toMergeObj = args[i2];
    currentObj = merge2(currentObj, toMergeObj);
  }
  return currentObj;
}
var __awaiter$9 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e20) {
        reject(e20);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e20) {
        reject(e20);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SRange extends SLitComponent {
  static get properties() {
    return SLitComponent.properties({}, SRangeComponentInterface);
  }
  static get styles() {
    return css$1`
            ${unsafeCSS(`
                ${__css$2}
            `)}
        `;
  }
  constructor() {
    super(__deepMerge$1({
      litComponent: {
        shadowDom: false
      },
      componentUtils: {
        interface: SRangeComponentInterface
      }
    }));
  }
  firstUpdated() {
    return __awaiter$9(this, void 0, void 0, function* () {
      this._$input = this.querySelector("input");
      this._$tooltip = this.querySelector(".s-range__tooltip");
      this._$input.addEventListener("input", (e20) => {
        this._handleTooltip();
        this._handleTarget();
      });
      if (this.props.target) {
        this._$targets = Array.from(document.querySelectorAll(this.props.target));
      }
      this._handleTooltip();
      this._handleTarget();
    });
  }
  _handleTarget() {
    if (!this._$targets)
      return;
    this._$targets.forEach(($target) => {
      $target.innerHTML = this._$input.value;
      $target.value = this._$input.value;
    });
  }
  _handleTooltip() {
    if (!this._$tooltip)
      return;
    const val = this._$input.value;
    const min2 = this._$input.min ? this._$input.min : 0;
    const max2 = this._$input.max ? this._$input.max : 100;
    const newVal = Number((val - min2) * 100 / (max2 - min2));
    this._$tooltip.style.left = `calc(${newVal}% + (${8 - newVal * 0.15}px))`;
    this._$tooltip.innerHTML = val;
  }
  render() {
    return html$2`
            <div class="${this.componentUtils.className("", "s-tooltip-container")}">
                <input
                    class="${this.componentUtils.className("__input", "s-range")}"
                    type="range"
                    name="${this.name}"
                    value="${this.value}"
                    min="${this.min}"
                    max="${this.max}"
                    step="${this.step}"
                />
                ${this.props.tooltip ? html$2` <div class="${this.componentUtils.className("__tooltip", "s-tooltip")}"></div> ` : ""}
            </div>
        `;
  }
}
function define$9(props = {}, tagName = "s-range") {
  SLitComponent.setDefaultProps(tagName, props);
  customElements.define(tagName, SRange);
}
function matches(el2, selector) {
  if (el2.nodeName == "#comment" || el2.nodeName == "#text") {
    return false;
  }
  const p2 = Element.prototype;
  const f2 = p2.matches || p2.webkitMatchesSelector || p2.mozMatchesSelector || p2.msMatchesSelector || function(s2) {
    return [].indexOf.call(document.querySelectorAll(s2), this) !== -1;
  };
  return f2.call(el2, selector);
}
let _observer;
const _selectors = {};
function querySelectorLive(selector, cb2 = null, settings = {}) {
  const id2 = `${selector} - ${uniqid()}`;
  settings = Object.assign({}, {
    rootNode: document,
    once: true
  }, settings);
  if (!_selectors[selector]) {
    _selectors[selector] = [
      {
        id: id2,
        selector,
        cb: cb2,
        lastMutationId: null,
        settings
      }
    ];
  } else {
    _selectors[selector].push({
      id: id2,
      selector,
      cb: cb2,
      lastMutationId: null,
      settings
    });
  }
  return new SPromise(({ resolve: resolve2, reject, emit }) => {
    function pushNewNode(node, sel, mutationId) {
      const objs = _selectors[sel];
      if (!objs)
        return;
      objs.forEach((obj2) => {
        if (obj2.lastMutationId && obj2.lastMutationId === mutationId)
          return;
        if (obj2.settings.once) {
          if (!node._querySelectorLive) {
            node._querySelectorLive = {};
          }
          if (node._querySelectorLive[obj2.id])
            return;
          node._querySelectorLive[obj2.id] = true;
        }
        emit("node", node);
        obj2.cb && obj2.cb(node, () => {
          delete _selectors[obj2.selector];
        });
      });
    }
    if (!_observer) {
      _observer = new MutationObserver((mutations) => {
        const mutationId = `mutation-${uniqid()}`;
        mutations.forEach((mutation) => {
          if (mutation.addedNodes && mutation.addedNodes.length) {
            [].forEach.call(mutation.addedNodes, (node) => {
              const selectors = Object.keys(_selectors);
              selectors.forEach((sel) => {
                if (matches(node, sel)) {
                  pushNewNode(node, sel, mutationId);
                }
              });
              if (!node.querySelectorAll)
                return;
              selectors.forEach((sel) => {
                const nestedNodes = node.querySelectorAll(sel);
                [].forEach.call(nestedNodes, (nestedNode) => {
                  pushNewNode(nestedNode, sel, mutationId);
                });
              });
            });
          } else if (mutation.attributeName) {
            const selectors = Object.keys(_selectors);
            selectors.forEach((sel) => {
              if (matches(mutation.target, sel)) {
                pushNewNode(mutation.target, sel, mutationId);
              }
            });
          }
        });
      });
      _observer.observe(settings.rootNode, {
        childList: true,
        subtree: true,
        attributes: true,
        attributeFilter: ["class", "id"]
      });
    }
    [].forEach.call(settings.rootNode.querySelectorAll(selector), (node) => {
      pushNewNode(node, selector, "init");
    });
  });
}
function expandPleasantCssClassname(classesStr) {
  const classesArray = [];
  const classNames = classesStr.split(/\s+/);
  let currentMedia = "";
  classNames.forEach((className) => {
    if (className.slice(0, 1) == "@") {
      currentMedia = className.replace("@", "___");
      return;
    }
    const parts = className.split(":");
    if (parts.length === 1) {
      let name2 = className;
      if (currentMedia !== "")
        name2 = className + currentMedia;
      classesArray.push(name2);
    } else {
      const firstClass = parts[0];
      let name2 = firstClass;
      if (currentMedia !== "")
        name2 = firstClass + currentMedia;
      classesArray.push(name2);
      parts.forEach((part, i2) => {
        if (i2 > 0) {
          name2 = firstClass + "--" + part;
          if (currentMedia !== "")
            name2 = name2 + currentMedia;
          classesArray.push(name2);
        }
      });
    }
  });
  return classesArray.join(" ");
}
function expandPleasantCssClassnamesLive(settings) {
  settings = Object.assign({ rootNode: document }, settings);
  querySelectorLive('[class*=":"]:not(code [class*=":"]):not(template [class*=":"]),[class*="@"]:not(code [class*="@"]):not(template [class*="@"])', ($elm) => {
    const classesStr = $elm.getAttribute("class");
    const newClassesStr = expandPleasantCssClassname(classesStr);
    $elm.setAttribute("class", newClassesStr);
  }, {
    rootNode: settings === null || settings === void 0 ? void 0 : settings.rootNode,
    once: false
  });
}
var __awaiter$8 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e20) {
        reject(e20);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e20) {
        reject(e20);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getState() {
  var _a2;
  const state = JSON.parse((_a2 = window.localStorage.getItem("coffeekrakenio")) !== null && _a2 !== void 0 ? _a2 : "{}");
  return state;
}
function setState(stateObj) {
  const state = getState();
  const newState = __deepMerge$7(state, stateObj);
  window.localStorage.setItem("coffeekrakenio", JSON.stringify(newState));
}
let _docmap, _docmapPromise;
function loadDocmap() {
  return __awaiter$8(this, void 0, void 0, function* () {
    getState();
    if (_docmap)
      return _docmap;
    if (_docmapPromise)
      return (yield _docmapPromise).data;
    const request2 = new SRequest({
      url: `/docmap.json`,
      method: "GET"
    });
    const promise = request2.send();
    _docmapPromise = promise;
    _docmap = (yield promise).data;
    return _docmap;
  });
}
var __decorate = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d2 = decorators[i2])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __awaiter$7 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e20) {
        reject(e20);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e20) {
        reject(e20);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class VersionSelector extends SLitComponent {
  constructor() {
    super({
      litComponent: {
        shadowDom: false
      }
    });
    this._versions = [];
    (() => __awaiter$7(this, void 0, void 0, function* () {
      const docmapJson = yield loadDocmap();
      this._versions = docmapJson.snapshots || [];
    }))();
  }
  _change(e20) {
    setTimeout(() => {
      let newLocation = document.location.href;
      if (document.location.href.match(/^https?:\/\/v[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\./)) {
        newLocation = document.location.href.replace(/^(https?:\/\/v)[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.(.*)/, `$1${e20.target.value}.$2`);
      } else {
        newLocation = document.location.href.replace(/^(https?:\/\/)(.*)/, `$1v${e20.target.value}.$2`);
      }
      document.location = newLocation;
    });
  }
  render() {
    return html$2`
            <label class="s-select s-color:accent">
                <select @change="${this._change}">
                    ${this._versions.map((snap) => html$2`
                            <option
                                ?selected="${this._currentVersion === snap}"
                                value="${snap}"
                            >
                                ${snap}
                            </option>
                        `)}
                </select>
            </label>
        `;
  }
}
__decorate([
  property$3()
], VersionSelector.prototype, "_currentVersion", void 0);
__decorate([
  property$3()
], VersionSelector.prototype, "_versions", void 0);
function define$8(props = {}, tagName = "version-selector") {
  SLitComponent.setDefaultProps(tagName, props);
  customElements.define(tagName, VersionSelector);
}
/**
* @license
* Copyright 2017 Google LLC
* SPDX-License-Identifier: BSD-3-Clause
*/
var _a, _b, _c, _d;
let issueWarning;
{
  (_a = globalThis.litIssuedWarnings) !== null && _a !== void 0 ? _a : globalThis.litIssuedWarnings = new Set();
  issueWarning = (code4, warning) => {
    warning += code4 ? ` See https://lit.dev/msg/${code4} for more information.` : "";
    if (!globalThis.litIssuedWarnings.has(warning)) {
      console.warn(warning);
      globalThis.litIssuedWarnings.add(warning);
    }
  };
  issueWarning("dev-mode", `Lit is in dev mode. Not recommended for production!`);
}
const wrap$1 = ((_b = window.ShadyDOM) === null || _b === void 0 ? void 0 : _b.inUse) && ((_c = window.ShadyDOM) === null || _c === void 0 ? void 0 : _c.noPatch) === true ? window.ShadyDOM.wrap : (node) => node;
const trustedTypes = globalThis.trustedTypes;
const policy = trustedTypes ? trustedTypes.createPolicy("lit-html", {
  createHTML: (s2) => s2
}) : void 0;
const identityFunction = (value) => value;
const noopSanitizer = (_node, _name, _type) => identityFunction;
const createSanitizer = (node, name2, type) => {
  return sanitizerFactoryInternal();
};
const boundAttributeSuffix = "$lit$";
const marker = `lit$${String(Math.random()).slice(9)}$`;
const markerMatch = "?" + marker;
const nodeMarker = `<${markerMatch}>`;
const d = document;
const createMarker = (v2 = "") => d.createComment(v2);
const isPrimitive = (value) => value === null || typeof value != "object" && typeof value != "function";
const isArray = Array.isArray;
const isIterable = (value) => {
  var _a2;
  return isArray(value) || typeof ((_a2 = value) === null || _a2 === void 0 ? void 0 : _a2[Symbol.iterator]) === "function";
};
const SPACE_CHAR = `[ 	
\f\r]`;
const ATTR_VALUE_CHAR = `[^ 	
\f\r"'\`<>=]`;
const NAME_CHAR = `[^\\s"'>=/]`;
const textEndRegex = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
const COMMENT_START = 1;
const TAG_NAME = 2;
const DYNAMIC_TAG_NAME = 3;
const commentEndRegex = /-->/g;
const comment2EndRegex = />/g;
const tagEndRegex = new RegExp(`>|${SPACE_CHAR}(?:(${NAME_CHAR}+)(${SPACE_CHAR}*=${SPACE_CHAR}*(?:${ATTR_VALUE_CHAR}|("|')|))|$)`, "g");
const ENTIRE_MATCH = 0;
const ATTRIBUTE_NAME = 1;
const SPACES_AND_EQUALS = 2;
const QUOTE_CHAR = 3;
const singleQuoteAttrEndRegex = /'/g;
const doubleQuoteAttrEndRegex = /"/g;
const rawTextElement = /^(?:script|style|textarea)$/i;
const SVG_RESULT = 2;
const ATTRIBUTE_PART = 1;
const CHILD_PART = 2;
const PROPERTY_PART = 3;
const BOOLEAN_ATTRIBUTE_PART = 4;
const EVENT_PART = 5;
const ELEMENT_PART = 6;
const COMMENT_PART = 7;
const noChange = Symbol.for("lit-noChange");
const nothing = Symbol.for("lit-nothing");
const templateCache = new WeakMap();
const walker = d.createTreeWalker(d, 129, null, false);
let sanitizerFactoryInternal = noopSanitizer;
const getTemplateHtml = (strings, type) => {
  const l2 = strings.length - 1;
  const attrNames = [];
  let html2 = type === SVG_RESULT ? "<svg>" : "";
  let rawTextEndRegex;
  let regex = textEndRegex;
  for (let i2 = 0; i2 < l2; i2++) {
    const s2 = strings[i2];
    let attrNameEndIndex = -1;
    let attrName;
    let lastIndex = 0;
    let match5;
    while (lastIndex < s2.length) {
      regex.lastIndex = lastIndex;
      match5 = regex.exec(s2);
      if (match5 === null) {
        break;
      }
      lastIndex = regex.lastIndex;
      if (regex === textEndRegex) {
        if (match5[COMMENT_START] === "!--") {
          regex = commentEndRegex;
        } else if (match5[COMMENT_START] !== void 0) {
          regex = comment2EndRegex;
        } else if (match5[TAG_NAME] !== void 0) {
          if (rawTextElement.test(match5[TAG_NAME])) {
            rawTextEndRegex = new RegExp(`</${match5[TAG_NAME]}`, "g");
          }
          regex = tagEndRegex;
        } else if (match5[DYNAMIC_TAG_NAME] !== void 0) {
          {
            throw new Error("Bindings in tag names are not supported. Please use static templates instead. See https://lit.dev/docs/templates/expressions/#static-expressions");
          }
        }
      } else if (regex === tagEndRegex) {
        if (match5[ENTIRE_MATCH] === ">") {
          regex = rawTextEndRegex !== null && rawTextEndRegex !== void 0 ? rawTextEndRegex : textEndRegex;
          attrNameEndIndex = -1;
        } else if (match5[ATTRIBUTE_NAME] === void 0) {
          attrNameEndIndex = -2;
        } else {
          attrNameEndIndex = regex.lastIndex - match5[SPACES_AND_EQUALS].length;
          attrName = match5[ATTRIBUTE_NAME];
          regex = match5[QUOTE_CHAR] === void 0 ? tagEndRegex : match5[QUOTE_CHAR] === '"' ? doubleQuoteAttrEndRegex : singleQuoteAttrEndRegex;
        }
      } else if (regex === doubleQuoteAttrEndRegex || regex === singleQuoteAttrEndRegex) {
        regex = tagEndRegex;
      } else if (regex === commentEndRegex || regex === comment2EndRegex) {
        regex = textEndRegex;
      } else {
        regex = tagEndRegex;
        rawTextEndRegex = void 0;
      }
    }
    {
      console.assert(attrNameEndIndex === -1 || regex === tagEndRegex || regex === singleQuoteAttrEndRegex || regex === doubleQuoteAttrEndRegex, "unexpected parse state B");
    }
    const end = regex === tagEndRegex && strings[i2 + 1].startsWith("/>") ? " " : "";
    html2 += regex === textEndRegex ? s2 + nodeMarker : attrNameEndIndex >= 0 ? (attrNames.push(attrName), s2.slice(0, attrNameEndIndex) + boundAttributeSuffix + s2.slice(attrNameEndIndex)) + marker + end : s2 + marker + (attrNameEndIndex === -2 ? (attrNames.push(void 0), i2) : end);
  }
  const htmlResult = html2 + (strings[l2] || "<?>") + (type === SVG_RESULT ? "</svg>" : "");
  return [
    policy !== void 0 ? policy.createHTML(htmlResult) : htmlResult,
    attrNames
  ];
};
class Template {
  constructor({ strings, ["_$litType$"]: type }, options) {
    this.parts = [];
    let node;
    let nodeIndex = 0;
    let attrNameIndex = 0;
    const partCount = strings.length - 1;
    const parts = this.parts;
    const [html2, attrNames] = getTemplateHtml(strings, type);
    this.el = Template.createElement(html2, options);
    walker.currentNode = this.el.content;
    if (type === SVG_RESULT) {
      const content = this.el.content;
      const svgElement = content.firstChild;
      svgElement.remove();
      content.append(...svgElement.childNodes);
    }
    while ((node = walker.nextNode()) !== null && parts.length < partCount) {
      if (node.nodeType === 1) {
        {
          const tag2 = node.localName;
          if (/^(?:textarea|template)$/i.test(tag2) && node.innerHTML.includes(marker)) {
            const m2 = `Expressions are not supported inside \`${tag2}\` elements. See https://lit.dev/msg/expression-in-${tag2} for more information.`;
            if (tag2 === "template") {
              throw new Error(m2);
            } else
              issueWarning("", m2);
          }
        }
        if (node.hasAttributes()) {
          const attrsToRemove = [];
          for (const name2 of node.getAttributeNames()) {
            if (name2.endsWith(boundAttributeSuffix) || name2.startsWith(marker)) {
              const realName = attrNames[attrNameIndex++];
              attrsToRemove.push(name2);
              if (realName !== void 0) {
                const value = node.getAttribute(realName.toLowerCase() + boundAttributeSuffix);
                const statics = value.split(marker);
                const m2 = /([.?@])?(.*)/.exec(realName);
                parts.push({
                  type: ATTRIBUTE_PART,
                  index: nodeIndex,
                  name: m2[2],
                  strings: statics,
                  ctor: m2[1] === "." ? PropertyPart : m2[1] === "?" ? BooleanAttributePart : m2[1] === "@" ? EventPart : AttributePart
                });
              } else {
                parts.push({
                  type: ELEMENT_PART,
                  index: nodeIndex
                });
              }
            }
          }
          for (const name2 of attrsToRemove) {
            node.removeAttribute(name2);
          }
        }
        if (rawTextElement.test(node.tagName)) {
          const strings2 = node.textContent.split(marker);
          const lastIndex = strings2.length - 1;
          if (lastIndex > 0) {
            node.textContent = trustedTypes ? trustedTypes.emptyScript : "";
            for (let i2 = 0; i2 < lastIndex; i2++) {
              node.append(strings2[i2], createMarker());
              walker.nextNode();
              parts.push({
                type: CHILD_PART,
                index: ++nodeIndex
              });
            }
            node.append(strings2[lastIndex], createMarker());
          }
        }
      } else if (node.nodeType === 8) {
        const data = node.data;
        if (data === markerMatch) {
          parts.push({ type: CHILD_PART, index: nodeIndex });
        } else {
          let i2 = -1;
          while ((i2 = node.data.indexOf(marker, i2 + 1)) !== -1) {
            parts.push({ type: COMMENT_PART, index: nodeIndex });
            i2 += marker.length - 1;
          }
        }
      }
      nodeIndex++;
    }
  }
  static createElement(html2, _options) {
    const el2 = d.createElement("template");
    el2.innerHTML = html2;
    return el2;
  }
}
function resolveDirective(part, value, parent = part, attributeIndex) {
  var _a2, _b2, _c2;
  var _d2;
  if (value === noChange) {
    return value;
  }
  let currentDirective = attributeIndex !== void 0 ? (_a2 = parent.__directives) === null || _a2 === void 0 ? void 0 : _a2[attributeIndex] : parent.__directive;
  const nextDirectiveConstructor = isPrimitive(value) ? void 0 : value["_$litDirective$"];
  if ((currentDirective === null || currentDirective === void 0 ? void 0 : currentDirective.constructor) !== nextDirectiveConstructor) {
    (_b2 = currentDirective === null || currentDirective === void 0 ? void 0 : currentDirective["_$notifyDirectiveConnectionChanged"]) === null || _b2 === void 0 ? void 0 : _b2.call(currentDirective, false);
    if (nextDirectiveConstructor === void 0) {
      currentDirective = void 0;
    } else {
      currentDirective = new nextDirectiveConstructor(part);
      currentDirective._$initialize(part, parent, attributeIndex);
    }
    if (attributeIndex !== void 0) {
      ((_c2 = (_d2 = parent).__directives) !== null && _c2 !== void 0 ? _c2 : _d2.__directives = [])[attributeIndex] = currentDirective;
    } else {
      parent.__directive = currentDirective;
    }
  }
  if (currentDirective !== void 0) {
    value = resolveDirective(part, currentDirective._$resolve(part, value.values), currentDirective, attributeIndex);
  }
  return value;
}
class TemplateInstance {
  constructor(template2, parent) {
    this._parts = [];
    this._$disconnectableChildren = void 0;
    this._$template = template2;
    this._$parent = parent;
  }
  get parentNode() {
    return this._$parent.parentNode;
  }
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  _clone(options) {
    var _a2;
    const {
      el: { content },
      parts
    } = this._$template;
    const fragment2 = ((_a2 = options === null || options === void 0 ? void 0 : options.creationScope) !== null && _a2 !== void 0 ? _a2 : d).importNode(content, true);
    walker.currentNode = fragment2;
    let node = walker.nextNode();
    let nodeIndex = 0;
    let partIndex = 0;
    let templatePart = parts[0];
    while (templatePart !== void 0) {
      if (nodeIndex === templatePart.index) {
        let part;
        if (templatePart.type === CHILD_PART) {
          part = new ChildPart(node, node.nextSibling, this, options);
        } else if (templatePart.type === ATTRIBUTE_PART) {
          part = new templatePart.ctor(node, templatePart.name, templatePart.strings, this, options);
        } else if (templatePart.type === ELEMENT_PART) {
          part = new ElementPart(node, this, options);
        }
        this._parts.push(part);
        templatePart = parts[++partIndex];
      }
      if (nodeIndex !== (templatePart === null || templatePart === void 0 ? void 0 : templatePart.index)) {
        node = walker.nextNode();
        nodeIndex++;
      }
    }
    return fragment2;
  }
  _update(values) {
    let i2 = 0;
    for (const part of this._parts) {
      if (part !== void 0) {
        if (part.strings !== void 0) {
          part._$setValue(values, part, i2);
          i2 += part.strings.length - 2;
        } else {
          part._$setValue(values[i2]);
        }
      }
      i2++;
    }
  }
}
class ChildPart {
  constructor(startNode, endNode, parent, options) {
    var _a2;
    this.type = CHILD_PART;
    this._$committedValue = nothing;
    this._$disconnectableChildren = void 0;
    this._$startNode = startNode;
    this._$endNode = endNode;
    this._$parent = parent;
    this.options = options;
    this.__isConnected = (_a2 = options === null || options === void 0 ? void 0 : options.isConnected) !== null && _a2 !== void 0 ? _a2 : true;
    {
      this._textSanitizer = void 0;
    }
  }
  get _$isConnected() {
    var _a2, _b2;
    return (_b2 = (_a2 = this._$parent) === null || _a2 === void 0 ? void 0 : _a2._$isConnected) !== null && _b2 !== void 0 ? _b2 : this.__isConnected;
  }
  get parentNode() {
    let parentNode = wrap$1(this._$startNode).parentNode;
    const parent = this._$parent;
    if (parent !== void 0 && parentNode.nodeType === 11) {
      parentNode = parent.parentNode;
    }
    return parentNode;
  }
  get startNode() {
    return this._$startNode;
  }
  get endNode() {
    return this._$endNode;
  }
  _$setValue(value, directiveParent = this) {
    if (this.parentNode === null) {
      throw new Error(`This \`ChildPart\` has no \`parentNode\` and therefore cannot accept a value. This likely means the element containing the part was manipulated in an unsupported way outside of Lit's control such that the part's marker nodes were ejected from DOM. For example, setting the element's \`innerHTML\` or \`textContent\` can do this.`);
    }
    value = resolveDirective(this, value, directiveParent);
    if (isPrimitive(value)) {
      if (value === nothing || value == null || value === "") {
        if (this._$committedValue !== nothing) {
          this._$clear();
        }
        this._$committedValue = nothing;
      } else if (value !== this._$committedValue && value !== noChange) {
        this._commitText(value);
      }
    } else if (value["_$litType$"] !== void 0) {
      this._commitTemplateResult(value);
    } else if (value.nodeType !== void 0) {
      this._commitNode(value);
    } else if (isIterable(value)) {
      this._commitIterable(value);
    } else {
      this._commitText(value);
    }
  }
  _insert(node, ref = this._$endNode) {
    return wrap$1(wrap$1(this._$startNode).parentNode).insertBefore(node, ref);
  }
  _commitNode(value) {
    var _a2;
    if (this._$committedValue !== value) {
      this._$clear();
      if (sanitizerFactoryInternal !== noopSanitizer) {
        const parentNodeName = (_a2 = this._$startNode.parentNode) === null || _a2 === void 0 ? void 0 : _a2.nodeName;
        if (parentNodeName === "STYLE" || parentNodeName === "SCRIPT") {
          let message = "Forbidden";
          {
            if (parentNodeName === "STYLE") {
              message = `Lit does not support binding inside style nodes. This is a security risk, as style injection attacks can exfiltrate data and spoof UIs. Consider instead using css\`...\` literals to compose styles, and make do dynamic styling with css custom properties, ::parts, <slot>s, and by mutating the DOM rather than stylesheets.`;
            } else {
              message = `Lit does not support binding inside script nodes. This is a security risk, as it could allow arbitrary code execution.`;
            }
          }
          throw new Error(message);
        }
      }
      this._$committedValue = this._insert(value);
    }
  }
  _commitText(value) {
    if (this._$committedValue !== nothing && isPrimitive(this._$committedValue)) {
      const node = wrap$1(this._$startNode).nextSibling;
      {
        if (this._textSanitizer === void 0) {
          this._textSanitizer = createSanitizer();
        }
        value = this._textSanitizer(value);
      }
      node.data = value;
    } else {
      {
        const textNode = document.createTextNode("");
        this._commitNode(textNode);
        if (this._textSanitizer === void 0) {
          this._textSanitizer = createSanitizer();
        }
        value = this._textSanitizer(value);
        textNode.data = value;
      }
    }
    this._$committedValue = value;
  }
  _commitTemplateResult(result) {
    var _a2;
    const { values, ["_$litType$"]: type } = result;
    const template2 = typeof type === "number" ? this._$getTemplate(result) : (type.el === void 0 && (type.el = Template.createElement(type.h, this.options)), type);
    if (((_a2 = this._$committedValue) === null || _a2 === void 0 ? void 0 : _a2._$template) === template2) {
      this._$committedValue._update(values);
    } else {
      const instance = new TemplateInstance(template2, this);
      const fragment2 = instance._clone(this.options);
      instance._update(values);
      this._commitNode(fragment2);
      this._$committedValue = instance;
    }
  }
  _$getTemplate(result) {
    let template2 = templateCache.get(result.strings);
    if (template2 === void 0) {
      templateCache.set(result.strings, template2 = new Template(result));
    }
    return template2;
  }
  _commitIterable(value) {
    if (!isArray(this._$committedValue)) {
      this._$committedValue = [];
      this._$clear();
    }
    const itemParts = this._$committedValue;
    let partIndex = 0;
    let itemPart;
    for (const item of value) {
      if (partIndex === itemParts.length) {
        itemParts.push(itemPart = new ChildPart(this._insert(createMarker()), this._insert(createMarker()), this, this.options));
      } else {
        itemPart = itemParts[partIndex];
      }
      itemPart._$setValue(item);
      partIndex++;
    }
    if (partIndex < itemParts.length) {
      this._$clear(itemPart && wrap$1(itemPart._$endNode).nextSibling, partIndex);
      itemParts.length = partIndex;
    }
  }
  _$clear(start = wrap$1(this._$startNode).nextSibling, from2) {
    var _a2;
    (_a2 = this._$notifyConnectionChanged) === null || _a2 === void 0 ? void 0 : _a2.call(this, false, true, from2);
    while (start && start !== this._$endNode) {
      const n2 = wrap$1(start).nextSibling;
      wrap$1(start).remove();
      start = n2;
    }
  }
  setConnected(isConnected) {
    var _a2;
    if (this._$parent === void 0) {
      this.__isConnected = isConnected;
      (_a2 = this._$notifyConnectionChanged) === null || _a2 === void 0 ? void 0 : _a2.call(this, isConnected);
    } else {
      throw new Error("part.setConnected() may only be called on a RootPart returned from render().");
    }
  }
}
class AttributePart {
  constructor(element, name2, strings, parent, options) {
    this.type = ATTRIBUTE_PART;
    this._$committedValue = nothing;
    this._$disconnectableChildren = void 0;
    this.element = element;
    this.name = name2;
    this._$parent = parent;
    this.options = options;
    if (strings.length > 2 || strings[0] !== "" || strings[1] !== "") {
      this._$committedValue = new Array(strings.length - 1).fill(new String());
      this.strings = strings;
    } else {
      this._$committedValue = nothing;
    }
    {
      this._sanitizer = void 0;
    }
  }
  get tagName() {
    return this.element.tagName;
  }
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  _$setValue(value, directiveParent = this, valueIndex, noCommit) {
    const strings = this.strings;
    let change = false;
    if (strings === void 0) {
      value = resolveDirective(this, value, directiveParent, 0);
      change = !isPrimitive(value) || value !== this._$committedValue && value !== noChange;
      if (change) {
        this._$committedValue = value;
      }
    } else {
      const values = value;
      value = strings[0];
      let i2, v2;
      for (i2 = 0; i2 < strings.length - 1; i2++) {
        v2 = resolveDirective(this, values[valueIndex + i2], directiveParent, i2);
        if (v2 === noChange) {
          v2 = this._$committedValue[i2];
        }
        change || (change = !isPrimitive(v2) || v2 !== this._$committedValue[i2]);
        if (v2 === nothing) {
          value = nothing;
        } else if (value !== nothing) {
          value += (v2 !== null && v2 !== void 0 ? v2 : "") + strings[i2 + 1];
        }
        this._$committedValue[i2] = v2;
      }
    }
    if (change && !noCommit) {
      this._commitValue(value);
    }
  }
  _commitValue(value) {
    if (value === nothing) {
      wrap$1(this.element).removeAttribute(this.name);
    } else {
      {
        if (this._sanitizer === void 0) {
          this._sanitizer = sanitizerFactoryInternal(this.element, this.name);
        }
        value = this._sanitizer(value !== null && value !== void 0 ? value : "");
      }
      wrap$1(this.element).setAttribute(this.name, value !== null && value !== void 0 ? value : "");
    }
  }
}
class PropertyPart extends AttributePart {
  constructor() {
    super(...arguments);
    this.type = PROPERTY_PART;
  }
  _commitValue(value) {
    {
      if (this._sanitizer === void 0) {
        this._sanitizer = sanitizerFactoryInternal(this.element, this.name);
      }
      value = this._sanitizer(value);
    }
    this.element[this.name] = value === nothing ? void 0 : value;
  }
}
class BooleanAttributePart extends AttributePart {
  constructor() {
    super(...arguments);
    this.type = BOOLEAN_ATTRIBUTE_PART;
  }
  _commitValue(value) {
    if (value && value !== nothing) {
      wrap$1(this.element).setAttribute(this.name, "");
    } else {
      wrap$1(this.element).removeAttribute(this.name);
    }
  }
}
class EventPart extends AttributePart {
  constructor(element, name2, strings, parent, options) {
    super(element, name2, strings, parent, options);
    this.type = EVENT_PART;
    if (this.strings !== void 0) {
      throw new Error(`A \`<${element.localName}>\` has a \`@${name2}=...\` listener with invalid content. Event listeners in templates must have exactly one expression and no surrounding text.`);
    }
  }
  _$setValue(newListener, directiveParent = this) {
    var _a2;
    newListener = (_a2 = resolveDirective(this, newListener, directiveParent, 0)) !== null && _a2 !== void 0 ? _a2 : nothing;
    if (newListener === noChange) {
      return;
    }
    const oldListener = this._$committedValue;
    const shouldRemoveListener = newListener === nothing && oldListener !== nothing || newListener.capture !== oldListener.capture || newListener.once !== oldListener.once || newListener.passive !== oldListener.passive;
    const shouldAddListener = newListener !== nothing && (oldListener === nothing || shouldRemoveListener);
    if (shouldRemoveListener) {
      this.element.removeEventListener(this.name, this, oldListener);
    }
    if (shouldAddListener) {
      this.element.addEventListener(this.name, this, newListener);
    }
    this._$committedValue = newListener;
  }
  handleEvent(event) {
    var _a2, _b2;
    if (typeof this._$committedValue === "function") {
      this._$committedValue.call((_b2 = (_a2 = this.options) === null || _a2 === void 0 ? void 0 : _a2.host) !== null && _b2 !== void 0 ? _b2 : this.element, event);
    } else {
      this._$committedValue.handleEvent(event);
    }
  }
}
class ElementPart {
  constructor(element, parent, options) {
    this.element = element;
    this.type = ELEMENT_PART;
    this._$disconnectableChildren = void 0;
    this._$parent = parent;
    this.options = options;
  }
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  _$setValue(value) {
    resolveDirective(this, value);
  }
}
const polyfillSupport = window.litHtmlPolyfillSupportDevMode;
polyfillSupport === null || polyfillSupport === void 0 ? void 0 : polyfillSupport(Template, ChildPart);
((_d = globalThis.litHtmlVersions) !== null && _d !== void 0 ? _d : globalThis.litHtmlVersions = []).push("2.0.1");
if (globalThis.litHtmlVersions.length > 1) {
  issueWarning("multiple-versions", `Multiple versions of Lit loaded. Loading multiple versions is not recommended.`);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const PartType = {
  ATTRIBUTE: 1,
  CHILD: 2,
  PROPERTY: 3,
  BOOLEAN_ATTRIBUTE: 4,
  EVENT: 5,
  ELEMENT: 6
};
const directive = (c2) => (...values) => ({
  ["_$litDirective$"]: c2,
  values
});
class Directive {
  constructor(_partInfo) {
  }
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  _$initialize(part, parent, attributeIndex) {
    this.__part = part;
    this._$parent = parent;
    this.__attributeIndex = attributeIndex;
  }
  _$resolve(part, props) {
    return this.update(part, props);
  }
  update(_part, props) {
    return this.render(...props);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const HTML_RESULT = 1;
class UnsafeHTMLDirective extends Directive {
  constructor(partInfo) {
    super(partInfo);
    this._value = nothing;
    if (partInfo.type !== PartType.CHILD) {
      throw new Error(`${this.constructor.directiveName}() can only be used in child bindings`);
    }
  }
  render(value) {
    if (value === nothing || value == null) {
      this._templateResult = void 0;
      return this._value = value;
    }
    if (value === noChange) {
      return value;
    }
    if (typeof value != "string") {
      throw new Error(`${this.constructor.directiveName}() called with a non-string value`);
    }
    if (value === this._value) {
      return this._templateResult;
    }
    this._value = value;
    const strings = [value];
    strings.raw = strings;
    return this._templateResult = {
      ["_$litType$"]: this.constructor.resultType,
      strings,
      values: []
    };
  }
}
UnsafeHTMLDirective.directiveName = "unsafeHTML";
UnsafeHTMLDirective.resultType = HTML_RESULT;
const unsafeHTML = directive(UnsafeHTMLDirective);
class SHighlightJsComponentInterface extends SInterface {
  static get _definition() {
    return {
      items: {
        type: "String|Function"
      },
      value: {
        type: "String",
        default: "value"
      },
      label: {
        type: "String|Function",
        default: "value"
      },
      emptyText: {
        type: "String",
        default: "No item to display"
      },
      loadingText: {
        type: "String",
        default: "Loading please wait..."
      },
      filtrable: {
        type: {
          type: "Array<String>",
          splitChars: [","]
        },
        default: []
      },
      templates: {
        description: 'Specify either an object with properties like "item", "empty" and "loading", or a function returning the good template depending on tne "type" argument property',
        type: "Object|Function"
      },
      closeTimeout: {
        type: "Number",
        default: 100
      },
      interactive: {
        type: "Boolean",
        default: false
      },
      notSelectable: {
        type: "Boolean",
        default: false
      },
      maxItems: {
        type: "Number",
        default: 25
      }
    };
  }
}
function plainObject(object) {
  if (!object)
    return false;
  if (typeof object !== "object")
    return false;
  if (object.constructor && object.constructor.name !== "Object")
    return false;
  if (Object.prototype.toString.call(object) !== "[object Object]")
    return false;
  if (object !== Object(object))
    return false;
  return true;
}
function __deepMerge(...args) {
  function merge2(firstObj, secondObj) {
    const newObj = {};
    if (!firstObj && secondObj)
      return secondObj;
    if (!secondObj && firstObj)
      return firstObj;
    if (!firstObj && !secondObj)
      return {};
    const firstProps = Object.getOwnPropertyNames(firstObj);
    firstProps.forEach((key) => {
      const desc = Object.getOwnPropertyDescriptor(firstObj, key);
      if (desc.set || desc.get) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = firstObj[key];
      }
    });
    const secondProps = Object.getOwnPropertyNames(secondObj);
    secondProps.forEach((key) => {
      const desc = Object.getOwnPropertyDescriptor(secondObj, key);
      if (desc.set || desc.get) {
        Object.defineProperty(newObj, key, desc);
      } else if (plainObject(newObj[key]) && plainObject(secondObj[key])) {
        newObj[key] = merge2(newObj[key], secondObj[key]);
      } else {
        newObj[key] = secondObj[key];
      }
    });
    return newObj;
  }
  let currentObj = {};
  for (let i2 = 0; i2 < args.length; i2++) {
    const toMergeObj = args[i2];
    currentObj = merge2(currentObj, toMergeObj);
  }
  return currentObj;
}
function clone(object, settings = {}) {
  settings = Object.assign({ deep: false }, settings);
  if (settings.deep) {
    return __deepClone(object);
  }
  return __clone(object);
}
function scrollTop() {
  return window.pageYOffset || document.scrollTop || document.body.scrollTop;
}
function offset(elm) {
  const box = elm.getBoundingClientRect(), body = document.body, docEl = document.documentElement, scrollTop2 = window.pageYOffset || docEl.scrollTop || body.scrollTop, scrollLeft = window.pageXOffset || docEl.scrollLeft || body.scrollLeft, clientTop = docEl.clientTop || body.clientTop || 0, clientLeft = docEl.clientLeft || body.clientLeft || 0, top = box.top + scrollTop2 - clientTop, left2 = box.left + scrollLeft - clientLeft;
  return {
    top: Math.round(top),
    left: Math.round(left2)
  };
}
function fromElementTopToViewportBottom(elm) {
  const offsets = offset(elm);
  const scrollTop$1 = scrollTop();
  const viewportHeight = window.innerHeight;
  const distance = viewportHeight - offsets.top + scrollTop$1;
  return distance;
}
function camelize(text) {
  let res = "";
  const reg = /(?:^|[_-\s])(\w)/g;
  res = text.replace(reg, function(_2, c2) {
    return c2 ? c2.toUpperCase() : "";
  });
  res = res.substr(0, 1).toLowerCase() + res.slice(1);
  return res.trim();
}
function autoCast(string) {
  if (typeof string !== "string")
    return string;
  if (string.substr(0, 1) === "'" && string.substr(-1) === "'") {
    return string.substr(1, string.length - 2);
  }
  const presumedNumber = parseFloat(string);
  if (!isNaN(presumedNumber)) {
    if (presumedNumber.toString() === string) {
      return presumedNumber;
    }
  }
  if (window[string]) {
    return string;
  }
  try {
    const obj = eval(`(${string})`);
    return obj;
  } catch (e20) {
    return string;
  }
}
function getStyleProperty(elm, property2) {
  setTimeout(() => {
    elm._sComputedStyle = null;
  });
  const computed = elm._sComputedStyle || window.getComputedStyle(elm);
  elm._sComputedStyle = computed;
  const prefixes = ["", "webkit-", "moz-", "ms-", "o-", "khtml-"];
  for (let i2 = 0; i2 < prefixes.length; i2++) {
    const prefix = prefixes[i2];
    const value = computed[camelize(`${prefix}${property2}`)];
    if (value && value.trim() !== "")
      return autoCast(value);
  }
  return null;
}
function fromElementTopToViewportTop(elm) {
  const offsets = offset(elm);
  const scrollTop$1 = scrollTop();
  return offsets.top - scrollTop$1;
}
/*!
 * hotkeys-js v3.8.7
 * A simple micro-library for defining and dispatching keyboard shortcuts. It has no dependencies.
 *
 * Copyright (c) 2021 kenny wong <wowohoo@qq.com>
 * http://jaywcjlove.github.io/hotkeys
 *
 * Licensed under the MIT license.
 */
var isff = typeof navigator !== "undefined" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : false;
function addEvent(object, event, method) {
  if (object.addEventListener) {
    object.addEventListener(event, method, false);
  } else if (object.attachEvent) {
    object.attachEvent("on".concat(event), function() {
      method(window.event);
    });
  }
}
function getMods(modifier, key) {
  var mods = key.slice(0, key.length - 1);
  for (var i2 = 0; i2 < mods.length; i2++) {
    mods[i2] = modifier[mods[i2].toLowerCase()];
  }
  return mods;
}
function getKeys(key) {
  if (typeof key !== "string")
    key = "";
  key = key.replace(/\s/g, "");
  var keys2 = key.split(",");
  var index = keys2.lastIndexOf("");
  for (; index >= 0; ) {
    keys2[index - 1] += ",";
    keys2.splice(index, 1);
    index = keys2.lastIndexOf("");
  }
  return keys2;
}
function compareArray(a1, a2) {
  var arr1 = a1.length >= a2.length ? a1 : a2;
  var arr2 = a1.length >= a2.length ? a2 : a1;
  var isIndex = true;
  for (var i2 = 0; i2 < arr1.length; i2++) {
    if (arr2.indexOf(arr1[i2]) === -1)
      isIndex = false;
  }
  return isIndex;
}
var _keyMap = {
  backspace: 8,
  tab: 9,
  clear: 12,
  enter: 13,
  return: 13,
  esc: 27,
  escape: 27,
  space: 32,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  del: 46,
  delete: 46,
  ins: 45,
  insert: 45,
  home: 36,
  end: 35,
  pageup: 33,
  pagedown: 34,
  capslock: 20,
  num_0: 96,
  num_1: 97,
  num_2: 98,
  num_3: 99,
  num_4: 100,
  num_5: 101,
  num_6: 102,
  num_7: 103,
  num_8: 104,
  num_9: 105,
  num_multiply: 106,
  num_add: 107,
  num_enter: 108,
  num_subtract: 109,
  num_decimal: 110,
  num_divide: 111,
  "\u21EA": 20,
  ",": 188,
  ".": 190,
  "/": 191,
  "`": 192,
  "-": isff ? 173 : 189,
  "=": isff ? 61 : 187,
  ";": isff ? 59 : 186,
  "'": 222,
  "[": 219,
  "]": 221,
  "\\": 220
};
var _modifier = {
  "\u21E7": 16,
  shift: 16,
  "\u2325": 18,
  alt: 18,
  option: 18,
  "\u2303": 17,
  ctrl: 17,
  control: 17,
  "\u2318": 91,
  cmd: 91,
  command: 91
};
var modifierMap = {
  16: "shiftKey",
  18: "altKey",
  17: "ctrlKey",
  91: "metaKey",
  shiftKey: 16,
  ctrlKey: 17,
  altKey: 18,
  metaKey: 91
};
var _mods = {
  16: false,
  18: false,
  17: false,
  91: false
};
var _handlers = {};
for (var k = 1; k < 20; k++) {
  _keyMap["f".concat(k)] = 111 + k;
}
var _downKeys = [];
var _scope = "all";
var elementHasBindEvent = [];
var code = function code3(x2) {
  return _keyMap[x2.toLowerCase()] || _modifier[x2.toLowerCase()] || x2.toUpperCase().charCodeAt(0);
};
function setScope(scope) {
  _scope = scope || "all";
}
function getScope() {
  return _scope || "all";
}
function getPressedKeyCodes() {
  return _downKeys.slice(0);
}
function filter(event) {
  var target = event.target || event.srcElement;
  var tagName = target.tagName;
  var flag = true;
  if (target.isContentEditable || (tagName === "INPUT" || tagName === "TEXTAREA" || tagName === "SELECT") && !target.readOnly) {
    flag = false;
  }
  return flag;
}
function isPressed(keyCode) {
  if (typeof keyCode === "string") {
    keyCode = code(keyCode);
  }
  return _downKeys.indexOf(keyCode) !== -1;
}
function deleteScope(scope, newScope) {
  var handlers;
  var i2;
  if (!scope)
    scope = getScope();
  for (var key in _handlers) {
    if (Object.prototype.hasOwnProperty.call(_handlers, key)) {
      handlers = _handlers[key];
      for (i2 = 0; i2 < handlers.length; ) {
        if (handlers[i2].scope === scope)
          handlers.splice(i2, 1);
        else
          i2++;
      }
    }
  }
  if (getScope() === scope)
    setScope(newScope || "all");
}
function clearModifier(event) {
  var key = event.keyCode || event.which || event.charCode;
  var i2 = _downKeys.indexOf(key);
  if (i2 >= 0) {
    _downKeys.splice(i2, 1);
  }
  if (event.key && event.key.toLowerCase() === "meta") {
    _downKeys.splice(0, _downKeys.length);
  }
  if (key === 93 || key === 224)
    key = 91;
  if (key in _mods) {
    _mods[key] = false;
    for (var k2 in _modifier) {
      if (_modifier[k2] === key)
        hotkeys[k2] = false;
    }
  }
}
function unbind(keysInfo) {
  if (!keysInfo) {
    Object.keys(_handlers).forEach(function(key) {
      return delete _handlers[key];
    });
  } else if (Array.isArray(keysInfo)) {
    keysInfo.forEach(function(info) {
      if (info.key)
        eachUnbind(info);
    });
  } else if (typeof keysInfo === "object") {
    if (keysInfo.key)
      eachUnbind(keysInfo);
  } else if (typeof keysInfo === "string") {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    var scope = args[0], method = args[1];
    if (typeof scope === "function") {
      method = scope;
      scope = "";
    }
    eachUnbind({
      key: keysInfo,
      scope,
      method,
      splitKey: "+"
    });
  }
}
var eachUnbind = function eachUnbind3(_ref) {
  var key = _ref.key, scope = _ref.scope, method = _ref.method, _ref$splitKey = _ref.splitKey, splitKey = _ref$splitKey === void 0 ? "+" : _ref$splitKey;
  var multipleKeys = getKeys(key);
  multipleKeys.forEach(function(originKey) {
    var unbindKeys = originKey.split(splitKey);
    var len = unbindKeys.length;
    var lastKey = unbindKeys[len - 1];
    var keyCode = lastKey === "*" ? "*" : code(lastKey);
    if (!_handlers[keyCode])
      return;
    if (!scope)
      scope = getScope();
    var mods = len > 1 ? getMods(_modifier, unbindKeys) : [];
    _handlers[keyCode] = _handlers[keyCode].map(function(record) {
      var isMatchingMethod = method ? record.method === method : true;
      if (isMatchingMethod && record.scope === scope && compareArray(record.mods, mods)) {
        return {};
      }
      return record;
    });
  });
};
function eventHandler(event, handler, scope) {
  var modifiersMatch;
  if (handler.scope === scope || handler.scope === "all") {
    modifiersMatch = handler.mods.length > 0;
    for (var y2 in _mods) {
      if (Object.prototype.hasOwnProperty.call(_mods, y2)) {
        if (!_mods[y2] && handler.mods.indexOf(+y2) > -1 || _mods[y2] && handler.mods.indexOf(+y2) === -1) {
          modifiersMatch = false;
        }
      }
    }
    if (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch || handler.shortcut === "*") {
      if (handler.method(event, handler) === false) {
        if (event.preventDefault)
          event.preventDefault();
        else
          event.returnValue = false;
        if (event.stopPropagation)
          event.stopPropagation();
        if (event.cancelBubble)
          event.cancelBubble = true;
      }
    }
  }
}
function dispatch(event) {
  var asterisk = _handlers["*"];
  var key = event.keyCode || event.which || event.charCode;
  if (!hotkeys.filter.call(this, event))
    return;
  if (key === 93 || key === 224)
    key = 91;
  if (_downKeys.indexOf(key) === -1 && key !== 229)
    _downKeys.push(key);
  ["ctrlKey", "altKey", "shiftKey", "metaKey"].forEach(function(keyName) {
    var keyNum = modifierMap[keyName];
    if (event[keyName] && _downKeys.indexOf(keyNum) === -1) {
      _downKeys.push(keyNum);
    } else if (!event[keyName] && _downKeys.indexOf(keyNum) > -1) {
      _downKeys.splice(_downKeys.indexOf(keyNum), 1);
    } else if (keyName === "metaKey" && event[keyName] && _downKeys.length === 3) {
      if (!(event.ctrlKey || event.shiftKey || event.altKey)) {
        _downKeys = _downKeys.slice(_downKeys.indexOf(keyNum));
      }
    }
  });
  if (key in _mods) {
    _mods[key] = true;
    for (var k2 in _modifier) {
      if (_modifier[k2] === key)
        hotkeys[k2] = true;
    }
    if (!asterisk)
      return;
  }
  for (var e20 in _mods) {
    if (Object.prototype.hasOwnProperty.call(_mods, e20)) {
      _mods[e20] = event[modifierMap[e20]];
    }
  }
  if (event.getModifierState && !(event.altKey && !event.ctrlKey) && event.getModifierState("AltGraph")) {
    if (_downKeys.indexOf(17) === -1) {
      _downKeys.push(17);
    }
    if (_downKeys.indexOf(18) === -1) {
      _downKeys.push(18);
    }
    _mods[17] = true;
    _mods[18] = true;
  }
  var scope = getScope();
  if (asterisk) {
    for (var i2 = 0; i2 < asterisk.length; i2++) {
      if (asterisk[i2].scope === scope && (event.type === "keydown" && asterisk[i2].keydown || event.type === "keyup" && asterisk[i2].keyup)) {
        eventHandler(event, asterisk[i2], scope);
      }
    }
  }
  if (!(key in _handlers))
    return;
  for (var _i2 = 0; _i2 < _handlers[key].length; _i2++) {
    if (event.type === "keydown" && _handlers[key][_i2].keydown || event.type === "keyup" && _handlers[key][_i2].keyup) {
      if (_handlers[key][_i2].key) {
        var record = _handlers[key][_i2];
        var splitKey = record.splitKey;
        var keyShortcut = record.key.split(splitKey);
        var _downKeysCurrent = [];
        for (var a2 = 0; a2 < keyShortcut.length; a2++) {
          _downKeysCurrent.push(code(keyShortcut[a2]));
        }
        if (_downKeysCurrent.sort().join("") === _downKeys.sort().join("")) {
          eventHandler(event, record, scope);
        }
      }
    }
  }
}
function isElementBind(element) {
  return elementHasBindEvent.indexOf(element) > -1;
}
function hotkeys(key, option, method) {
  _downKeys = [];
  var keys2 = getKeys(key);
  var mods = [];
  var scope = "all";
  var element = document;
  var i2 = 0;
  var keyup = false;
  var keydown = true;
  var splitKey = "+";
  if (method === void 0 && typeof option === "function") {
    method = option;
  }
  if (Object.prototype.toString.call(option) === "[object Object]") {
    if (option.scope)
      scope = option.scope;
    if (option.element)
      element = option.element;
    if (option.keyup)
      keyup = option.keyup;
    if (option.keydown !== void 0)
      keydown = option.keydown;
    if (typeof option.splitKey === "string")
      splitKey = option.splitKey;
  }
  if (typeof option === "string")
    scope = option;
  for (; i2 < keys2.length; i2++) {
    key = keys2[i2].split(splitKey);
    mods = [];
    if (key.length > 1)
      mods = getMods(_modifier, key);
    key = key[key.length - 1];
    key = key === "*" ? "*" : code(key);
    if (!(key in _handlers))
      _handlers[key] = [];
    _handlers[key].push({
      keyup,
      keydown,
      scope,
      mods,
      shortcut: keys2[i2],
      method,
      key: keys2[i2],
      splitKey
    });
  }
  if (typeof element !== "undefined" && !isElementBind(element) && window) {
    elementHasBindEvent.push(element);
    addEvent(element, "keydown", function(e20) {
      dispatch(e20);
    });
    addEvent(window, "focus", function() {
      _downKeys = [];
    });
    addEvent(element, "keyup", function(e20) {
      dispatch(e20);
      clearModifier(e20);
    });
  }
}
var _api = {
  setScope,
  getScope,
  deleteScope,
  getPressedKeyCodes,
  isPressed,
  filter,
  unbind
};
for (var a in _api) {
  if (Object.prototype.hasOwnProperty.call(_api, a)) {
    hotkeys[a] = _api[a];
  }
}
if (typeof window !== "undefined") {
  var _hotkeys = window.hotkeys;
  hotkeys.noConflict = function(deep) {
    if (deep && window.hotkeys === hotkeys) {
      window.hotkeys = _hotkeys;
    }
    return hotkeys;
  };
  window.hotkeys = hotkeys;
}
var hotkeys_common = hotkeys;
hotkeys_common.filter = function() {
  return true;
};
function hotkey(hotkey2, settings = {}) {
  return new SPromise(({ resolve: resolve2, reject, emit, cancel }) => {
    settings = Object.assign({
      element: null,
      keyup: false,
      keydown: true,
      once: false,
      splitKey: "+"
    }, settings);
    hotkeys_common(hotkey2, settings, (e20, h2) => {
      emit("press", e20);
      if (settings.once)
        cancel();
    });
  }, {
    id: "hotkey"
  }).on("finally", () => {
    hotkeys_common.unbind(hotkey2);
  });
}
function stripTags(html2) {
  const tmp2 = document.createElement("div");
  tmp2.innerHTML = html2;
  return tmp2.textContent || tmp2.innerText || "";
}
function onScrollEnd($elm, callback, settings) {
  const finalSettings = Object.assign({ offset: 20, once: false, times: -1 }, settings !== null && settings !== void 0 ? settings : {});
  let isBody = false;
  let $scrollListenedElm = $elm;
  let $scrollHeightElm = $elm;
  if ($elm === window.document.body) {
    isBody = true;
    $scrollListenedElm = document;
    $scrollHeightElm = window.document.body;
  } else if ($elm === window.document) {
    isBody = true;
    $elm = window.document.body;
    $scrollHeightElm = window.document.body;
  }
  let active = true, count = 0;
  const internalCallback = (e20) => {
    let fullHeight, viewportHeight, scrollTop2;
    if (isBody) {
      viewportHeight = window.innerHeight;
      scrollTop2 = $scrollHeightElm.scrollTop;
      fullHeight = Math.max(window.document.body.scrollHeight, window.document.documentElement.scrollHeight, window.document.body.offsetHeight, window.document.documentElement.offsetHeight, window.document.body.clientHeight, window.document.documentElement.clientHeight);
    } else {
      viewportHeight = $scrollHeightElm.offsetHeight;
      scrollTop2 = $scrollHeightElm.scrollTop;
      fullHeight = $scrollHeightElm.scrollHeight;
    }
    console.log("is", active);
    console.log($elm, scrollTop2, viewportHeight, fullHeight, finalSettings.offset);
    console.log(scrollTop2 + viewportHeight, fullHeight - finalSettings.offset);
    if (active && scrollTop2 + viewportHeight >= fullHeight - finalSettings.offset) {
      callback();
      count++;
      if (finalSettings.once) {
        $scrollListenedElm.removeEventListener("scroll", internalCallback);
        active = false;
      } else if (finalSettings.times > 0 && count >= finalSettings.times) {
        $scrollListenedElm.removeEventListener("scroll", internalCallback);
        active = false;
      }
    } else if ($scrollHeightElm.offsetHeight + $scrollHeightElm.scrollTop < $scrollHeightElm.scrollHeight - finalSettings.offset) {
      active = true;
    }
  };
  console.log($scrollListenedElm);
  $scrollListenedElm.addEventListener("scroll", internalCallback);
}
var __css$1 = ".s-filtrable-input {\n    font-size: calc(1rem * var(--s-scale, 1));\n    display: inline-block;\n    position: relative;\n\n    /* @sugar.scope.lnf {\n        .s-filtrable-input__list {\n            transition: max-height 0.1s ease-in-out;\n        }\n\n        .s-filtrable-input__list-item-highlight {\n            background-color: sugar.color(current);\n        }\n    } */\n}\n\n    .s-filtrable-input .s-filtrable-input__input {\n    }\n\n    .s-filtrable-input .s-filtrable-input__list {\n        position: absolute;\n        top: 100%;\n        left: 0;\n        overflow-x: hidden;\n        overflow-y: auto;\n        opacity: 0;\n        max-width: calc(100vw - 100px);\n        pointer-events: none;\n        margin: 20px 0;\n    }\n\n    .s-filtrable-input:focus-within .s-filtrable-input__list {\n        pointer-events: all;\n        opacity: 1;\n    }\n\n    .s-filtrable-input.s-filtrable-input--top .s-filtrable-input__list {\n            top: auto;\n            bottom: 100%;\n        }\n\n    .s-filtrable-input .s-filtrable-input__input:focus + .s-filtrable-input__list,\n    .s-filtrable-input .s-filtrable-input__list:focus,\n    .s-filtrable-input .s-filtrable-input__list:focus-within {\n        opacity: 1;\n        pointer-events: all !important;\n    }\n\n    .s-filtrable-input .s-filtrable-input__list-item {\n        position: relative;\n        -webkit-user-select: none;\n           -moz-user-select: none;\n            -ms-user-select: none;\n                user-select: none;\n    }\n\n    .s-filtrable-input:not([interactive]) .s-filtrable-input__list-item {\n        cursor: pointer;\n    }\n\n    .s-filtrable-input:not([interactive]) .s-filtrable-input__list-item * {\n            pointer-events: none;\n        }\n";
var __awaiter$6 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e20) {
        reject(e20);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e20) {
        reject(e20);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SFiltrableInput extends SLitComponent {
  constructor() {
    super(__deepMerge({
      litComponent: {
        shadowDom: false
      },
      componentUtils: {
        interface: SHighlightJsComponentInterface
      }
    }));
    this.state = {
      baseTemplates: void 0,
      preselectedItem: void 0,
      preselectedItemIdx: -1,
      selectedItemIdx: -1,
      displayedMaxItems: 0,
      value: "",
      isActive: false,
      isLoading: false,
      items: [],
      filteredItems: []
    };
    this.state.displayedMaxItems = this.props.maxItems;
    if (this.props.items && typeof this.props.items === "string") {
      const $itemsElm = document.querySelector(this.props.items);
      if ($itemsElm) {
        this.state.items = JSON.parse($itemsElm.innerHTML);
        this.requestUpdate();
      }
    }
    this.state.baseTemplates = ({ type, item, html: html2 }) => {
      switch (type) {
        case "item":
          return html2`
                        <div class="${this.componentUtils.className("__item")}">
                            ${unsafeHTML(typeof this.props.label === "function" ? this.props.label(item) : item[this.props.label])}
                        </div>
                    `;
        case "empty":
          return html2`
                        <div
                            class="${this.componentUtils.className("__empty")}"
                        >
                            ${this.props.emptyText}
                        </div>
                    `;
        case "loading":
          return html2`
                        <div
                            class="${this.componentUtils.className("__loading")}"
                        >
                            ${this.props.loadingText}
                        </div>
                    `;
      }
    };
  }
  static get styles() {
    return css$1`
            ${unsafeCSS(__css$1)}
        `;
  }
  firstUpdated() {
    var _a2;
    return __awaiter$6(this, void 0, void 0, function* () {
      this.$input = this.querySelector("input");
      this.$input.setAttribute("autocomplete", "off");
      if (!this.props.bare) {
        (_a2 = this.$input.classList) === null || _a2 === void 0 ? void 0 : _a2.add("s-input");
      }
      this.$input.addEventListener("keyup", (e20) => {
        const value = e20.target.value;
        this.state.value = value;
        this.state.displayedMaxItems = this.props.maxItems;
        this.filterItems();
      });
      this.$input.classList.add(this.componentUtils.className("__input"));
      this.$container = this;
      this.$container.classList.add("s-filtrable-input");
      this.$container.classList.add(this.componentUtils.className());
      this.$list = this.querySelector("ul");
      this.prepend(this.$input);
      this.filterItems();
      document.addEventListener("scroll", () => {
        this._updateListSizeAndPosition();
      });
      this.$input.addEventListener("focus", (e20) => {
        this.state.isActive = true;
        this.filterItems();
        this._updateListSizeAndPosition();
      });
      this._updateListSizeAndPosition();
      onScrollEnd(this.$list, () => {
        var _a3;
        this.state.displayedMaxItems = ((_a3 = this.state.displayedMaxItems) !== null && _a3 !== void 0 ? _a3 : 0) + this.props.maxItems;
        this.filterItems(false);
      });
      hotkey("escape").on("press", (e20) => {
        e20.preventDefault();
        if (!this.state.isActive)
          return;
        this.close();
      });
      hotkey("up").on("press", (e20) => {
        e20.preventDefault();
        if (!this.state.isActive)
          return;
        this.state.preselectedItemIdx = this.state.preselectedItemIdx > 0 ? this.state.preselectedItemIdx - 1 : 0;
        this.requestUpdate();
        const $item = this.$list.children[this.state.preselectedItemIdx];
        $item.focus();
      });
      hotkey("down").on("press", (e20) => {
        e20.preventDefault();
        if (!this.state.isActive)
          return;
        this.state.preselectedItemIdx = this.state.preselectedItemIdx >= this.state.filteredItems.length - 1 ? this.state.filteredItems.length - 1 : this.state.preselectedItemIdx + 1;
        this.requestUpdate();
        const $item = this.$list.children[this.state.preselectedItemIdx];
        $item.focus();
      });
      hotkey("return").on("press", (e20) => {
        if (!this.state.isActive)
          return;
        this.validateAndClose();
      });
    });
  }
  get selectedItem() {
    if (this.state.selectedItemIdx === -1)
      return;
    return this.state.filteredItems[this.state.selectedItemIdx];
  }
  get preselectedItem() {
    if (this.state.preselectedItemIdx === -1)
      return;
    return this.state.filteredItems[this.state.preselectedItemIdx];
  }
  validate() {
    var _a2;
    if (!this.state.preselectedItem)
      return;
    if (this.state.preselectedItem) {
      if (typeof this.props.value === "string" && ((_a2 = this.state.preselectedItem) === null || _a2 === void 0 ? void 0 : _a2[this.props.value])) {
        this.$input.value = stripTags(this.state.preselectedItem[this.props.value]);
      } else if (typeof this.props.value === "function") {
        const v2 = this.props.value({
          item: this.state.filteredItems[this.state.preselectedItemIdx]
        });
        if (typeof v2 !== "string") {
          throw new Error(`<red>[s-filtrable-input]</red> Sorry but the returned value "<yellow>${v2}</yellow>" has to be a string...`);
        }
        this.$input.value = stripTags(v2);
      }
    }
    this.state.selectedItemIdx = this.state.preselectedItemIdx;
    this.state.value = this.$input.value;
    this.requestUpdate();
    console.log("DISPA");
    const event = new CustomEvent("select", {
      bubbles: true,
      detail: this.selectedItem
    });
    this.dispatchEvent(event);
  }
  validateAndClose() {
    this.validate();
    setTimeout(() => {
      this.close();
    }, this.props.closeTimeout);
  }
  close() {
    this.$input.focus();
    this.$input.blur();
    this.state.isActive = false;
  }
  refreshItems() {
    return __awaiter$6(this, void 0, void 0, function* () {
      if (typeof this.props.items === "function") {
        this.state.isLoading = true;
        this.requestUpdate();
        const items = yield this.props.items({
          value: this.$input.value
        });
        if (plainObject(items)) {
          this.state.items = Object.values(items);
        } else if (Array.isArray(items)) {
          this.state.items = items;
        } else {
          throw new Error(`Sorry but the "items" MUST be an Array...`);
        }
      }
    });
  }
  filterItems(needUpdate = true) {
    return __awaiter$6(this, void 0, void 0, function* () {
      if (needUpdate)
        yield this.refreshItems();
      let items = this.state.items;
      let matchedItemsCount = 0;
      const filteredItems = items.map((item) => clone(item)).filter((item) => {
        if (matchedItemsCount >= this.state.displayedMaxItems)
          return false;
        if (!this.props.filtrable.length)
          return true;
        let matchFilter = false;
        for (let i2 = 0; i2 < Object.keys(item).length; i2++) {
          const propName = Object.keys(item)[i2], propValue = item[propName];
          if (typeof propValue !== "string")
            continue;
          if (this.props.filtrable.indexOf(propName) !== -1) {
            const reg = new RegExp(this.state.value.split(" ").join("|"), "gi");
            if (propValue.match(reg)) {
              matchFilter = true;
              if (this.state.value && this.state.value !== "") {
                const reg2 = new RegExp(this.state.value.split(" ").join("|"), "gi");
                const finalString = propValue.replace(reg2, (str) => {
                  return `<span class="${this.componentUtils.className("__list-item-highlight")} s-highlight"
                                                >${str}</span>`;
                });
                item[propName] = finalString;
              }
            }
          }
        }
        if (matchFilter) {
          matchedItemsCount++;
        }
        return matchFilter;
      });
      this.state.filteredItems = filteredItems;
      this.state.isLoading = false;
      this.requestUpdate();
    });
  }
  select(idx) {
    this._setPreselectedItemByIdx(idx);
  }
  selectAndValidate(idx) {
    this._setPreselectedItemByIdx(idx);
    this.validate();
  }
  selectValidateAndClose(idx) {
    this._setPreselectedItemByIdx(idx);
    this.validateAndClose();
  }
  _setPreselectedItemByIdx(idx) {
    if (this.props.notSelectable)
      return;
    this.state.preselectedItemIdx = idx;
    this.state.preselectedItem = this.state.items[idx];
    this.requestUpdate();
  }
  _updateListSizeAndPosition() {
    if (!this.state.isActive)
      return;
    const marginTop = getStyleProperty(this.$list, "marginTop");
    getStyleProperty(this.$list, "marginLeft");
    getStyleProperty(this.$list, "marginRight");
    const marginBottom = getStyleProperty(this.$list, "marginBottom");
    const distanceTop = fromElementTopToViewportTop(this.$input);
    const distanceBottom = fromElementTopToViewportBottom(this.$input) - this.$input.clientHeight;
    let maxHeight;
    if (distanceTop > distanceBottom) {
      this.$container.classList.add("s-filtrable-input--top");
      this.$list.style.top = `auto`;
      this.$list.style.bottom = `calc(100% - ${marginBottom})`;
      maxHeight = distanceTop - parseInt(marginTop);
    } else {
      this.$container.classList.remove("s-filtrable-input--top");
      this.$list.style.bottom = `auto`;
      this.$list.style.top = `calc(100% - ${marginTop})`;
      maxHeight = distanceBottom - parseInt(marginBottom);
    }
    this.$list.style.maxHeight = `${maxHeight}px`;
  }
  render() {
    var _a2, _b2, _c2, _d2, _e2, _f3;
    return html$2`
            <ul
                class="s-filtrable-input__list ${this.componentUtils.className("__list")}"
            >
                ${this.state.isLoading ? html$2`
                          <li
                              class="s-filtrable-input__list-item s-filtrable-input__list-loading ${this.componentUtils.className("__list-item __list-loading")}"
                          >
                              ${(_c2 = (_b2 = (_a2 = this.props).templates) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, {
      type: "loading",
      html: html$2
    })) !== null && _c2 !== void 0 ? _c2 : this.state.baseTemplates({
      type: "loading",
      html: html$2
    })}
                          </li>
                      ` : !this.state.isLoading && this.state.filteredItems.length <= 0 ? html$2`
                          <li
                              class="s-filtrable-input__list-item s-filtrable-input__list-no-item  ${this.componentUtils.className("__list-item __list-no-item")}"
                          >
                              ${(_f3 = (_e2 = (_d2 = this.props).templates) === null || _e2 === void 0 ? void 0 : _e2.call(_d2, {
      type: "empty",
      html: html$2
    })) !== null && _f3 !== void 0 ? _f3 : this.state.baseTemplates({
      type: "empty",
      html: html$2
    })}
                          </li>
                      ` : !this.state.isLoading && this.state.filteredItems.length ? this.state.filteredItems.map((item, idx) => {
      var _a3, _b3, _c3;
      return idx < this.state.displayedMaxItems ? html$2`
                                    <li
                                        @click=${() => this.selectAndValidate(idx)}
                                        @dblclick=${() => this.selectValidateAndClose(idx)}
                                        @focus=${() => this._setPreselectedItemByIdx(idx)}
                                        style="z-index: ${999999999 - idx}"
                                        tabindex="0"
                                        class="s-filtrable-input__list-item ${this.componentUtils.className("__list-item") + " " + (this.state.selectedItemIdx === idx ? "active" : "")}"
                                        hoverable
                                    >
                                        ${(_c3 = (_b3 = (_a3 = this.props).templates) === null || _b3 === void 0 ? void 0 : _b3.call(_a3, {
        type: "item",
        html: html$2,
        unsafeHTML,
        item,
        idx
      })) !== null && _c3 !== void 0 ? _c3 : this.state.baseTemplates({
        type: "item",
        html: html$2,
        unsafeHTML,
        item,
        idx
      })}
                                    </li>
                                ` : "";
    }) : ""}
            </ul>
        `;
  }
}
function define$7(props = {}, tagName = "s-filtrable-input") {
  SLitComponent.setDefaultProps(tagName, props);
  customElements.define(tagName, SFiltrableInput);
}
var __awaiter$5 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e20) {
        reject(e20);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e20) {
        reject(e20);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
define$7({
  value: "name",
  label: (item) => {
    return `${item.type} ${item.namespace}`;
  },
  filtrable: ["namespace", "name", "type"],
  templates: ({ type, item, html: html2, unsafeHTML: unsafeHTML2 }) => {
    var _a2, _b2, _c2;
    if (type === "item") {
      return html2`
                    <div class="__item">
                        <div class="s-flex s-mbe:10">
                            <h4
                                class="__title s-typo:bold s-tc:accent s-flex-item:grow"
                            >
                                ${unsafeHTML2(item.name)}
                            </h4>
                            <div>
                                ${item.platform.map((platform) => html2`
                                        <i
                                            class="s-platform:${platform.name}"
                                        ></i>
                                    `)}
                                &nbsp;
                                <span class="s-badge s-color:main"
                                    >${unsafeHTML2((_a2 = item.type) !== null && _a2 !== void 0 ? _a2 : "")}</span
                                >
                            </div>
                        </div>
                        <p class="__namespace s-opacity:50 s-font:20 s-mbe:20">
                            ${unsafeHTML2((_b2 = item.namespace) !== null && _b2 !== void 0 ? _b2 : "")}
                        </p>
                        <p class="__description s-typo:p s-truncate:2">
                            ${unsafeHTML2((_c2 = item.description) !== null && _c2 !== void 0 ? _c2 : "")}
                        </p>
                    </div>
                `;
    }
  },
  items: ({ value }) => __awaiter$5(void 0, void 0, void 0, function* () {
    function fetchItems() {
      return __awaiter$5(this, void 0, void 0, function* () {
        const request2 = new SRequest({
          url: "/docmap.json"
        });
        const result = yield request2.send();
        const items = [];
        Object.keys(result.data.map).forEach((namespace) => {
          const item = result.data.map[namespace];
          item.fullNamespace = namespace;
          items.push(item);
        });
        window.localStorage.setItem("ck-search-items", JSON.stringify(items));
        return items;
      });
    }
    const cached = window.localStorage.getItem("ck-search-items");
    if (!cached) {
      const items = yield fetchItems();
      return items;
    } else {
      fetchItems();
      const items = JSON.parse(cached);
      return items;
    }
  })
}, "ck-search-input");
class CKSearch extends SLitComponent {
  constructor() {
    super({
      litComponent: {
        shadowDom: false
      }
    });
  }
  firstUpdated() {
    this.addEventListener("select", (e20) => {
      var _a2;
      const item = e20.detail;
      if ((_a2 = item.menu) === null || _a2 === void 0 ? void 0 : _a2.slug) {
        if (item.package !== window.packageJson.name) {
          document.location.href = `${item.package}${item.menu.slug}`;
        } else {
          document.location.href = item.menu.slug;
        }
      } else {
        document.location.href = `/api/${item.fullNamespace}`;
      }
    });
  }
  render() {
    return html$2`
            <div class="ck-search">
                <div class="__background"></div>
                <div class="__content s-color:accent">
                    <ck-search-input>
                        <input
                            placeholder="API search..."
                            type="text"
                            name="search"
                            class="s-input s-color:accent s-scale:11"
                        />
                    </ck-search-input>
                </div>
            </div>
        `;
  }
}
function define$6(props = {}, tagName = "ck-search") {
  SLitComponent.setDefaultProps(tagName, props);
  customElements.define(tagName, CKSearch);
}
var __awaiter$4 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e20) {
        reject(e20);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e20) {
        reject(e20);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class CKDiscover extends SLitComponent {
  constructor() {
    super({
      litComponent: {
        shadowDom: false
      }
    });
  }
  firstUpdated() {
    return __awaiter$4(this, void 0, void 0, function* () {
      this._docmap = yield loadDocmap();
      this.grabItem();
    });
  }
  grabItem() {
    return __awaiter$4(this, void 0, void 0, function* () {
      this.item = void 0;
      this.requestUpdate();
      yield wait$1();
      const newMap = filter$2(this._docmap.map, (key, item) => {
        if (!item.platform)
          return false;
        if (item.platform[0].name !== this.props.platform)
          return false;
        if (!item.example)
          return false;
        return true;
      });
      const mapCount = Object.keys(newMap).length;
      const mapKeys = Object.keys(newMap);
      const itemIdx = Math.floor(Math.random() * mapCount);
      this.item = newMap[mapKeys[itemIdx]];
      this.requestUpdate();
    });
  }
  render() {
    return html$2`
            <div class="ck-discover">
                ${!this.item ? html$2`<div class="s-code-example-loader">
                          <i class="s-loader:spinner s-color:accent"></i>
                          &nbsp;
                          <p class="s-typo:p s-display:inline-block">
                              Loading code example. Please wait...
                          </p>
                      </div>` : html$2`
                          <h1 class="s-typo:h3 s-mbe:30">
                              ${this.item.async ? html$2`
                                        <span
                                            class="s-badge:outline s-color:accent"
                                            >Async</span
                                        >&nbsp;
                                    ` : ""}
                              ${this.item.name}
                              <a
                                  @click="${this.grabItem}"
                                  class="s-btn s-radius:100 s-align:abs-top-right s-color:accent s-float:right"
                              >
                                  <i class="s-icon:refresh"></i>
                              </a>
                          </h1>
                          <p class="s-typo:p s-mbe:30">
                              ${this.item.description}
                          </p>
                          <s-code-example>
                              <textarea
                                  lang="${this.props.platform === "ts" || this.props.platform === "node" ? "js" : this.props.platform}"
                              >
                                ${this.item.example[0].code}
                              </textarea
                              >
                          </s-code-example>
                          <div
                              class="s-until:sibling:mounted s-code-example-loader"
                          >
                              <i class="s-loader:spinner s-color:accent"></i>
                              &nbsp;
                              <p class="s-typo:p s-display:inline-block">
                                  Loading code example. Please wait...
                              </p>
                          </div>
                      `}
            </div>
        `;
  }
}
function define$5(props = {}, tagName = "ck-discover") {
  SLitComponent.setDefaultProps(tagName, props);
  customElements.define(tagName, CKDiscover);
}
var __awaiter$3 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e20) {
        reject(e20);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e20) {
        reject(e20);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class CkSettings extends SLitComponent {
  constructor() {
    super({
      litComponent: {
        shadowDom: false
      }
    });
    this._settings = {
      darkMode: true,
      colors: {
        accent: void 0,
        complementary: void 0
      }
    };
    this._restoreState();
  }
  firstUpdated() {
    return __awaiter$3(this, void 0, void 0, function* () {
      const $root = document.querySelector(":root"), $darkRoot = document.querySelector(".s-theme--coffeekrakenDark"), $theme = $darkRoot !== null && $darkRoot !== void 0 ? $darkRoot : $root;
      const $mainColorPicker = this.querySelector("#setting-main-color");
      const $accentColorPicker = this.querySelector("#setting-accent-color");
      $mainColorPicker.addEventListener("change", (e20) => {
        $theme.style.setProperty("--s-theme-color-main-h", e20.detail.hsla.h);
        $theme.style.setProperty("--s-theme-color-main-s", e20.detail.hsla.s);
        $theme.style.setProperty("--s-theme-color-main-l", e20.detail.hsla.l);
      });
      $accentColorPicker.addEventListener("change", (e20) => {
        $theme.style.setProperty("--s-theme-color-accent-h", e20.detail.hsla.h);
        $theme.style.setProperty("--s-theme-color-accent-s", e20.detail.hsla.s);
        $theme.style.setProperty("--s-theme-color-accent-l", e20.detail.hsla.l);
      });
    });
  }
  _restoreState() {
    const state = getState();
    this.setDarkMode(state.darkMode);
  }
  _saveState() {
    setState(Object.assign({}, this._settings));
  }
  setDarkMode(mode) {
    this._settings.darkMode = mode;
    if (mode) {
      document.body.classList.add("s-theme--coffeekraken-dark");
    } else {
      document.body.classList.remove("s-theme--coffeekraken-dark");
    }
    this._saveState();
  }
  render() {
    return html$2`
            <div class="ck-settings">
                <div class="s-p:40 s-mbe:40">
                    <h1 class="s-typo:h3 s-mbe:40">Settings</h1>
                    <p class="s-typo:p">
                        These settings allows you to customize your Coffeekraken
                        experience as well as feature some of the capabilities
                        that our toolkit has to offer.
                    </p>
                </div>

                <ul class="__settings s-bg:odd">
                    <li class="s-bg:main-surface">
                        <label
                            class="s-label s-pi:40 s-pb:30"
                            for="theme-switcher"
                        >
                            Dark mode
                            <input
                                class="s-switch"
                                type="checkbox"
                                id="theme-switcher"
                                ?checked="${this._settings.darkMode}"
                                @change="${(e20) => {
      this.setDarkMode(e20.target.checked);
    }}"
                            />
                        </label>
                    </li>
                    <li class="s-bg:main-surface">
                        <label
                            class="s-label s-pi:40 s-pb:30"
                            for="setting-main-color"
                        >
                            Main color
                            <s-color-picker
                                id="setting-main-color"
                                value="#ff0000"
                            />
                        </label>
                    </li>
                    <li class="s-bg:main-surface">
                        <label
                            class="s-label s-pi:40 s-pb:30"
                            for="setting-accent-color"
                        >
                            Accent color
                            <s-color-picker
                                id="setting-accent-color"
                                value="#ff0000"
                            />
                        </label>
                    </li>
                    <li class="s-bg:main-surface">
                        <label
                            class="s-label s-pi:40 s-pb:30"
                            for="setting-accent-color"
                        >
                            Complementary color
                            <s-color-picker
                                id="setting-complementary-color"
                                value="#ff0000"
                            />
                        </label>
                    </li>
                </ul>
            </div>
        `;
  }
}
function define$4(props = {}, tagName = "ck-settings") {
  SLitComponent.setDefaultProps(tagName, props);
  customElements.define(tagName, CkSettings);
}
/**
* @license
* Copyright 2010-2021 Three.js Authors
* SPDX-License-Identifier: MIT
*/
const REVISION = "134";
const CullFaceNone = 0;
const CullFaceBack = 1;
const CullFaceFront = 2;
const PCFShadowMap = 1;
const PCFSoftShadowMap = 2;
const VSMShadowMap = 3;
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const FlatShading = 1;
const NoBlending = 0;
const NormalBlending = 1;
const AdditiveBlending = 2;
const SubtractiveBlending = 3;
const MultiplyBlending = 4;
const CustomBlending = 5;
const AddEquation = 100;
const SubtractEquation = 101;
const ReverseSubtractEquation = 102;
const MinEquation = 103;
const MaxEquation = 104;
const ZeroFactor = 200;
const OneFactor = 201;
const SrcColorFactor = 202;
const OneMinusSrcColorFactor = 203;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const DstAlphaFactor = 206;
const OneMinusDstAlphaFactor = 207;
const DstColorFactor = 208;
const OneMinusDstColorFactor = 209;
const SrcAlphaSaturateFactor = 210;
const NeverDepth = 0;
const AlwaysDepth = 1;
const LessDepth = 2;
const LessEqualDepth = 3;
const EqualDepth = 4;
const GreaterEqualDepth = 5;
const GreaterDepth = 6;
const NotEqualDepth = 7;
const MultiplyOperation = 0;
const MixOperation = 1;
const AddOperation = 2;
const NoToneMapping = 0;
const LinearToneMapping = 1;
const ReinhardToneMapping = 2;
const CineonToneMapping = 3;
const ACESFilmicToneMapping = 4;
const CustomToneMapping = 5;
const UVMapping = 300;
const CubeReflectionMapping = 301;
const CubeRefractionMapping = 302;
const EquirectangularReflectionMapping = 303;
const EquirectangularRefractionMapping = 304;
const CubeUVReflectionMapping = 306;
const CubeUVRefractionMapping = 307;
const RepeatWrapping = 1e3;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const NearestMipmapNearestFilter = 1004;
const NearestMipmapLinearFilter = 1005;
const LinearFilter = 1006;
const LinearMipmapNearestFilter = 1007;
const LinearMipmapLinearFilter = 1008;
const UnsignedByteType = 1009;
const ByteType = 1010;
const ShortType = 1011;
const UnsignedShortType = 1012;
const IntType = 1013;
const UnsignedIntType = 1014;
const FloatType = 1015;
const HalfFloatType = 1016;
const UnsignedShort4444Type = 1017;
const UnsignedShort5551Type = 1018;
const UnsignedShort565Type = 1019;
const UnsignedInt248Type = 1020;
const AlphaFormat = 1021;
const RGBFormat = 1022;
const RGBAFormat = 1023;
const LuminanceFormat = 1024;
const LuminanceAlphaFormat = 1025;
const RGBEFormat = RGBAFormat;
const DepthFormat = 1026;
const DepthStencilFormat = 1027;
const RedFormat = 1028;
const RedIntegerFormat = 1029;
const RGFormat = 1030;
const RGIntegerFormat = 1031;
const RGBIntegerFormat = 1032;
const RGBAIntegerFormat = 1033;
const RGB_S3TC_DXT1_Format = 33776;
const RGBA_S3TC_DXT1_Format = 33777;
const RGBA_S3TC_DXT3_Format = 33778;
const RGBA_S3TC_DXT5_Format = 33779;
const RGB_PVRTC_4BPPV1_Format = 35840;
const RGB_PVRTC_2BPPV1_Format = 35841;
const RGBA_PVRTC_4BPPV1_Format = 35842;
const RGBA_PVRTC_2BPPV1_Format = 35843;
const RGB_ETC1_Format = 36196;
const RGB_ETC2_Format = 37492;
const RGBA_ETC2_EAC_Format = 37496;
const RGBA_ASTC_4x4_Format = 37808;
const RGBA_ASTC_5x4_Format = 37809;
const RGBA_ASTC_5x5_Format = 37810;
const RGBA_ASTC_6x5_Format = 37811;
const RGBA_ASTC_6x6_Format = 37812;
const RGBA_ASTC_8x5_Format = 37813;
const RGBA_ASTC_8x6_Format = 37814;
const RGBA_ASTC_8x8_Format = 37815;
const RGBA_ASTC_10x5_Format = 37816;
const RGBA_ASTC_10x6_Format = 37817;
const RGBA_ASTC_10x8_Format = 37818;
const RGBA_ASTC_10x10_Format = 37819;
const RGBA_ASTC_12x10_Format = 37820;
const RGBA_ASTC_12x12_Format = 37821;
const RGBA_BPTC_Format = 36492;
const SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
const SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
const SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
const SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
const SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
const SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
const SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
const SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
const SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
const SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
const SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
const SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
const SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
const SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
const LoopOnce = 2200;
const LoopRepeat = 2201;
const LoopPingPong = 2202;
const InterpolateDiscrete = 2300;
const InterpolateLinear = 2301;
const InterpolateSmooth = 2302;
const ZeroCurvatureEnding = 2400;
const ZeroSlopeEnding = 2401;
const WrapAroundEnding = 2402;
const NormalAnimationBlendMode = 2500;
const AdditiveAnimationBlendMode = 2501;
const TrianglesDrawMode = 0;
const LinearEncoding = 3e3;
const sRGBEncoding = 3001;
const GammaEncoding = 3007;
const RGBEEncoding = 3002;
const LogLuvEncoding = 3003;
const RGBM7Encoding = 3004;
const RGBM16Encoding = 3005;
const RGBDEncoding = 3006;
const BasicDepthPacking = 3200;
const RGBADepthPacking = 3201;
const TangentSpaceNormalMap = 0;
const ObjectSpaceNormalMap = 1;
const KeepStencilOp = 7680;
const AlwaysStencilFunc = 519;
const StaticDrawUsage = 35044;
const DynamicDrawUsage = 35048;
const GLSL3 = "300 es";
class EventDispatcher {
  addEventListener(type, listener) {
    if (this._listeners === void 0)
      this._listeners = {};
    const listeners = this._listeners;
    if (listeners[type] === void 0) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  }
  hasEventListener(type, listener) {
    if (this._listeners === void 0)
      return false;
    const listeners = this._listeners;
    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
  }
  removeEventListener(type, listener) {
    if (this._listeners === void 0)
      return;
    const listeners = this._listeners;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index = listenerArray.indexOf(listener);
      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  }
  dispatchEvent(event) {
    if (this._listeners === void 0)
      return;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array = listenerArray.slice(0);
      for (let i2 = 0, l2 = array.length; i2 < l2; i2++) {
        array[i2].call(this, event);
      }
      event.target = null;
    }
  }
}
const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;
const _lut = [];
for (let i2 = 0; i2 < 256; i2++) {
  _lut[i2] = (i2 < 16 ? "0" : "") + i2.toString(16);
}
const hasRandomUUID = typeof crypto !== "undefined" && "randomUUID" in crypto;
function generateUUID() {
  if (hasRandomUUID) {
    return crypto.randomUUID().toUpperCase();
  }
  const d0 = Math.random() * 4294967295 | 0;
  const d1 = Math.random() * 4294967295 | 0;
  const d2 = Math.random() * 4294967295 | 0;
  const d3 = Math.random() * 4294967295 | 0;
  const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
  return uuid.toUpperCase();
}
function clamp(value, min2, max2) {
  return Math.max(min2, Math.min(max2, value));
}
function euclideanModulo(n2, m2) {
  return (n2 % m2 + m2) % m2;
}
function lerp(x2, y2, t2) {
  return (1 - t2) * x2 + t2 * y2;
}
function isPowerOfTwo(value) {
  return (value & value - 1) === 0 && value !== 0;
}
function floorPowerOfTwo(value) {
  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}
class Vector2 {
  constructor(x2 = 0, y2 = 0) {
    this.x = x2;
    this.y = y2;
  }
  get width() {
    return this.x;
  }
  set width(value) {
    this.x = value;
  }
  get height() {
    return this.y;
  }
  set height(value) {
    this.y = value;
  }
  set(x2, y2) {
    this.x = x2;
    this.y = y2;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }
  setX(x2) {
    this.x = x2;
    return this;
  }
  setY(y2) {
    this.y = y2;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(v2) {
    this.x = v2.x;
    this.y = v2.y;
    return this;
  }
  add(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v2, w2);
    }
    this.x += v2.x;
    this.y += v2.y;
    return this;
  }
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    return this;
  }
  addVectors(a2, b2) {
    this.x = a2.x + b2.x;
    this.y = a2.y + b2.y;
    return this;
  }
  addScaledVector(v2, s2) {
    this.x += v2.x * s2;
    this.y += v2.y * s2;
    return this;
  }
  sub(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v2, w2);
    }
    this.x -= v2.x;
    this.y -= v2.y;
    return this;
  }
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    return this;
  }
  subVectors(a2, b2) {
    this.x = a2.x - b2.x;
    this.y = a2.y - b2.y;
    return this;
  }
  multiply(v2) {
    this.x *= v2.x;
    this.y *= v2.y;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  divide(v2) {
    this.x /= v2.x;
    this.y /= v2.y;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  applyMatrix3(m2) {
    const x2 = this.x, y2 = this.y;
    const e20 = m2.elements;
    this.x = e20[0] * x2 + e20[3] * y2 + e20[6];
    this.y = e20[1] * x2 + e20[4] * y2 + e20[7];
    return this;
  }
  min(v2) {
    this.x = Math.min(this.x, v2.x);
    this.y = Math.min(this.y, v2.y);
    return this;
  }
  max(v2) {
    this.x = Math.max(this.x, v2.x);
    this.y = Math.max(this.y, v2.y);
    return this;
  }
  clamp(min2, max2) {
    this.x = Math.max(min2.x, Math.min(max2.x, this.x));
    this.y = Math.max(min2.y, Math.min(max2.y, this.y));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  }
  clampLength(min2, max2) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min2, Math.min(max2, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  dot(v2) {
    return this.x * v2.x + this.y * v2.y;
  }
  cross(v2) {
    return this.x * v2.y - this.y * v2.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  }
  distanceTo(v2) {
    return Math.sqrt(this.distanceToSquared(v2));
  }
  distanceToSquared(v2) {
    const dx2 = this.x - v2.x, dy2 = this.y - v2.y;
    return dx2 * dx2 + dy2 * dy2;
  }
  manhattanDistanceTo(v2) {
    return Math.abs(this.x - v2.x) + Math.abs(this.y - v2.y);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v2, alpha) {
    this.x += (v2.x - this.x) * alpha;
    this.y += (v2.y - this.y) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    return this;
  }
  equals(v2) {
    return v2.x === this.x && v2.y === this.y;
  }
  fromArray(array, offset2 = 0) {
    this.x = array[offset2];
    this.y = array[offset2 + 1];
    return this;
  }
  toArray(array = [], offset2 = 0) {
    array[offset2] = this.x;
    array[offset2 + 1] = this.y;
    return array;
  }
  fromBufferAttribute(attribute, index, offset2) {
    if (offset2 !== void 0) {
      console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    return this;
  }
  rotateAround(center, angle) {
    const c2 = Math.cos(angle), s2 = Math.sin(angle);
    const x2 = this.x - center.x;
    const y2 = this.y - center.y;
    this.x = x2 * c2 - y2 * s2 + center.x;
    this.y = x2 * s2 + y2 * c2 + center.y;
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
  }
}
Vector2.prototype.isVector2 = true;
class Matrix3 {
  constructor() {
    this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
    if (arguments.length > 0) {
      console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
    }
  }
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te2 = this.elements;
    te2[0] = n11;
    te2[1] = n21;
    te2[2] = n31;
    te2[3] = n12;
    te2[4] = n22;
    te2[5] = n32;
    te2[6] = n13;
    te2[7] = n23;
    te2[8] = n33;
    return this;
  }
  identity() {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  }
  copy(m2) {
    const te2 = this.elements;
    const me2 = m2.elements;
    te2[0] = me2[0];
    te2[1] = me2[1];
    te2[2] = me2[2];
    te2[3] = me2[3];
    te2[4] = me2[4];
    te2[5] = me2[5];
    te2[6] = me2[6];
    te2[7] = me2[7];
    te2[8] = me2[8];
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }
  setFromMatrix4(m2) {
    const me2 = m2.elements;
    this.set(me2[0], me2[4], me2[8], me2[1], me2[5], me2[9], me2[2], me2[6], me2[10]);
    return this;
  }
  multiply(m2) {
    return this.multiplyMatrices(this, m2);
  }
  premultiply(m2) {
    return this.multiplyMatrices(m2, this);
  }
  multiplyMatrices(a2, b2) {
    const ae2 = a2.elements;
    const be2 = b2.elements;
    const te2 = this.elements;
    const a11 = ae2[0], a12 = ae2[3], a13 = ae2[6];
    const a21 = ae2[1], a22 = ae2[4], a23 = ae2[7];
    const a31 = ae2[2], a32 = ae2[5], a33 = ae2[8];
    const b11 = be2[0], b12 = be2[3], b13 = be2[6];
    const b21 = be2[1], b22 = be2[4], b23 = be2[7];
    const b31 = be2[2], b32 = be2[5], b33 = be2[8];
    te2[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te2[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te2[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te2[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te2[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te2[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te2[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te2[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te2[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }
  multiplyScalar(s2) {
    const te2 = this.elements;
    te2[0] *= s2;
    te2[3] *= s2;
    te2[6] *= s2;
    te2[1] *= s2;
    te2[4] *= s2;
    te2[7] *= s2;
    te2[2] *= s2;
    te2[5] *= s2;
    te2[8] *= s2;
    return this;
  }
  determinant() {
    const te2 = this.elements;
    const a2 = te2[0], b2 = te2[1], c2 = te2[2], d2 = te2[3], e20 = te2[4], f2 = te2[5], g2 = te2[6], h2 = te2[7], i2 = te2[8];
    return a2 * e20 * i2 - a2 * f2 * h2 - b2 * d2 * i2 + b2 * f2 * g2 + c2 * d2 * h2 - c2 * e20 * g2;
  }
  invert() {
    const te2 = this.elements, n11 = te2[0], n21 = te2[1], n31 = te2[2], n12 = te2[3], n22 = te2[4], n32 = te2[5], n13 = te2[6], n23 = te2[7], n33 = te2[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te2[0] = t11 * detInv;
    te2[1] = (n31 * n23 - n33 * n21) * detInv;
    te2[2] = (n32 * n21 - n31 * n22) * detInv;
    te2[3] = t12 * detInv;
    te2[4] = (n33 * n11 - n31 * n13) * detInv;
    te2[5] = (n31 * n12 - n32 * n11) * detInv;
    te2[6] = t13 * detInv;
    te2[7] = (n21 * n13 - n23 * n11) * detInv;
    te2[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }
  transpose() {
    let tmp2;
    const m2 = this.elements;
    tmp2 = m2[1];
    m2[1] = m2[3];
    m2[3] = tmp2;
    tmp2 = m2[2];
    m2[2] = m2[6];
    m2[6] = tmp2;
    tmp2 = m2[5];
    m2[5] = m2[7];
    m2[7] = tmp2;
    return this;
  }
  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).invert().transpose();
  }
  transposeIntoArray(r2) {
    const m2 = this.elements;
    r2[0] = m2[0];
    r2[1] = m2[3];
    r2[2] = m2[6];
    r2[3] = m2[1];
    r2[4] = m2[4];
    r2[5] = m2[7];
    r2[6] = m2[2];
    r2[7] = m2[5];
    r2[8] = m2[8];
    return this;
  }
  setUvTransform(tx2, ty2, sx2, sy2, rotation, cx2, cy2) {
    const c2 = Math.cos(rotation);
    const s2 = Math.sin(rotation);
    this.set(sx2 * c2, sx2 * s2, -sx2 * (c2 * cx2 + s2 * cy2) + cx2 + tx2, -sy2 * s2, sy2 * c2, -sy2 * (-s2 * cx2 + c2 * cy2) + cy2 + ty2, 0, 0, 1);
    return this;
  }
  scale(sx2, sy2) {
    const te2 = this.elements;
    te2[0] *= sx2;
    te2[3] *= sx2;
    te2[6] *= sx2;
    te2[1] *= sy2;
    te2[4] *= sy2;
    te2[7] *= sy2;
    return this;
  }
  rotate(theta) {
    const c2 = Math.cos(theta);
    const s2 = Math.sin(theta);
    const te2 = this.elements;
    const a11 = te2[0], a12 = te2[3], a13 = te2[6];
    const a21 = te2[1], a22 = te2[4], a23 = te2[7];
    te2[0] = c2 * a11 + s2 * a21;
    te2[3] = c2 * a12 + s2 * a22;
    te2[6] = c2 * a13 + s2 * a23;
    te2[1] = -s2 * a11 + c2 * a21;
    te2[4] = -s2 * a12 + c2 * a22;
    te2[7] = -s2 * a13 + c2 * a23;
    return this;
  }
  translate(tx2, ty2) {
    const te2 = this.elements;
    te2[0] += tx2 * te2[2];
    te2[3] += tx2 * te2[5];
    te2[6] += tx2 * te2[8];
    te2[1] += ty2 * te2[2];
    te2[4] += ty2 * te2[5];
    te2[7] += ty2 * te2[8];
    return this;
  }
  equals(matrix) {
    const te2 = this.elements;
    const me2 = matrix.elements;
    for (let i2 = 0; i2 < 9; i2++) {
      if (te2[i2] !== me2[i2])
        return false;
    }
    return true;
  }
  fromArray(array, offset2 = 0) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.elements[i2] = array[i2 + offset2];
    }
    return this;
  }
  toArray(array = [], offset2 = 0) {
    const te2 = this.elements;
    array[offset2] = te2[0];
    array[offset2 + 1] = te2[1];
    array[offset2 + 2] = te2[2];
    array[offset2 + 3] = te2[3];
    array[offset2 + 4] = te2[4];
    array[offset2 + 5] = te2[5];
    array[offset2 + 6] = te2[6];
    array[offset2 + 7] = te2[7];
    array[offset2 + 8] = te2[8];
    return array;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
Matrix3.prototype.isMatrix3 = true;
function arrayMax(array) {
  if (array.length === 0)
    return -Infinity;
  let max2 = array[0];
  for (let i2 = 1, l2 = array.length; i2 < l2; ++i2) {
    if (array[i2] > max2)
      max2 = array[i2];
  }
  return max2;
}
function createElementNS(name2) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", name2);
}
function hashString(str, seed = 0) {
  let h1 = 3735928559 ^ seed, h2 = 1103547991 ^ seed;
  for (let i2 = 0, ch2; i2 < str.length; i2++) {
    ch2 = str.charCodeAt(i2);
    h1 = Math.imul(h1 ^ ch2, 2654435761);
    h2 = Math.imul(h2 ^ ch2, 1597334677);
  }
  h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507) ^ Math.imul(h2 ^ h2 >>> 13, 3266489909);
  h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507) ^ Math.imul(h1 ^ h1 >>> 13, 3266489909);
  return 4294967296 * (2097151 & h2) + (h1 >>> 0);
}
let _canvas;
class ImageUtils {
  static getDataURL(image) {
    if (/^data:/i.test(image.src)) {
      return image.src;
    }
    if (typeof HTMLCanvasElement == "undefined") {
      return image.src;
    }
    let canvas;
    if (image instanceof HTMLCanvasElement) {
      canvas = image;
    } else {
      if (_canvas === void 0)
        _canvas = createElementNS("canvas");
      _canvas.width = image.width;
      _canvas.height = image.height;
      const context = _canvas.getContext("2d");
      if (image instanceof ImageData) {
        context.putImageData(image, 0, 0);
      } else {
        context.drawImage(image, 0, 0, image.width, image.height);
      }
      canvas = _canvas;
    }
    if (canvas.width > 2048 || canvas.height > 2048) {
      console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);
      return canvas.toDataURL("image/jpeg", 0.6);
    } else {
      return canvas.toDataURL("image/png");
    }
  }
}
let textureId = 0;
class Texture extends EventDispatcher {
  constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format2 = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {
    super();
    Object.defineProperty(this, "id", { value: textureId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.image = image;
    this.mipmaps = [];
    this.mapping = mapping;
    this.wrapS = wrapS;
    this.wrapT = wrapT;
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.anisotropy = anisotropy;
    this.format = format2;
    this.internalFormat = null;
    this.type = type;
    this.offset = new Vector2(0, 0);
    this.repeat = new Vector2(1, 1);
    this.center = new Vector2(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix3();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    this.encoding = encoding;
    this.userData = {};
    this.version = 0;
    this.onUpdate = null;
    this.isRenderTargetTexture = false;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source3) {
    this.name = source3.name;
    this.image = source3.image;
    this.mipmaps = source3.mipmaps.slice(0);
    this.mapping = source3.mapping;
    this.wrapS = source3.wrapS;
    this.wrapT = source3.wrapT;
    this.magFilter = source3.magFilter;
    this.minFilter = source3.minFilter;
    this.anisotropy = source3.anisotropy;
    this.format = source3.format;
    this.internalFormat = source3.internalFormat;
    this.type = source3.type;
    this.offset.copy(source3.offset);
    this.repeat.copy(source3.repeat);
    this.center.copy(source3.center);
    this.rotation = source3.rotation;
    this.matrixAutoUpdate = source3.matrixAutoUpdate;
    this.matrix.copy(source3.matrix);
    this.generateMipmaps = source3.generateMipmaps;
    this.premultiplyAlpha = source3.premultiplyAlpha;
    this.flipY = source3.flipY;
    this.unpackAlignment = source3.unpackAlignment;
    this.encoding = source3.encoding;
    this.userData = JSON.parse(JSON.stringify(source3.userData));
    return this;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.textures[this.uuid] !== void 0) {
      return meta.textures[this.uuid];
    }
    const output = {
      metadata: {
        version: 4.5,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    if (this.image !== void 0) {
      const image = this.image;
      if (image.uuid === void 0) {
        image.uuid = generateUUID();
      }
      if (!isRootObject && meta.images[image.uuid] === void 0) {
        let url;
        if (Array.isArray(image)) {
          url = [];
          for (let i2 = 0, l2 = image.length; i2 < l2; i2++) {
            if (image[i2].isDataTexture) {
              url.push(serializeImage(image[i2].image));
            } else {
              url.push(serializeImage(image[i2]));
            }
          }
        } else {
          url = serializeImage(image);
        }
        meta.images[image.uuid] = {
          uuid: image.uuid,
          url
        };
      }
      output.image = image.uuid;
    }
    if (JSON.stringify(this.userData) !== "{}")
      output.userData = this.userData;
    if (!isRootObject) {
      meta.textures[this.uuid] = output;
    }
    return output;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(uv2) {
    if (this.mapping !== UVMapping)
      return uv2;
    uv2.applyMatrix3(this.matrix);
    if (uv2.x < 0 || uv2.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv2.x = uv2.x - Math.floor(uv2.x);
          break;
        case ClampToEdgeWrapping:
          uv2.x = uv2.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv2.x) % 2) === 1) {
            uv2.x = Math.ceil(uv2.x) - uv2.x;
          } else {
            uv2.x = uv2.x - Math.floor(uv2.x);
          }
          break;
      }
    }
    if (uv2.y < 0 || uv2.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv2.y = uv2.y - Math.floor(uv2.y);
          break;
        case ClampToEdgeWrapping:
          uv2.y = uv2.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv2.y) % 2) === 1) {
            uv2.y = Math.ceil(uv2.y) - uv2.y;
          } else {
            uv2.y = uv2.y - Math.floor(uv2.y);
          }
          break;
      }
    }
    if (this.flipY) {
      uv2.y = 1 - uv2.y;
    }
    return uv2;
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
}
Texture.DEFAULT_IMAGE = void 0;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.prototype.isTexture = true;
function serializeImage(image) {
  if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return ImageUtils.getDataURL(image);
  } else {
    if (image.data) {
      return {
        data: Array.prototype.slice.call(image.data),
        width: image.width,
        height: image.height,
        type: image.data.constructor.name
      };
    } else {
      console.warn("THREE.Texture: Unable to serialize Texture.");
      return {};
    }
  }
}
class Vector4 {
  constructor(x2 = 0, y2 = 0, z2 = 0, w2 = 1) {
    this.x = x2;
    this.y = y2;
    this.z = z2;
    this.w = w2;
  }
  get width() {
    return this.z;
  }
  set width(value) {
    this.z = value;
  }
  get height() {
    return this.w;
  }
  set height(value) {
    this.w = value;
  }
  set(x2, y2, z2, w2) {
    this.x = x2;
    this.y = y2;
    this.z = z2;
    this.w = w2;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  }
  setX(x2) {
    this.x = x2;
    return this;
  }
  setY(y2) {
    this.y = y2;
    return this;
  }
  setZ(z2) {
    this.z = z2;
    return this;
  }
  setW(w2) {
    this.w = w2;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      case 3:
        this.w = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(v2) {
    this.x = v2.x;
    this.y = v2.y;
    this.z = v2.z;
    this.w = v2.w !== void 0 ? v2.w : 1;
    return this;
  }
  add(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v2, w2);
    }
    this.x += v2.x;
    this.y += v2.y;
    this.z += v2.z;
    this.w += v2.w;
    return this;
  }
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    this.z += s2;
    this.w += s2;
    return this;
  }
  addVectors(a2, b2) {
    this.x = a2.x + b2.x;
    this.y = a2.y + b2.y;
    this.z = a2.z + b2.z;
    this.w = a2.w + b2.w;
    return this;
  }
  addScaledVector(v2, s2) {
    this.x += v2.x * s2;
    this.y += v2.y * s2;
    this.z += v2.z * s2;
    this.w += v2.w * s2;
    return this;
  }
  sub(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v2, w2);
    }
    this.x -= v2.x;
    this.y -= v2.y;
    this.z -= v2.z;
    this.w -= v2.w;
    return this;
  }
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    this.z -= s2;
    this.w -= s2;
    return this;
  }
  subVectors(a2, b2) {
    this.x = a2.x - b2.x;
    this.y = a2.y - b2.y;
    this.z = a2.z - b2.z;
    this.w = a2.w - b2.w;
    return this;
  }
  multiply(v2) {
    this.x *= v2.x;
    this.y *= v2.y;
    this.z *= v2.z;
    this.w *= v2.w;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  }
  applyMatrix4(m2) {
    const x2 = this.x, y2 = this.y, z2 = this.z, w2 = this.w;
    const e20 = m2.elements;
    this.x = e20[0] * x2 + e20[4] * y2 + e20[8] * z2 + e20[12] * w2;
    this.y = e20[1] * x2 + e20[5] * y2 + e20[9] * z2 + e20[13] * w2;
    this.z = e20[2] * x2 + e20[6] * y2 + e20[10] * z2 + e20[14] * w2;
    this.w = e20[3] * x2 + e20[7] * y2 + e20[11] * z2 + e20[15] * w2;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  setAxisAngleFromQuaternion(q2) {
    this.w = 2 * Math.acos(q2.w);
    const s2 = Math.sqrt(1 - q2.w * q2.w);
    if (s2 < 1e-4) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q2.x / s2;
      this.y = q2.y / s2;
      this.z = q2.z / s2;
    }
    return this;
  }
  setAxisAngleFromRotationMatrix(m2) {
    let angle, x2, y2, z2;
    const epsilon = 0.01, epsilon2 = 0.1, te2 = m2.elements, m11 = te2[0], m12 = te2[4], m13 = te2[8], m21 = te2[1], m22 = te2[5], m23 = te2[9], m31 = te2[2], m32 = te2[6], m33 = te2[10];
    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        this.set(1, 0, 0, 0);
        return this;
      }
      angle = Math.PI;
      const xx2 = (m11 + 1) / 2;
      const yy2 = (m22 + 1) / 2;
      const zz = (m33 + 1) / 2;
      const xy2 = (m12 + m21) / 4;
      const xz = (m13 + m31) / 4;
      const yz = (m23 + m32) / 4;
      if (xx2 > yy2 && xx2 > zz) {
        if (xx2 < epsilon) {
          x2 = 0;
          y2 = 0.707106781;
          z2 = 0.707106781;
        } else {
          x2 = Math.sqrt(xx2);
          y2 = xy2 / x2;
          z2 = xz / x2;
        }
      } else if (yy2 > zz) {
        if (yy2 < epsilon) {
          x2 = 0.707106781;
          y2 = 0;
          z2 = 0.707106781;
        } else {
          y2 = Math.sqrt(yy2);
          x2 = xy2 / y2;
          z2 = yz / y2;
        }
      } else {
        if (zz < epsilon) {
          x2 = 0.707106781;
          y2 = 0.707106781;
          z2 = 0;
        } else {
          z2 = Math.sqrt(zz);
          x2 = xz / z2;
          y2 = yz / z2;
        }
      }
      this.set(x2, y2, z2, angle);
      return this;
    }
    let s2 = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
    if (Math.abs(s2) < 1e-3)
      s2 = 1;
    this.x = (m32 - m23) / s2;
    this.y = (m13 - m31) / s2;
    this.z = (m21 - m12) / s2;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  }
  min(v2) {
    this.x = Math.min(this.x, v2.x);
    this.y = Math.min(this.y, v2.y);
    this.z = Math.min(this.z, v2.z);
    this.w = Math.min(this.w, v2.w);
    return this;
  }
  max(v2) {
    this.x = Math.max(this.x, v2.x);
    this.y = Math.max(this.y, v2.y);
    this.z = Math.max(this.z, v2.z);
    this.w = Math.max(this.w, v2.w);
    return this;
  }
  clamp(min2, max2) {
    this.x = Math.max(min2.x, Math.min(max2.x, this.x));
    this.y = Math.max(min2.y, Math.min(max2.y, this.y));
    this.z = Math.max(min2.z, Math.min(max2.z, this.z));
    this.w = Math.max(min2.w, Math.min(max2.w, this.w));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    this.w = Math.max(minVal, Math.min(maxVal, this.w));
    return this;
  }
  clampLength(min2, max2) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min2, Math.min(max2, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }
  dot(v2) {
    return this.x * v2.x + this.y * v2.y + this.z * v2.z + this.w * v2.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v2, alpha) {
    this.x += (v2.x - this.x) * alpha;
    this.y += (v2.y - this.y) * alpha;
    this.z += (v2.z - this.z) * alpha;
    this.w += (v2.w - this.w) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    this.w = v1.w + (v2.w - v1.w) * alpha;
    return this;
  }
  equals(v2) {
    return v2.x === this.x && v2.y === this.y && v2.z === this.z && v2.w === this.w;
  }
  fromArray(array, offset2 = 0) {
    this.x = array[offset2];
    this.y = array[offset2 + 1];
    this.z = array[offset2 + 2];
    this.w = array[offset2 + 3];
    return this;
  }
  toArray(array = [], offset2 = 0) {
    array[offset2] = this.x;
    array[offset2 + 1] = this.y;
    array[offset2 + 2] = this.z;
    array[offset2 + 3] = this.w;
    return array;
  }
  fromBufferAttribute(attribute, index, offset2) {
    if (offset2 !== void 0) {
      console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    this.w = attribute.getW(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    this.w = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
    yield this.w;
  }
}
Vector4.prototype.isVector4 = true;
class WebGLRenderTarget extends EventDispatcher {
  constructor(width, height, options = {}) {
    super();
    this.width = width;
    this.height = height;
    this.depth = 1;
    this.scissor = new Vector4(0, 0, width, height);
    this.scissorTest = false;
    this.viewport = new Vector4(0, 0, width, height);
    this.texture = new Texture(void 0, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
    this.texture.isRenderTargetTexture = true;
    this.texture.image = { width, height, depth: 1 };
    this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
    this.texture.internalFormat = options.internalFormat !== void 0 ? options.internalFormat : null;
    this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
    this.depthBuffer = options.depthBuffer !== void 0 ? options.depthBuffer : true;
    this.stencilBuffer = options.stencilBuffer !== void 0 ? options.stencilBuffer : false;
    this.depthTexture = options.depthTexture !== void 0 ? options.depthTexture : null;
  }
  setTexture(texture) {
    texture.image = {
      width: this.width,
      height: this.height,
      depth: this.depth
    };
    this.texture = texture;
  }
  setSize(width, height, depth = 1) {
    if (this.width !== width || this.height !== height || this.depth !== depth) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      this.texture.image.width = width;
      this.texture.image.height = height;
      this.texture.image.depth = depth;
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source3) {
    this.width = source3.width;
    this.height = source3.height;
    this.depth = source3.depth;
    this.viewport.copy(source3.viewport);
    this.texture = source3.texture.clone();
    this.texture.image = __spreadValues({}, this.texture.image);
    this.depthBuffer = source3.depthBuffer;
    this.stencilBuffer = source3.stencilBuffer;
    this.depthTexture = source3.depthTexture;
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
WebGLRenderTarget.prototype.isWebGLRenderTarget = true;
class WebGLMultipleRenderTargets extends WebGLRenderTarget {
  constructor(width, height, count) {
    super(width, height);
    const texture = this.texture;
    this.texture = [];
    for (let i2 = 0; i2 < count; i2++) {
      this.texture[i2] = texture.clone();
    }
  }
  setSize(width, height, depth = 1) {
    if (this.width !== width || this.height !== height || this.depth !== depth) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      for (let i2 = 0, il2 = this.texture.length; i2 < il2; i2++) {
        this.texture[i2].image.width = width;
        this.texture[i2].image.height = height;
        this.texture[i2].image.depth = depth;
      }
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
    return this;
  }
  copy(source3) {
    this.dispose();
    this.width = source3.width;
    this.height = source3.height;
    this.depth = source3.depth;
    this.viewport.set(0, 0, this.width, this.height);
    this.scissor.set(0, 0, this.width, this.height);
    this.depthBuffer = source3.depthBuffer;
    this.stencilBuffer = source3.stencilBuffer;
    this.depthTexture = source3.depthTexture;
    this.texture.length = 0;
    for (let i2 = 0, il2 = source3.texture.length; i2 < il2; i2++) {
      this.texture[i2] = source3.texture[i2].clone();
    }
    return this;
  }
}
WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true;
class WebGLMultisampleRenderTarget extends WebGLRenderTarget {
  constructor(width, height, options) {
    super(width, height, options);
    this.samples = 4;
  }
  copy(source3) {
    super.copy.call(this, source3);
    this.samples = source3.samples;
    return this;
  }
}
WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;
class Quaternion {
  constructor(x2 = 0, y2 = 0, z2 = 0, w2 = 1) {
    this._x = x2;
    this._y = y2;
    this._z = z2;
    this._w = w2;
  }
  static slerp(qa2, qb2, qm2, t2) {
    console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.");
    return qm2.slerpQuaternions(qa2, qb2, t2);
  }
  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t2) {
    let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
    if (t2 === 0) {
      dst[dstOffset + 0] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
      return;
    }
    if (t2 === 1) {
      dst[dstOffset + 0] = x1;
      dst[dstOffset + 1] = y1;
      dst[dstOffset + 2] = z1;
      dst[dstOffset + 3] = w1;
      return;
    }
    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s2 = 1 - t2;
      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
      if (sqrSin > Number.EPSILON) {
        const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
        s2 = Math.sin(s2 * len) / sin;
        t2 = Math.sin(t2 * len) / sin;
      }
      const tDir = t2 * dir;
      x0 = x0 * s2 + x1 * tDir;
      y0 = y0 * s2 + y1 * tDir;
      z0 = z0 * s2 + z1 * tDir;
      w0 = w0 * s2 + w1 * tDir;
      if (s2 === 1 - t2) {
        const f2 = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f2;
        y0 *= f2;
        z0 *= f2;
        w0 *= f2;
      }
    }
    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }
  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w1 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(value) {
    this._w = value;
    this._onChangeCallback();
  }
  set(x2, y2, z2, w2) {
    this._x = x2;
    this._y = y2;
    this._z = z2;
    this._w = w2;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this._onChangeCallback();
    return this;
  }
  setFromEuler(euler, update) {
    if (!(euler && euler.isEuler)) {
      throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    }
    const x2 = euler._x, y2 = euler._y, z2 = euler._z, order = euler._order;
    const cos = Math.cos;
    const sin = Math.sin;
    const c1 = cos(x2 / 2);
    const c2 = cos(y2 / 2);
    const c3 = cos(z2 / 2);
    const s1 = sin(x2 / 2);
    const s2 = sin(y2 / 2);
    const s3 = sin(z2 / 2);
    switch (order) {
      case "XYZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "YXZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "ZXY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "ZYX":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "YZX":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "XZY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
    }
    if (update !== false)
      this._onChangeCallback();
    return this;
  }
  setFromAxisAngle(axis, angle) {
    const halfAngle = angle / 2, s2 = Math.sin(halfAngle);
    this._x = axis.x * s2;
    this._y = axis.y * s2;
    this._z = axis.z * s2;
    this._w = Math.cos(halfAngle);
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m2) {
    const te2 = m2.elements, m11 = te2[0], m12 = te2[4], m13 = te2[8], m21 = te2[1], m22 = te2[5], m23 = te2[9], m31 = te2[2], m32 = te2[6], m33 = te2[10], trace = m11 + m22 + m33;
    if (trace > 0) {
      const s2 = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s2;
      this._x = (m32 - m23) * s2;
      this._y = (m13 - m31) * s2;
      this._z = (m21 - m12) * s2;
    } else if (m11 > m22 && m11 > m33) {
      const s2 = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s2;
      this._x = 0.25 * s2;
      this._y = (m12 + m21) / s2;
      this._z = (m13 + m31) / s2;
    } else if (m22 > m33) {
      const s2 = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s2;
      this._x = (m12 + m21) / s2;
      this._y = 0.25 * s2;
      this._z = (m23 + m32) / s2;
    } else {
      const s2 = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s2;
      this._x = (m13 + m31) / s2;
      this._y = (m23 + m32) / s2;
      this._z = 0.25 * s2;
    }
    this._onChangeCallback();
    return this;
  }
  setFromUnitVectors(vFrom, vTo) {
    let r2 = vFrom.dot(vTo) + 1;
    if (r2 < Number.EPSILON) {
      r2 = 0;
      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r2;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r2;
      }
    } else {
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r2;
    }
    return this.normalize();
  }
  angleTo(q2) {
    return 2 * Math.acos(Math.abs(clamp(this.dot(q2), -1, 1)));
  }
  rotateTowards(q2, step) {
    const angle = this.angleTo(q2);
    if (angle === 0)
      return this;
    const t2 = Math.min(1, step / angle);
    this.slerp(q2, t2);
    return this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._onChangeCallback();
    return this;
  }
  dot(v2) {
    return this._x * v2._x + this._y * v2._y + this._z * v2._z + this._w * v2._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let l2 = this.length();
    if (l2 === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l2 = 1 / l2;
      this._x = this._x * l2;
      this._y = this._y * l2;
      this._z = this._z * l2;
      this._w = this._w * l2;
    }
    this._onChangeCallback();
    return this;
  }
  multiply(q2, p2) {
    if (p2 !== void 0) {
      console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
      return this.multiplyQuaternions(q2, p2);
    }
    return this.multiplyQuaternions(this, q2);
  }
  premultiply(q2) {
    return this.multiplyQuaternions(q2, this);
  }
  multiplyQuaternions(a2, b2) {
    const qax = a2._x, qay = a2._y, qaz = a2._z, qaw = a2._w;
    const qbx = b2._x, qby = b2._y, qbz = b2._z, qbw = b2._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this._onChangeCallback();
    return this;
  }
  slerp(qb2, t2) {
    if (t2 === 0)
      return this;
    if (t2 === 1)
      return this.copy(qb2);
    const x2 = this._x, y2 = this._y, z2 = this._z, w2 = this._w;
    let cosHalfTheta = w2 * qb2._w + x2 * qb2._x + y2 * qb2._y + z2 * qb2._z;
    if (cosHalfTheta < 0) {
      this._w = -qb2._w;
      this._x = -qb2._x;
      this._y = -qb2._y;
      this._z = -qb2._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb2);
    }
    if (cosHalfTheta >= 1) {
      this._w = w2;
      this._x = x2;
      this._y = y2;
      this._z = z2;
      return this;
    }
    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s2 = 1 - t2;
      this._w = s2 * w2 + t2 * this._w;
      this._x = s2 * x2 + t2 * this._x;
      this._y = s2 * y2 + t2 * this._y;
      this._z = s2 * z2 + t2 * this._z;
      this.normalize();
      this._onChangeCallback();
      return this;
    }
    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t2) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t2 * halfTheta) / sinHalfTheta;
    this._w = w2 * ratioA + this._w * ratioB;
    this._x = x2 * ratioA + this._x * ratioB;
    this._y = y2 * ratioA + this._y * ratioB;
    this._z = z2 * ratioA + this._z * ratioB;
    this._onChangeCallback();
    return this;
  }
  slerpQuaternions(qa2, qb2, t2) {
    this.copy(qa2).slerp(qb2, t2);
  }
  random() {
    const u1 = Math.random();
    const sqrt1u1 = Math.sqrt(1 - u1);
    const sqrtu1 = Math.sqrt(u1);
    const u2 = 2 * Math.PI * Math.random();
    const u3 = 2 * Math.PI * Math.random();
    return this.set(sqrt1u1 * Math.cos(u2), sqrtu1 * Math.sin(u3), sqrtu1 * Math.cos(u3), sqrt1u1 * Math.sin(u2));
  }
  equals(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  }
  fromArray(array, offset2 = 0) {
    this._x = array[offset2];
    this._y = array[offset2 + 1];
    this._z = array[offset2 + 2];
    this._w = array[offset2 + 3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset2 = 0) {
    array[offset2] = this._x;
    array[offset2 + 1] = this._y;
    array[offset2 + 2] = this._z;
    array[offset2 + 3] = this._w;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this._x = attribute.getX(index);
    this._y = attribute.getY(index);
    this._z = attribute.getZ(index);
    this._w = attribute.getW(index);
    return this;
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
}
Quaternion.prototype.isQuaternion = true;
class Vector3 {
  constructor(x2 = 0, y2 = 0, z2 = 0) {
    this.x = x2;
    this.y = y2;
    this.z = z2;
  }
  set(x2, y2, z2) {
    if (z2 === void 0)
      z2 = this.z;
    this.x = x2;
    this.y = y2;
    this.z = z2;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }
  setX(x2) {
    this.x = x2;
    return this;
  }
  setY(y2) {
    this.y = y2;
    return this;
  }
  setZ(z2) {
    this.z = z2;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(v2) {
    this.x = v2.x;
    this.y = v2.y;
    this.z = v2.z;
    return this;
  }
  add(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v2, w2);
    }
    this.x += v2.x;
    this.y += v2.y;
    this.z += v2.z;
    return this;
  }
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    this.z += s2;
    return this;
  }
  addVectors(a2, b2) {
    this.x = a2.x + b2.x;
    this.y = a2.y + b2.y;
    this.z = a2.z + b2.z;
    return this;
  }
  addScaledVector(v2, s2) {
    this.x += v2.x * s2;
    this.y += v2.y * s2;
    this.z += v2.z * s2;
    return this;
  }
  sub(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v2, w2);
    }
    this.x -= v2.x;
    this.y -= v2.y;
    this.z -= v2.z;
    return this;
  }
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    this.z -= s2;
    return this;
  }
  subVectors(a2, b2) {
    this.x = a2.x - b2.x;
    this.y = a2.y - b2.y;
    this.z = a2.z - b2.z;
    return this;
  }
  multiply(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
      return this.multiplyVectors(v2, w2);
    }
    this.x *= v2.x;
    this.y *= v2.y;
    this.z *= v2.z;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }
  multiplyVectors(a2, b2) {
    this.x = a2.x * b2.x;
    this.y = a2.y * b2.y;
    this.z = a2.z * b2.z;
    return this;
  }
  applyEuler(euler) {
    if (!(euler && euler.isEuler)) {
      console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
    }
    return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
  }
  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
  }
  applyMatrix3(m2) {
    const x2 = this.x, y2 = this.y, z2 = this.z;
    const e20 = m2.elements;
    this.x = e20[0] * x2 + e20[3] * y2 + e20[6] * z2;
    this.y = e20[1] * x2 + e20[4] * y2 + e20[7] * z2;
    this.z = e20[2] * x2 + e20[5] * y2 + e20[8] * z2;
    return this;
  }
  applyNormalMatrix(m2) {
    return this.applyMatrix3(m2).normalize();
  }
  applyMatrix4(m2) {
    const x2 = this.x, y2 = this.y, z2 = this.z;
    const e20 = m2.elements;
    const w2 = 1 / (e20[3] * x2 + e20[7] * y2 + e20[11] * z2 + e20[15]);
    this.x = (e20[0] * x2 + e20[4] * y2 + e20[8] * z2 + e20[12]) * w2;
    this.y = (e20[1] * x2 + e20[5] * y2 + e20[9] * z2 + e20[13]) * w2;
    this.z = (e20[2] * x2 + e20[6] * y2 + e20[10] * z2 + e20[14]) * w2;
    return this;
  }
  applyQuaternion(q2) {
    const x2 = this.x, y2 = this.y, z2 = this.z;
    const qx2 = q2.x, qy2 = q2.y, qz = q2.z, qw2 = q2.w;
    const ix2 = qw2 * x2 + qy2 * z2 - qz * y2;
    const iy2 = qw2 * y2 + qz * x2 - qx2 * z2;
    const iz = qw2 * z2 + qx2 * y2 - qy2 * x2;
    const iw2 = -qx2 * x2 - qy2 * y2 - qz * z2;
    this.x = ix2 * qw2 + iw2 * -qx2 + iy2 * -qz - iz * -qy2;
    this.y = iy2 * qw2 + iw2 * -qy2 + iz * -qx2 - ix2 * -qz;
    this.z = iz * qw2 + iw2 * -qz + ix2 * -qy2 - iy2 * -qx2;
    return this;
  }
  project(camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  }
  unproject(camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
  }
  transformDirection(m2) {
    const x2 = this.x, y2 = this.y, z2 = this.z;
    const e20 = m2.elements;
    this.x = e20[0] * x2 + e20[4] * y2 + e20[8] * z2;
    this.y = e20[1] * x2 + e20[5] * y2 + e20[9] * z2;
    this.z = e20[2] * x2 + e20[6] * y2 + e20[10] * z2;
    return this.normalize();
  }
  divide(v2) {
    this.x /= v2.x;
    this.y /= v2.y;
    this.z /= v2.z;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  min(v2) {
    this.x = Math.min(this.x, v2.x);
    this.y = Math.min(this.y, v2.y);
    this.z = Math.min(this.z, v2.z);
    return this;
  }
  max(v2) {
    this.x = Math.max(this.x, v2.x);
    this.y = Math.max(this.y, v2.y);
    this.z = Math.max(this.z, v2.z);
    return this;
  }
  clamp(min2, max2) {
    this.x = Math.max(min2.x, Math.min(max2.x, this.x));
    this.y = Math.max(min2.y, Math.min(max2.y, this.y));
    this.z = Math.max(min2.z, Math.min(max2.z, this.z));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  }
  clampLength(min2, max2) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min2, Math.min(max2, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  dot(v2) {
    return this.x * v2.x + this.y * v2.y + this.z * v2.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v2, alpha) {
    this.x += (v2.x - this.x) * alpha;
    this.y += (v2.y - this.y) * alpha;
    this.z += (v2.z - this.z) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    return this;
  }
  cross(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
      return this.crossVectors(v2, w2);
    }
    return this.crossVectors(this, v2);
  }
  crossVectors(a2, b2) {
    const ax2 = a2.x, ay2 = a2.y, az = a2.z;
    const bx2 = b2.x, by2 = b2.y, bz = b2.z;
    this.x = ay2 * bz - az * by2;
    this.y = az * bx2 - ax2 * bz;
    this.z = ax2 * by2 - ay2 * bx2;
    return this;
  }
  projectOnVector(v2) {
    const denominator = v2.lengthSq();
    if (denominator === 0)
      return this.set(0, 0, 0);
    const scalar = v2.dot(this) / denominator;
    return this.copy(v2).multiplyScalar(scalar);
  }
  projectOnPlane(planeNormal) {
    _vector$c.copy(this).projectOnVector(planeNormal);
    return this.sub(_vector$c);
  }
  reflect(normal) {
    return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
  }
  angleTo(v2) {
    const denominator = Math.sqrt(this.lengthSq() * v2.lengthSq());
    if (denominator === 0)
      return Math.PI / 2;
    const theta = this.dot(v2) / denominator;
    return Math.acos(clamp(theta, -1, 1));
  }
  distanceTo(v2) {
    return Math.sqrt(this.distanceToSquared(v2));
  }
  distanceToSquared(v2) {
    const dx2 = this.x - v2.x, dy2 = this.y - v2.y, dz = this.z - v2.z;
    return dx2 * dx2 + dy2 * dy2 + dz * dz;
  }
  manhattanDistanceTo(v2) {
    return Math.abs(this.x - v2.x) + Math.abs(this.y - v2.y) + Math.abs(this.z - v2.z);
  }
  setFromSpherical(s2) {
    return this.setFromSphericalCoords(s2.radius, s2.phi, s2.theta);
  }
  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }
  setFromCylindrical(c2) {
    return this.setFromCylindricalCoords(c2.radius, c2.theta, c2.y);
  }
  setFromCylindricalCoords(radius, theta, y2) {
    this.x = radius * Math.sin(theta);
    this.y = y2;
    this.z = radius * Math.cos(theta);
    return this;
  }
  setFromMatrixPosition(m2) {
    const e20 = m2.elements;
    this.x = e20[12];
    this.y = e20[13];
    this.z = e20[14];
    return this;
  }
  setFromMatrixScale(m2) {
    const sx2 = this.setFromMatrixColumn(m2, 0).length();
    const sy2 = this.setFromMatrixColumn(m2, 1).length();
    const sz = this.setFromMatrixColumn(m2, 2).length();
    this.x = sx2;
    this.y = sy2;
    this.z = sz;
    return this;
  }
  setFromMatrixColumn(m2, index) {
    return this.fromArray(m2.elements, index * 4);
  }
  setFromMatrix3Column(m2, index) {
    return this.fromArray(m2.elements, index * 3);
  }
  equals(v2) {
    return v2.x === this.x && v2.y === this.y && v2.z === this.z;
  }
  fromArray(array, offset2 = 0) {
    this.x = array[offset2];
    this.y = array[offset2 + 1];
    this.z = array[offset2 + 2];
    return this;
  }
  toArray(array = [], offset2 = 0) {
    array[offset2] = this.x;
    array[offset2 + 1] = this.y;
    array[offset2 + 2] = this.z;
    return array;
  }
  fromBufferAttribute(attribute, index, offset2) {
    if (offset2 !== void 0) {
      console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }
  randomDirection() {
    const u2 = (Math.random() - 0.5) * 2;
    const t2 = Math.random() * Math.PI * 2;
    const f2 = Math.sqrt(1 - u2 ** 2);
    this.x = f2 * Math.cos(t2);
    this.y = f2 * Math.sin(t2);
    this.z = u2;
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
  }
}
Vector3.prototype.isVector3 = true;
const _vector$c = /* @__PURE__ */ new Vector3();
const _quaternion$4 = /* @__PURE__ */ new Quaternion();
class Box3 {
  constructor(min2 = new Vector3(Infinity, Infinity, Infinity), max2 = new Vector3(-Infinity, -Infinity, -Infinity)) {
    this.min = min2;
    this.max = max2;
  }
  set(min2, max2) {
    this.min.copy(min2);
    this.max.copy(max2);
    return this;
  }
  setFromArray(array) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    for (let i2 = 0, l2 = array.length; i2 < l2; i2 += 3) {
      const x2 = array[i2];
      const y2 = array[i2 + 1];
      const z2 = array[i2 + 2];
      if (x2 < minX)
        minX = x2;
      if (y2 < minY)
        minY = y2;
      if (z2 < minZ)
        minZ = z2;
      if (x2 > maxX)
        maxX = x2;
      if (y2 > maxY)
        maxY = y2;
      if (z2 > maxZ)
        maxZ = z2;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  }
  setFromBufferAttribute(attribute) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    for (let i2 = 0, l2 = attribute.count; i2 < l2; i2++) {
      const x2 = attribute.getX(i2);
      const y2 = attribute.getY(i2);
      const z2 = attribute.getZ(i2);
      if (x2 < minX)
        minX = x2;
      if (y2 < minY)
        minY = y2;
      if (z2 < minZ)
        minZ = z2;
      if (x2 > maxX)
        maxX = x2;
      if (y2 > maxY)
        maxY = y2;
      if (z2 > maxZ)
        maxZ = z2;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i2 = 0, il2 = points.length; i2 < il2; i2++) {
      this.expandByPoint(points[i2]);
    }
    return this;
  }
  setFromCenterAndSize(center, size) {
    const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  setFromObject(object) {
    this.makeEmpty();
    return this.expandByObject(object);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  }
  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  expandByObject(object) {
    object.updateWorldMatrix(false, false);
    const geometry2 = object.geometry;
    if (geometry2 !== void 0) {
      if (geometry2.boundingBox === null) {
        geometry2.computeBoundingBox();
      }
      _box$3.copy(geometry2.boundingBox);
      _box$3.applyMatrix4(object.matrixWorld);
      this.union(_box$3);
    }
    const children = object.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      this.expandByObject(children[i2]);
    }
    return this;
  }
  containsPoint(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
  }
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  }
  getParameter(point, target) {
    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
  }
  intersectsBox(box) {
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
  }
  intersectsSphere(sphere) {
    this.clampPoint(sphere.center, _vector$b);
    return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  }
  intersectsPlane(plane) {
    let min2, max2;
    if (plane.normal.x > 0) {
      min2 = plane.normal.x * this.min.x;
      max2 = plane.normal.x * this.max.x;
    } else {
      min2 = plane.normal.x * this.max.x;
      max2 = plane.normal.x * this.min.x;
    }
    if (plane.normal.y > 0) {
      min2 += plane.normal.y * this.min.y;
      max2 += plane.normal.y * this.max.y;
    } else {
      min2 += plane.normal.y * this.max.y;
      max2 += plane.normal.y * this.min.y;
    }
    if (plane.normal.z > 0) {
      min2 += plane.normal.z * this.min.z;
      max2 += plane.normal.z * this.max.z;
    } else {
      min2 += plane.normal.z * this.max.z;
      max2 += plane.normal.z * this.min.z;
    }
    return min2 <= -plane.constant && max2 >= -plane.constant;
  }
  intersectsTriangle(triangle) {
    if (this.isEmpty()) {
      return false;
    }
    this.getCenter(_center);
    _extents.subVectors(this.max, _center);
    _v0$2.subVectors(triangle.a, _center);
    _v1$7.subVectors(triangle.b, _center);
    _v2$3.subVectors(triangle.c, _center);
    _f0.subVectors(_v1$7, _v0$2);
    _f1.subVectors(_v2$3, _v1$7);
    _f2.subVectors(_v0$2, _v2$3);
    let axes = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0
    ];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
      return false;
    }
    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
      return false;
    }
    _triangleNormal.crossVectors(_f0, _f1);
    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);
  }
  clampPoint(point, target) {
    return target.copy(point).clamp(this.min, this.max);
  }
  distanceToPoint(point) {
    const clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);
    return clampedPoint.sub(point).length();
  }
  getBoundingSphere(target) {
    this.getCenter(target.center);
    target.radius = this.getSize(_vector$b).length() * 0.5;
    return target;
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    if (this.isEmpty())
      this.makeEmpty();
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  applyMatrix4(matrix) {
    if (this.isEmpty())
      return this;
    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
    this.setFromPoints(_points);
    return this;
  }
  translate(offset2) {
    this.min.add(offset2);
    this.max.add(offset2);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
}
Box3.prototype.isBox3 = true;
const _points = [
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3()
];
const _vector$b = /* @__PURE__ */ new Vector3();
const _box$3 = /* @__PURE__ */ new Box3();
const _v0$2 = /* @__PURE__ */ new Vector3();
const _v1$7 = /* @__PURE__ */ new Vector3();
const _v2$3 = /* @__PURE__ */ new Vector3();
const _f0 = /* @__PURE__ */ new Vector3();
const _f1 = /* @__PURE__ */ new Vector3();
const _f2 = /* @__PURE__ */ new Vector3();
const _center = /* @__PURE__ */ new Vector3();
const _extents = /* @__PURE__ */ new Vector3();
const _triangleNormal = /* @__PURE__ */ new Vector3();
const _testAxis = /* @__PURE__ */ new Vector3();
function satForAxes(axes, v0, v1, v2, extents) {
  for (let i2 = 0, j2 = axes.length - 3; i2 <= j2; i2 += 3) {
    _testAxis.fromArray(axes, i2);
    const r2 = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
    const p0 = v0.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p2 = v2.dot(_testAxis);
    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r2) {
      return false;
    }
  }
  return true;
}
const _box$2 = /* @__PURE__ */ new Box3();
const _v1$6 = /* @__PURE__ */ new Vector3();
const _toFarthestPoint = /* @__PURE__ */ new Vector3();
const _toPoint = /* @__PURE__ */ new Vector3();
class Sphere {
  constructor(center = new Vector3(), radius = -1) {
    this.center = center;
    this.radius = radius;
  }
  set(center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  }
  setFromPoints(points, optionalCenter) {
    const center = this.center;
    if (optionalCenter !== void 0) {
      center.copy(optionalCenter);
    } else {
      _box$2.setFromPoints(points).getCenter(center);
    }
    let maxRadiusSq = 0;
    for (let i2 = 0, il2 = points.length; i2 < il2; i2++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i2]));
    }
    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  }
  copy(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  }
  containsPoint(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(point) {
    return point.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(sphere) {
    const radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  }
  intersectsBox(box) {
    return box.intersectsSphere(this);
  }
  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(point, target) {
    const deltaLengthSq = this.center.distanceToSquared(point);
    target.copy(point);
    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }
    return target;
  }
  getBoundingBox(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
      return target;
    }
    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  }
  applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  }
  translate(offset2) {
    this.center.add(offset2);
    return this;
  }
  expandByPoint(point) {
    _toPoint.subVectors(point, this.center);
    const lengthSq = _toPoint.lengthSq();
    if (lengthSq > this.radius * this.radius) {
      const length = Math.sqrt(lengthSq);
      const missingRadiusHalf = (length - this.radius) * 0.5;
      this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));
      this.radius += missingRadiusHalf;
    }
    return this;
  }
  union(sphere) {
    _toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);
    this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));
    this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));
    return this;
  }
  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _vector$a = /* @__PURE__ */ new Vector3();
const _segCenter = /* @__PURE__ */ new Vector3();
const _segDir = /* @__PURE__ */ new Vector3();
const _diff = /* @__PURE__ */ new Vector3();
const _edge1 = /* @__PURE__ */ new Vector3();
const _edge2 = /* @__PURE__ */ new Vector3();
const _normal$1 = /* @__PURE__ */ new Vector3();
class Ray {
  constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
    this.origin = origin;
    this.direction = direction;
  }
  set(origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  }
  copy(ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  }
  at(t2, target) {
    return target.copy(this.direction).multiplyScalar(t2).add(this.origin);
  }
  lookAt(v2) {
    this.direction.copy(v2).sub(this.origin).normalize();
    return this;
  }
  recast(t2) {
    this.origin.copy(this.at(t2, _vector$a));
    return this;
  }
  closestPointToPoint(point, target) {
    target.subVectors(point, this.origin);
    const directionDistance = target.dot(this.direction);
    if (directionDistance < 0) {
      return target.copy(this.origin);
    }
    return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
  }
  distanceToPoint(point) {
    return Math.sqrt(this.distanceSqToPoint(point));
  }
  distanceSqToPoint(point) {
    const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
    if (directionDistance < 0) {
      return this.origin.distanceToSquared(point);
    }
    _vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    return _vector$a.distanceToSquared(point);
  }
  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
    _segDir.copy(v1).sub(v0).normalize();
    _diff.copy(this.origin).sub(_segCenter);
    const segExtent = v0.distanceTo(v1) * 0.5;
    const a01 = -this.direction.dot(_segDir);
    const b0 = _diff.dot(this.direction);
    const b1 = -_diff.dot(_segDir);
    const c2 = _diff.lengthSq();
    const det = Math.abs(1 - a01 * a01);
    let s0, s1, sqrDist, extDet;
    if (det > 0) {
      s0 = a01 * b1 - b0;
      s1 = a01 * b0 - b1;
      extDet = segExtent * det;
      if (s0 >= 0) {
        if (s1 >= -extDet) {
          if (s1 <= extDet) {
            const invDet = 1 / det;
            s0 *= invDet;
            s1 *= invDet;
            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c2;
          } else {
            s1 = segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
          }
        } else {
          s1 = -segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
        }
      } else {
        if (s1 <= -extDet) {
          s0 = Math.max(0, -(-a01 * segExtent + b0));
          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
        } else if (s1 <= extDet) {
          s0 = 0;
          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = s1 * (s1 + 2 * b1) + c2;
        } else {
          s0 = Math.max(0, -(a01 * segExtent + b0));
          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
        }
      }
    } else {
      s1 = a01 > 0 ? -segExtent : segExtent;
      s0 = Math.max(0, -(a01 * s1 + b0));
      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
    }
    if (optionalPointOnRay) {
      optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
    }
    if (optionalPointOnSegment) {
      optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
    }
    return sqrDist;
  }
  intersectSphere(sphere, target) {
    _vector$a.subVectors(sphere.center, this.origin);
    const tca = _vector$a.dot(this.direction);
    const d2 = _vector$a.dot(_vector$a) - tca * tca;
    const radius2 = sphere.radius * sphere.radius;
    if (d2 > radius2)
      return null;
    const thc = Math.sqrt(radius2 - d2);
    const t0 = tca - thc;
    const t1 = tca + thc;
    if (t0 < 0 && t1 < 0)
      return null;
    if (t0 < 0)
      return this.at(t1, target);
    return this.at(t0, target);
  }
  intersectsSphere(sphere) {
    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
  }
  distanceToPlane(plane) {
    const denominator = plane.normal.dot(this.direction);
    if (denominator === 0) {
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      }
      return null;
    }
    const t2 = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
    return t2 >= 0 ? t2 : null;
  }
  intersectPlane(plane, target) {
    const t2 = this.distanceToPlane(plane);
    if (t2 === null) {
      return null;
    }
    return this.at(t2, target);
  }
  intersectsPlane(plane) {
    const distToPoint = plane.distanceToPoint(this.origin);
    if (distToPoint === 0) {
      return true;
    }
    const denominator = plane.normal.dot(this.direction);
    if (denominator * distToPoint < 0) {
      return true;
    }
    return false;
  }
  intersectBox(box, target) {
    let tmin, tmax, tymin, tymax, tzmin, tzmax;
    const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
    const origin = this.origin;
    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }
    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }
    if (tmin > tymax || tymin > tmax)
      return null;
    if (tymin > tmin || tmin !== tmin)
      tmin = tymin;
    if (tymax < tmax || tmax !== tmax)
      tmax = tymax;
    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }
    if (tmin > tzmax || tzmin > tmax)
      return null;
    if (tzmin > tmin || tmin !== tmin)
      tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax)
      tmax = tzmax;
    if (tmax < 0)
      return null;
    return this.at(tmin >= 0 ? tmin : tmax, target);
  }
  intersectsBox(box) {
    return this.intersectBox(box, _vector$a) !== null;
  }
  intersectTriangle(a2, b2, c2, backfaceCulling, target) {
    _edge1.subVectors(b2, a2);
    _edge2.subVectors(c2, a2);
    _normal$1.crossVectors(_edge1, _edge2);
    let DdN = this.direction.dot(_normal$1);
    let sign2;
    if (DdN > 0) {
      if (backfaceCulling)
        return null;
      sign2 = 1;
    } else if (DdN < 0) {
      sign2 = -1;
      DdN = -DdN;
    } else {
      return null;
    }
    _diff.subVectors(this.origin, a2);
    const DdQxE2 = sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (DdQxE2 < 0) {
      return null;
    }
    const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));
    if (DdE1xQ < 0) {
      return null;
    }
    if (DdQxE2 + DdE1xQ > DdN) {
      return null;
    }
    const QdN = -sign2 * _diff.dot(_normal$1);
    if (QdN < 0) {
      return null;
    }
    return this.at(QdN / DdN, target);
  }
  applyMatrix4(matrix4) {
    this.origin.applyMatrix4(matrix4);
    this.direction.transformDirection(matrix4);
    return this;
  }
  equals(ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Matrix4 {
  constructor() {
    this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    if (arguments.length > 0) {
      console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
    }
  }
  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te2 = this.elements;
    te2[0] = n11;
    te2[4] = n12;
    te2[8] = n13;
    te2[12] = n14;
    te2[1] = n21;
    te2[5] = n22;
    te2[9] = n23;
    te2[13] = n24;
    te2[2] = n31;
    te2[6] = n32;
    te2[10] = n33;
    te2[14] = n34;
    te2[3] = n41;
    te2[7] = n42;
    te2[11] = n43;
    te2[15] = n44;
    return this;
  }
  identity() {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }
  clone() {
    return new Matrix4().fromArray(this.elements);
  }
  copy(m2) {
    const te2 = this.elements;
    const me2 = m2.elements;
    te2[0] = me2[0];
    te2[1] = me2[1];
    te2[2] = me2[2];
    te2[3] = me2[3];
    te2[4] = me2[4];
    te2[5] = me2[5];
    te2[6] = me2[6];
    te2[7] = me2[7];
    te2[8] = me2[8];
    te2[9] = me2[9];
    te2[10] = me2[10];
    te2[11] = me2[11];
    te2[12] = me2[12];
    te2[13] = me2[13];
    te2[14] = me2[14];
    te2[15] = me2[15];
    return this;
  }
  copyPosition(m2) {
    const te2 = this.elements, me2 = m2.elements;
    te2[12] = me2[12];
    te2[13] = me2[13];
    te2[14] = me2[14];
    return this;
  }
  setFromMatrix3(m2) {
    const me2 = m2.elements;
    this.set(me2[0], me2[3], me2[6], 0, me2[1], me2[4], me2[7], 0, me2[2], me2[5], me2[8], 0, 0, 0, 0, 1);
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }
  makeBasis(xAxis, yAxis, zAxis) {
    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
    return this;
  }
  extractRotation(m2) {
    const te2 = this.elements;
    const me2 = m2.elements;
    const scaleX = 1 / _v1$5.setFromMatrixColumn(m2, 0).length();
    const scaleY = 1 / _v1$5.setFromMatrixColumn(m2, 1).length();
    const scaleZ = 1 / _v1$5.setFromMatrixColumn(m2, 2).length();
    te2[0] = me2[0] * scaleX;
    te2[1] = me2[1] * scaleX;
    te2[2] = me2[2] * scaleX;
    te2[3] = 0;
    te2[4] = me2[4] * scaleY;
    te2[5] = me2[5] * scaleY;
    te2[6] = me2[6] * scaleY;
    te2[7] = 0;
    te2[8] = me2[8] * scaleZ;
    te2[9] = me2[9] * scaleZ;
    te2[10] = me2[10] * scaleZ;
    te2[11] = 0;
    te2[12] = 0;
    te2[13] = 0;
    te2[14] = 0;
    te2[15] = 1;
    return this;
  }
  makeRotationFromEuler(euler) {
    if (!(euler && euler.isEuler)) {
      console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
    }
    const te2 = this.elements;
    const x2 = euler.x, y2 = euler.y, z2 = euler.z;
    const a2 = Math.cos(x2), b2 = Math.sin(x2);
    const c2 = Math.cos(y2), d2 = Math.sin(y2);
    const e20 = Math.cos(z2), f2 = Math.sin(z2);
    if (euler.order === "XYZ") {
      const ae2 = a2 * e20, af2 = a2 * f2, be2 = b2 * e20, bf2 = b2 * f2;
      te2[0] = c2 * e20;
      te2[4] = -c2 * f2;
      te2[8] = d2;
      te2[1] = af2 + be2 * d2;
      te2[5] = ae2 - bf2 * d2;
      te2[9] = -b2 * c2;
      te2[2] = bf2 - ae2 * d2;
      te2[6] = be2 + af2 * d2;
      te2[10] = a2 * c2;
    } else if (euler.order === "YXZ") {
      const ce2 = c2 * e20, cf2 = c2 * f2, de2 = d2 * e20, df2 = d2 * f2;
      te2[0] = ce2 + df2 * b2;
      te2[4] = de2 * b2 - cf2;
      te2[8] = a2 * d2;
      te2[1] = a2 * f2;
      te2[5] = a2 * e20;
      te2[9] = -b2;
      te2[2] = cf2 * b2 - de2;
      te2[6] = df2 + ce2 * b2;
      te2[10] = a2 * c2;
    } else if (euler.order === "ZXY") {
      const ce2 = c2 * e20, cf2 = c2 * f2, de2 = d2 * e20, df2 = d2 * f2;
      te2[0] = ce2 - df2 * b2;
      te2[4] = -a2 * f2;
      te2[8] = de2 + cf2 * b2;
      te2[1] = cf2 + de2 * b2;
      te2[5] = a2 * e20;
      te2[9] = df2 - ce2 * b2;
      te2[2] = -a2 * d2;
      te2[6] = b2;
      te2[10] = a2 * c2;
    } else if (euler.order === "ZYX") {
      const ae2 = a2 * e20, af2 = a2 * f2, be2 = b2 * e20, bf2 = b2 * f2;
      te2[0] = c2 * e20;
      te2[4] = be2 * d2 - af2;
      te2[8] = ae2 * d2 + bf2;
      te2[1] = c2 * f2;
      te2[5] = bf2 * d2 + ae2;
      te2[9] = af2 * d2 - be2;
      te2[2] = -d2;
      te2[6] = b2 * c2;
      te2[10] = a2 * c2;
    } else if (euler.order === "YZX") {
      const ac2 = a2 * c2, ad2 = a2 * d2, bc2 = b2 * c2, bd2 = b2 * d2;
      te2[0] = c2 * e20;
      te2[4] = bd2 - ac2 * f2;
      te2[8] = bc2 * f2 + ad2;
      te2[1] = f2;
      te2[5] = a2 * e20;
      te2[9] = -b2 * e20;
      te2[2] = -d2 * e20;
      te2[6] = ad2 * f2 + bc2;
      te2[10] = ac2 - bd2 * f2;
    } else if (euler.order === "XZY") {
      const ac2 = a2 * c2, ad2 = a2 * d2, bc2 = b2 * c2, bd2 = b2 * d2;
      te2[0] = c2 * e20;
      te2[4] = -f2;
      te2[8] = d2 * e20;
      te2[1] = ac2 * f2 + bd2;
      te2[5] = a2 * e20;
      te2[9] = ad2 * f2 - bc2;
      te2[2] = bc2 * f2 - ad2;
      te2[6] = b2 * e20;
      te2[10] = bd2 * f2 + ac2;
    }
    te2[3] = 0;
    te2[7] = 0;
    te2[11] = 0;
    te2[12] = 0;
    te2[13] = 0;
    te2[14] = 0;
    te2[15] = 1;
    return this;
  }
  makeRotationFromQuaternion(q2) {
    return this.compose(_zero, q2, _one);
  }
  lookAt(eye, target, up2) {
    const te2 = this.elements;
    _z.subVectors(eye, target);
    if (_z.lengthSq() === 0) {
      _z.z = 1;
    }
    _z.normalize();
    _x.crossVectors(up2, _z);
    if (_x.lengthSq() === 0) {
      if (Math.abs(up2.z) === 1) {
        _z.x += 1e-4;
      } else {
        _z.z += 1e-4;
      }
      _z.normalize();
      _x.crossVectors(up2, _z);
    }
    _x.normalize();
    _y.crossVectors(_z, _x);
    te2[0] = _x.x;
    te2[4] = _y.x;
    te2[8] = _z.x;
    te2[1] = _x.y;
    te2[5] = _y.y;
    te2[9] = _z.y;
    te2[2] = _x.z;
    te2[6] = _y.z;
    te2[10] = _z.z;
    return this;
  }
  multiply(m2, n2) {
    if (n2 !== void 0) {
      console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
      return this.multiplyMatrices(m2, n2);
    }
    return this.multiplyMatrices(this, m2);
  }
  premultiply(m2) {
    return this.multiplyMatrices(m2, this);
  }
  multiplyMatrices(a2, b2) {
    const ae2 = a2.elements;
    const be2 = b2.elements;
    const te2 = this.elements;
    const a11 = ae2[0], a12 = ae2[4], a13 = ae2[8], a14 = ae2[12];
    const a21 = ae2[1], a22 = ae2[5], a23 = ae2[9], a24 = ae2[13];
    const a31 = ae2[2], a32 = ae2[6], a33 = ae2[10], a34 = ae2[14];
    const a41 = ae2[3], a42 = ae2[7], a43 = ae2[11], a44 = ae2[15];
    const b11 = be2[0], b12 = be2[4], b13 = be2[8], b14 = be2[12];
    const b21 = be2[1], b22 = be2[5], b23 = be2[9], b24 = be2[13];
    const b31 = be2[2], b32 = be2[6], b33 = be2[10], b34 = be2[14];
    const b41 = be2[3], b42 = be2[7], b43 = be2[11], b44 = be2[15];
    te2[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te2[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te2[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te2[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te2[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te2[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te2[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te2[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te2[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te2[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te2[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te2[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te2[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te2[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te2[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te2[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }
  multiplyScalar(s2) {
    const te2 = this.elements;
    te2[0] *= s2;
    te2[4] *= s2;
    te2[8] *= s2;
    te2[12] *= s2;
    te2[1] *= s2;
    te2[5] *= s2;
    te2[9] *= s2;
    te2[13] *= s2;
    te2[2] *= s2;
    te2[6] *= s2;
    te2[10] *= s2;
    te2[14] *= s2;
    te2[3] *= s2;
    te2[7] *= s2;
    te2[11] *= s2;
    te2[15] *= s2;
    return this;
  }
  determinant() {
    const te2 = this.elements;
    const n11 = te2[0], n12 = te2[4], n13 = te2[8], n14 = te2[12];
    const n21 = te2[1], n22 = te2[5], n23 = te2[9], n24 = te2[13];
    const n31 = te2[2], n32 = te2[6], n33 = te2[10], n34 = te2[14];
    const n41 = te2[3], n42 = te2[7], n43 = te2[11], n44 = te2[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }
  transpose() {
    const te2 = this.elements;
    let tmp2;
    tmp2 = te2[1];
    te2[1] = te2[4];
    te2[4] = tmp2;
    tmp2 = te2[2];
    te2[2] = te2[8];
    te2[8] = tmp2;
    tmp2 = te2[6];
    te2[6] = te2[9];
    te2[9] = tmp2;
    tmp2 = te2[3];
    te2[3] = te2[12];
    te2[12] = tmp2;
    tmp2 = te2[7];
    te2[7] = te2[13];
    te2[13] = tmp2;
    tmp2 = te2[11];
    te2[11] = te2[14];
    te2[14] = tmp2;
    return this;
  }
  setPosition(x2, y2, z2) {
    const te2 = this.elements;
    if (x2.isVector3) {
      te2[12] = x2.x;
      te2[13] = x2.y;
      te2[14] = x2.z;
    } else {
      te2[12] = x2;
      te2[13] = y2;
      te2[14] = z2;
    }
    return this;
  }
  invert() {
    const te2 = this.elements, n11 = te2[0], n21 = te2[1], n31 = te2[2], n41 = te2[3], n12 = te2[4], n22 = te2[5], n32 = te2[6], n42 = te2[7], n13 = te2[8], n23 = te2[9], n33 = te2[10], n43 = te2[11], n14 = te2[12], n24 = te2[13], n34 = te2[14], n44 = te2[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te2[0] = t11 * detInv;
    te2[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te2[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te2[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te2[4] = t12 * detInv;
    te2[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te2[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te2[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te2[8] = t13 * detInv;
    te2[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te2[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te2[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te2[12] = t14 * detInv;
    te2[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te2[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te2[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }
  scale(v2) {
    const te2 = this.elements;
    const x2 = v2.x, y2 = v2.y, z2 = v2.z;
    te2[0] *= x2;
    te2[4] *= y2;
    te2[8] *= z2;
    te2[1] *= x2;
    te2[5] *= y2;
    te2[9] *= z2;
    te2[2] *= x2;
    te2[6] *= y2;
    te2[10] *= z2;
    te2[3] *= x2;
    te2[7] *= y2;
    te2[11] *= z2;
    return this;
  }
  getMaxScaleOnAxis() {
    const te2 = this.elements;
    const scaleXSq = te2[0] * te2[0] + te2[1] * te2[1] + te2[2] * te2[2];
    const scaleYSq = te2[4] * te2[4] + te2[5] * te2[5] + te2[6] * te2[6];
    const scaleZSq = te2[8] * te2[8] + te2[9] * te2[9] + te2[10] * te2[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }
  makeTranslation(x2, y2, z2) {
    this.set(1, 0, 0, x2, 0, 1, 0, y2, 0, 0, 1, z2, 0, 0, 0, 1);
    return this;
  }
  makeRotationX(theta) {
    const c2 = Math.cos(theta), s2 = Math.sin(theta);
    this.set(1, 0, 0, 0, 0, c2, -s2, 0, 0, s2, c2, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationY(theta) {
    const c2 = Math.cos(theta), s2 = Math.sin(theta);
    this.set(c2, 0, s2, 0, 0, 1, 0, 0, -s2, 0, c2, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationZ(theta) {
    const c2 = Math.cos(theta), s2 = Math.sin(theta);
    this.set(c2, -s2, 0, 0, s2, c2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationAxis(axis, angle) {
    const c2 = Math.cos(angle);
    const s2 = Math.sin(angle);
    const t2 = 1 - c2;
    const x2 = axis.x, y2 = axis.y, z2 = axis.z;
    const tx2 = t2 * x2, ty2 = t2 * y2;
    this.set(tx2 * x2 + c2, tx2 * y2 - s2 * z2, tx2 * z2 + s2 * y2, 0, tx2 * y2 + s2 * z2, ty2 * y2 + c2, ty2 * z2 - s2 * x2, 0, tx2 * z2 - s2 * y2, ty2 * z2 + s2 * x2, t2 * z2 * z2 + c2, 0, 0, 0, 0, 1);
    return this;
  }
  makeScale(x2, y2, z2) {
    this.set(x2, 0, 0, 0, 0, y2, 0, 0, 0, 0, z2, 0, 0, 0, 0, 1);
    return this;
  }
  makeShear(xy2, xz, yx2, yz, zx2, zy2) {
    this.set(1, yx2, zx2, 0, xy2, 1, zy2, 0, xz, yz, 1, 0, 0, 0, 0, 1);
    return this;
  }
  compose(position, quaternion, scale) {
    const te2 = this.elements;
    const x2 = quaternion._x, y2 = quaternion._y, z2 = quaternion._z, w2 = quaternion._w;
    const x22 = x2 + x2, y22 = y2 + y2, z22 = z2 + z2;
    const xx2 = x2 * x22, xy2 = x2 * y22, xz = x2 * z22;
    const yy2 = y2 * y22, yz = y2 * z22, zz = z2 * z22;
    const wx2 = w2 * x22, wy2 = w2 * y22, wz = w2 * z22;
    const sx2 = scale.x, sy2 = scale.y, sz = scale.z;
    te2[0] = (1 - (yy2 + zz)) * sx2;
    te2[1] = (xy2 + wz) * sx2;
    te2[2] = (xz - wy2) * sx2;
    te2[3] = 0;
    te2[4] = (xy2 - wz) * sy2;
    te2[5] = (1 - (xx2 + zz)) * sy2;
    te2[6] = (yz + wx2) * sy2;
    te2[7] = 0;
    te2[8] = (xz + wy2) * sz;
    te2[9] = (yz - wx2) * sz;
    te2[10] = (1 - (xx2 + yy2)) * sz;
    te2[11] = 0;
    te2[12] = position.x;
    te2[13] = position.y;
    te2[14] = position.z;
    te2[15] = 1;
    return this;
  }
  decompose(position, quaternion, scale) {
    const te2 = this.elements;
    let sx2 = _v1$5.set(te2[0], te2[1], te2[2]).length();
    const sy2 = _v1$5.set(te2[4], te2[5], te2[6]).length();
    const sz = _v1$5.set(te2[8], te2[9], te2[10]).length();
    const det = this.determinant();
    if (det < 0)
      sx2 = -sx2;
    position.x = te2[12];
    position.y = te2[13];
    position.z = te2[14];
    _m1$2.copy(this);
    const invSX = 1 / sx2;
    const invSY = 1 / sy2;
    const invSZ = 1 / sz;
    _m1$2.elements[0] *= invSX;
    _m1$2.elements[1] *= invSX;
    _m1$2.elements[2] *= invSX;
    _m1$2.elements[4] *= invSY;
    _m1$2.elements[5] *= invSY;
    _m1$2.elements[6] *= invSY;
    _m1$2.elements[8] *= invSZ;
    _m1$2.elements[9] *= invSZ;
    _m1$2.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1$2);
    scale.x = sx2;
    scale.y = sy2;
    scale.z = sz;
    return this;
  }
  makePerspective(left2, right, top, bottom, near, far) {
    if (far === void 0) {
      console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
    }
    const te2 = this.elements;
    const x2 = 2 * near / (right - left2);
    const y2 = 2 * near / (top - bottom);
    const a2 = (right + left2) / (right - left2);
    const b2 = (top + bottom) / (top - bottom);
    const c2 = -(far + near) / (far - near);
    const d2 = -2 * far * near / (far - near);
    te2[0] = x2;
    te2[4] = 0;
    te2[8] = a2;
    te2[12] = 0;
    te2[1] = 0;
    te2[5] = y2;
    te2[9] = b2;
    te2[13] = 0;
    te2[2] = 0;
    te2[6] = 0;
    te2[10] = c2;
    te2[14] = d2;
    te2[3] = 0;
    te2[7] = 0;
    te2[11] = -1;
    te2[15] = 0;
    return this;
  }
  makeOrthographic(left2, right, top, bottom, near, far) {
    const te2 = this.elements;
    const w2 = 1 / (right - left2);
    const h2 = 1 / (top - bottom);
    const p2 = 1 / (far - near);
    const x2 = (right + left2) * w2;
    const y2 = (top + bottom) * h2;
    const z2 = (far + near) * p2;
    te2[0] = 2 * w2;
    te2[4] = 0;
    te2[8] = 0;
    te2[12] = -x2;
    te2[1] = 0;
    te2[5] = 2 * h2;
    te2[9] = 0;
    te2[13] = -y2;
    te2[2] = 0;
    te2[6] = 0;
    te2[10] = -2 * p2;
    te2[14] = -z2;
    te2[3] = 0;
    te2[7] = 0;
    te2[11] = 0;
    te2[15] = 1;
    return this;
  }
  equals(matrix) {
    const te2 = this.elements;
    const me2 = matrix.elements;
    for (let i2 = 0; i2 < 16; i2++) {
      if (te2[i2] !== me2[i2])
        return false;
    }
    return true;
  }
  fromArray(array, offset2 = 0) {
    for (let i2 = 0; i2 < 16; i2++) {
      this.elements[i2] = array[i2 + offset2];
    }
    return this;
  }
  toArray(array = [], offset2 = 0) {
    const te2 = this.elements;
    array[offset2] = te2[0];
    array[offset2 + 1] = te2[1];
    array[offset2 + 2] = te2[2];
    array[offset2 + 3] = te2[3];
    array[offset2 + 4] = te2[4];
    array[offset2 + 5] = te2[5];
    array[offset2 + 6] = te2[6];
    array[offset2 + 7] = te2[7];
    array[offset2 + 8] = te2[8];
    array[offset2 + 9] = te2[9];
    array[offset2 + 10] = te2[10];
    array[offset2 + 11] = te2[11];
    array[offset2 + 12] = te2[12];
    array[offset2 + 13] = te2[13];
    array[offset2 + 14] = te2[14];
    array[offset2 + 15] = te2[15];
    return array;
  }
}
Matrix4.prototype.isMatrix4 = true;
const _v1$5 = /* @__PURE__ */ new Vector3();
const _m1$2 = /* @__PURE__ */ new Matrix4();
const _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
const _one = /* @__PURE__ */ new Vector3(1, 1, 1);
const _x = /* @__PURE__ */ new Vector3();
const _y = /* @__PURE__ */ new Vector3();
const _z = /* @__PURE__ */ new Vector3();
const _matrix$1 = /* @__PURE__ */ new Matrix4();
const _quaternion$3 = /* @__PURE__ */ new Quaternion();
class Euler {
  constructor(x2 = 0, y2 = 0, z2 = 0, order = Euler.DefaultOrder) {
    this._x = x2;
    this._y = y2;
    this._z = z2;
    this._order = order;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(value) {
    this._order = value;
    this._onChangeCallback();
  }
  set(x2, y2, z2, order = this._order) {
    this._x = x2;
    this._y = y2;
    this._z = z2;
    this._order = order;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m2, order = this._order, update = true) {
    const te2 = m2.elements;
    const m11 = te2[0], m12 = te2[4], m13 = te2[8];
    const m21 = te2[1], m22 = te2[5], m23 = te2[9];
    const m31 = te2[2], m32 = te2[6], m33 = te2[10];
    switch (order) {
      case "XYZ":
        this._y = Math.asin(clamp(m13, -1, 1));
        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }
        break;
      case "YXZ":
        this._x = Math.asin(-clamp(m23, -1, 1));
        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }
        break;
      case "ZXY":
        this._x = Math.asin(clamp(m32, -1, 1));
        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }
        break;
      case "ZYX":
        this._y = Math.asin(-clamp(m31, -1, 1));
        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }
        break;
      case "YZX":
        this._z = Math.asin(clamp(m21, -1, 1));
        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }
        break;
      case "XZY":
        this._z = Math.asin(-clamp(m12, -1, 1));
        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
    }
    this._order = order;
    if (update === true)
      this._onChangeCallback();
    return this;
  }
  setFromQuaternion(q2, order, update) {
    _matrix$1.makeRotationFromQuaternion(q2);
    return this.setFromRotationMatrix(_matrix$1, order, update);
  }
  setFromVector3(v2, order = this._order) {
    return this.set(v2.x, v2.y, v2.z, order);
  }
  reorder(newOrder) {
    _quaternion$3.setFromEuler(this);
    return this.setFromQuaternion(_quaternion$3, newOrder);
  }
  equals(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  }
  fromArray(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== void 0)
      this._order = array[3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset2 = 0) {
    array[offset2] = this._x;
    array[offset2 + 1] = this._y;
    array[offset2 + 2] = this._z;
    array[offset2 + 3] = this._order;
    return array;
  }
  toVector3(optionalResult) {
    if (optionalResult) {
      return optionalResult.set(this._x, this._y, this._z);
    } else {
      return new Vector3(this._x, this._y, this._z);
    }
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
}
Euler.prototype.isEuler = true;
Euler.DefaultOrder = "XYZ";
Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
class Layers {
  constructor() {
    this.mask = 1 | 0;
  }
  set(channel) {
    this.mask = 1 << channel | 0;
  }
  enable(channel) {
    this.mask |= 1 << channel | 0;
  }
  enableAll() {
    this.mask = 4294967295 | 0;
  }
  toggle(channel) {
    this.mask ^= 1 << channel | 0;
  }
  disable(channel) {
    this.mask &= ~(1 << channel | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(layers) {
    return (this.mask & layers.mask) !== 0;
  }
}
let _object3DId = 0;
const _v1$4 = /* @__PURE__ */ new Vector3();
const _q1 = /* @__PURE__ */ new Quaternion();
const _m1$1 = /* @__PURE__ */ new Matrix4();
const _target = /* @__PURE__ */ new Vector3();
const _position$3 = /* @__PURE__ */ new Vector3();
const _scale$2 = /* @__PURE__ */ new Vector3();
const _quaternion$2 = /* @__PURE__ */ new Quaternion();
const _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);
const _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);
const _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);
const _addedEvent = { type: "added" };
const _removedEvent = { type: "removed" };
class Object3D extends EventDispatcher {
  constructor() {
    super();
    Object.defineProperty(this, "id", { value: _object3DId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Object3D";
    this.parent = null;
    this.children = [];
    this.up = Object3D.DefaultUp.clone();
    const position = new Vector3();
    const rotation = new Euler();
    const quaternion = new Quaternion();
    const scale = new Vector3(1, 1, 1);
    function onRotationChange() {
      quaternion.setFromEuler(rotation, false);
    }
    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion, void 0, false);
    }
    rotation._onChange(onRotationChange);
    quaternion._onChange(onQuaternionChange);
    Object.defineProperties(this, {
      position: {
        configurable: true,
        enumerable: true,
        value: position
      },
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation
      },
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion
      },
      scale: {
        configurable: true,
        enumerable: true,
        value: scale
      },
      modelViewMatrix: {
        value: new Matrix4()
      },
      normalMatrix: {
        value: new Matrix3()
      }
    });
    this.matrix = new Matrix4();
    this.matrixWorld = new Matrix4();
    this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
    this.matrixWorldNeedsUpdate = false;
    this.layers = new Layers();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.animations = [];
    this.userData = {};
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(matrix) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(q2) {
    this.quaternion.premultiply(q2);
    return this;
  }
  setRotationFromAxisAngle(axis, angle) {
    this.quaternion.setFromAxisAngle(axis, angle);
  }
  setRotationFromEuler(euler) {
    this.quaternion.setFromEuler(euler, true);
  }
  setRotationFromMatrix(m2) {
    this.quaternion.setFromRotationMatrix(m2);
  }
  setRotationFromQuaternion(q2) {
    this.quaternion.copy(q2);
  }
  rotateOnAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.multiply(_q1);
    return this;
  }
  rotateOnWorldAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.premultiply(_q1);
    return this;
  }
  rotateX(angle) {
    return this.rotateOnAxis(_xAxis, angle);
  }
  rotateY(angle) {
    return this.rotateOnAxis(_yAxis, angle);
  }
  rotateZ(angle) {
    return this.rotateOnAxis(_zAxis, angle);
  }
  translateOnAxis(axis, distance) {
    _v1$4.copy(axis).applyQuaternion(this.quaternion);
    this.position.add(_v1$4.multiplyScalar(distance));
    return this;
  }
  translateX(distance) {
    return this.translateOnAxis(_xAxis, distance);
  }
  translateY(distance) {
    return this.translateOnAxis(_yAxis, distance);
  }
  translateZ(distance) {
    return this.translateOnAxis(_zAxis, distance);
  }
  localToWorld(vector) {
    return vector.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(vector) {
    return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
  }
  lookAt(x2, y2, z2) {
    if (x2.isVector3) {
      _target.copy(x2);
    } else {
      _target.set(x2, y2, z2);
    }
    const parent = this.parent;
    this.updateWorldMatrix(true, false);
    _position$3.setFromMatrixPosition(this.matrixWorld);
    if (this.isCamera || this.isLight) {
      _m1$1.lookAt(_position$3, _target, this.up);
    } else {
      _m1$1.lookAt(_target, _position$3, this.up);
    }
    this.quaternion.setFromRotationMatrix(_m1$1);
    if (parent) {
      _m1$1.extractRotation(parent.matrixWorld);
      _q1.setFromRotationMatrix(_m1$1);
      this.quaternion.premultiply(_q1.invert());
    }
  }
  add(object) {
    if (arguments.length > 1) {
      for (let i2 = 0; i2 < arguments.length; i2++) {
        this.add(arguments[i2]);
      }
      return this;
    }
    if (object === this) {
      console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
      return this;
    }
    if (object && object.isObject3D) {
      if (object.parent !== null) {
        object.parent.remove(object);
      }
      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
    } else {
      console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
    }
    return this;
  }
  remove(object) {
    if (arguments.length > 1) {
      for (let i2 = 0; i2 < arguments.length; i2++) {
        this.remove(arguments[i2]);
      }
      return this;
    }
    const index = this.children.indexOf(object);
    if (index !== -1) {
      object.parent = null;
      this.children.splice(index, 1);
      object.dispatchEvent(_removedEvent);
    }
    return this;
  }
  removeFromParent() {
    const parent = this.parent;
    if (parent !== null) {
      parent.remove(this);
    }
    return this;
  }
  clear() {
    for (let i2 = 0; i2 < this.children.length; i2++) {
      const object = this.children[i2];
      object.parent = null;
      object.dispatchEvent(_removedEvent);
    }
    this.children.length = 0;
    return this;
  }
  attach(object) {
    this.updateWorldMatrix(true, false);
    _m1$1.copy(this.matrixWorld).invert();
    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);
      _m1$1.multiply(object.parent.matrixWorld);
    }
    object.applyMatrix4(_m1$1);
    this.add(object);
    object.updateWorldMatrix(false, true);
    return this;
  }
  getObjectById(id2) {
    return this.getObjectByProperty("id", id2);
  }
  getObjectByName(name2) {
    return this.getObjectByProperty("name", name2);
  }
  getObjectByProperty(name2, value) {
    if (this[name2] === value)
      return this;
    for (let i2 = 0, l2 = this.children.length; i2 < l2; i2++) {
      const child = this.children[i2];
      const object = child.getObjectByProperty(name2, value);
      if (object !== void 0) {
        return object;
      }
    }
    return void 0;
  }
  getWorldPosition(target) {
    this.updateWorldMatrix(true, false);
    return target.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, target, _scale$2);
    return target;
  }
  getWorldScale(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, _quaternion$2, target);
    return target;
  }
  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e20 = this.matrixWorld.elements;
    return target.set(e20[8], e20[9], e20[10]).normalize();
  }
  raycast() {
  }
  traverse(callback) {
    callback(this);
    const children = this.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      children[i2].traverse(callback);
    }
  }
  traverseVisible(callback) {
    if (this.visible === false)
      return;
    callback(this);
    const children = this.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      children[i2].traverseVisible(callback);
    }
  }
  traverseAncestors(callback) {
    const parent = this.parent;
    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  }
  updateMatrixWorld(force) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    const children = this.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      children[i2].updateMatrixWorld(force);
    }
  }
  updateWorldMatrix(updateParents, updateChildren) {
    const parent = this.parent;
    if (updateParents === true && parent !== null) {
      parent.updateWorldMatrix(true, false);
    }
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    }
    if (updateChildren === true) {
      const children = this.children;
      for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
        children[i2].updateWorldMatrix(false, true);
      }
    }
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    const output = {};
    if (isRootObject) {
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {}
      };
      output.metadata = {
        version: 4.5,
        type: "Object",
        generator: "Object3D.toJSON"
      };
    }
    const object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== "")
      object.name = this.name;
    if (this.castShadow === true)
      object.castShadow = true;
    if (this.receiveShadow === true)
      object.receiveShadow = true;
    if (this.visible === false)
      object.visible = false;
    if (this.frustumCulled === false)
      object.frustumCulled = false;
    if (this.renderOrder !== 0)
      object.renderOrder = this.renderOrder;
    if (JSON.stringify(this.userData) !== "{}")
      object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    if (this.matrixAutoUpdate === false)
      object.matrixAutoUpdate = false;
    if (this.isInstancedMesh) {
      object.type = "InstancedMesh";
      object.count = this.count;
      object.instanceMatrix = this.instanceMatrix.toJSON();
      if (this.instanceColor !== null)
        object.instanceColor = this.instanceColor.toJSON();
    }
    function serialize(library, element) {
      if (library[element.uuid] === void 0) {
        library[element.uuid] = element.toJSON(meta);
      }
      return element.uuid;
    }
    if (this.isScene) {
      if (this.background) {
        if (this.background.isColor) {
          object.background = this.background.toJSON();
        } else if (this.background.isTexture) {
          object.background = this.background.toJSON(meta).uuid;
        }
      }
      if (this.environment && this.environment.isTexture) {
        object.environment = this.environment.toJSON(meta).uuid;
      }
    } else if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry);
      const parameters = this.geometry.parameters;
      if (parameters !== void 0 && parameters.shapes !== void 0) {
        const shapes = parameters.shapes;
        if (Array.isArray(shapes)) {
          for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
            const shape = shapes[i2];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }
    if (this.isSkinnedMesh) {
      object.bindMode = this.bindMode;
      object.bindMatrix = this.bindMatrix.toArray();
      if (this.skeleton !== void 0) {
        serialize(meta.skeletons, this.skeleton);
        object.skeleton = this.skeleton.uuid;
      }
    }
    if (this.material !== void 0) {
      if (Array.isArray(this.material)) {
        const uuids = [];
        for (let i2 = 0, l2 = this.material.length; i2 < l2; i2++) {
          uuids.push(serialize(meta.materials, this.material[i2]));
        }
        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    }
    if (this.children.length > 0) {
      object.children = [];
      for (let i2 = 0; i2 < this.children.length; i2++) {
        object.children.push(this.children[i2].toJSON(meta).object);
      }
    }
    if (this.animations.length > 0) {
      object.animations = [];
      for (let i2 = 0; i2 < this.animations.length; i2++) {
        const animation = this.animations[i2];
        object.animations.push(serialize(meta.animations, animation));
      }
    }
    if (isRootObject) {
      const geometries = extractFromCache(meta.geometries);
      const materials = extractFromCache(meta.materials);
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const shapes = extractFromCache(meta.shapes);
      const skeletons = extractFromCache(meta.skeletons);
      const animations = extractFromCache(meta.animations);
      if (geometries.length > 0)
        output.geometries = geometries;
      if (materials.length > 0)
        output.materials = materials;
      if (textures.length > 0)
        output.textures = textures;
      if (images.length > 0)
        output.images = images;
      if (shapes.length > 0)
        output.shapes = shapes;
      if (skeletons.length > 0)
        output.skeletons = skeletons;
      if (animations.length > 0)
        output.animations = animations;
    }
    output.object = object;
    return output;
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data = cache[key];
        delete data.metadata;
        values.push(data);
      }
      return values;
    }
  }
  clone(recursive) {
    return new this.constructor().copy(this, recursive);
  }
  copy(source3, recursive = true) {
    this.name = source3.name;
    this.up.copy(source3.up);
    this.position.copy(source3.position);
    this.rotation.order = source3.rotation.order;
    this.quaternion.copy(source3.quaternion);
    this.scale.copy(source3.scale);
    this.matrix.copy(source3.matrix);
    this.matrixWorld.copy(source3.matrixWorld);
    this.matrixAutoUpdate = source3.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source3.matrixWorldNeedsUpdate;
    this.layers.mask = source3.layers.mask;
    this.visible = source3.visible;
    this.castShadow = source3.castShadow;
    this.receiveShadow = source3.receiveShadow;
    this.frustumCulled = source3.frustumCulled;
    this.renderOrder = source3.renderOrder;
    this.userData = JSON.parse(JSON.stringify(source3.userData));
    if (recursive === true) {
      for (let i2 = 0; i2 < source3.children.length; i2++) {
        const child = source3.children[i2];
        this.add(child.clone());
      }
    }
    return this;
  }
}
Object3D.DefaultUp = new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;
Object3D.prototype.isObject3D = true;
const _v0$1 = /* @__PURE__ */ new Vector3();
const _v1$3 = /* @__PURE__ */ new Vector3();
const _v2$2 = /* @__PURE__ */ new Vector3();
const _v3$1 = /* @__PURE__ */ new Vector3();
const _vab = /* @__PURE__ */ new Vector3();
const _vac = /* @__PURE__ */ new Vector3();
const _vbc = /* @__PURE__ */ new Vector3();
const _vap = /* @__PURE__ */ new Vector3();
const _vbp = /* @__PURE__ */ new Vector3();
const _vcp = /* @__PURE__ */ new Vector3();
class Triangle {
  constructor(a2 = new Vector3(), b2 = new Vector3(), c2 = new Vector3()) {
    this.a = a2;
    this.b = b2;
    this.c = c2;
  }
  static getNormal(a2, b2, c2, target) {
    target.subVectors(c2, b2);
    _v0$1.subVectors(a2, b2);
    target.cross(_v0$1);
    const targetLengthSq = target.lengthSq();
    if (targetLengthSq > 0) {
      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
    }
    return target.set(0, 0, 0);
  }
  static getBarycoord(point, a2, b2, c2, target) {
    _v0$1.subVectors(c2, a2);
    _v1$3.subVectors(b2, a2);
    _v2$2.subVectors(point, a2);
    const dot00 = _v0$1.dot(_v0$1);
    const dot01 = _v0$1.dot(_v1$3);
    const dot02 = _v0$1.dot(_v2$2);
    const dot11 = _v1$3.dot(_v1$3);
    const dot12 = _v1$3.dot(_v2$2);
    const denom = dot00 * dot11 - dot01 * dot01;
    if (denom === 0) {
      return target.set(-2, -1, -1);
    }
    const invDenom = 1 / denom;
    const u2 = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v2 = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return target.set(1 - u2 - v2, v2, u2);
  }
  static containsPoint(point, a2, b2, c2) {
    this.getBarycoord(point, a2, b2, c2, _v3$1);
    return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
  }
  static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
    this.getBarycoord(point, p1, p2, p3, _v3$1);
    target.set(0, 0);
    target.addScaledVector(uv1, _v3$1.x);
    target.addScaledVector(uv2, _v3$1.y);
    target.addScaledVector(uv3, _v3$1.z);
    return target;
  }
  static isFrontFacing(a2, b2, c2, direction) {
    _v0$1.subVectors(c2, b2);
    _v1$3.subVectors(a2, b2);
    return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
  }
  set(a2, b2, c2) {
    this.a.copy(a2);
    this.b.copy(b2);
    this.c.copy(c2);
    return this;
  }
  setFromPointsAndIndices(points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  }
  setFromAttributeAndIndices(attribute, i0, i1, i2) {
    this.a.fromBufferAttribute(attribute, i0);
    this.b.fromBufferAttribute(attribute, i1);
    this.c.fromBufferAttribute(attribute, i2);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  }
  getArea() {
    _v0$1.subVectors(this.c, this.b);
    _v1$3.subVectors(this.a, this.b);
    return _v0$1.cross(_v1$3).length() * 0.5;
  }
  getMidpoint(target) {
    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(target) {
    return Triangle.getNormal(this.a, this.b, this.c, target);
  }
  getPlane(target) {
    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(point, target) {
    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
  }
  getUV(point, uv1, uv2, uv3, target) {
    return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
  }
  containsPoint(point) {
    return Triangle.containsPoint(point, this.a, this.b, this.c);
  }
  isFrontFacing(direction) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
  }
  intersectsBox(box) {
    return box.intersectsTriangle(this);
  }
  closestPointToPoint(p2, target) {
    const a2 = this.a, b2 = this.b, c2 = this.c;
    let v2, w2;
    _vab.subVectors(b2, a2);
    _vac.subVectors(c2, a2);
    _vap.subVectors(p2, a2);
    const d1 = _vab.dot(_vap);
    const d2 = _vac.dot(_vap);
    if (d1 <= 0 && d2 <= 0) {
      return target.copy(a2);
    }
    _vbp.subVectors(p2, b2);
    const d3 = _vab.dot(_vbp);
    const d4 = _vac.dot(_vbp);
    if (d3 >= 0 && d4 <= d3) {
      return target.copy(b2);
    }
    const vc2 = d1 * d4 - d3 * d2;
    if (vc2 <= 0 && d1 >= 0 && d3 <= 0) {
      v2 = d1 / (d1 - d3);
      return target.copy(a2).addScaledVector(_vab, v2);
    }
    _vcp.subVectors(p2, c2);
    const d5 = _vab.dot(_vcp);
    const d6 = _vac.dot(_vcp);
    if (d6 >= 0 && d5 <= d6) {
      return target.copy(c2);
    }
    const vb2 = d5 * d2 - d1 * d6;
    if (vb2 <= 0 && d2 >= 0 && d6 <= 0) {
      w2 = d2 / (d2 - d6);
      return target.copy(a2).addScaledVector(_vac, w2);
    }
    const va2 = d3 * d6 - d5 * d4;
    if (va2 <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
      _vbc.subVectors(c2, b2);
      w2 = (d4 - d3) / (d4 - d3 + (d5 - d6));
      return target.copy(b2).addScaledVector(_vbc, w2);
    }
    const denom = 1 / (va2 + vb2 + vc2);
    v2 = vb2 * denom;
    w2 = vc2 * denom;
    return target.copy(a2).addScaledVector(_vab, v2).addScaledVector(_vac, w2);
  }
  equals(triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }
}
let materialId = 0;
class Material extends EventDispatcher {
  constructor() {
    super();
    Object.defineProperty(this, "id", { value: materialId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Material";
    this.fog = true;
    this.blending = NormalBlending;
    this.side = FrontSide;
    this.vertexColors = false;
    this.opacity = 1;
    this.format = RGBAFormat;
    this.transparent = false;
    this.blendSrc = SrcAlphaFactor;
    this.blendDst = OneMinusSrcAlphaFactor;
    this.blendEquation = AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;
    this.depthFunc = LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;
    this.stencilWriteMask = 255;
    this.stencilFunc = AlwaysStencilFunc;
    this.stencilRef = 0;
    this.stencilFuncMask = 255;
    this.stencilFail = KeepStencilOp;
    this.stencilZFail = KeepStencilOp;
    this.stencilZPass = KeepStencilOp;
    this.stencilWrite = false;
    this.clippingPlanes = null;
    this.clipIntersection = false;
    this.clipShadows = false;
    this.shadowSide = null;
    this.colorWrite = true;
    this.precision = null;
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.dithering = false;
    this.alphaToCoverage = false;
    this.premultipliedAlpha = false;
    this.visible = true;
    this.toneMapped = true;
    this.userData = {};
    this.version = 0;
    this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(value) {
    if (this._alphaTest > 0 !== value > 0) {
      this.version++;
    }
    this._alphaTest = value;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(values) {
    if (values === void 0)
      return;
    for (const key in values) {
      const newValue = values[key];
      if (newValue === void 0) {
        console.warn("THREE.Material: '" + key + "' parameter is undefined.");
        continue;
      }
      if (key === "shading") {
        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
        this.flatShading = newValue === FlatShading ? true : false;
        continue;
      }
      const currentValue = this[key];
      if (currentValue === void 0) {
        console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
        continue;
      }
      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  }
  toJSON(meta) {
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {}
      };
    }
    const data = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "")
      data.name = this.name;
    if (this.color && this.color.isColor)
      data.color = this.color.getHex();
    if (this.roughness !== void 0)
      data.roughness = this.roughness;
    if (this.metalness !== void 0)
      data.metalness = this.metalness;
    if (this.sheen !== void 0)
      data.sheen = this.sheen;
    if (this.sheenColor && this.sheenColor.isColor)
      data.sheenColor = this.sheenColor.getHex();
    if (this.sheenRoughness !== void 0)
      data.sheenRoughness = this.sheenRoughness;
    if (this.emissive && this.emissive.isColor)
      data.emissive = this.emissive.getHex();
    if (this.emissiveIntensity && this.emissiveIntensity !== 1)
      data.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor)
      data.specular = this.specular.getHex();
    if (this.specularIntensity !== void 0)
      data.specularIntensity = this.specularIntensity;
    if (this.specularColor && this.specularColor.isColor)
      data.specularColor = this.specularColor.getHex();
    if (this.shininess !== void 0)
      data.shininess = this.shininess;
    if (this.clearcoat !== void 0)
      data.clearcoat = this.clearcoat;
    if (this.clearcoatRoughness !== void 0)
      data.clearcoatRoughness = this.clearcoatRoughness;
    if (this.clearcoatMap && this.clearcoatMap.isTexture) {
      data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
    }
    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
      data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
    }
    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
    }
    if (this.map && this.map.isTexture)
      data.map = this.map.toJSON(meta).uuid;
    if (this.matcap && this.matcap.isTexture)
      data.matcap = this.matcap.toJSON(meta).uuid;
    if (this.alphaMap && this.alphaMap.isTexture)
      data.alphaMap = this.alphaMap.toJSON(meta).uuid;
    if (this.lightMap && this.lightMap.isTexture) {
      data.lightMap = this.lightMap.toJSON(meta).uuid;
      data.lightMapIntensity = this.lightMapIntensity;
    }
    if (this.aoMap && this.aoMap.isTexture) {
      data.aoMap = this.aoMap.toJSON(meta).uuid;
      data.aoMapIntensity = this.aoMapIntensity;
    }
    if (this.bumpMap && this.bumpMap.isTexture) {
      data.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data.bumpScale = this.bumpScale;
    }
    if (this.normalMap && this.normalMap.isTexture) {
      data.normalMap = this.normalMap.toJSON(meta).uuid;
      data.normalMapType = this.normalMapType;
      data.normalScale = this.normalScale.toArray();
    }
    if (this.displacementMap && this.displacementMap.isTexture) {
      data.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;
    }
    if (this.roughnessMap && this.roughnessMap.isTexture)
      data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture)
      data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture)
      data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap && this.specularMap.isTexture)
      data.specularMap = this.specularMap.toJSON(meta).uuid;
    if (this.specularIntensityMap && this.specularIntensityMap.isTexture)
      data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
    if (this.specularColorMap && this.specularColorMap.isTexture)
      data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
    if (this.envMap && this.envMap.isTexture) {
      data.envMap = this.envMap.toJSON(meta).uuid;
      if (this.combine !== void 0)
        data.combine = this.combine;
    }
    if (this.envMapIntensity !== void 0)
      data.envMapIntensity = this.envMapIntensity;
    if (this.reflectivity !== void 0)
      data.reflectivity = this.reflectivity;
    if (this.refractionRatio !== void 0)
      data.refractionRatio = this.refractionRatio;
    if (this.gradientMap && this.gradientMap.isTexture) {
      data.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }
    if (this.transmission !== void 0)
      data.transmission = this.transmission;
    if (this.transmissionMap && this.transmissionMap.isTexture)
      data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
    if (this.thickness !== void 0)
      data.thickness = this.thickness;
    if (this.thicknessMap && this.thicknessMap.isTexture)
      data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
    if (this.attenuationDistance !== void 0)
      data.attenuationDistance = this.attenuationDistance;
    if (this.attenuationColor !== void 0)
      data.attenuationColor = this.attenuationColor.getHex();
    if (this.size !== void 0)
      data.size = this.size;
    if (this.shadowSide !== null)
      data.shadowSide = this.shadowSide;
    if (this.sizeAttenuation !== void 0)
      data.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== NormalBlending)
      data.blending = this.blending;
    if (this.side !== FrontSide)
      data.side = this.side;
    if (this.vertexColors)
      data.vertexColors = true;
    if (this.opacity < 1)
      data.opacity = this.opacity;
    if (this.format !== RGBAFormat)
      data.format = this.format;
    if (this.transparent === true)
      data.transparent = this.transparent;
    data.depthFunc = this.depthFunc;
    data.depthTest = this.depthTest;
    data.depthWrite = this.depthWrite;
    data.colorWrite = this.colorWrite;
    data.stencilWrite = this.stencilWrite;
    data.stencilWriteMask = this.stencilWriteMask;
    data.stencilFunc = this.stencilFunc;
    data.stencilRef = this.stencilRef;
    data.stencilFuncMask = this.stencilFuncMask;
    data.stencilFail = this.stencilFail;
    data.stencilZFail = this.stencilZFail;
    data.stencilZPass = this.stencilZPass;
    if (this.rotation && this.rotation !== 0)
      data.rotation = this.rotation;
    if (this.polygonOffset === true)
      data.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0)
      data.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0)
      data.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth && this.linewidth !== 1)
      data.linewidth = this.linewidth;
    if (this.dashSize !== void 0)
      data.dashSize = this.dashSize;
    if (this.gapSize !== void 0)
      data.gapSize = this.gapSize;
    if (this.scale !== void 0)
      data.scale = this.scale;
    if (this.dithering === true)
      data.dithering = true;
    if (this.alphaTest > 0)
      data.alphaTest = this.alphaTest;
    if (this.alphaToCoverage === true)
      data.alphaToCoverage = this.alphaToCoverage;
    if (this.premultipliedAlpha === true)
      data.premultipliedAlpha = this.premultipliedAlpha;
    if (this.wireframe === true)
      data.wireframe = this.wireframe;
    if (this.wireframeLinewidth > 1)
      data.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== "round")
      data.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== "round")
      data.wireframeLinejoin = this.wireframeLinejoin;
    if (this.flatShading === true)
      data.flatShading = this.flatShading;
    if (this.visible === false)
      data.visible = false;
    if (this.toneMapped === false)
      data.toneMapped = false;
    if (JSON.stringify(this.userData) !== "{}")
      data.userData = this.userData;
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data2 = cache[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
    }
    return data;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source3) {
    this.name = source3.name;
    this.fog = source3.fog;
    this.blending = source3.blending;
    this.side = source3.side;
    this.vertexColors = source3.vertexColors;
    this.opacity = source3.opacity;
    this.format = source3.format;
    this.transparent = source3.transparent;
    this.blendSrc = source3.blendSrc;
    this.blendDst = source3.blendDst;
    this.blendEquation = source3.blendEquation;
    this.blendSrcAlpha = source3.blendSrcAlpha;
    this.blendDstAlpha = source3.blendDstAlpha;
    this.blendEquationAlpha = source3.blendEquationAlpha;
    this.depthFunc = source3.depthFunc;
    this.depthTest = source3.depthTest;
    this.depthWrite = source3.depthWrite;
    this.stencilWriteMask = source3.stencilWriteMask;
    this.stencilFunc = source3.stencilFunc;
    this.stencilRef = source3.stencilRef;
    this.stencilFuncMask = source3.stencilFuncMask;
    this.stencilFail = source3.stencilFail;
    this.stencilZFail = source3.stencilZFail;
    this.stencilZPass = source3.stencilZPass;
    this.stencilWrite = source3.stencilWrite;
    const srcPlanes = source3.clippingPlanes;
    let dstPlanes = null;
    if (srcPlanes !== null) {
      const n2 = srcPlanes.length;
      dstPlanes = new Array(n2);
      for (let i2 = 0; i2 !== n2; ++i2) {
        dstPlanes[i2] = srcPlanes[i2].clone();
      }
    }
    this.clippingPlanes = dstPlanes;
    this.clipIntersection = source3.clipIntersection;
    this.clipShadows = source3.clipShadows;
    this.shadowSide = source3.shadowSide;
    this.colorWrite = source3.colorWrite;
    this.precision = source3.precision;
    this.polygonOffset = source3.polygonOffset;
    this.polygonOffsetFactor = source3.polygonOffsetFactor;
    this.polygonOffsetUnits = source3.polygonOffsetUnits;
    this.dithering = source3.dithering;
    this.alphaTest = source3.alphaTest;
    this.alphaToCoverage = source3.alphaToCoverage;
    this.premultipliedAlpha = source3.premultipliedAlpha;
    this.visible = source3.visible;
    this.toneMapped = source3.toneMapped;
    this.userData = JSON.parse(JSON.stringify(source3.userData));
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
}
Material.prototype.isMaterial = true;
const _colorKeywords = {
  "aliceblue": 15792383,
  "antiquewhite": 16444375,
  "aqua": 65535,
  "aquamarine": 8388564,
  "azure": 15794175,
  "beige": 16119260,
  "bisque": 16770244,
  "black": 0,
  "blanchedalmond": 16772045,
  "blue": 255,
  "blueviolet": 9055202,
  "brown": 10824234,
  "burlywood": 14596231,
  "cadetblue": 6266528,
  "chartreuse": 8388352,
  "chocolate": 13789470,
  "coral": 16744272,
  "cornflowerblue": 6591981,
  "cornsilk": 16775388,
  "crimson": 14423100,
  "cyan": 65535,
  "darkblue": 139,
  "darkcyan": 35723,
  "darkgoldenrod": 12092939,
  "darkgray": 11119017,
  "darkgreen": 25600,
  "darkgrey": 11119017,
  "darkkhaki": 12433259,
  "darkmagenta": 9109643,
  "darkolivegreen": 5597999,
  "darkorange": 16747520,
  "darkorchid": 10040012,
  "darkred": 9109504,
  "darksalmon": 15308410,
  "darkseagreen": 9419919,
  "darkslateblue": 4734347,
  "darkslategray": 3100495,
  "darkslategrey": 3100495,
  "darkturquoise": 52945,
  "darkviolet": 9699539,
  "deeppink": 16716947,
  "deepskyblue": 49151,
  "dimgray": 6908265,
  "dimgrey": 6908265,
  "dodgerblue": 2003199,
  "firebrick": 11674146,
  "floralwhite": 16775920,
  "forestgreen": 2263842,
  "fuchsia": 16711935,
  "gainsboro": 14474460,
  "ghostwhite": 16316671,
  "gold": 16766720,
  "goldenrod": 14329120,
  "gray": 8421504,
  "green": 32768,
  "greenyellow": 11403055,
  "grey": 8421504,
  "honeydew": 15794160,
  "hotpink": 16738740,
  "indianred": 13458524,
  "indigo": 4915330,
  "ivory": 16777200,
  "khaki": 15787660,
  "lavender": 15132410,
  "lavenderblush": 16773365,
  "lawngreen": 8190976,
  "lemonchiffon": 16775885,
  "lightblue": 11393254,
  "lightcoral": 15761536,
  "lightcyan": 14745599,
  "lightgoldenrodyellow": 16448210,
  "lightgray": 13882323,
  "lightgreen": 9498256,
  "lightgrey": 13882323,
  "lightpink": 16758465,
  "lightsalmon": 16752762,
  "lightseagreen": 2142890,
  "lightskyblue": 8900346,
  "lightslategray": 7833753,
  "lightslategrey": 7833753,
  "lightsteelblue": 11584734,
  "lightyellow": 16777184,
  "lime": 65280,
  "limegreen": 3329330,
  "linen": 16445670,
  "magenta": 16711935,
  "maroon": 8388608,
  "mediumaquamarine": 6737322,
  "mediumblue": 205,
  "mediumorchid": 12211667,
  "mediumpurple": 9662683,
  "mediumseagreen": 3978097,
  "mediumslateblue": 8087790,
  "mediumspringgreen": 64154,
  "mediumturquoise": 4772300,
  "mediumvioletred": 13047173,
  "midnightblue": 1644912,
  "mintcream": 16121850,
  "mistyrose": 16770273,
  "moccasin": 16770229,
  "navajowhite": 16768685,
  "navy": 128,
  "oldlace": 16643558,
  "olive": 8421376,
  "olivedrab": 7048739,
  "orange": 16753920,
  "orangered": 16729344,
  "orchid": 14315734,
  "palegoldenrod": 15657130,
  "palegreen": 10025880,
  "paleturquoise": 11529966,
  "palevioletred": 14381203,
  "papayawhip": 16773077,
  "peachpuff": 16767673,
  "peru": 13468991,
  "pink": 16761035,
  "plum": 14524637,
  "powderblue": 11591910,
  "purple": 8388736,
  "rebeccapurple": 6697881,
  "red": 16711680,
  "rosybrown": 12357519,
  "royalblue": 4286945,
  "saddlebrown": 9127187,
  "salmon": 16416882,
  "sandybrown": 16032864,
  "seagreen": 3050327,
  "seashell": 16774638,
  "sienna": 10506797,
  "silver": 12632256,
  "skyblue": 8900331,
  "slateblue": 6970061,
  "slategray": 7372944,
  "slategrey": 7372944,
  "snow": 16775930,
  "springgreen": 65407,
  "steelblue": 4620980,
  "tan": 13808780,
  "teal": 32896,
  "thistle": 14204888,
  "tomato": 16737095,
  "turquoise": 4251856,
  "violet": 15631086,
  "wheat": 16113331,
  "white": 16777215,
  "whitesmoke": 16119285,
  "yellow": 16776960,
  "yellowgreen": 10145074
};
const _hslA = { h: 0, s: 0, l: 0 };
const _hslB = { h: 0, s: 0, l: 0 };
function hue2rgb(p2, q2, t2) {
  if (t2 < 0)
    t2 += 1;
  if (t2 > 1)
    t2 -= 1;
  if (t2 < 1 / 6)
    return p2 + (q2 - p2) * 6 * t2;
  if (t2 < 1 / 2)
    return q2;
  if (t2 < 2 / 3)
    return p2 + (q2 - p2) * 6 * (2 / 3 - t2);
  return p2;
}
function SRGBToLinear(c2) {
  return c2 < 0.04045 ? c2 * 0.0773993808 : Math.pow(c2 * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c2) {
  return c2 < 31308e-7 ? c2 * 12.92 : 1.055 * Math.pow(c2, 0.41666) - 0.055;
}
class Color {
  constructor(r2, g2, b2) {
    if (g2 === void 0 && b2 === void 0) {
      return this.set(r2);
    }
    return this.setRGB(r2, g2, b2);
  }
  set(value) {
    if (value && value.isColor) {
      this.copy(value);
    } else if (typeof value === "number") {
      this.setHex(value);
    } else if (typeof value === "string") {
      this.setStyle(value);
    }
    return this;
  }
  setScalar(scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  }
  setHex(hex) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    return this;
  }
  setRGB(r2, g2, b2) {
    this.r = r2;
    this.g = g2;
    this.b = b2;
    return this;
  }
  setHSL(h2, s2, l2) {
    h2 = euclideanModulo(h2, 1);
    s2 = clamp(s2, 0, 1);
    l2 = clamp(l2, 0, 1);
    if (s2 === 0) {
      this.r = this.g = this.b = l2;
    } else {
      const p2 = l2 <= 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
      const q2 = 2 * l2 - p2;
      this.r = hue2rgb(q2, p2, h2 + 1 / 3);
      this.g = hue2rgb(q2, p2, h2);
      this.b = hue2rgb(q2, p2, h2 - 1 / 3);
    }
    return this;
  }
  setStyle(style) {
    function handleAlpha(string2) {
      if (string2 === void 0)
        return;
      if (parseFloat(string2) < 1) {
        console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
      }
    }
    let m2;
    if (m2 = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
      let color2;
      const name2 = m2[1];
      const components = m2[2];
      switch (name2) {
        case "rgb":
        case "rgba":
          if (color2 = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            this.r = Math.min(255, parseInt(color2[1], 10)) / 255;
            this.g = Math.min(255, parseInt(color2[2], 10)) / 255;
            this.b = Math.min(255, parseInt(color2[3], 10)) / 255;
            handleAlpha(color2[4]);
            return this;
          }
          if (color2 = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            this.r = Math.min(100, parseInt(color2[1], 10)) / 100;
            this.g = Math.min(100, parseInt(color2[2], 10)) / 100;
            this.b = Math.min(100, parseInt(color2[3], 10)) / 100;
            handleAlpha(color2[4]);
            return this;
          }
          break;
        case "hsl":
        case "hsla":
          if (color2 = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            const h2 = parseFloat(color2[1]) / 360;
            const s2 = parseInt(color2[2], 10) / 100;
            const l2 = parseInt(color2[3], 10) / 100;
            handleAlpha(color2[4]);
            return this.setHSL(h2, s2, l2);
          }
          break;
      }
    } else if (m2 = /^\#([A-Fa-f\d]+)$/.exec(style)) {
      const hex = m2[1];
      const size = hex.length;
      if (size === 3) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
        this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
        this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
        return this;
      } else if (size === 6) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
        this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
        this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
        return this;
      }
    }
    if (style && style.length > 0) {
      return this.setColorName(style);
    }
    return this;
  }
  setColorName(style) {
    const hex = _colorKeywords[style.toLowerCase()];
    if (hex !== void 0) {
      this.setHex(hex);
    } else {
      console.warn("THREE.Color: Unknown color " + style);
    }
    return this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(color2) {
    this.r = color2.r;
    this.g = color2.g;
    this.b = color2.b;
    return this;
  }
  copyGammaToLinear(color2, gammaFactor = 2) {
    this.r = Math.pow(color2.r, gammaFactor);
    this.g = Math.pow(color2.g, gammaFactor);
    this.b = Math.pow(color2.b, gammaFactor);
    return this;
  }
  copyLinearToGamma(color2, gammaFactor = 2) {
    const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
    this.r = Math.pow(color2.r, safeInverse);
    this.g = Math.pow(color2.g, safeInverse);
    this.b = Math.pow(color2.b, safeInverse);
    return this;
  }
  convertGammaToLinear(gammaFactor) {
    this.copyGammaToLinear(this, gammaFactor);
    return this;
  }
  convertLinearToGamma(gammaFactor) {
    this.copyLinearToGamma(this, gammaFactor);
    return this;
  }
  copySRGBToLinear(color2) {
    this.r = SRGBToLinear(color2.r);
    this.g = SRGBToLinear(color2.g);
    this.b = SRGBToLinear(color2.b);
    return this;
  }
  copyLinearToSRGB(color2) {
    this.r = LinearToSRGB(color2.r);
    this.g = LinearToSRGB(color2.g);
    this.b = LinearToSRGB(color2.b);
    return this;
  }
  convertSRGBToLinear() {
    this.copySRGBToLinear(this);
    return this;
  }
  convertLinearToSRGB() {
    this.copyLinearToSRGB(this);
    return this;
  }
  getHex() {
    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
  }
  getHexString() {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  }
  getHSL(target) {
    const r2 = this.r, g2 = this.g, b2 = this.b;
    const max2 = Math.max(r2, g2, b2);
    const min2 = Math.min(r2, g2, b2);
    let hue, saturation;
    const lightness = (min2 + max2) / 2;
    if (min2 === max2) {
      hue = 0;
      saturation = 0;
    } else {
      const delta = max2 - min2;
      saturation = lightness <= 0.5 ? delta / (max2 + min2) : delta / (2 - max2 - min2);
      switch (max2) {
        case r2:
          hue = (g2 - b2) / delta + (g2 < b2 ? 6 : 0);
          break;
        case g2:
          hue = (b2 - r2) / delta + 2;
          break;
        case b2:
          hue = (r2 - g2) / delta + 4;
          break;
      }
      hue /= 6;
    }
    target.h = hue;
    target.s = saturation;
    target.l = lightness;
    return target;
  }
  getStyle() {
    return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
  }
  offsetHSL(h2, s2, l2) {
    this.getHSL(_hslA);
    _hslA.h += h2;
    _hslA.s += s2;
    _hslA.l += l2;
    this.setHSL(_hslA.h, _hslA.s, _hslA.l);
    return this;
  }
  add(color2) {
    this.r += color2.r;
    this.g += color2.g;
    this.b += color2.b;
    return this;
  }
  addColors(color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  }
  addScalar(s2) {
    this.r += s2;
    this.g += s2;
    this.b += s2;
    return this;
  }
  sub(color2) {
    this.r = Math.max(0, this.r - color2.r);
    this.g = Math.max(0, this.g - color2.g);
    this.b = Math.max(0, this.b - color2.b);
    return this;
  }
  multiply(color2) {
    this.r *= color2.r;
    this.g *= color2.g;
    this.b *= color2.b;
    return this;
  }
  multiplyScalar(s2) {
    this.r *= s2;
    this.g *= s2;
    this.b *= s2;
    return this;
  }
  lerp(color2, alpha) {
    this.r += (color2.r - this.r) * alpha;
    this.g += (color2.g - this.g) * alpha;
    this.b += (color2.b - this.b) * alpha;
    return this;
  }
  lerpColors(color1, color2, alpha) {
    this.r = color1.r + (color2.r - color1.r) * alpha;
    this.g = color1.g + (color2.g - color1.g) * alpha;
    this.b = color1.b + (color2.b - color1.b) * alpha;
    return this;
  }
  lerpHSL(color2, alpha) {
    this.getHSL(_hslA);
    color2.getHSL(_hslB);
    const h2 = lerp(_hslA.h, _hslB.h, alpha);
    const s2 = lerp(_hslA.s, _hslB.s, alpha);
    const l2 = lerp(_hslA.l, _hslB.l, alpha);
    this.setHSL(h2, s2, l2);
    return this;
  }
  equals(c2) {
    return c2.r === this.r && c2.g === this.g && c2.b === this.b;
  }
  fromArray(array, offset2 = 0) {
    this.r = array[offset2];
    this.g = array[offset2 + 1];
    this.b = array[offset2 + 2];
    return this;
  }
  toArray(array = [], offset2 = 0) {
    array[offset2] = this.r;
    array[offset2 + 1] = this.g;
    array[offset2 + 2] = this.b;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.r = attribute.getX(index);
    this.g = attribute.getY(index);
    this.b = attribute.getZ(index);
    if (attribute.normalized === true) {
      this.r /= 255;
      this.g /= 255;
      this.b /= 255;
    }
    return this;
  }
  toJSON() {
    return this.getHex();
  }
}
Color.NAMES = _colorKeywords;
Color.prototype.isColor = true;
Color.prototype.r = 1;
Color.prototype.g = 1;
Color.prototype.b = 1;
class MeshBasicMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshBasicMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.setValues(parameters);
  }
  copy(source3) {
    super.copy(source3);
    this.color.copy(source3.color);
    this.map = source3.map;
    this.lightMap = source3.lightMap;
    this.lightMapIntensity = source3.lightMapIntensity;
    this.aoMap = source3.aoMap;
    this.aoMapIntensity = source3.aoMapIntensity;
    this.specularMap = source3.specularMap;
    this.alphaMap = source3.alphaMap;
    this.envMap = source3.envMap;
    this.combine = source3.combine;
    this.reflectivity = source3.reflectivity;
    this.refractionRatio = source3.refractionRatio;
    this.wireframe = source3.wireframe;
    this.wireframeLinewidth = source3.wireframeLinewidth;
    this.wireframeLinecap = source3.wireframeLinecap;
    this.wireframeLinejoin = source3.wireframeLinejoin;
    return this;
  }
}
MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
const _vector$9 = /* @__PURE__ */ new Vector3();
const _vector2$1 = /* @__PURE__ */ new Vector2();
class BufferAttribute {
  constructor(array, itemSize, normalized) {
    if (Array.isArray(array)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.name = "";
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== void 0 ? array.length / itemSize : 0;
    this.normalized = normalized === true;
    this.usage = StaticDrawUsage;
    this.updateRange = { offset: 0, count: -1 };
    this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  copy(source3) {
    this.name = source3.name;
    this.array = new source3.array.constructor(source3.array);
    this.itemSize = source3.itemSize;
    this.count = source3.count;
    this.normalized = source3.normalized;
    this.usage = source3.usage;
    return this;
  }
  copyAt(index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;
    for (let i2 = 0, l2 = this.itemSize; i2 < l2; i2++) {
      this.array[index1 + i2] = attribute.array[index2 + i2];
    }
    return this;
  }
  copyArray(array) {
    this.array.set(array);
    return this;
  }
  copyColorsArray(colors) {
    const array = this.array;
    let offset2 = 0;
    for (let i2 = 0, l2 = colors.length; i2 < l2; i2++) {
      let color2 = colors[i2];
      if (color2 === void 0) {
        console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i2);
        color2 = new Color();
      }
      array[offset2++] = color2.r;
      array[offset2++] = color2.g;
      array[offset2++] = color2.b;
    }
    return this;
  }
  copyVector2sArray(vectors) {
    const array = this.array;
    let offset2 = 0;
    for (let i2 = 0, l2 = vectors.length; i2 < l2; i2++) {
      let vector = vectors[i2];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i2);
        vector = new Vector2();
      }
      array[offset2++] = vector.x;
      array[offset2++] = vector.y;
    }
    return this;
  }
  copyVector3sArray(vectors) {
    const array = this.array;
    let offset2 = 0;
    for (let i2 = 0, l2 = vectors.length; i2 < l2; i2++) {
      let vector = vectors[i2];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i2);
        vector = new Vector3();
      }
      array[offset2++] = vector.x;
      array[offset2++] = vector.y;
      array[offset2++] = vector.z;
    }
    return this;
  }
  copyVector4sArray(vectors) {
    const array = this.array;
    let offset2 = 0;
    for (let i2 = 0, l2 = vectors.length; i2 < l2; i2++) {
      let vector = vectors[i2];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i2);
        vector = new Vector4();
      }
      array[offset2++] = vector.x;
      array[offset2++] = vector.y;
      array[offset2++] = vector.z;
      array[offset2++] = vector.w;
    }
    return this;
  }
  applyMatrix3(m2) {
    if (this.itemSize === 2) {
      for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
        _vector2$1.fromBufferAttribute(this, i2);
        _vector2$1.applyMatrix3(m2);
        this.setXY(i2, _vector2$1.x, _vector2$1.y);
      }
    } else if (this.itemSize === 3) {
      for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
        _vector$9.fromBufferAttribute(this, i2);
        _vector$9.applyMatrix3(m2);
        this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
      }
    }
    return this;
  }
  applyMatrix4(m2) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$9.x = this.getX(i2);
      _vector$9.y = this.getY(i2);
      _vector$9.z = this.getZ(i2);
      _vector$9.applyMatrix4(m2);
      this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  applyNormalMatrix(m2) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$9.x = this.getX(i2);
      _vector$9.y = this.getY(i2);
      _vector$9.z = this.getZ(i2);
      _vector$9.applyNormalMatrix(m2);
      this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  transformDirection(m2) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$9.x = this.getX(i2);
      _vector$9.y = this.getY(i2);
      _vector$9.z = this.getZ(i2);
      _vector$9.transformDirection(m2);
      this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  set(value, offset2 = 0) {
    this.array.set(value, offset2);
    return this;
  }
  getX(index) {
    return this.array[index * this.itemSize];
  }
  setX(index, x2) {
    this.array[index * this.itemSize] = x2;
    return this;
  }
  getY(index) {
    return this.array[index * this.itemSize + 1];
  }
  setY(index, y2) {
    this.array[index * this.itemSize + 1] = y2;
    return this;
  }
  getZ(index) {
    return this.array[index * this.itemSize + 2];
  }
  setZ(index, z2) {
    this.array[index * this.itemSize + 2] = z2;
    return this;
  }
  getW(index) {
    return this.array[index * this.itemSize + 3];
  }
  setW(index, w2) {
    this.array[index * this.itemSize + 3] = w2;
    return this;
  }
  setXY(index, x2, y2) {
    index *= this.itemSize;
    this.array[index + 0] = x2;
    this.array[index + 1] = y2;
    return this;
  }
  setXYZ(index, x2, y2, z2) {
    index *= this.itemSize;
    this.array[index + 0] = x2;
    this.array[index + 1] = y2;
    this.array[index + 2] = z2;
    return this;
  }
  setXYZW(index, x2, y2, z2, w2) {
    index *= this.itemSize;
    this.array[index + 0] = x2;
    this.array[index + 1] = y2;
    this.array[index + 2] = z2;
    this.array[index + 3] = w2;
    return this;
  }
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const data = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.prototype.slice.call(this.array),
      normalized: this.normalized
    };
    if (this.name !== "")
      data.name = this.name;
    if (this.usage !== StaticDrawUsage)
      data.usage = this.usage;
    if (this.updateRange.offset !== 0 || this.updateRange.count !== -1)
      data.updateRange = this.updateRange;
    return data;
  }
}
BufferAttribute.prototype.isBufferAttribute = true;
class Uint16BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized);
  }
}
class Uint32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint32Array(array), itemSize, normalized);
  }
}
class Float16BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized);
  }
}
Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;
class Float32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Float32Array(array), itemSize, normalized);
  }
}
let _id = 0;
const _m1 = /* @__PURE__ */ new Matrix4();
const _obj = /* @__PURE__ */ new Object3D();
const _offset = /* @__PURE__ */ new Vector3();
const _box$1 = /* @__PURE__ */ new Box3();
const _boxMorphTargets = /* @__PURE__ */ new Box3();
const _vector$8 = /* @__PURE__ */ new Vector3();
class BufferGeometry extends EventDispatcher {
  constructor() {
    super();
    Object.defineProperty(this, "id", { value: _id++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "BufferGeometry";
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.morphTargetsRelative = false;
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = { start: 0, count: Infinity };
    this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(index) {
    if (Array.isArray(index)) {
      this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
    } else {
      this.index = index;
    }
    return this;
  }
  getAttribute(name2) {
    return this.attributes[name2];
  }
  setAttribute(name2, attribute) {
    this.attributes[name2] = attribute;
    return this;
  }
  deleteAttribute(name2) {
    delete this.attributes[name2];
    return this;
  }
  hasAttribute(name2) {
    return this.attributes[name2] !== void 0;
  }
  addGroup(start, count, materialIndex = 0) {
    this.groups.push({
      start,
      count,
      materialIndex
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  }
  applyMatrix4(matrix) {
    const position = this.attributes.position;
    if (position !== void 0) {
      position.applyMatrix4(matrix);
      position.needsUpdate = true;
    }
    const normal = this.attributes.normal;
    if (normal !== void 0) {
      const normalMatrix = new Matrix3().getNormalMatrix(matrix);
      normal.applyNormalMatrix(normalMatrix);
      normal.needsUpdate = true;
    }
    const tangent = this.attributes.tangent;
    if (tangent !== void 0) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  }
  applyQuaternion(q2) {
    _m1.makeRotationFromQuaternion(q2);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateX(angle) {
    _m1.makeRotationX(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateY(angle) {
    _m1.makeRotationY(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateZ(angle) {
    _m1.makeRotationZ(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  translate(x2, y2, z2) {
    _m1.makeTranslation(x2, y2, z2);
    this.applyMatrix4(_m1);
    return this;
  }
  scale(x2, y2, z2) {
    _m1.makeScale(x2, y2, z2);
    this.applyMatrix4(_m1);
    return this;
  }
  lookAt(vector) {
    _obj.lookAt(vector);
    _obj.updateMatrix();
    this.applyMatrix4(_obj.matrix);
    return this;
  }
  center() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  }
  setFromPoints(points) {
    const position = [];
    for (let i2 = 0, l2 = points.length; i2 < l2; i2++) {
      const point = points[i2];
      position.push(point.x, point.y, point.z || 0);
    }
    this.setAttribute("position", new Float32BufferAttribute(position, 3));
    return this;
  }
  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(Infinity, Infinity, Infinity));
      return;
    }
    if (position !== void 0) {
      this.boundingBox.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i2 = 0, il2 = morphAttributesPosition.length; i2 < il2; i2++) {
          const morphAttribute = morphAttributesPosition[i2];
          _box$1.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(this.boundingBox.min, _box$1.min);
            this.boundingBox.expandByPoint(_vector$8);
            _vector$8.addVectors(this.boundingBox.max, _box$1.max);
            this.boundingBox.expandByPoint(_vector$8);
          } else {
            this.boundingBox.expandByPoint(_box$1.min);
            this.boundingBox.expandByPoint(_box$1.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }
    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingSphere.set(new Vector3(), Infinity);
      return;
    }
    if (position) {
      const center = this.boundingSphere.center;
      _box$1.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i2 = 0, il2 = morphAttributesPosition.length; i2 < il2; i2++) {
          const morphAttribute = morphAttributesPosition[i2];
          _boxMorphTargets.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(_box$1.min, _boxMorphTargets.min);
            _box$1.expandByPoint(_vector$8);
            _vector$8.addVectors(_box$1.max, _boxMorphTargets.max);
            _box$1.expandByPoint(_vector$8);
          } else {
            _box$1.expandByPoint(_boxMorphTargets.min);
            _box$1.expandByPoint(_boxMorphTargets.max);
          }
        }
      }
      _box$1.getCenter(center);
      let maxRadiusSq = 0;
      for (let i2 = 0, il2 = position.count; i2 < il2; i2++) {
        _vector$8.fromBufferAttribute(position, i2);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
      }
      if (morphAttributesPosition) {
        for (let i2 = 0, il2 = morphAttributesPosition.length; i2 < il2; i2++) {
          const morphAttribute = morphAttributesPosition[i2];
          const morphTargetsRelative = this.morphTargetsRelative;
          for (let j2 = 0, jl2 = morphAttribute.count; j2 < jl2; j2++) {
            _vector$8.fromBufferAttribute(morphAttribute, j2);
            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position, j2);
              _vector$8.add(_offset);
            }
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
          }
        }
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      if (isNaN(this.boundingSphere.radius)) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  }
  computeTangents() {
    const index = this.index;
    const attributes = this.attributes;
    if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const indices = index.array;
    const positions = attributes.position.array;
    const normals = attributes.normal.array;
    const uvs = attributes.uv.array;
    const nVertices = positions.length / 3;
    if (attributes.tangent === void 0) {
      this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * nVertices), 4));
    }
    const tangents = attributes.tangent.array;
    const tan1 = [], tan2 = [];
    for (let i2 = 0; i2 < nVertices; i2++) {
      tan1[i2] = new Vector3();
      tan2[i2] = new Vector3();
    }
    const vA2 = new Vector3(), vB2 = new Vector3(), vC2 = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
    function handleTriangle(a2, b2, c2) {
      vA2.fromArray(positions, a2 * 3);
      vB2.fromArray(positions, b2 * 3);
      vC2.fromArray(positions, c2 * 3);
      uvA.fromArray(uvs, a2 * 2);
      uvB.fromArray(uvs, b2 * 2);
      uvC.fromArray(uvs, c2 * 2);
      vB2.sub(vA2);
      vC2.sub(vA2);
      uvB.sub(uvA);
      uvC.sub(uvA);
      const r2 = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
      if (!isFinite(r2))
        return;
      sdir.copy(vB2).multiplyScalar(uvC.y).addScaledVector(vC2, -uvB.y).multiplyScalar(r2);
      tdir.copy(vC2).multiplyScalar(uvB.x).addScaledVector(vB2, -uvC.x).multiplyScalar(r2);
      tan1[a2].add(sdir);
      tan1[b2].add(sdir);
      tan1[c2].add(sdir);
      tan2[a2].add(tdir);
      tan2[b2].add(tdir);
      tan2[c2].add(tdir);
    }
    let groups = this.groups;
    if (groups.length === 0) {
      groups = [{
        start: 0,
        count: indices.length
      }];
    }
    for (let i2 = 0, il2 = groups.length; i2 < il2; ++i2) {
      const group = groups[i2];
      const start = group.start;
      const count = group.count;
      for (let j2 = start, jl2 = start + count; j2 < jl2; j2 += 3) {
        handleTriangle(indices[j2 + 0], indices[j2 + 1], indices[j2 + 2]);
      }
    }
    const tmp2 = new Vector3(), tmp22 = new Vector3();
    const n2 = new Vector3(), n22 = new Vector3();
    function handleVertex(v2) {
      n2.fromArray(normals, v2 * 3);
      n22.copy(n2);
      const t2 = tan1[v2];
      tmp2.copy(t2);
      tmp2.sub(n2.multiplyScalar(n2.dot(t2))).normalize();
      tmp22.crossVectors(n22, t2);
      const test = tmp22.dot(tan2[v2]);
      const w2 = test < 0 ? -1 : 1;
      tangents[v2 * 4] = tmp2.x;
      tangents[v2 * 4 + 1] = tmp2.y;
      tangents[v2 * 4 + 2] = tmp2.z;
      tangents[v2 * 4 + 3] = w2;
    }
    for (let i2 = 0, il2 = groups.length; i2 < il2; ++i2) {
      const group = groups[i2];
      const start = group.start;
      const count = group.count;
      for (let j2 = start, jl2 = start + count; j2 < jl2; j2 += 3) {
        handleVertex(indices[j2 + 0]);
        handleVertex(indices[j2 + 1]);
        handleVertex(indices[j2 + 2]);
      }
    }
  }
  computeVertexNormals() {
    const index = this.index;
    const positionAttribute = this.getAttribute("position");
    if (positionAttribute !== void 0) {
      let normalAttribute = this.getAttribute("normal");
      if (normalAttribute === void 0) {
        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
        this.setAttribute("normal", normalAttribute);
      } else {
        for (let i2 = 0, il2 = normalAttribute.count; i2 < il2; i2++) {
          normalAttribute.setXYZ(i2, 0, 0, 0);
        }
      }
      const pA2 = new Vector3(), pB2 = new Vector3(), pC2 = new Vector3();
      const nA2 = new Vector3(), nB2 = new Vector3(), nC2 = new Vector3();
      const cb2 = new Vector3(), ab2 = new Vector3();
      if (index) {
        for (let i2 = 0, il2 = index.count; i2 < il2; i2 += 3) {
          const vA2 = index.getX(i2 + 0);
          const vB2 = index.getX(i2 + 1);
          const vC2 = index.getX(i2 + 2);
          pA2.fromBufferAttribute(positionAttribute, vA2);
          pB2.fromBufferAttribute(positionAttribute, vB2);
          pC2.fromBufferAttribute(positionAttribute, vC2);
          cb2.subVectors(pC2, pB2);
          ab2.subVectors(pA2, pB2);
          cb2.cross(ab2);
          nA2.fromBufferAttribute(normalAttribute, vA2);
          nB2.fromBufferAttribute(normalAttribute, vB2);
          nC2.fromBufferAttribute(normalAttribute, vC2);
          nA2.add(cb2);
          nB2.add(cb2);
          nC2.add(cb2);
          normalAttribute.setXYZ(vA2, nA2.x, nA2.y, nA2.z);
          normalAttribute.setXYZ(vB2, nB2.x, nB2.y, nB2.z);
          normalAttribute.setXYZ(vC2, nC2.x, nC2.y, nC2.z);
        }
      } else {
        for (let i2 = 0, il2 = positionAttribute.count; i2 < il2; i2 += 3) {
          pA2.fromBufferAttribute(positionAttribute, i2 + 0);
          pB2.fromBufferAttribute(positionAttribute, i2 + 1);
          pC2.fromBufferAttribute(positionAttribute, i2 + 2);
          cb2.subVectors(pC2, pB2);
          ab2.subVectors(pA2, pB2);
          cb2.cross(ab2);
          normalAttribute.setXYZ(i2 + 0, cb2.x, cb2.y, cb2.z);
          normalAttribute.setXYZ(i2 + 1, cb2.x, cb2.y, cb2.z);
          normalAttribute.setXYZ(i2 + 2, cb2.x, cb2.y, cb2.z);
        }
      }
      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  }
  merge(geometry2, offset2) {
    if (!(geometry2 && geometry2.isBufferGeometry)) {
      console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry2);
      return;
    }
    if (offset2 === void 0) {
      offset2 = 0;
      console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      if (geometry2.attributes[key] === void 0)
        continue;
      const attribute1 = attributes[key];
      const attributeArray1 = attribute1.array;
      const attribute2 = geometry2.attributes[key];
      const attributeArray2 = attribute2.array;
      const attributeOffset = attribute2.itemSize * offset2;
      const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
      for (let i2 = 0, j2 = attributeOffset; i2 < length; i2++, j2++) {
        attributeArray1[j2] = attributeArray2[i2];
      }
    }
    return this;
  }
  normalizeNormals() {
    const normals = this.attributes.normal;
    for (let i2 = 0, il2 = normals.count; i2 < il2; i2++) {
      _vector$8.fromBufferAttribute(normals, i2);
      _vector$8.normalize();
      normals.setXYZ(i2, _vector$8.x, _vector$8.y, _vector$8.z);
    }
  }
  toNonIndexed() {
    function convertBufferAttribute(attribute, indices2) {
      const array = attribute.array;
      const itemSize = attribute.itemSize;
      const normalized = attribute.normalized;
      const array2 = new array.constructor(indices2.length * itemSize);
      let index = 0, index2 = 0;
      for (let i2 = 0, l2 = indices2.length; i2 < l2; i2++) {
        if (attribute.isInterleavedBufferAttribute) {
          index = indices2[i2] * attribute.data.stride + attribute.offset;
        } else {
          index = indices2[i2] * itemSize;
        }
        for (let j2 = 0; j2 < itemSize; j2++) {
          array2[index2++] = array[index++];
        }
      }
      return new BufferAttribute(array2, itemSize, normalized);
    }
    if (this.index === null) {
      console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
      return this;
    }
    const geometry2 = new BufferGeometry();
    const indices = this.index.array;
    const attributes = this.attributes;
    for (const name2 in attributes) {
      const attribute = attributes[name2];
      const newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.setAttribute(name2, newAttribute);
    }
    const morphAttributes = this.morphAttributes;
    for (const name2 in morphAttributes) {
      const morphArray = [];
      const morphAttribute = morphAttributes[name2];
      for (let i2 = 0, il2 = morphAttribute.length; i2 < il2; i2++) {
        const attribute = morphAttribute[i2];
        const newAttribute = convertBufferAttribute(attribute, indices);
        morphArray.push(newAttribute);
      }
      geometry2.morphAttributes[name2] = morphArray;
    }
    geometry2.morphTargetsRelative = this.morphTargetsRelative;
    const groups = this.groups;
    for (let i2 = 0, l2 = groups.length; i2 < l2; i2++) {
      const group = groups[i2];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }
    return geometry2;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "")
      data.name = this.name;
    if (Object.keys(this.userData).length > 0)
      data.userData = this.userData;
    if (this.parameters !== void 0) {
      const parameters = this.parameters;
      for (const key in parameters) {
        if (parameters[key] !== void 0)
          data[key] = parameters[key];
      }
      return data;
    }
    data.data = { attributes: {} };
    const index = this.index;
    if (index !== null) {
      data.data.index = {
        type: index.array.constructor.name,
        array: Array.prototype.slice.call(index.array)
      };
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      const attribute = attributes[key];
      data.data.attributes[key] = attribute.toJSON(data.data);
    }
    const morphAttributes = {};
    let hasMorphAttributes = false;
    for (const key in this.morphAttributes) {
      const attributeArray = this.morphAttributes[key];
      const array = [];
      for (let i2 = 0, il2 = attributeArray.length; i2 < il2; i2++) {
        const attribute = attributeArray[i2];
        array.push(attribute.toJSON(data.data));
      }
      if (array.length > 0) {
        morphAttributes[key] = array;
        hasMorphAttributes = true;
      }
    }
    if (hasMorphAttributes) {
      data.data.morphAttributes = morphAttributes;
      data.data.morphTargetsRelative = this.morphTargetsRelative;
    }
    const groups = this.groups;
    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }
    const boundingSphere = this.boundingSphere;
    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }
    return data;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source3) {
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    const data = {};
    this.name = source3.name;
    const index = source3.index;
    if (index !== null) {
      this.setIndex(index.clone(data));
    }
    const attributes = source3.attributes;
    for (const name2 in attributes) {
      const attribute = attributes[name2];
      this.setAttribute(name2, attribute.clone(data));
    }
    const morphAttributes = source3.morphAttributes;
    for (const name2 in morphAttributes) {
      const array = [];
      const morphAttribute = morphAttributes[name2];
      for (let i2 = 0, l2 = morphAttribute.length; i2 < l2; i2++) {
        array.push(morphAttribute[i2].clone(data));
      }
      this.morphAttributes[name2] = array;
    }
    this.morphTargetsRelative = source3.morphTargetsRelative;
    const groups = source3.groups;
    for (let i2 = 0, l2 = groups.length; i2 < l2; i2++) {
      const group = groups[i2];
      this.addGroup(group.start, group.count, group.materialIndex);
    }
    const boundingBox = source3.boundingBox;
    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    }
    const boundingSphere = source3.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.drawRange.start = source3.drawRange.start;
    this.drawRange.count = source3.drawRange.count;
    this.userData = source3.userData;
    if (source3.parameters !== void 0)
      this.parameters = Object.assign({}, source3.parameters);
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
BufferGeometry.prototype.isBufferGeometry = true;
const _inverseMatrix$2 = /* @__PURE__ */ new Matrix4();
const _ray$2 = /* @__PURE__ */ new Ray();
const _sphere$3 = /* @__PURE__ */ new Sphere();
const _vA$1 = /* @__PURE__ */ new Vector3();
const _vB$1 = /* @__PURE__ */ new Vector3();
const _vC$1 = /* @__PURE__ */ new Vector3();
const _tempA = /* @__PURE__ */ new Vector3();
const _tempB = /* @__PURE__ */ new Vector3();
const _tempC = /* @__PURE__ */ new Vector3();
const _morphA = /* @__PURE__ */ new Vector3();
const _morphB = /* @__PURE__ */ new Vector3();
const _morphC = /* @__PURE__ */ new Vector3();
const _uvA$1 = /* @__PURE__ */ new Vector2();
const _uvB$1 = /* @__PURE__ */ new Vector2();
const _uvC$1 = /* @__PURE__ */ new Vector2();
const _intersectionPoint = /* @__PURE__ */ new Vector3();
const _intersectionPointWorld = /* @__PURE__ */ new Vector3();
class Mesh extends Object3D {
  constructor(geometry2 = new BufferGeometry(), material = new MeshBasicMaterial()) {
    super();
    this.type = "Mesh";
    this.geometry = geometry2;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source3) {
    super.copy(source3);
    if (source3.morphTargetInfluences !== void 0) {
      this.morphTargetInfluences = source3.morphTargetInfluences.slice();
    }
    if (source3.morphTargetDictionary !== void 0) {
      this.morphTargetDictionary = Object.assign({}, source3.morphTargetDictionary);
    }
    this.material = source3.material;
    this.geometry = source3.geometry;
    return this;
  }
  updateMorphTargets() {
    const geometry2 = this.geometry;
    if (geometry2.isBufferGeometry) {
      const morphAttributes = geometry2.morphAttributes;
      const keys2 = Object.keys(morphAttributes);
      if (keys2.length > 0) {
        const morphAttribute = morphAttributes[keys2[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m2 = 0, ml2 = morphAttribute.length; m2 < ml2; m2++) {
            const name2 = morphAttribute[m2].name || String(m2);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name2] = m2;
          }
        }
      }
    } else {
      const morphTargets = geometry2.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
  raycast(raycaster, intersects2) {
    const geometry2 = this.geometry;
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === void 0)
      return;
    if (geometry2.boundingSphere === null)
      geometry2.computeBoundingSphere();
    _sphere$3.copy(geometry2.boundingSphere);
    _sphere$3.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(_sphere$3) === false)
      return;
    _inverseMatrix$2.copy(matrixWorld).invert();
    _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
    if (geometry2.boundingBox !== null) {
      if (_ray$2.intersectsBox(geometry2.boundingBox) === false)
        return;
    }
    let intersection;
    if (geometry2.isBufferGeometry) {
      const index = geometry2.index;
      const position = geometry2.attributes.position;
      const morphPosition = geometry2.morphAttributes.position;
      const morphTargetsRelative = geometry2.morphTargetsRelative;
      const uv2 = geometry2.attributes.uv;
      const uv22 = geometry2.attributes.uv2;
      const groups = geometry2.groups;
      const drawRange = geometry2.drawRange;
      if (index !== null) {
        if (Array.isArray(material)) {
          for (let i2 = 0, il2 = groups.length; i2 < il2; i2++) {
            const group = groups[i2];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
            for (let j2 = start, jl2 = end; j2 < jl2; j2 += 3) {
              const a2 = index.getX(j2);
              const b2 = index.getX(j2 + 1);
              const c2 = index.getX(j2 + 2);
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv2, uv22, a2, b2, c2);
              if (intersection) {
                intersection.faceIndex = Math.floor(j2 / 3);
                intersection.face.materialIndex = group.materialIndex;
                intersects2.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(index.count, drawRange.start + drawRange.count);
          for (let i2 = start, il2 = end; i2 < il2; i2 += 3) {
            const a2 = index.getX(i2);
            const b2 = index.getX(i2 + 1);
            const c2 = index.getX(i2 + 2);
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv2, uv22, a2, b2, c2);
            if (intersection) {
              intersection.faceIndex = Math.floor(i2 / 3);
              intersects2.push(intersection);
            }
          }
        }
      } else if (position !== void 0) {
        if (Array.isArray(material)) {
          for (let i2 = 0, il2 = groups.length; i2 < il2; i2++) {
            const group = groups[i2];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
            for (let j2 = start, jl2 = end; j2 < jl2; j2 += 3) {
              const a2 = j2;
              const b2 = j2 + 1;
              const c2 = j2 + 2;
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv2, uv22, a2, b2, c2);
              if (intersection) {
                intersection.faceIndex = Math.floor(j2 / 3);
                intersection.face.materialIndex = group.materialIndex;
                intersects2.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(position.count, drawRange.start + drawRange.count);
          for (let i2 = start, il2 = end; i2 < il2; i2 += 3) {
            const a2 = i2;
            const b2 = i2 + 1;
            const c2 = i2 + 2;
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv2, uv22, a2, b2, c2);
            if (intersection) {
              intersection.faceIndex = Math.floor(i2 / 3);
              intersects2.push(intersection);
            }
          }
        }
      }
    } else if (geometry2.isGeometry) {
      console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
}
Mesh.prototype.isMesh = true;
function checkIntersection(object, material, raycaster, ray, pA2, pB2, pC2, point) {
  let intersect;
  if (material.side === BackSide) {
    intersect = ray.intersectTriangle(pC2, pB2, pA2, true, point);
  } else {
    intersect = ray.intersectTriangle(pA2, pB2, pC2, material.side !== DoubleSide, point);
  }
  if (intersect === null)
    return null;
  _intersectionPointWorld.copy(point);
  _intersectionPointWorld.applyMatrix4(object.matrixWorld);
  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance < raycaster.near || distance > raycaster.far)
    return null;
  return {
    distance,
    point: _intersectionPointWorld.clone(),
    object
  };
}
function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv2, uv22, a2, b2, c2) {
  _vA$1.fromBufferAttribute(position, a2);
  _vB$1.fromBufferAttribute(position, b2);
  _vC$1.fromBufferAttribute(position, c2);
  const morphInfluences = object.morphTargetInfluences;
  if (morphPosition && morphInfluences) {
    _morphA.set(0, 0, 0);
    _morphB.set(0, 0, 0);
    _morphC.set(0, 0, 0);
    for (let i2 = 0, il2 = morphPosition.length; i2 < il2; i2++) {
      const influence = morphInfluences[i2];
      const morphAttribute = morphPosition[i2];
      if (influence === 0)
        continue;
      _tempA.fromBufferAttribute(morphAttribute, a2);
      _tempB.fromBufferAttribute(morphAttribute, b2);
      _tempC.fromBufferAttribute(morphAttribute, c2);
      if (morphTargetsRelative) {
        _morphA.addScaledVector(_tempA, influence);
        _morphB.addScaledVector(_tempB, influence);
        _morphC.addScaledVector(_tempC, influence);
      } else {
        _morphA.addScaledVector(_tempA.sub(_vA$1), influence);
        _morphB.addScaledVector(_tempB.sub(_vB$1), influence);
        _morphC.addScaledVector(_tempC.sub(_vC$1), influence);
      }
    }
    _vA$1.add(_morphA);
    _vB$1.add(_morphB);
    _vC$1.add(_morphC);
  }
  if (object.isSkinnedMesh) {
    object.boneTransform(a2, _vA$1);
    object.boneTransform(b2, _vB$1);
    object.boneTransform(c2, _vC$1);
  }
  const intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
  if (intersection) {
    if (uv2) {
      _uvA$1.fromBufferAttribute(uv2, a2);
      _uvB$1.fromBufferAttribute(uv2, b2);
      _uvC$1.fromBufferAttribute(uv2, c2);
      intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
    }
    if (uv22) {
      _uvA$1.fromBufferAttribute(uv22, a2);
      _uvB$1.fromBufferAttribute(uv22, b2);
      _uvC$1.fromBufferAttribute(uv22, c2);
      intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
    }
    const face = {
      a: a2,
      b: b2,
      c: c2,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
    intersection.face = face;
  }
  return intersection;
}
class BoxGeometry extends BufferGeometry {
  constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
    super();
    this.type = "BoxGeometry";
    this.parameters = {
      width,
      height,
      depth,
      widthSegments,
      heightSegments,
      depthSegments
    };
    const scope = this;
    widthSegments = Math.floor(widthSegments);
    heightSegments = Math.floor(heightSegments);
    depthSegments = Math.floor(depthSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let numberOfVertices = 0;
    let groupStart = 0;
    buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
    buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
    buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
    buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
    buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
    buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function buildPlane(u2, v2, w2, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
      const segmentWidth = width2 / gridX;
      const segmentHeight = height2 / gridY;
      const widthHalf = width2 / 2;
      const heightHalf = height2 / 2;
      const depthHalf = depth2 / 2;
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      let vertexCounter = 0;
      let groupCount = 0;
      const vector = new Vector3();
      for (let iy2 = 0; iy2 < gridY1; iy2++) {
        const y2 = iy2 * segmentHeight - heightHalf;
        for (let ix2 = 0; ix2 < gridX1; ix2++) {
          const x2 = ix2 * segmentWidth - widthHalf;
          vector[u2] = x2 * udir;
          vector[v2] = y2 * vdir;
          vector[w2] = depthHalf;
          vertices.push(vector.x, vector.y, vector.z);
          vector[u2] = 0;
          vector[v2] = 0;
          vector[w2] = depth2 > 0 ? 1 : -1;
          normals.push(vector.x, vector.y, vector.z);
          uvs.push(ix2 / gridX);
          uvs.push(1 - iy2 / gridY);
          vertexCounter += 1;
        }
      }
      for (let iy2 = 0; iy2 < gridY; iy2++) {
        for (let ix2 = 0; ix2 < gridX; ix2++) {
          const a2 = numberOfVertices + ix2 + gridX1 * iy2;
          const b2 = numberOfVertices + ix2 + gridX1 * (iy2 + 1);
          const c2 = numberOfVertices + (ix2 + 1) + gridX1 * (iy2 + 1);
          const d2 = numberOfVertices + (ix2 + 1) + gridX1 * iy2;
          indices.push(a2, b2, d2);
          indices.push(b2, c2, d2);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, materialIndex);
      groupStart += groupCount;
      numberOfVertices += vertexCounter;
    }
  }
  static fromJSON(data) {
    return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
  }
}
function cloneUniforms(src) {
  const dst = {};
  for (const u2 in src) {
    dst[u2] = {};
    for (const p2 in src[u2]) {
      const property2 = src[u2][p2];
      if (property2 && (property2.isColor || property2.isMatrix3 || property2.isMatrix4 || property2.isVector2 || property2.isVector3 || property2.isVector4 || property2.isTexture || property2.isQuaternion)) {
        dst[u2][p2] = property2.clone();
      } else if (Array.isArray(property2)) {
        dst[u2][p2] = property2.slice();
      } else {
        dst[u2][p2] = property2;
      }
    }
  }
  return dst;
}
function mergeUniforms(uniforms) {
  const merged = {};
  for (let u2 = 0; u2 < uniforms.length; u2++) {
    const tmp2 = cloneUniforms(uniforms[u2]);
    for (const p2 in tmp2) {
      merged[p2] = tmp2[p2];
    }
  }
  return merged;
}
const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
class ShaderMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "ShaderMaterial";
    this.defines = {};
    this.uniforms = {};
    this.vertexShader = default_vertex;
    this.fragmentShader = default_fragment;
    this.linewidth = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.lights = false;
    this.clipping = false;
    this.extensions = {
      derivatives: false,
      fragDepth: false,
      drawBuffers: false,
      shaderTextureLOD: false
    };
    this.defaultAttributeValues = {
      "color": [1, 1, 1],
      "uv": [0, 0],
      "uv2": [0, 0]
    };
    this.index0AttributeName = void 0;
    this.uniformsNeedUpdate = false;
    this.glslVersion = null;
    if (parameters !== void 0) {
      if (parameters.attributes !== void 0) {
        console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
      }
      this.setValues(parameters);
    }
  }
  copy(source3) {
    super.copy(source3);
    this.fragmentShader = source3.fragmentShader;
    this.vertexShader = source3.vertexShader;
    this.uniforms = cloneUniforms(source3.uniforms);
    this.defines = Object.assign({}, source3.defines);
    this.wireframe = source3.wireframe;
    this.wireframeLinewidth = source3.wireframeLinewidth;
    this.lights = source3.lights;
    this.clipping = source3.clipping;
    this.extensions = Object.assign({}, source3.extensions);
    this.glslVersion = source3.glslVersion;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.glslVersion = this.glslVersion;
    data.uniforms = {};
    for (const name2 in this.uniforms) {
      const uniform = this.uniforms[name2];
      const value = uniform.value;
      if (value && value.isTexture) {
        data.uniforms[name2] = {
          type: "t",
          value: value.toJSON(meta).uuid
        };
      } else if (value && value.isColor) {
        data.uniforms[name2] = {
          type: "c",
          value: value.getHex()
        };
      } else if (value && value.isVector2) {
        data.uniforms[name2] = {
          type: "v2",
          value: value.toArray()
        };
      } else if (value && value.isVector3) {
        data.uniforms[name2] = {
          type: "v3",
          value: value.toArray()
        };
      } else if (value && value.isVector4) {
        data.uniforms[name2] = {
          type: "v4",
          value: value.toArray()
        };
      } else if (value && value.isMatrix3) {
        data.uniforms[name2] = {
          type: "m3",
          value: value.toArray()
        };
      } else if (value && value.isMatrix4) {
        data.uniforms[name2] = {
          type: "m4",
          value: value.toArray()
        };
      } else {
        data.uniforms[name2] = {
          value
        };
      }
    }
    if (Object.keys(this.defines).length > 0)
      data.defines = this.defines;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;
    const extensions = {};
    for (const key in this.extensions) {
      if (this.extensions[key] === true)
        extensions[key] = true;
    }
    if (Object.keys(extensions).length > 0)
      data.extensions = extensions;
    return data;
  }
}
ShaderMaterial.prototype.isShaderMaterial = true;
class Camera extends Object3D {
  constructor() {
    super();
    this.type = "Camera";
    this.matrixWorldInverse = new Matrix4();
    this.projectionMatrix = new Matrix4();
    this.projectionMatrixInverse = new Matrix4();
  }
  copy(source3, recursive) {
    super.copy(source3, recursive);
    this.matrixWorldInverse.copy(source3.matrixWorldInverse);
    this.projectionMatrix.copy(source3.projectionMatrix);
    this.projectionMatrixInverse.copy(source3.projectionMatrixInverse);
    return this;
  }
  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e20 = this.matrixWorld.elements;
    return target.set(-e20[8], -e20[9], -e20[10]).normalize();
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(updateParents, updateChildren) {
    super.updateWorldMatrix(updateParents, updateChildren);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
Camera.prototype.isCamera = true;
class PerspectiveCamera extends Camera {
  constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
    super();
    this.type = "PerspectiveCamera";
    this.fov = fov2;
    this.zoom = 1;
    this.near = near;
    this.far = far;
    this.focus = 10;
    this.aspect = aspect2;
    this.view = null;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix();
  }
  copy(source3, recursive) {
    super.copy(source3, recursive);
    this.fov = source3.fov;
    this.zoom = source3.zoom;
    this.near = source3.near;
    this.far = source3.far;
    this.focus = source3.focus;
    this.aspect = source3.aspect;
    this.view = source3.view === null ? null : Object.assign({}, source3.view);
    this.filmGauge = source3.filmGauge;
    this.filmOffset = source3.filmOffset;
    return this;
  }
  setFocalLength(focalLength) {
    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  }
  getFocalLength() {
    const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / vExtentSlope;
  }
  getEffectiveFOV() {
    return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(fullWidth, fullHeight, x2, y2, width, height) {
    this.aspect = fullWidth / fullHeight;
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x2;
    this.view.offsetY = y2;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const near = this.near;
    let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
    let height = 2 * top;
    let width = this.aspect * height;
    let left2 = -0.5 * width;
    const view = this.view;
    if (this.view !== null && this.view.enabled) {
      const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
      left2 += view.offsetX * width / fullWidth;
      top -= view.offsetY * height / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }
    const skew = this.filmOffset;
    if (skew !== 0)
      left2 += near * skew / this.getFilmWidth();
    this.projectionMatrix.makePerspective(left2, left2 + width, top, top - height, near, this.far);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.fov = this.fov;
    data.object.zoom = this.zoom;
    data.object.near = this.near;
    data.object.far = this.far;
    data.object.focus = this.focus;
    data.object.aspect = this.aspect;
    if (this.view !== null)
      data.object.view = Object.assign({}, this.view);
    data.object.filmGauge = this.filmGauge;
    data.object.filmOffset = this.filmOffset;
    return data;
  }
}
PerspectiveCamera.prototype.isPerspectiveCamera = true;
const fov = 90, aspect = 1;
class CubeCamera extends Object3D {
  constructor(near, far, renderTarget) {
    super();
    this.type = "CubeCamera";
    if (renderTarget.isWebGLCubeRenderTarget !== true) {
      console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
      return;
    }
    this.renderTarget = renderTarget;
    const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
    cameraPX.layers = this.layers;
    cameraPX.up.set(0, -1, 0);
    cameraPX.lookAt(new Vector3(1, 0, 0));
    this.add(cameraPX);
    const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
    cameraNX.layers = this.layers;
    cameraNX.up.set(0, -1, 0);
    cameraNX.lookAt(new Vector3(-1, 0, 0));
    this.add(cameraNX);
    const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
    cameraPY.layers = this.layers;
    cameraPY.up.set(0, 0, 1);
    cameraPY.lookAt(new Vector3(0, 1, 0));
    this.add(cameraPY);
    const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
    cameraNY.layers = this.layers;
    cameraNY.up.set(0, 0, -1);
    cameraNY.lookAt(new Vector3(0, -1, 0));
    this.add(cameraNY);
    const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.layers = this.layers;
    cameraPZ.up.set(0, -1, 0);
    cameraPZ.lookAt(new Vector3(0, 0, 1));
    this.add(cameraPZ);
    const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.layers = this.layers;
    cameraNZ.up.set(0, -1, 0);
    cameraNZ.lookAt(new Vector3(0, 0, -1));
    this.add(cameraNZ);
  }
  update(renderer, scene) {
    if (this.parent === null)
      this.updateMatrixWorld();
    const renderTarget = this.renderTarget;
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
    const currentXrEnabled = renderer.xr.enabled;
    const currentRenderTarget = renderer.getRenderTarget();
    renderer.xr.enabled = false;
    const generateMipmaps = renderTarget.texture.generateMipmaps;
    renderTarget.texture.generateMipmaps = false;
    renderer.setRenderTarget(renderTarget, 0);
    renderer.render(scene, cameraPX);
    renderer.setRenderTarget(renderTarget, 1);
    renderer.render(scene, cameraNX);
    renderer.setRenderTarget(renderTarget, 2);
    renderer.render(scene, cameraPY);
    renderer.setRenderTarget(renderTarget, 3);
    renderer.render(scene, cameraNY);
    renderer.setRenderTarget(renderTarget, 4);
    renderer.render(scene, cameraPZ);
    renderTarget.texture.generateMipmaps = generateMipmaps;
    renderer.setRenderTarget(renderTarget, 5);
    renderer.render(scene, cameraNZ);
    renderer.setRenderTarget(currentRenderTarget);
    renderer.xr.enabled = currentXrEnabled;
  }
}
class CubeTexture extends Texture {
  constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy, encoding) {
    images = images !== void 0 ? images : [];
    mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
    super(images, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy, encoding);
    this.flipY = false;
  }
  get images() {
    return this.image;
  }
  set images(value) {
    this.image = value;
  }
}
CubeTexture.prototype.isCubeTexture = true;
class WebGLCubeRenderTarget extends WebGLRenderTarget {
  constructor(size, options, dummy) {
    if (Number.isInteger(options)) {
      console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )");
      options = dummy;
    }
    super(size, size, options);
    options = options || {};
    this.texture = new CubeTexture(void 0, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
    this.texture.isRenderTargetTexture = true;
    this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
    this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
    this.texture._needsFlipEnvMap = false;
  }
  fromEquirectangularTexture(renderer, texture) {
    this.texture.type = texture.type;
    this.texture.format = RGBAFormat;
    this.texture.encoding = texture.encoding;
    this.texture.generateMipmaps = texture.generateMipmaps;
    this.texture.minFilter = texture.minFilter;
    this.texture.magFilter = texture.magFilter;
    const shader = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
      fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
    };
    const geometry2 = new BoxGeometry(5, 5, 5);
    const material = new ShaderMaterial({
      name: "CubemapFromEquirect",
      uniforms: cloneUniforms(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: BackSide,
      blending: NoBlending
    });
    material.uniforms.tEquirect.value = texture;
    const mesh = new Mesh(geometry2, material);
    const currentMinFilter = texture.minFilter;
    if (texture.minFilter === LinearMipmapLinearFilter)
      texture.minFilter = LinearFilter;
    const camera = new CubeCamera(1, 10, this);
    camera.update(renderer, mesh);
    texture.minFilter = currentMinFilter;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  }
  clear(renderer, color2, depth, stencil) {
    const currentRenderTarget = renderer.getRenderTarget();
    for (let i2 = 0; i2 < 6; i2++) {
      renderer.setRenderTarget(this, i2);
      renderer.clear(color2, depth, stencil);
    }
    renderer.setRenderTarget(currentRenderTarget);
  }
}
WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
const _vector1 = /* @__PURE__ */ new Vector3();
const _vector2 = /* @__PURE__ */ new Vector3();
const _normalMatrix = /* @__PURE__ */ new Matrix3();
class Plane {
  constructor(normal = new Vector3(1, 0, 0), constant = 0) {
    this.normal = normal;
    this.constant = constant;
  }
  set(normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  }
  setComponents(x2, y2, z2, w2) {
    this.normal.set(x2, y2, z2);
    this.constant = w2;
    return this;
  }
  setFromNormalAndCoplanarPoint(normal, point) {
    this.normal.copy(normal);
    this.constant = -point.dot(this.normal);
    return this;
  }
  setFromCoplanarPoints(a2, b2, c2) {
    const normal = _vector1.subVectors(c2, b2).cross(_vector2.subVectors(a2, b2)).normalize();
    this.setFromNormalAndCoplanarPoint(normal, a2);
    return this;
  }
  copy(plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  }
  normalize() {
    const inverseNormalLength = 1 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  }
  negate() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  }
  distanceToPoint(point) {
    return this.normal.dot(point) + this.constant;
  }
  distanceToSphere(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  }
  projectPoint(point, target) {
    return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
  }
  intersectLine(line, target) {
    const direction = line.delta(_vector1);
    const denominator = this.normal.dot(direction);
    if (denominator === 0) {
      if (this.distanceToPoint(line.start) === 0) {
        return target.copy(line.start);
      }
      return null;
    }
    const t2 = -(line.start.dot(this.normal) + this.constant) / denominator;
    if (t2 < 0 || t2 > 1) {
      return null;
    }
    return target.copy(direction).multiplyScalar(t2).add(line.start);
  }
  intersectsLine(line) {
    const startSign = this.distanceToPoint(line.start);
    const endSign = this.distanceToPoint(line.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  }
  intersectsBox(box) {
    return box.intersectsPlane(this);
  }
  intersectsSphere(sphere) {
    return sphere.intersectsPlane(this);
  }
  coplanarPoint(target) {
    return target.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(matrix, optionalNormalMatrix) {
    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
    const normal = this.normal.applyMatrix3(normalMatrix).normalize();
    this.constant = -referencePoint.dot(normal);
    return this;
  }
  translate(offset2) {
    this.constant -= offset2.dot(this.normal);
    return this;
  }
  equals(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
Plane.prototype.isPlane = true;
const _sphere$2 = /* @__PURE__ */ new Sphere();
const _vector$7 = /* @__PURE__ */ new Vector3();
class Frustum {
  constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
    this.planes = [p0, p1, p2, p3, p4, p5];
  }
  set(p0, p1, p2, p3, p4, p5) {
    const planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p2);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  }
  copy(frustum) {
    const planes = this.planes;
    for (let i2 = 0; i2 < 6; i2++) {
      planes[i2].copy(frustum.planes[i2]);
    }
    return this;
  }
  setFromProjectionMatrix(m2) {
    const planes = this.planes;
    const me2 = m2.elements;
    const me0 = me2[0], me1 = me2[1], me22 = me2[2], me3 = me2[3];
    const me4 = me2[4], me5 = me2[5], me6 = me2[6], me7 = me2[7];
    const me8 = me2[8], me9 = me2[9], me10 = me2[10], me11 = me2[11];
    const me12 = me2[12], me13 = me2[13], me14 = me2[14], me15 = me2[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me22, me7 - me6, me11 - me10, me15 - me14).normalize();
    planes[5].setComponents(me3 + me22, me7 + me6, me11 + me10, me15 + me14).normalize();
    return this;
  }
  intersectsObject(object) {
    const geometry2 = object.geometry;
    if (geometry2.boundingSphere === null)
      geometry2.computeBoundingSphere();
    _sphere$2.copy(geometry2.boundingSphere).applyMatrix4(object.matrixWorld);
    return this.intersectsSphere(_sphere$2);
  }
  intersectsSprite(sprite) {
    _sphere$2.center.set(0, 0, 0);
    _sphere$2.radius = 0.7071067811865476;
    _sphere$2.applyMatrix4(sprite.matrixWorld);
    return this.intersectsSphere(_sphere$2);
  }
  intersectsSphere(sphere) {
    const planes = this.planes;
    const center = sphere.center;
    const negRadius = -sphere.radius;
    for (let i2 = 0; i2 < 6; i2++) {
      const distance = planes[i2].distanceToPoint(center);
      if (distance < negRadius) {
        return false;
      }
    }
    return true;
  }
  intersectsBox(box) {
    const planes = this.planes;
    for (let i2 = 0; i2 < 6; i2++) {
      const plane = planes[i2];
      _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
      _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
      _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
      if (plane.distanceToPoint(_vector$7) < 0) {
        return false;
      }
    }
    return true;
  }
  containsPoint(point) {
    const planes = this.planes;
    for (let i2 = 0; i2 < 6; i2++) {
      if (planes[i2].distanceToPoint(point) < 0) {
        return false;
      }
    }
    return true;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function WebGLAnimation() {
  let context = null;
  let isAnimating = false;
  let animationLoop = null;
  let requestId = null;
  function onAnimationFrame(time, frame) {
    animationLoop(time, frame);
    requestId = context.requestAnimationFrame(onAnimationFrame);
  }
  return {
    start: function() {
      if (isAnimating === true)
        return;
      if (animationLoop === null)
        return;
      requestId = context.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function() {
      context.cancelAnimationFrame(requestId);
      isAnimating = false;
    },
    setAnimationLoop: function(callback) {
      animationLoop = callback;
    },
    setContext: function(value) {
      context = value;
    }
  };
}
function WebGLAttributes(gl2, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  const buffers = new WeakMap();
  function createBuffer(attribute, bufferType) {
    const array = attribute.array;
    const usage = attribute.usage;
    const buffer = gl2.createBuffer();
    gl2.bindBuffer(bufferType, buffer);
    gl2.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    let type = 5126;
    if (array instanceof Float32Array) {
      type = 5126;
    } else if (array instanceof Float64Array) {
      console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.");
    } else if (array instanceof Uint16Array) {
      if (attribute.isFloat16BufferAttribute) {
        if (isWebGL2) {
          type = 5131;
        } else {
          console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
        }
      } else {
        type = 5123;
      }
    } else if (array instanceof Int16Array) {
      type = 5122;
    } else if (array instanceof Uint32Array) {
      type = 5125;
    } else if (array instanceof Int32Array) {
      type = 5124;
    } else if (array instanceof Int8Array) {
      type = 5120;
    } else if (array instanceof Uint8Array) {
      type = 5121;
    } else if (array instanceof Uint8ClampedArray) {
      type = 5121;
    }
    return {
      buffer,
      type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version
    };
  }
  function updateBuffer(buffer, attribute, bufferType) {
    const array = attribute.array;
    const updateRange = attribute.updateRange;
    gl2.bindBuffer(bufferType, buffer);
    if (updateRange.count === -1) {
      gl2.bufferSubData(bufferType, 0, array);
    } else {
      if (isWebGL2) {
        gl2.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
      } else {
        gl2.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
      }
      updateRange.count = -1;
    }
  }
  function get2(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    return buffers.get(attribute);
  }
  function remove(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data) {
      gl2.deleteBuffer(data.buffer);
      buffers.delete(attribute);
    }
  }
  function update(attribute, bufferType) {
    if (attribute.isGLBufferAttribute) {
      const cached = buffers.get(attribute);
      if (!cached || cached.version < attribute.version) {
        buffers.set(attribute, {
          buffer: attribute.buffer,
          type: attribute.type,
          bytesPerElement: attribute.elementSize,
          version: attribute.version
        });
      }
      return;
    }
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data === void 0) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data.version < attribute.version) {
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }
  return {
    get: get2,
    remove,
    update
  };
}
class PlaneGeometry extends BufferGeometry {
  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
    super();
    this.type = "PlaneGeometry";
    this.parameters = {
      width,
      height,
      widthSegments,
      heightSegments
    };
    const width_half = width / 2;
    const height_half = height / 2;
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const segment_width = width / gridX;
    const segment_height = height / gridY;
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy2 = 0; iy2 < gridY1; iy2++) {
      const y2 = iy2 * segment_height - height_half;
      for (let ix2 = 0; ix2 < gridX1; ix2++) {
        const x2 = ix2 * segment_width - width_half;
        vertices.push(x2, -y2, 0);
        normals.push(0, 0, 1);
        uvs.push(ix2 / gridX);
        uvs.push(1 - iy2 / gridY);
      }
    }
    for (let iy2 = 0; iy2 < gridY; iy2++) {
      for (let ix2 = 0; ix2 < gridX; ix2++) {
        const a2 = ix2 + gridX1 * iy2;
        const b2 = ix2 + gridX1 * (iy2 + 1);
        const c2 = ix2 + 1 + gridX1 * (iy2 + 1);
        const d2 = ix2 + 1 + gridX1 * iy2;
        indices.push(a2, b2, d2);
        indices.push(b2, c2, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  static fromJSON(data) {
    return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
  }
}
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif";
var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
var color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n		vec2 f = fract( uv );\n		uv += 0.5 - f;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		if ( mipInt < cubeUV_maxMipLevel ) {\n			uv.y += 2.0 * cubeUV_maxTileSize;\n		}\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n		uv *= texelSize;\n		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x += texelSize;\n		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.y += texelSize;\n		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x -= texelSize;\n		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		vec3 tm = mix( tl, tr, f.x );\n		vec3 bm = mix( bl, br, f.x );\n		return mix( tm, bm, f.y );\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n		envColor = envMapTexelToLinear( envColor );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
var envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return texture2D( gradientMap, coord ).rgb;\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}";
var lightmap_fragment = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n	vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		lightMapIrradiance *= PI;\n	#endif\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointLightInfo( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotLightInfo( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif";
var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#else\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif";
var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 reflectVec;\n			#ifdef ENVMAP_MODE_REFLECTION\n				reflectVec = reflect( - viewDir, normal );\n				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			#else\n				reflectVec = refract( - viewDir, normal, refractionRatio );\n			#endif\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n#endif";
var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	#ifdef SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARCOLORMAP\n			specularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEENCOLORMAP\n		material.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEENROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n	#endif\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry.normal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
var map_fragment = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform vec2 morphTargetsTextureSize;\n		vec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n			float texelIndex = float( vertexIndex * stride + offset );\n			float y = floor( texelIndex / morphTargetsTextureSize.x );\n			float x = texelIndex - y * morphTargetsTextureSize.x;\n			vec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n			return texture( morphTargetsTexture, morphUV ).xyz;\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			#ifndef USE_MORPHNORMALS\n				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n			#else\n				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n			#endif\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif";
var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;";
var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
var normal_pars_fragment = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var normal_pars_vertex = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var normal_vertex = "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif";
var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif";
var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif";
var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif";
var output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var transmission_fragment = "#ifdef USE_TRANSMISSION\n	float transmissionAlpha = 1.0;\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmission = getIBLVolumeRefraction(\n		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationColor, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif";
var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( float roughness, float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		#ifdef TEXTURE_LOD_EXT\n			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#else\n			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#endif\n	}\n	vec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n		if ( attenuationDistance == 0.0 ) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n		vec3 attenuationColor, float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n	}\n#endif";
var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif";
var uv_pars_vertex = "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif";
var uv_vertex = "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif";
var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
const vertex$g = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
const fragment$g = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
const vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
const fragment$f = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
const vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
const fragment$e = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
const vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
const fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
const vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
const fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
const vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
const fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
const vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$9 = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$9 = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
const fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
const fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
const vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}";
const fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARCOLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEENCOLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEENROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
const fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
const vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
const vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
const fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
const ShaderChunk = {
  alphamap_fragment,
  alphamap_pars_fragment,
  alphatest_fragment,
  alphatest_pars_fragment,
  aomap_fragment,
  aomap_pars_fragment,
  begin_vertex,
  beginnormal_vertex,
  bsdfs,
  bumpmap_pars_fragment,
  clipping_planes_fragment,
  clipping_planes_pars_fragment,
  clipping_planes_pars_vertex,
  clipping_planes_vertex,
  color_fragment,
  color_pars_fragment,
  color_pars_vertex,
  color_vertex,
  common,
  cube_uv_reflection_fragment,
  defaultnormal_vertex,
  displacementmap_pars_vertex,
  displacementmap_vertex,
  emissivemap_fragment,
  emissivemap_pars_fragment,
  encodings_fragment,
  encodings_pars_fragment,
  envmap_fragment,
  envmap_common_pars_fragment,
  envmap_pars_fragment,
  envmap_pars_vertex,
  envmap_physical_pars_fragment,
  envmap_vertex,
  fog_vertex,
  fog_pars_vertex,
  fog_fragment,
  fog_pars_fragment,
  gradientmap_pars_fragment,
  lightmap_fragment,
  lightmap_pars_fragment,
  lights_lambert_vertex,
  lights_pars_begin,
  lights_toon_fragment,
  lights_toon_pars_fragment,
  lights_phong_fragment,
  lights_phong_pars_fragment,
  lights_physical_fragment,
  lights_physical_pars_fragment,
  lights_fragment_begin,
  lights_fragment_maps,
  lights_fragment_end,
  logdepthbuf_fragment,
  logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex,
  logdepthbuf_vertex,
  map_fragment,
  map_pars_fragment,
  map_particle_fragment,
  map_particle_pars_fragment,
  metalnessmap_fragment,
  metalnessmap_pars_fragment,
  morphnormal_vertex,
  morphtarget_pars_vertex,
  morphtarget_vertex,
  normal_fragment_begin,
  normal_fragment_maps,
  normal_pars_fragment,
  normal_pars_vertex,
  normal_vertex,
  normalmap_pars_fragment,
  clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps,
  clearcoat_pars_fragment,
  output_fragment,
  packing,
  premultiplied_alpha_fragment,
  project_vertex,
  dithering_fragment,
  dithering_pars_fragment,
  roughnessmap_fragment,
  roughnessmap_pars_fragment,
  shadowmap_pars_fragment,
  shadowmap_pars_vertex,
  shadowmap_vertex,
  shadowmask_pars_fragment,
  skinbase_vertex,
  skinning_pars_vertex,
  skinning_vertex,
  skinnormal_vertex,
  specularmap_fragment,
  specularmap_pars_fragment,
  tonemapping_fragment,
  tonemapping_pars_fragment,
  transmission_fragment,
  transmission_pars_fragment,
  uv_pars_fragment,
  uv_pars_vertex,
  uv_vertex,
  uv2_pars_fragment,
  uv2_pars_vertex,
  uv2_vertex,
  worldpos_vertex,
  background_vert: vertex$g,
  background_frag: fragment$g,
  cube_vert: vertex$f,
  cube_frag: fragment$f,
  depth_vert: vertex$e,
  depth_frag: fragment$e,
  distanceRGBA_vert: vertex$d,
  distanceRGBA_frag: fragment$d,
  equirect_vert: vertex$c,
  equirect_frag: fragment$c,
  linedashed_vert: vertex$b,
  linedashed_frag: fragment$b,
  meshbasic_vert: vertex$a,
  meshbasic_frag: fragment$a,
  meshlambert_vert: vertex$9,
  meshlambert_frag: fragment$9,
  meshmatcap_vert: vertex$8,
  meshmatcap_frag: fragment$8,
  meshnormal_vert: vertex$7,
  meshnormal_frag: fragment$7,
  meshphong_vert: vertex$6,
  meshphong_frag: fragment$6,
  meshphysical_vert: vertex$5,
  meshphysical_frag: fragment$5,
  meshtoon_vert: vertex$4,
  meshtoon_frag: fragment$4,
  points_vert: vertex$3,
  points_frag: fragment$3,
  shadow_vert: vertex$2,
  shadow_frag: fragment$2,
  sprite_vert: vertex$1,
  sprite_frag: fragment$1
};
const UniformsLib = {
  common: {
    diffuse: { value: new Color(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    uvTransform: { value: new Matrix3() },
    uv2Transform: { value: new Matrix3() },
    alphaMap: { value: null },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    ior: { value: 1.5 },
    refractionRatio: { value: 0.98 },
    maxMipLevel: { value: 0 }
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 }
  },
  emissivemap: {
    emissiveMap: { value: null }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalScale: { value: new Vector2(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  roughnessmap: {
    roughnessMap: { value: null }
  },
  metalnessmap: {
    metalnessMap: { value: null }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: new Color(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotShadowMap: { value: [] },
    spotShadowMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: new Color(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaTest: { value: 0 },
    uvTransform: { value: new Matrix3() }
  },
  sprite: {
    diffuse: { value: new Color(16777215) },
    opacity: { value: 1 },
    center: { value: new Vector2(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    alphaMap: { value: null },
    alphaTest: { value: 0 },
    uvTransform: { value: new Matrix3() }
  }
};
const ShaderLib = {
  basic: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) },
        specular: { value: new Color(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.roughnessmap,
      UniformsLib.metalnessmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  toon: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.gradientmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshtoon_vert,
    fragmentShader: ShaderChunk.meshtoon_frag
  },
  matcap: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: mergeUniforms([
      UniformsLib.points,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap
    ]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.meshnormal_vert,
    fragmentShader: ShaderChunk.meshnormal_frag
  },
  sprite: {
    uniforms: mergeUniforms([
      UniformsLib.sprite,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: new Matrix3() },
      t2D: { value: null }
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },
  cube: {
    uniforms: mergeUniforms([
      UniformsLib.envmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap,
      {
        referencePosition: { value: new Vector3() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: mergeUniforms([
      UniformsLib.lights,
      UniformsLib.fog,
      {
        color: { value: new Color(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
ShaderLib.physical = {
  uniforms: mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatNormalScale: { value: new Vector2(1, 1) },
      clearcoatNormalMap: { value: null },
      sheen: { value: 0 },
      sheenColor: { value: new Color(0) },
      sheenColorMap: { value: null },
      sheenRoughness: { value: 0 },
      sheenRoughnessMap: { value: null },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionSamplerSize: { value: new Vector2() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Color(0) },
      specularIntensity: { value: 0 },
      specularIntensityMap: { value: null },
      specularColor: { value: new Color(1, 1, 1) },
      specularColorMap: { value: null }
    }
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};
function WebGLBackground(renderer, cubemaps, state, objects, premultipliedAlpha) {
  const clearColor = new Color(0);
  let clearAlpha = 0;
  let planeMesh;
  let boxMesh;
  let currentBackground = null;
  let currentBackgroundVersion = 0;
  let currentTonemapping = null;
  function render2(renderList, scene) {
    let forceClear = false;
    let background = scene.isScene === true ? scene.background : null;
    if (background && background.isTexture) {
      background = cubemaps.get(background);
    }
    const xr2 = renderer.xr;
    const session = xr2.getSession && xr2.getSession();
    if (session && session.environmentBlendMode === "additive") {
      background = null;
    }
    if (background === null) {
      setClear(clearColor, clearAlpha);
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
    }
    if (renderer.autoClear || forceClear) {
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    }
    if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
      if (boxMesh === void 0) {
        boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
          name: "BackgroundCubeMaterial",
          uniforms: cloneUniforms(ShaderLib.cube.uniforms),
          vertexShader: ShaderLib.cube.vertexShader,
          fragmentShader: ShaderLib.cube.fragmentShader,
          side: BackSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        boxMesh.geometry.deleteAttribute("normal");
        boxMesh.geometry.deleteAttribute("uv");
        boxMesh.onBeforeRender = function(renderer2, scene2, camera) {
          this.matrixWorld.copyPosition(camera.matrixWorld);
        };
        Object.defineProperty(boxMesh.material, "envMap", {
          get: function() {
            return this.uniforms.envMap.value;
          }
        });
        objects.update(boxMesh);
      }
      boxMesh.material.uniforms.envMap.value = background;
      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === void 0) {
        planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
          name: "BackgroundMaterial",
          uniforms: cloneUniforms(ShaderLib.background.uniforms),
          vertexShader: ShaderLib.background.vertexShader,
          fragmentShader: ShaderLib.background.fragmentShader,
          side: FrontSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        planeMesh.geometry.deleteAttribute("normal");
        Object.defineProperty(planeMesh.material, "map", {
          get: function() {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }
      planeMesh.material.uniforms.t2D.value = background;
      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }
      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }
  function setClear(color2, alpha) {
    state.buffers.color.setClear(color2.r, color2.g, color2.b, alpha, premultipliedAlpha);
  }
  return {
    getClearColor: function() {
      return clearColor;
    },
    setClearColor: function(color2, alpha = 1) {
      clearColor.set(color2);
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function() {
      return clearAlpha;
    },
    setClearAlpha: function(alpha) {
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    render: render2
  };
}
function WebGLBindingStates(gl2, extensions, attributes, capabilities) {
  const maxVertexAttributes = gl2.getParameter(34921);
  const extension = capabilities.isWebGL2 ? null : extensions.get("OES_vertex_array_object");
  const vaoAvailable = capabilities.isWebGL2 || extension !== null;
  const bindingStates = {};
  const defaultState = createBindingState(null);
  let currentState = defaultState;
  function setup(object, material, program, geometry2, index) {
    let updateBuffers = false;
    if (vaoAvailable) {
      const state = getBindingState(geometry2, program, material);
      if (currentState !== state) {
        currentState = state;
        bindVertexArrayObject(currentState.object);
      }
      updateBuffers = needsUpdate(geometry2, index);
      if (updateBuffers)
        saveCache(geometry2, index);
    } else {
      const wireframe = material.wireframe === true;
      if (currentState.geometry !== geometry2.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
        currentState.geometry = geometry2.id;
        currentState.program = program.id;
        currentState.wireframe = wireframe;
        updateBuffers = true;
      }
    }
    if (object.isInstancedMesh === true) {
      updateBuffers = true;
    }
    if (index !== null) {
      attributes.update(index, 34963);
    }
    if (updateBuffers) {
      setupVertexAttributes(object, material, program, geometry2);
      if (index !== null) {
        gl2.bindBuffer(34963, attributes.get(index).buffer);
      }
    }
  }
  function createVertexArrayObject() {
    if (capabilities.isWebGL2)
      return gl2.createVertexArray();
    return extension.createVertexArrayOES();
  }
  function bindVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl2.bindVertexArray(vao);
    return extension.bindVertexArrayOES(vao);
  }
  function deleteVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl2.deleteVertexArray(vao);
    return extension.deleteVertexArrayOES(vao);
  }
  function getBindingState(geometry2, program, material) {
    const wireframe = material.wireframe === true;
    let programMap = bindingStates[geometry2.id];
    if (programMap === void 0) {
      programMap = {};
      bindingStates[geometry2.id] = programMap;
    }
    let stateMap = programMap[program.id];
    if (stateMap === void 0) {
      stateMap = {};
      programMap[program.id] = stateMap;
    }
    let state = stateMap[wireframe];
    if (state === void 0) {
      state = createBindingState(createVertexArrayObject());
      stateMap[wireframe] = state;
    }
    return state;
  }
  function createBindingState(vao) {
    const newAttributes = [];
    const enabledAttributes = [];
    const attributeDivisors = [];
    for (let i2 = 0; i2 < maxVertexAttributes; i2++) {
      newAttributes[i2] = 0;
      enabledAttributes[i2] = 0;
      attributeDivisors[i2] = 0;
    }
    return {
      geometry: null,
      program: null,
      wireframe: false,
      newAttributes,
      enabledAttributes,
      attributeDivisors,
      object: vao,
      attributes: {},
      index: null
    };
  }
  function needsUpdate(geometry2, index) {
    const cachedAttributes = currentState.attributes;
    const geometryAttributes = geometry2.attributes;
    let attributesNum = 0;
    for (const key in geometryAttributes) {
      const cachedAttribute = cachedAttributes[key];
      const geometryAttribute = geometryAttributes[key];
      if (cachedAttribute === void 0)
        return true;
      if (cachedAttribute.attribute !== geometryAttribute)
        return true;
      if (cachedAttribute.data !== geometryAttribute.data)
        return true;
      attributesNum++;
    }
    if (currentState.attributesNum !== attributesNum)
      return true;
    if (currentState.index !== index)
      return true;
    return false;
  }
  function saveCache(geometry2, index) {
    const cache = {};
    const attributes2 = geometry2.attributes;
    let attributesNum = 0;
    for (const key in attributes2) {
      const attribute = attributes2[key];
      const data = {};
      data.attribute = attribute;
      if (attribute.data) {
        data.data = attribute.data;
      }
      cache[key] = data;
      attributesNum++;
    }
    currentState.attributes = cache;
    currentState.attributesNum = attributesNum;
    currentState.index = index;
  }
  function initAttributes() {
    const newAttributes = currentState.newAttributes;
    for (let i2 = 0, il2 = newAttributes.length; i2 < il2; i2++) {
      newAttributes[i2] = 0;
    }
  }
  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }
  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    const attributeDivisors = currentState.attributeDivisors;
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
      gl2.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== meshPerAttribute) {
      const extension2 = capabilities.isWebGL2 ? gl2 : extensions.get("ANGLE_instanced_arrays");
      extension2[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }
  function disableUnusedAttributes() {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    for (let i2 = 0, il2 = enabledAttributes.length; i2 < il2; i2++) {
      if (enabledAttributes[i2] !== newAttributes[i2]) {
        gl2.disableVertexAttribArray(i2);
        enabledAttributes[i2] = 0;
      }
    }
  }
  function vertexAttribPointer(index, size, type, normalized, stride, offset2) {
    if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {
      gl2.vertexAttribIPointer(index, size, type, stride, offset2);
    } else {
      gl2.vertexAttribPointer(index, size, type, normalized, stride, offset2);
    }
  }
  function setupVertexAttributes(object, material, program, geometry2) {
    if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry2.isInstancedBufferGeometry)) {
      if (extensions.get("ANGLE_instanced_arrays") === null)
        return;
    }
    initAttributes();
    const geometryAttributes = geometry2.attributes;
    const programAttributes = program.getAttributes();
    const materialDefaultAttributeValues = material.defaultAttributeValues;
    for (const name2 in programAttributes) {
      const programAttribute = programAttributes[name2];
      if (programAttribute.location >= 0) {
        let geometryAttribute = geometryAttributes[name2];
        if (geometryAttribute === void 0) {
          if (name2 === "instanceMatrix" && object.instanceMatrix)
            geometryAttribute = object.instanceMatrix;
          if (name2 === "instanceColor" && object.instanceColor)
            geometryAttribute = object.instanceColor;
        }
        if (geometryAttribute !== void 0) {
          const normalized = geometryAttribute.normalized;
          const size = geometryAttribute.itemSize;
          const attribute = attributes.get(geometryAttribute);
          if (attribute === void 0)
            continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          const bytesPerElement = attribute.bytesPerElement;
          if (geometryAttribute.isInterleavedBufferAttribute) {
            const data = geometryAttribute.data;
            const stride = data.stride;
            const offset2 = geometryAttribute.offset;
            if (data && data.isInstancedInterleavedBuffer) {
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                enableAttributeAndDivisor(programAttribute.location + i2, data.meshPerAttribute);
              }
              if (object.isInstancedMesh !== true && geometry2._maxInstanceCount === void 0) {
                geometry2._maxInstanceCount = data.meshPerAttribute * data.count;
              }
            } else {
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                enableAttribute(programAttribute.location + i2);
              }
            }
            gl2.bindBuffer(34962, buffer);
            for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
              vertexAttribPointer(programAttribute.location + i2, size / programAttribute.locationSize, type, normalized, stride * bytesPerElement, (offset2 + size / programAttribute.locationSize * i2) * bytesPerElement);
            }
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                enableAttributeAndDivisor(programAttribute.location + i2, geometryAttribute.meshPerAttribute);
              }
              if (object.isInstancedMesh !== true && geometry2._maxInstanceCount === void 0) {
                geometry2._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                enableAttribute(programAttribute.location + i2);
              }
            }
            gl2.bindBuffer(34962, buffer);
            for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
              vertexAttribPointer(programAttribute.location + i2, size / programAttribute.locationSize, type, normalized, size * bytesPerElement, size / programAttribute.locationSize * i2 * bytesPerElement);
            }
          }
        } else if (materialDefaultAttributeValues !== void 0) {
          const value = materialDefaultAttributeValues[name2];
          if (value !== void 0) {
            switch (value.length) {
              case 2:
                gl2.vertexAttrib2fv(programAttribute.location, value);
                break;
              case 3:
                gl2.vertexAttrib3fv(programAttribute.location, value);
                break;
              case 4:
                gl2.vertexAttrib4fv(programAttribute.location, value);
                break;
              default:
                gl2.vertexAttrib1fv(programAttribute.location, value);
            }
          }
        }
      }
    }
    disableUnusedAttributes();
  }
  function dispose() {
    reset();
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometryId];
    }
  }
  function releaseStatesOfGeometry(geometry2) {
    if (bindingStates[geometry2.id] === void 0)
      return;
    const programMap = bindingStates[geometry2.id];
    for (const programId in programMap) {
      const stateMap = programMap[programId];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[programId];
    }
    delete bindingStates[geometry2.id];
  }
  function releaseStatesOfProgram(program) {
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      if (programMap[program.id] === void 0)
        continue;
      const stateMap = programMap[program.id];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[program.id];
    }
  }
  function reset() {
    resetDefaultState();
    if (currentState === defaultState)
      return;
    currentState = defaultState;
    bindVertexArrayObject(currentState.object);
  }
  function resetDefaultState() {
    defaultState.geometry = null;
    defaultState.program = null;
    defaultState.wireframe = false;
  }
  return {
    setup,
    reset,
    resetDefaultState,
    dispose,
    releaseStatesOfGeometry,
    releaseStatesOfProgram,
    initAttributes,
    enableAttribute,
    disableUnusedAttributes
  };
}
function WebGLBufferRenderer(gl2, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  function render2(start, count) {
    gl2.drawArrays(mode, start, count);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl2;
      methodName = "drawArraysInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawArraysInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, start, count, primcount);
    info.update(count, mode, primcount);
  }
  this.setMode = setMode;
  this.render = render2;
  this.renderInstances = renderInstances;
}
function WebGLCapabilities(gl2, extensions, parameters) {
  let maxAnisotropy;
  function getMaxAnisotropy() {
    if (maxAnisotropy !== void 0)
      return maxAnisotropy;
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      maxAnisotropy = gl2.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }
    return maxAnisotropy;
  }
  function getMaxPrecision(precision2) {
    if (precision2 === "highp") {
      if (gl2.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl2.getShaderPrecisionFormat(35632, 36338).precision > 0) {
        return "highp";
      }
      precision2 = "mediump";
    }
    if (precision2 === "mediump") {
      if (gl2.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl2.getShaderPrecisionFormat(35632, 36337).precision > 0) {
        return "mediump";
      }
    }
    return "lowp";
  }
  const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl2 instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== "undefined" && gl2 instanceof WebGL2ComputeRenderingContext;
  let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
  const maxPrecision = getMaxPrecision(precision);
  if (maxPrecision !== precision) {
    console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
    precision = maxPrecision;
  }
  const drawBuffers = isWebGL2 || extensions.has("WEBGL_draw_buffers");
  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  const maxTextures = gl2.getParameter(34930);
  const maxVertexTextures = gl2.getParameter(35660);
  const maxTextureSize = gl2.getParameter(3379);
  const maxCubemapSize = gl2.getParameter(34076);
  const maxAttributes = gl2.getParameter(34921);
  const maxVertexUniforms = gl2.getParameter(36347);
  const maxVaryings = gl2.getParameter(36348);
  const maxFragmentUniforms = gl2.getParameter(36349);
  const vertexTextures = maxVertexTextures > 0;
  const floatFragmentTextures = isWebGL2 || extensions.has("OES_texture_float");
  const floatVertexTextures = vertexTextures && floatFragmentTextures;
  const maxSamples = isWebGL2 ? gl2.getParameter(36183) : 0;
  return {
    isWebGL2,
    drawBuffers,
    getMaxAnisotropy,
    getMaxPrecision,
    precision,
    logarithmicDepthBuffer,
    maxTextures,
    maxVertexTextures,
    maxTextureSize,
    maxCubemapSize,
    maxAttributes,
    maxVertexUniforms,
    maxVaryings,
    maxFragmentUniforms,
    vertexTextures,
    floatFragmentTextures,
    floatVertexTextures,
    maxSamples
  };
}
function WebGLClipping(properties) {
  const scope = this;
  let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
  const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: false };
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;
  this.init = function(planes, enableLocalClipping, camera) {
    const enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    globalState = projectPlanes(planes, camera, 0);
    numGlobalPlanes = planes.length;
    return enabled;
  };
  this.beginShadows = function() {
    renderingShadows = true;
    projectPlanes(null);
  };
  this.endShadows = function() {
    renderingShadows = false;
    resetGlobalState();
  };
  this.setState = function(material, camera, useCache) {
    const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
    const materialProperties = properties.get(material);
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      if (renderingShadows) {
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
      let dstArray = materialProperties.clippingState || null;
      uniform.value = dstArray;
      dstArray = projectPlanes(planes, camera, lGlobal, useCache);
      for (let i2 = 0; i2 !== lGlobal; ++i2) {
        dstArray[i2] = globalState[i2];
      }
      materialProperties.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };
  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }
    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }
  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    const nPlanes = planes !== null ? planes.length : 0;
    let dstArray = null;
    if (nPlanes !== 0) {
      dstArray = uniform.value;
      if (skipTransform !== true || dstArray === null) {
        const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);
        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }
        for (let i2 = 0, i4 = dstOffset; i2 !== nPlanes; ++i2, i4 += 4) {
          plane.copy(planes[i2]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }
      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }
    scope.numPlanes = nPlanes;
    scope.numIntersection = 0;
    return dstArray;
  }
}
function WebGLCubeMaps(renderer) {
  let cubemaps = new WeakMap();
  function mapTextureMapping(texture, mapping) {
    if (mapping === EquirectangularReflectionMapping) {
      texture.mapping = CubeReflectionMapping;
    } else if (mapping === EquirectangularRefractionMapping) {
      texture.mapping = CubeRefractionMapping;
    }
    return texture;
  }
  function get2(texture) {
    if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
      const mapping = texture.mapping;
      if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
        if (cubemaps.has(texture)) {
          const cubemap = cubemaps.get(texture).texture;
          return mapTextureMapping(cubemap, texture.mapping);
        } else {
          const image = texture.image;
          if (image && image.height > 0) {
            const currentRenderTarget = renderer.getRenderTarget();
            const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
            renderTarget.fromEquirectangularTexture(renderer, texture);
            cubemaps.set(texture, renderTarget);
            renderer.setRenderTarget(currentRenderTarget);
            texture.addEventListener("dispose", onTextureDispose);
            return mapTextureMapping(renderTarget.texture, texture.mapping);
          } else {
            return null;
          }
        }
      }
    }
    return texture;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemap = cubemaps.get(texture);
    if (cubemap !== void 0) {
      cubemaps.delete(texture);
      cubemap.dispose();
    }
  }
  function dispose() {
    cubemaps = new WeakMap();
  }
  return {
    get: get2,
    dispose
  };
}
class OrthographicCamera extends Camera {
  constructor(left2 = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
    super();
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = left2;
    this.right = right;
    this.top = top;
    this.bottom = bottom;
    this.near = near;
    this.far = far;
    this.updateProjectionMatrix();
  }
  copy(source3, recursive) {
    super.copy(source3, recursive);
    this.left = source3.left;
    this.right = source3.right;
    this.top = source3.top;
    this.bottom = source3.bottom;
    this.near = source3.near;
    this.far = source3.far;
    this.zoom = source3.zoom;
    this.view = source3.view === null ? null : Object.assign({}, source3.view);
    return this;
  }
  setViewOffset(fullWidth, fullHeight, x2, y2, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x2;
    this.view.offsetY = y2;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const dx2 = (this.right - this.left) / (2 * this.zoom);
    const dy2 = (this.top - this.bottom) / (2 * this.zoom);
    const cx2 = (this.right + this.left) / 2;
    const cy2 = (this.top + this.bottom) / 2;
    let left2 = cx2 - dx2;
    let right = cx2 + dx2;
    let top = cy2 + dy2;
    let bottom = cy2 - dy2;
    if (this.view !== null && this.view.enabled) {
      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
      const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      left2 += scaleW * this.view.offsetX;
      right = left2 + scaleW * this.view.width;
      top -= scaleH * this.view.offsetY;
      bottom = top - scaleH * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(left2, right, top, bottom, this.near, this.far);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;
    if (this.view !== null)
      data.object.view = Object.assign({}, this.view);
    return data;
  }
}
OrthographicCamera.prototype.isOrthographicCamera = true;
class RawShaderMaterial extends ShaderMaterial {
  constructor(parameters) {
    super(parameters);
    this.type = "RawShaderMaterial";
  }
}
RawShaderMaterial.prototype.isRawShaderMaterial = true;
const LOD_MIN = 4;
const LOD_MAX = 8;
const SIZE_MAX = Math.pow(2, LOD_MAX);
const EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
const TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
const MAX_SAMPLES = 20;
const ENCODINGS = {
  [LinearEncoding]: 0,
  [sRGBEncoding]: 1,
  [RGBEEncoding]: 2,
  [RGBM7Encoding]: 3,
  [RGBM16Encoding]: 4,
  [RGBDEncoding]: 5,
  [GammaEncoding]: 6
};
const _flatCamera = /* @__PURE__ */ new OrthographicCamera();
const { _lodPlanes, _sizeLods, _sigmas } = /* @__PURE__ */ _createPlanes();
const _clearColor = /* @__PURE__ */ new Color();
let _oldTarget = null;
const PHI = (1 + Math.sqrt(5)) / 2;
const INV_PHI = 1 / PHI;
const _axisDirections = [
  /* @__PURE__ */ new Vector3(1, 1, 1),
  /* @__PURE__ */ new Vector3(-1, 1, 1),
  /* @__PURE__ */ new Vector3(1, 1, -1),
  /* @__PURE__ */ new Vector3(-1, 1, -1),
  /* @__PURE__ */ new Vector3(0, PHI, INV_PHI),
  /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI),
  /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0),
  /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0)
];
class PMREMGenerator {
  constructor(renderer) {
    this._renderer = renderer;
    this._pingPongRenderTarget = null;
    this._blurMaterial = _getBlurShader(MAX_SAMPLES);
    this._equirectShader = null;
    this._cubemapShader = null;
    this._compileMaterial(this._blurMaterial);
  }
  fromScene(scene, sigma = 0, near = 0.1, far = 100) {
    _oldTarget = this._renderer.getRenderTarget();
    const cubeUVRenderTarget = this._allocateTargets();
    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
    if (sigma > 0) {
      this._blur(cubeUVRenderTarget, 0, 0, sigma);
    }
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  fromEquirectangular(equirectangular) {
    return this._fromTexture(equirectangular);
  }
  fromCubemap(cubemap) {
    return this._fromTexture(cubemap);
  }
  compileCubemapShader() {
    if (this._cubemapShader === null) {
      this._cubemapShader = _getCubemapShader();
      this._compileMaterial(this._cubemapShader);
    }
  }
  compileEquirectangularShader() {
    if (this._equirectShader === null) {
      this._equirectShader = _getEquirectShader();
      this._compileMaterial(this._equirectShader);
    }
  }
  dispose() {
    this._blurMaterial.dispose();
    if (this._cubemapShader !== null)
      this._cubemapShader.dispose();
    if (this._equirectShader !== null)
      this._equirectShader.dispose();
    for (let i2 = 0; i2 < _lodPlanes.length; i2++) {
      _lodPlanes[i2].dispose();
    }
  }
  _cleanup(outputTarget) {
    this._pingPongRenderTarget.dispose();
    this._renderer.setRenderTarget(_oldTarget);
    outputTarget.scissorTest = false;
    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
  }
  _fromTexture(texture) {
    _oldTarget = this._renderer.getRenderTarget();
    const cubeUVRenderTarget = this._allocateTargets(texture);
    this._textureToCubeUV(texture, cubeUVRenderTarget);
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  _allocateTargets(texture) {
    const params = {
      magFilter: NearestFilter,
      minFilter: NearestFilter,
      generateMipmaps: false,
      type: UnsignedByteType,
      format: RGBEFormat,
      encoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,
      depthBuffer: false
    };
    const cubeUVRenderTarget = _createRenderTarget(params);
    cubeUVRenderTarget.depthBuffer = texture ? false : true;
    this._pingPongRenderTarget = _createRenderTarget(params);
    return cubeUVRenderTarget;
  }
  _compileMaterial(material) {
    const tmpMesh = new Mesh(_lodPlanes[0], material);
    this._renderer.compile(tmpMesh, _flatCamera);
  }
  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
    const fov2 = 90;
    const aspect2 = 1;
    const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);
    const upSign = [1, -1, 1, 1, 1, 1];
    const forwardSign = [1, 1, 1, -1, -1, -1];
    const renderer = this._renderer;
    const originalAutoClear = renderer.autoClear;
    const outputEncoding = renderer.outputEncoding;
    const toneMapping = renderer.toneMapping;
    renderer.getClearColor(_clearColor);
    renderer.toneMapping = NoToneMapping;
    renderer.outputEncoding = LinearEncoding;
    renderer.autoClear = false;
    const backgroundMaterial = new MeshBasicMaterial({
      name: "PMREM.Background",
      side: BackSide,
      depthWrite: false,
      depthTest: false
    });
    const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
    let useSolidColor = false;
    const background = scene.background;
    if (background) {
      if (background.isColor) {
        backgroundMaterial.color.copy(background);
        scene.background = null;
        useSolidColor = true;
      }
    } else {
      backgroundMaterial.color.copy(_clearColor);
      useSolidColor = true;
    }
    for (let i2 = 0; i2 < 6; i2++) {
      const col = i2 % 3;
      if (col == 0) {
        cubeCamera.up.set(0, upSign[i2], 0);
        cubeCamera.lookAt(forwardSign[i2], 0, 0);
      } else if (col == 1) {
        cubeCamera.up.set(0, 0, upSign[i2]);
        cubeCamera.lookAt(0, forwardSign[i2], 0);
      } else {
        cubeCamera.up.set(0, upSign[i2], 0);
        cubeCamera.lookAt(0, 0, forwardSign[i2]);
      }
      _setViewport(cubeUVRenderTarget, col * SIZE_MAX, i2 > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);
      renderer.setRenderTarget(cubeUVRenderTarget);
      if (useSolidColor) {
        renderer.render(backgroundBox, cubeCamera);
      }
      renderer.render(scene, cubeCamera);
    }
    backgroundBox.geometry.dispose();
    backgroundBox.material.dispose();
    renderer.toneMapping = toneMapping;
    renderer.outputEncoding = outputEncoding;
    renderer.autoClear = originalAutoClear;
    scene.background = background;
  }
  _setEncoding(uniform, texture) {
    if (this._renderer.capabilities.isWebGL2 === true && texture.format === RGBAFormat && texture.type === UnsignedByteType && texture.encoding === sRGBEncoding) {
      uniform.value = ENCODINGS[LinearEncoding];
    } else {
      uniform.value = ENCODINGS[texture.encoding];
    }
  }
  _textureToCubeUV(texture, cubeUVRenderTarget) {
    const renderer = this._renderer;
    const isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;
    if (isCubeTexture) {
      if (this._cubemapShader == null) {
        this._cubemapShader = _getCubemapShader();
      }
    } else {
      if (this._equirectShader == null) {
        this._equirectShader = _getEquirectShader();
      }
    }
    const material = isCubeTexture ? this._cubemapShader : this._equirectShader;
    const mesh = new Mesh(_lodPlanes[0], material);
    const uniforms = material.uniforms;
    uniforms["envMap"].value = texture;
    if (!isCubeTexture) {
      uniforms["texelSize"].value.set(1 / texture.image.width, 1 / texture.image.height);
    }
    this._setEncoding(uniforms["inputEncoding"], texture);
    this._setEncoding(uniforms["outputEncoding"], cubeUVRenderTarget.texture);
    _setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);
    renderer.setRenderTarget(cubeUVRenderTarget);
    renderer.render(mesh, _flatCamera);
  }
  _applyPMREM(cubeUVRenderTarget) {
    const renderer = this._renderer;
    const autoClear = renderer.autoClear;
    renderer.autoClear = false;
    for (let i2 = 1; i2 < TOTAL_LODS; i2++) {
      const sigma = Math.sqrt(_sigmas[i2] * _sigmas[i2] - _sigmas[i2 - 1] * _sigmas[i2 - 1]);
      const poleAxis = _axisDirections[(i2 - 1) % _axisDirections.length];
      this._blur(cubeUVRenderTarget, i2 - 1, i2, sigma, poleAxis);
    }
    renderer.autoClear = autoClear;
  }
  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
    const pingPongRenderTarget = this._pingPongRenderTarget;
    this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, "latitudinal", poleAxis);
    this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, "longitudinal", poleAxis);
  }
  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
    const renderer = this._renderer;
    const blurMaterial = this._blurMaterial;
    if (direction !== "latitudinal" && direction !== "longitudinal") {
      console.error("blur direction must be either latitudinal or longitudinal!");
    }
    const STANDARD_DEVIATIONS = 3;
    const blurMesh = new Mesh(_lodPlanes[lodOut], blurMaterial);
    const blurUniforms = blurMaterial.uniforms;
    const pixels = _sizeLods[lodIn] - 1;
    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
    const sigmaPixels = sigmaRadians / radiansPerPixel;
    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
    if (samples > MAX_SAMPLES) {
      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
    }
    const weights = [];
    let sum = 0;
    for (let i2 = 0; i2 < MAX_SAMPLES; ++i2) {
      const x3 = i2 / sigmaPixels;
      const weight = Math.exp(-x3 * x3 / 2);
      weights.push(weight);
      if (i2 == 0) {
        sum += weight;
      } else if (i2 < samples) {
        sum += 2 * weight;
      }
    }
    for (let i2 = 0; i2 < weights.length; i2++) {
      weights[i2] = weights[i2] / sum;
    }
    blurUniforms["envMap"].value = targetIn.texture;
    blurUniforms["samples"].value = samples;
    blurUniforms["weights"].value = weights;
    blurUniforms["latitudinal"].value = direction === "latitudinal";
    if (poleAxis) {
      blurUniforms["poleAxis"].value = poleAxis;
    }
    blurUniforms["dTheta"].value = radiansPerPixel;
    blurUniforms["mipInt"].value = LOD_MAX - lodIn;
    this._setEncoding(blurUniforms["inputEncoding"], targetIn.texture);
    this._setEncoding(blurUniforms["outputEncoding"], targetIn.texture);
    const outputSize = _sizeLods[lodOut];
    const x2 = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);
    const y2 = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);
    _setViewport(targetOut, x2, y2, 3 * outputSize, 2 * outputSize);
    renderer.setRenderTarget(targetOut);
    renderer.render(blurMesh, _flatCamera);
  }
}
function _isLDR(texture) {
  if (texture === void 0 || texture.type !== UnsignedByteType)
    return false;
  return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;
}
function _createPlanes() {
  const _lodPlanes2 = [];
  const _sizeLods2 = [];
  const _sigmas2 = [];
  let lod = LOD_MAX;
  for (let i2 = 0; i2 < TOTAL_LODS; i2++) {
    const sizeLod = Math.pow(2, lod);
    _sizeLods2.push(sizeLod);
    let sigma = 1 / sizeLod;
    if (i2 > LOD_MAX - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[i2 - LOD_MAX + LOD_MIN - 1];
    } else if (i2 == 0) {
      sigma = 0;
    }
    _sigmas2.push(sigma);
    const texelSize = 1 / (sizeLod - 1);
    const min2 = -texelSize / 2;
    const max2 = 1 + texelSize / 2;
    const uv1 = [min2, min2, max2, min2, max2, max2, min2, min2, max2, max2, min2, max2];
    const cubeFaces = 6;
    const vertices = 6;
    const positionSize = 3;
    const uvSize = 2;
    const faceIndexSize = 1;
    const position = new Float32Array(positionSize * vertices * cubeFaces);
    const uv2 = new Float32Array(uvSize * vertices * cubeFaces);
    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
    for (let face = 0; face < cubeFaces; face++) {
      const x2 = face % 3 * 2 / 3 - 1;
      const y2 = face > 2 ? 0 : -1;
      const coordinates = [
        x2,
        y2,
        0,
        x2 + 2 / 3,
        y2,
        0,
        x2 + 2 / 3,
        y2 + 1,
        0,
        x2,
        y2,
        0,
        x2 + 2 / 3,
        y2 + 1,
        0,
        x2,
        y2 + 1,
        0
      ];
      position.set(coordinates, positionSize * vertices * face);
      uv2.set(uv1, uvSize * vertices * face);
      const fill = [face, face, face, face, face, face];
      faceIndex.set(fill, faceIndexSize * vertices * face);
    }
    const planes = new BufferGeometry();
    planes.setAttribute("position", new BufferAttribute(position, positionSize));
    planes.setAttribute("uv", new BufferAttribute(uv2, uvSize));
    planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
    _lodPlanes2.push(planes);
    if (lod > LOD_MIN) {
      lod--;
    }
  }
  return { _lodPlanes: _lodPlanes2, _sizeLods: _sizeLods2, _sigmas: _sigmas2 };
}
function _createRenderTarget(params) {
  const cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);
  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
  cubeUVRenderTarget.scissorTest = true;
  return cubeUVRenderTarget;
}
function _setViewport(target, x2, y2, width, height) {
  target.viewport.set(x2, y2, width, height);
  target.scissor.set(x2, y2, width, height);
}
function _getBlurShader(maxSamples) {
  const weights = new Float32Array(maxSamples);
  const poleAxis = new Vector3(0, 1, 0);
  const shaderMaterial = new RawShaderMaterial({
    name: "SphericalGaussianBlur",
    defines: { "n": maxSamples },
    uniforms: {
      "envMap": { value: null },
      "samples": { value: 1 },
      "weights": { value: weights },
      "latitudinal": { value: false },
      "dTheta": { value: 0 },
      "mipInt": { value: 0 },
      "poleAxis": { value: poleAxis },
      "inputEncoding": { value: ENCODINGS[LinearEncoding] },
      "outputEncoding": { value: ENCODINGS[LinearEncoding] }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${_getEncodings()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getEquirectShader() {
  const texelSize = new Vector2(1, 1);
  const shaderMaterial = new RawShaderMaterial({
    name: "EquirectangularToCubeUV",
    uniforms: {
      "envMap": { value: null },
      "texelSize": { value: texelSize },
      "inputEncoding": { value: ENCODINGS[LinearEncoding] },
      "outputEncoding": { value: ENCODINGS[LinearEncoding] }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${_getEncodings()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getCubemapShader() {
  const shaderMaterial = new RawShaderMaterial({
    name: "CubemapToCubeUV",
    uniforms: {
      "envMap": { value: null },
      "inputEncoding": { value: ENCODINGS[LinearEncoding] },
      "outputEncoding": { value: ENCODINGS[LinearEncoding] }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${_getEncodings()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getCommonVertexShader() {
  return `

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function _getEncodings() {
  return `

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`;
}
function WebGLCubeUVMaps(renderer) {
  let cubeUVmaps = new WeakMap();
  let pmremGenerator = null;
  function get2(texture) {
    if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
      const mapping = texture.mapping;
      const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
      const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;
      if (isEquirectMap || isCubeMap) {
        if (cubeUVmaps.has(texture)) {
          return cubeUVmaps.get(texture).texture;
        } else {
          const image = texture.image;
          if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
            const currentRenderTarget = renderer.getRenderTarget();
            if (pmremGenerator === null)
              pmremGenerator = new PMREMGenerator(renderer);
            const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
            cubeUVmaps.set(texture, renderTarget);
            renderer.setRenderTarget(currentRenderTarget);
            texture.addEventListener("dispose", onTextureDispose);
            return renderTarget.texture;
          } else {
            return null;
          }
        }
      }
    }
    return texture;
  }
  function isCubeTextureComplete(image) {
    let count = 0;
    const length = 6;
    for (let i2 = 0; i2 < length; i2++) {
      if (image[i2] !== void 0)
        count++;
    }
    return count === length;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemapUV = cubeUVmaps.get(texture);
    if (cubemapUV !== void 0) {
      cubeUVmaps.delete(texture);
      cubemapUV.dispose();
    }
  }
  function dispose() {
    cubeUVmaps = new WeakMap();
    if (pmremGenerator !== null) {
      pmremGenerator.dispose();
      pmremGenerator = null;
    }
  }
  return {
    get: get2,
    dispose
  };
}
function WebGLExtensions(gl2) {
  const extensions = {};
  function getExtension(name2) {
    if (extensions[name2] !== void 0) {
      return extensions[name2];
    }
    let extension;
    switch (name2) {
      case "WEBGL_depth_texture":
        extension = gl2.getExtension("WEBGL_depth_texture") || gl2.getExtension("MOZ_WEBGL_depth_texture") || gl2.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        extension = gl2.getExtension("EXT_texture_filter_anisotropic") || gl2.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl2.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        extension = gl2.getExtension("WEBGL_compressed_texture_s3tc") || gl2.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl2.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        extension = gl2.getExtension("WEBGL_compressed_texture_pvrtc") || gl2.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        extension = gl2.getExtension(name2);
    }
    extensions[name2] = extension;
    return extension;
  }
  return {
    has: function(name2) {
      return getExtension(name2) !== null;
    },
    init: function(capabilities) {
      if (capabilities.isWebGL2) {
        getExtension("EXT_color_buffer_float");
      } else {
        getExtension("WEBGL_depth_texture");
        getExtension("OES_texture_float");
        getExtension("OES_texture_half_float");
        getExtension("OES_texture_half_float_linear");
        getExtension("OES_standard_derivatives");
        getExtension("OES_element_index_uint");
        getExtension("OES_vertex_array_object");
        getExtension("ANGLE_instanced_arrays");
      }
      getExtension("OES_texture_float_linear");
      getExtension("EXT_color_buffer_half_float");
    },
    get: function(name2) {
      const extension = getExtension(name2);
      if (extension === null) {
        console.warn("THREE.WebGLRenderer: " + name2 + " extension not supported.");
      }
      return extension;
    }
  };
}
function WebGLGeometries(gl2, attributes, info, bindingStates) {
  const geometries = {};
  const wireframeAttributes = new WeakMap();
  function onGeometryDispose(event) {
    const geometry2 = event.target;
    if (geometry2.index !== null) {
      attributes.remove(geometry2.index);
    }
    for (const name2 in geometry2.attributes) {
      attributes.remove(geometry2.attributes[name2]);
    }
    geometry2.removeEventListener("dispose", onGeometryDispose);
    delete geometries[geometry2.id];
    const attribute = wireframeAttributes.get(geometry2);
    if (attribute) {
      attributes.remove(attribute);
      wireframeAttributes.delete(geometry2);
    }
    bindingStates.releaseStatesOfGeometry(geometry2);
    if (geometry2.isInstancedBufferGeometry === true) {
      delete geometry2._maxInstanceCount;
    }
    info.memory.geometries--;
  }
  function get2(object, geometry2) {
    if (geometries[geometry2.id] === true)
      return geometry2;
    geometry2.addEventListener("dispose", onGeometryDispose);
    geometries[geometry2.id] = true;
    info.memory.geometries++;
    return geometry2;
  }
  function update(geometry2) {
    const geometryAttributes = geometry2.attributes;
    for (const name2 in geometryAttributes) {
      attributes.update(geometryAttributes[name2], 34962);
    }
    const morphAttributes = geometry2.morphAttributes;
    for (const name2 in morphAttributes) {
      const array = morphAttributes[name2];
      for (let i2 = 0, l2 = array.length; i2 < l2; i2++) {
        attributes.update(array[i2], 34962);
      }
    }
  }
  function updateWireframeAttribute(geometry2) {
    const indices = [];
    const geometryIndex = geometry2.index;
    const geometryPosition = geometry2.attributes.position;
    let version2 = 0;
    if (geometryIndex !== null) {
      const array = geometryIndex.array;
      version2 = geometryIndex.version;
      for (let i2 = 0, l2 = array.length; i2 < l2; i2 += 3) {
        const a2 = array[i2 + 0];
        const b2 = array[i2 + 1];
        const c2 = array[i2 + 2];
        indices.push(a2, b2, b2, c2, c2, a2);
      }
    } else {
      const array = geometryPosition.array;
      version2 = geometryPosition.version;
      for (let i2 = 0, l2 = array.length / 3 - 1; i2 < l2; i2 += 3) {
        const a2 = i2 + 0;
        const b2 = i2 + 1;
        const c2 = i2 + 2;
        indices.push(a2, b2, b2, c2, c2, a2);
      }
    }
    const attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attribute.version = version2;
    const previousAttribute = wireframeAttributes.get(geometry2);
    if (previousAttribute)
      attributes.remove(previousAttribute);
    wireframeAttributes.set(geometry2, attribute);
  }
  function getWireframeAttribute(geometry2) {
    const currentAttribute = wireframeAttributes.get(geometry2);
    if (currentAttribute) {
      const geometryIndex = geometry2.index;
      if (geometryIndex !== null) {
        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry2);
        }
      }
    } else {
      updateWireframeAttribute(geometry2);
    }
    return wireframeAttributes.get(geometry2);
  }
  return {
    get: get2,
    update,
    getWireframeAttribute
  };
}
function WebGLIndexedBufferRenderer(gl2, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  let type, bytesPerElement;
  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }
  function render2(start, count) {
    gl2.drawElements(mode, count, type, start * bytesPerElement);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl2;
      methodName = "drawElementsInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawElementsInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, count, type, start * bytesPerElement, primcount);
    info.update(count, mode, primcount);
  }
  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render2;
  this.renderInstances = renderInstances;
}
function WebGLInfo(gl2) {
  const memory = {
    geometries: 0,
    textures: 0
  };
  const render2 = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function update(count, mode, instanceCount) {
    render2.calls++;
    switch (mode) {
      case 4:
        render2.triangles += instanceCount * (count / 3);
        break;
      case 1:
        render2.lines += instanceCount * (count / 2);
        break;
      case 3:
        render2.lines += instanceCount * (count - 1);
        break;
      case 2:
        render2.lines += instanceCount * count;
        break;
      case 0:
        render2.points += instanceCount * count;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
        break;
    }
  }
  function reset() {
    render2.frame++;
    render2.calls = 0;
    render2.triangles = 0;
    render2.points = 0;
    render2.lines = 0;
  }
  return {
    memory,
    render: render2,
    programs: null,
    autoReset: true,
    reset,
    update
  };
}
class DataTexture2DArray extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.image = { data, width, height, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
  }
}
DataTexture2DArray.prototype.isDataTexture2DArray = true;
function numericalSort(a2, b2) {
  return a2[0] - b2[0];
}
function absNumericalSort(a2, b2) {
  return Math.abs(b2[1]) - Math.abs(a2[1]);
}
function denormalize(morph, attribute) {
  let denominator = 1;
  const array = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;
  if (array instanceof Int8Array)
    denominator = 127;
  else if (array instanceof Int16Array)
    denominator = 32767;
  else if (array instanceof Int32Array)
    denominator = 2147483647;
  else
    console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", array);
  morph.divideScalar(denominator);
}
function WebGLMorphtargets(gl2, capabilities, textures) {
  const influencesList = {};
  const morphInfluences = new Float32Array(8);
  const morphTextures = new WeakMap();
  const morph = new Vector3();
  const workInfluences = [];
  for (let i2 = 0; i2 < 8; i2++) {
    workInfluences[i2] = [i2, 0];
  }
  function update(object, geometry2, material, program) {
    const objectInfluences = object.morphTargetInfluences;
    if (capabilities.isWebGL2 === true) {
      const numberOfMorphTargets = geometry2.morphAttributes.position.length;
      let entry = morphTextures.get(geometry2);
      if (entry === void 0 || entry.count !== numberOfMorphTargets) {
        if (entry !== void 0)
          entry.texture.dispose();
        const hasMorphNormals = geometry2.morphAttributes.normal !== void 0;
        const morphTargets = geometry2.morphAttributes.position;
        const morphNormals = geometry2.morphAttributes.normal || [];
        const numberOfVertices = geometry2.attributes.position.count;
        const numberOfVertexData = hasMorphNormals === true ? 2 : 1;
        let width = numberOfVertices * numberOfVertexData;
        let height = 1;
        if (width > capabilities.maxTextureSize) {
          height = Math.ceil(width / capabilities.maxTextureSize);
          width = capabilities.maxTextureSize;
        }
        const buffer = new Float32Array(width * height * 4 * numberOfMorphTargets);
        const texture = new DataTexture2DArray(buffer, width, height, numberOfMorphTargets);
        texture.format = RGBAFormat;
        texture.type = FloatType;
        const vertexDataStride = numberOfVertexData * 4;
        for (let i2 = 0; i2 < numberOfMorphTargets; i2++) {
          const morphTarget = morphTargets[i2];
          const morphNormal = morphNormals[i2];
          const offset2 = width * height * 4 * i2;
          for (let j2 = 0; j2 < morphTarget.count; j2++) {
            morph.fromBufferAttribute(morphTarget, j2);
            if (morphTarget.normalized === true)
              denormalize(morph, morphTarget);
            const stride = j2 * vertexDataStride;
            buffer[offset2 + stride + 0] = morph.x;
            buffer[offset2 + stride + 1] = morph.y;
            buffer[offset2 + stride + 2] = morph.z;
            buffer[offset2 + stride + 3] = 0;
            if (hasMorphNormals === true) {
              morph.fromBufferAttribute(morphNormal, j2);
              if (morphNormal.normalized === true)
                denormalize(morph, morphNormal);
              buffer[offset2 + stride + 4] = morph.x;
              buffer[offset2 + stride + 5] = morph.y;
              buffer[offset2 + stride + 6] = morph.z;
              buffer[offset2 + stride + 7] = 0;
            }
          }
        }
        entry = {
          count: numberOfMorphTargets,
          texture,
          size: new Vector2(width, height)
        };
        morphTextures.set(geometry2, entry);
      }
      let morphInfluencesSum = 0;
      for (let i2 = 0; i2 < objectInfluences.length; i2++) {
        morphInfluencesSum += objectInfluences[i2];
      }
      const morphBaseInfluence = geometry2.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      program.getUniforms().setValue(gl2, "morphTargetBaseInfluence", morphBaseInfluence);
      program.getUniforms().setValue(gl2, "morphTargetInfluences", objectInfluences);
      program.getUniforms().setValue(gl2, "morphTargetsTexture", entry.texture, textures);
      program.getUniforms().setValue(gl2, "morphTargetsTextureSize", entry.size);
    } else {
      const length = objectInfluences === void 0 ? 0 : objectInfluences.length;
      let influences = influencesList[geometry2.id];
      if (influences === void 0 || influences.length !== length) {
        influences = [];
        for (let i2 = 0; i2 < length; i2++) {
          influences[i2] = [i2, 0];
        }
        influencesList[geometry2.id] = influences;
      }
      for (let i2 = 0; i2 < length; i2++) {
        const influence = influences[i2];
        influence[0] = i2;
        influence[1] = objectInfluences[i2];
      }
      influences.sort(absNumericalSort);
      for (let i2 = 0; i2 < 8; i2++) {
        if (i2 < length && influences[i2][1]) {
          workInfluences[i2][0] = influences[i2][0];
          workInfluences[i2][1] = influences[i2][1];
        } else {
          workInfluences[i2][0] = Number.MAX_SAFE_INTEGER;
          workInfluences[i2][1] = 0;
        }
      }
      workInfluences.sort(numericalSort);
      const morphTargets = geometry2.morphAttributes.position;
      const morphNormals = geometry2.morphAttributes.normal;
      let morphInfluencesSum = 0;
      for (let i2 = 0; i2 < 8; i2++) {
        const influence = workInfluences[i2];
        const index = influence[0];
        const value = influence[1];
        if (index !== Number.MAX_SAFE_INTEGER && value) {
          if (morphTargets && geometry2.getAttribute("morphTarget" + i2) !== morphTargets[index]) {
            geometry2.setAttribute("morphTarget" + i2, morphTargets[index]);
          }
          if (morphNormals && geometry2.getAttribute("morphNormal" + i2) !== morphNormals[index]) {
            geometry2.setAttribute("morphNormal" + i2, morphNormals[index]);
          }
          morphInfluences[i2] = value;
          morphInfluencesSum += value;
        } else {
          if (morphTargets && geometry2.hasAttribute("morphTarget" + i2) === true) {
            geometry2.deleteAttribute("morphTarget" + i2);
          }
          if (morphNormals && geometry2.hasAttribute("morphNormal" + i2) === true) {
            geometry2.deleteAttribute("morphNormal" + i2);
          }
          morphInfluences[i2] = 0;
        }
      }
      const morphBaseInfluence = geometry2.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      program.getUniforms().setValue(gl2, "morphTargetBaseInfluence", morphBaseInfluence);
      program.getUniforms().setValue(gl2, "morphTargetInfluences", morphInfluences);
    }
  }
  return {
    update
  };
}
function WebGLObjects(gl2, geometries, attributes, info) {
  let updateMap = new WeakMap();
  function update(object) {
    const frame = info.render.frame;
    const geometry2 = object.geometry;
    const buffergeometry = geometries.get(object, geometry2);
    if (updateMap.get(buffergeometry) !== frame) {
      geometries.update(buffergeometry);
      updateMap.set(buffergeometry, frame);
    }
    if (object.isInstancedMesh) {
      if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
        object.addEventListener("dispose", onInstancedMeshDispose);
      }
      attributes.update(object.instanceMatrix, 34962);
      if (object.instanceColor !== null) {
        attributes.update(object.instanceColor, 34962);
      }
    }
    return buffergeometry;
  }
  function dispose() {
    updateMap = new WeakMap();
  }
  function onInstancedMeshDispose(event) {
    const instancedMesh = event.target;
    instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
    attributes.remove(instancedMesh.instanceMatrix);
    if (instancedMesh.instanceColor !== null)
      attributes.remove(instancedMesh.instanceColor);
  }
  return {
    update,
    dispose
  };
}
class DataTexture3D extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.image = { data, width, height, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
  }
}
DataTexture3D.prototype.isDataTexture3D = true;
const emptyTexture = new Texture();
const emptyTexture2dArray = new DataTexture2DArray();
const emptyTexture3d = new DataTexture3D();
const emptyCubeTexture = new CubeTexture();
const arrayCacheF32 = [];
const arrayCacheI32 = [];
const mat4array = new Float32Array(16);
const mat3array = new Float32Array(9);
const mat2array = new Float32Array(4);
function flatten(array, nBlocks, blockSize) {
  const firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0)
    return array;
  const n2 = nBlocks * blockSize;
  let r2 = arrayCacheF32[n2];
  if (r2 === void 0) {
    r2 = new Float32Array(n2);
    arrayCacheF32[n2] = r2;
  }
  if (nBlocks !== 0) {
    firstElem.toArray(r2, 0);
    for (let i2 = 1, offset2 = 0; i2 !== nBlocks; ++i2) {
      offset2 += blockSize;
      array[i2].toArray(r2, offset2);
    }
  }
  return r2;
}
function arraysEqual(a2, b2) {
  if (a2.length !== b2.length)
    return false;
  for (let i2 = 0, l2 = a2.length; i2 < l2; i2++) {
    if (a2[i2] !== b2[i2])
      return false;
  }
  return true;
}
function copyArray(a2, b2) {
  for (let i2 = 0, l2 = b2.length; i2 < l2; i2++) {
    a2[i2] = b2[i2];
  }
}
function allocTexUnits(textures, n2) {
  let r2 = arrayCacheI32[n2];
  if (r2 === void 0) {
    r2 = new Int32Array(n2);
    arrayCacheI32[n2] = r2;
  }
  for (let i2 = 0; i2 !== n2; ++i2) {
    r2[i2] = textures.allocateTextureUnit();
  }
  return r2;
}
function setValueV1f(gl2, v2) {
  const cache = this.cache;
  if (cache[0] === v2)
    return;
  gl2.uniform1f(this.addr, v2);
  cache[0] = v2;
}
function setValueV2f(gl2, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y) {
      gl2.uniform2f(this.addr, v2.x, v2.y);
      cache[0] = v2.x;
      cache[1] = v2.y;
    }
  } else {
    if (arraysEqual(cache, v2))
      return;
    gl2.uniform2fv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV3f(gl2, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z) {
      gl2.uniform3f(this.addr, v2.x, v2.y, v2.z);
      cache[0] = v2.x;
      cache[1] = v2.y;
      cache[2] = v2.z;
    }
  } else if (v2.r !== void 0) {
    if (cache[0] !== v2.r || cache[1] !== v2.g || cache[2] !== v2.b) {
      gl2.uniform3f(this.addr, v2.r, v2.g, v2.b);
      cache[0] = v2.r;
      cache[1] = v2.g;
      cache[2] = v2.b;
    }
  } else {
    if (arraysEqual(cache, v2))
      return;
    gl2.uniform3fv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV4f(gl2, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z || cache[3] !== v2.w) {
      gl2.uniform4f(this.addr, v2.x, v2.y, v2.z, v2.w);
      cache[0] = v2.x;
      cache[1] = v2.y;
      cache[2] = v2.z;
      cache[3] = v2.w;
    }
  } else {
    if (arraysEqual(cache, v2))
      return;
    gl2.uniform4fv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueM2(gl2, v2) {
  const cache = this.cache;
  const elements = v2.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v2))
      return;
    gl2.uniformMatrix2fv(this.addr, false, v2);
    copyArray(cache, v2);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat2array.set(elements);
    gl2.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache, elements);
  }
}
function setValueM3(gl2, v2) {
  const cache = this.cache;
  const elements = v2.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v2))
      return;
    gl2.uniformMatrix3fv(this.addr, false, v2);
    copyArray(cache, v2);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat3array.set(elements);
    gl2.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache, elements);
  }
}
function setValueM4(gl2, v2) {
  const cache = this.cache;
  const elements = v2.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v2))
      return;
    gl2.uniformMatrix4fv(this.addr, false, v2);
    copyArray(cache, v2);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat4array.set(elements);
    gl2.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache, elements);
  }
}
function setValueV1i(gl2, v2) {
  const cache = this.cache;
  if (cache[0] === v2)
    return;
  gl2.uniform1i(this.addr, v2);
  cache[0] = v2;
}
function setValueV2i(gl2, v2) {
  const cache = this.cache;
  if (arraysEqual(cache, v2))
    return;
  gl2.uniform2iv(this.addr, v2);
  copyArray(cache, v2);
}
function setValueV3i(gl2, v2) {
  const cache = this.cache;
  if (arraysEqual(cache, v2))
    return;
  gl2.uniform3iv(this.addr, v2);
  copyArray(cache, v2);
}
function setValueV4i(gl2, v2) {
  const cache = this.cache;
  if (arraysEqual(cache, v2))
    return;
  gl2.uniform4iv(this.addr, v2);
  copyArray(cache, v2);
}
function setValueV1ui(gl2, v2) {
  const cache = this.cache;
  if (cache[0] === v2)
    return;
  gl2.uniform1ui(this.addr, v2);
  cache[0] = v2;
}
function setValueV2ui(gl2, v2) {
  const cache = this.cache;
  if (arraysEqual(cache, v2))
    return;
  gl2.uniform2uiv(this.addr, v2);
  copyArray(cache, v2);
}
function setValueV3ui(gl2, v2) {
  const cache = this.cache;
  if (arraysEqual(cache, v2))
    return;
  gl2.uniform3uiv(this.addr, v2);
  copyArray(cache, v2);
}
function setValueV4ui(gl2, v2) {
  const cache = this.cache;
  if (arraysEqual(cache, v2))
    return;
  gl2.uniform4uiv(this.addr, v2);
  copyArray(cache, v2);
}
function setValueT1(gl2, v2, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl2.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.safeSetTexture2D(v2 || emptyTexture, unit);
}
function setValueT3D1(gl2, v2, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl2.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture3D(v2 || emptyTexture3d, unit);
}
function setValueT6(gl2, v2, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl2.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.safeSetTextureCube(v2 || emptyCubeTexture, unit);
}
function setValueT2DArray1(gl2, v2, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl2.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture2DArray(v2 || emptyTexture2dArray, unit);
}
function getSingularSetter(type) {
  switch (type) {
    case 5126:
      return setValueV1f;
    case 35664:
      return setValueV2f;
    case 35665:
      return setValueV3f;
    case 35666:
      return setValueV4f;
    case 35674:
      return setValueM2;
    case 35675:
      return setValueM3;
    case 35676:
      return setValueM4;
    case 5124:
    case 35670:
      return setValueV1i;
    case 35667:
    case 35671:
      return setValueV2i;
    case 35668:
    case 35672:
      return setValueV3i;
    case 35669:
    case 35673:
      return setValueV4i;
    case 5125:
      return setValueV1ui;
    case 36294:
      return setValueV2ui;
    case 36295:
      return setValueV3ui;
    case 36296:
      return setValueV4ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArray1;
  }
}
function setValueV1fArray(gl2, v2) {
  gl2.uniform1fv(this.addr, v2);
}
function setValueV2fArray(gl2, v2) {
  const data = flatten(v2, this.size, 2);
  gl2.uniform2fv(this.addr, data);
}
function setValueV3fArray(gl2, v2) {
  const data = flatten(v2, this.size, 3);
  gl2.uniform3fv(this.addr, data);
}
function setValueV4fArray(gl2, v2) {
  const data = flatten(v2, this.size, 4);
  gl2.uniform4fv(this.addr, data);
}
function setValueM2Array(gl2, v2) {
  const data = flatten(v2, this.size, 4);
  gl2.uniformMatrix2fv(this.addr, false, data);
}
function setValueM3Array(gl2, v2) {
  const data = flatten(v2, this.size, 9);
  gl2.uniformMatrix3fv(this.addr, false, data);
}
function setValueM4Array(gl2, v2) {
  const data = flatten(v2, this.size, 16);
  gl2.uniformMatrix4fv(this.addr, false, data);
}
function setValueV1iArray(gl2, v2) {
  gl2.uniform1iv(this.addr, v2);
}
function setValueV2iArray(gl2, v2) {
  gl2.uniform2iv(this.addr, v2);
}
function setValueV3iArray(gl2, v2) {
  gl2.uniform3iv(this.addr, v2);
}
function setValueV4iArray(gl2, v2) {
  gl2.uniform4iv(this.addr, v2);
}
function setValueV1uiArray(gl2, v2) {
  gl2.uniform1uiv(this.addr, v2);
}
function setValueV2uiArray(gl2, v2) {
  gl2.uniform2uiv(this.addr, v2);
}
function setValueV3uiArray(gl2, v2) {
  gl2.uniform3uiv(this.addr, v2);
}
function setValueV4uiArray(gl2, v2) {
  gl2.uniform4uiv(this.addr, v2);
}
function setValueT1Array(gl2, v2, textures) {
  const n2 = v2.length;
  const units = allocTexUnits(textures, n2);
  gl2.uniform1iv(this.addr, units);
  for (let i2 = 0; i2 !== n2; ++i2) {
    textures.safeSetTexture2D(v2[i2] || emptyTexture, units[i2]);
  }
}
function setValueT6Array(gl2, v2, textures) {
  const n2 = v2.length;
  const units = allocTexUnits(textures, n2);
  gl2.uniform1iv(this.addr, units);
  for (let i2 = 0; i2 !== n2; ++i2) {
    textures.safeSetTextureCube(v2[i2] || emptyCubeTexture, units[i2]);
  }
}
function getPureArraySetter(type) {
  switch (type) {
    case 5126:
      return setValueV1fArray;
    case 35664:
      return setValueV2fArray;
    case 35665:
      return setValueV3fArray;
    case 35666:
      return setValueV4fArray;
    case 35674:
      return setValueM2Array;
    case 35675:
      return setValueM3Array;
    case 35676:
      return setValueM4Array;
    case 5124:
    case 35670:
      return setValueV1iArray;
    case 35667:
    case 35671:
      return setValueV2iArray;
    case 35668:
    case 35672:
      return setValueV3iArray;
    case 35669:
    case 35673:
      return setValueV4iArray;
    case 5125:
      return setValueV1uiArray;
    case 36294:
      return setValueV2uiArray;
    case 36295:
      return setValueV3uiArray;
    case 36296:
      return setValueV4uiArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1Array;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6Array;
  }
}
function SingleUniform(id2, activeInfo, addr) {
  this.id = id2;
  this.addr = addr;
  this.cache = [];
  this.setValue = getSingularSetter(activeInfo.type);
}
function PureArrayUniform(id2, activeInfo, addr) {
  this.id = id2;
  this.addr = addr;
  this.cache = [];
  this.size = activeInfo.size;
  this.setValue = getPureArraySetter(activeInfo.type);
}
PureArrayUniform.prototype.updateCache = function(data) {
  const cache = this.cache;
  if (data instanceof Float32Array && cache.length !== data.length) {
    this.cache = new Float32Array(data.length);
  }
  copyArray(cache, data);
};
function StructuredUniform(id2) {
  this.id = id2;
  this.seq = [];
  this.map = {};
}
StructuredUniform.prototype.setValue = function(gl2, value, textures) {
  const seq = this.seq;
  for (let i2 = 0, n2 = seq.length; i2 !== n2; ++i2) {
    const u2 = seq[i2];
    u2.setValue(gl2, value[u2.id], textures);
  }
};
const RePathPart = /(\w+)(\])?(\[|\.)?/g;
function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
  const path2 = activeInfo.name, pathLength = path2.length;
  RePathPart.lastIndex = 0;
  while (true) {
    const match5 = RePathPart.exec(path2), matchEnd = RePathPart.lastIndex;
    let id2 = match5[1];
    const idIsIndex = match5[2] === "]", subscript = match5[3];
    if (idIsIndex)
      id2 = id2 | 0;
    if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
      addUniform(container, subscript === void 0 ? new SingleUniform(id2, activeInfo, addr) : new PureArrayUniform(id2, activeInfo, addr));
      break;
    } else {
      const map2 = container.map;
      let next = map2[id2];
      if (next === void 0) {
        next = new StructuredUniform(id2);
        addUniform(container, next);
      }
      container = next;
    }
  }
}
function WebGLUniforms(gl2, program) {
  this.seq = [];
  this.map = {};
  const n2 = gl2.getProgramParameter(program, 35718);
  for (let i2 = 0; i2 < n2; ++i2) {
    const info = gl2.getActiveUniform(program, i2), addr = gl2.getUniformLocation(program, info.name);
    parseUniform(info, addr, this);
  }
}
WebGLUniforms.prototype.setValue = function(gl2, name2, value, textures) {
  const u2 = this.map[name2];
  if (u2 !== void 0)
    u2.setValue(gl2, value, textures);
};
WebGLUniforms.prototype.setOptional = function(gl2, object, name2) {
  const v2 = object[name2];
  if (v2 !== void 0)
    this.setValue(gl2, name2, v2);
};
WebGLUniforms.upload = function(gl2, seq, values, textures) {
  for (let i2 = 0, n2 = seq.length; i2 !== n2; ++i2) {
    const u2 = seq[i2], v2 = values[u2.id];
    if (v2.needsUpdate !== false) {
      u2.setValue(gl2, v2.value, textures);
    }
  }
};
WebGLUniforms.seqWithValue = function(seq, values) {
  const r2 = [];
  for (let i2 = 0, n2 = seq.length; i2 !== n2; ++i2) {
    const u2 = seq[i2];
    if (u2.id in values)
      r2.push(u2);
  }
  return r2;
};
function WebGLShader(gl2, type, string2) {
  const shader = gl2.createShader(type);
  gl2.shaderSource(shader, string2);
  gl2.compileShader(shader);
  return shader;
}
let programIdCount = 0;
function addLineNumbers(string2) {
  const lines = string2.split("\n");
  for (let i2 = 0; i2 < lines.length; i2++) {
    lines[i2] = i2 + 1 + ": " + lines[i2];
  }
  return lines.join("\n");
}
function getEncodingComponents(encoding) {
  switch (encoding) {
    case LinearEncoding:
      return ["Linear", "( value )"];
    case sRGBEncoding:
      return ["sRGB", "( value )"];
    case RGBEEncoding:
      return ["RGBE", "( value )"];
    case RGBM7Encoding:
      return ["RGBM", "( value, 7.0 )"];
    case RGBM16Encoding:
      return ["RGBM", "( value, 16.0 )"];
    case RGBDEncoding:
      return ["RGBD", "( value, 256.0 )"];
    case GammaEncoding:
      return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
    case LogLuvEncoding:
      return ["LogLuv", "( value )"];
    default:
      console.warn("THREE.WebGLProgram: Unsupported encoding:", encoding);
      return ["Linear", "( value )"];
  }
}
function getShaderErrors(gl2, shader, type) {
  const status = gl2.getShaderParameter(shader, 35713);
  const errors = gl2.getShaderInfoLog(shader).trim();
  if (status && errors === "")
    return "";
  return type.toUpperCase() + "\n\n" + errors + "\n\n" + addLineNumbers(gl2.getShaderSource(shader));
}
function getTexelDecodingFunction(functionName, encoding) {
  const components = getEncodingComponents(encoding);
  return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }";
}
function getTexelEncodingFunction(functionName, encoding) {
  const components = getEncodingComponents(encoding);
  return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
}
function getToneMappingFunction(functionName, toneMapping) {
  let toneMappingName;
  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = "Linear";
      break;
    case ReinhardToneMapping:
      toneMappingName = "Reinhard";
      break;
    case CineonToneMapping:
      toneMappingName = "OptimizedCineon";
      break;
    case ACESFilmicToneMapping:
      toneMappingName = "ACESFilmic";
      break;
    case CustomToneMapping:
      toneMappingName = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
      toneMappingName = "Linear";
  }
  return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
}
function generateExtensions(parameters) {
  const chunks = [
    parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ];
  return chunks.filter(filterEmptyLine).join("\n");
}
function generateDefines(defines) {
  const chunks = [];
  for (const name2 in defines) {
    const value = defines[name2];
    if (value === false)
      continue;
    chunks.push("#define " + name2 + " " + value);
  }
  return chunks.join("\n");
}
function fetchAttributeLocations(gl2, program) {
  const attributes = {};
  const n2 = gl2.getProgramParameter(program, 35721);
  for (let i2 = 0; i2 < n2; i2++) {
    const info = gl2.getActiveAttrib(program, i2);
    const name2 = info.name;
    let locationSize = 1;
    if (info.type === 35674)
      locationSize = 2;
    if (info.type === 35675)
      locationSize = 3;
    if (info.type === 35676)
      locationSize = 4;
    attributes[name2] = {
      type: info.type,
      location: gl2.getAttribLocation(program, name2),
      locationSize
    };
  }
  return attributes;
}
function filterEmptyLine(string2) {
  return string2 !== "";
}
function replaceLightNums(string2, parameters) {
  return string2.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string2, parameters) {
  return string2.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(string2) {
  return string2.replace(includePattern, includeReplacer);
}
function includeReplacer(match5, include) {
  const string2 = ShaderChunk[include];
  if (string2 === void 0) {
    throw new Error("Can not resolve #include <" + include + ">");
  }
  return resolveIncludes(string2);
}
const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(string2) {
  return string2.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
}
function deprecatedLoopReplacer(match5, start, end, snippet) {
  console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.");
  return loopReplacer(match5, start, end, snippet);
}
function loopReplacer(match5, start, end, snippet) {
  let string2 = "";
  for (let i2 = parseInt(start); i2 < parseInt(end); i2++) {
    string2 += snippet.replace(/\[\s*i\s*\]/g, "[ " + i2 + " ]").replace(/UNROLLED_LOOP_INDEX/g, i2);
  }
  return string2;
}
function generatePrecision(parameters) {
  let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
  if (parameters.precision === "highp") {
    precisionstring += "\n#define HIGH_PRECISION";
  } else if (parameters.precision === "mediump") {
    precisionstring += "\n#define MEDIUM_PRECISION";
  } else if (parameters.precision === "lowp") {
    precisionstring += "\n#define LOW_PRECISION";
  }
  return precisionstring;
}
function generateShadowMapTypeDefine(parameters) {
  let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
  } else if (parameters.shadowMapType === VSMShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
  }
  return shadowMapTypeDefine;
}
function generateEnvMapTypeDefine(parameters) {
  let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
      case CubeUVRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  }
  return envMapTypeDefine;
}
function generateEnvMapModeDefine(parameters) {
  let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeRefractionMapping:
      case CubeUVRefractionMapping:
        envMapModeDefine = "ENVMAP_MODE_REFRACTION";
        break;
    }
  }
  return envMapModeDefine;
}
function generateEnvMapBlendingDefine(parameters) {
  let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
  if (parameters.envMap) {
    switch (parameters.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
        break;
    }
  }
  return envMapBlendingDefine;
}
function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
  const gl2 = renderer.getContext();
  const defines = parameters.defines;
  let vertexShader = parameters.vertexShader;
  let fragmentShader = parameters.fragmentShader;
  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
  const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
  const envMapModeDefine = generateEnvMapModeDefine(parameters);
  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
  const gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1;
  const customExtensions = parameters.isWebGL2 ? "" : generateExtensions(parameters);
  const customDefines = generateDefines(defines);
  const program = gl2.createProgram();
  let prefixVertex, prefixFragment;
  let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
  if (parameters.isRawShaderMaterial) {
    prefixVertex = [
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixVertex.length > 0) {
      prefixVertex += "\n";
    }
    prefixFragment = [
      customExtensions,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixFragment.length > 0) {
      prefixFragment += "\n";
    }
  } else {
    prefixVertex = [
      generatePrecision(parameters),
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.instancing ? "#define USE_INSTANCING" : "",
      parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
      parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
      "#define GAMMA_FACTOR " + gammaFactorDefine,
      "#define MAX_BONES " + parameters.maxBones,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUvs ? "#define USE_UV" : "",
      parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.skinning ? "#define USE_SKINNING" : "",
      parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",
      parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
      parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
      parameters.morphTargets && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
      parameters.morphTargets && parameters.isWebGL2 ? "#define MORPHTARGETS_COUNT " + parameters.morphTargetsCount : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      "#ifdef USE_INSTANCING",
      "	attribute mat4 instanceMatrix;",
      "#endif",
      "#ifdef USE_INSTANCING_COLOR",
      "	attribute vec3 instanceColor;",
      "#endif",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_TANGENT",
      "	attribute vec4 tangent;",
      "#endif",
      "#if defined( USE_COLOR_ALPHA )",
      "	attribute vec4 color;",
      "#elif defined( USE_COLOR )",
      "	attribute vec3 color;",
      "#endif",
      "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
      "	attribute vec3 morphTarget0;",
      "	attribute vec3 morphTarget1;",
      "	attribute vec3 morphTarget2;",
      "	attribute vec3 morphTarget3;",
      "	#ifdef USE_MORPHNORMALS",
      "		attribute vec3 morphNormal0;",
      "		attribute vec3 morphNormal1;",
      "		attribute vec3 morphNormal2;",
      "		attribute vec3 morphNormal3;",
      "	#else",
      "		attribute vec3 morphTarget4;",
      "		attribute vec3 morphTarget5;",
      "		attribute vec3 morphTarget6;",
      "		attribute vec3 morphTarget7;",
      "	#endif",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      "\n"
    ].filter(filterEmptyLine).join("\n");
    prefixFragment = [
      customExtensions,
      generatePrecision(parameters),
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      "#define GAMMA_FACTOR " + gammaFactorDefine,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.matcap ? "#define USE_MATCAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapTypeDefine : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.envMap ? "#define " + envMapBlendingDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      parameters.clearcoat ? "#define USE_CLEARCOAT" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.alphaTest ? "#define USE_ALPHATEST" : "",
      parameters.sheen ? "#define USE_SHEEN" : "",
      parameters.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUvs ? "#define USE_UV" : "",
      parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
      parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
      parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
      parameters.dithering ? "#define DITHERING" : "",
      parameters.format === RGBFormat ? "#define OPAQUE" : "",
      ShaderChunk["encodings_pars_fragment"],
      parameters.map ? getTexelDecodingFunction("mapTexelToLinear", parameters.mapEncoding) : "",
      parameters.matcap ? getTexelDecodingFunction("matcapTexelToLinear", parameters.matcapEncoding) : "",
      parameters.envMap ? getTexelDecodingFunction("envMapTexelToLinear", parameters.envMapEncoding) : "",
      parameters.emissiveMap ? getTexelDecodingFunction("emissiveMapTexelToLinear", parameters.emissiveMapEncoding) : "",
      parameters.specularColorMap ? getTexelDecodingFunction("specularColorMapTexelToLinear", parameters.specularColorMapEncoding) : "",
      parameters.sheenColorMap ? getTexelDecodingFunction("sheenColorMapTexelToLinear", parameters.sheenColorMapEncoding) : "",
      parameters.lightMap ? getTexelDecodingFunction("lightMapTexelToLinear", parameters.lightMapEncoding) : "",
      getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding),
      parameters.depthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
      "\n"
    ].filter(filterEmptyLine).join("\n");
  }
  vertexShader = resolveIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = resolveIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);
  if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
    versionString = "#version 300 es\n";
    prefixVertex = [
      "precision mediump sampler2DArray;",
      "#define attribute in",
      "#define varying out",
      "#define texture2D texture"
    ].join("\n") + "\n" + prefixVertex;
    prefixFragment = [
      "#define varying in",
      parameters.glslVersion === GLSL3 ? "" : "out highp vec4 pc_fragColor;",
      parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
      "#define gl_FragDepthEXT gl_FragDepth",
      "#define texture2D texture",
      "#define textureCube texture",
      "#define texture2DProj textureProj",
      "#define texture2DLodEXT textureLod",
      "#define texture2DProjLodEXT textureProjLod",
      "#define textureCubeLodEXT textureLod",
      "#define texture2DGradEXT textureGrad",
      "#define texture2DProjGradEXT textureProjGrad",
      "#define textureCubeGradEXT textureGrad"
    ].join("\n") + "\n" + prefixFragment;
  }
  const vertexGlsl = versionString + prefixVertex + vertexShader;
  const fragmentGlsl = versionString + prefixFragment + fragmentShader;
  const glVertexShader = WebGLShader(gl2, 35633, vertexGlsl);
  const glFragmentShader = WebGLShader(gl2, 35632, fragmentGlsl);
  gl2.attachShader(program, glVertexShader);
  gl2.attachShader(program, glFragmentShader);
  if (parameters.index0AttributeName !== void 0) {
    gl2.bindAttribLocation(program, 0, parameters.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    gl2.bindAttribLocation(program, 0, "position");
  }
  gl2.linkProgram(program);
  if (renderer.debug.checkShaderErrors) {
    const programLog = gl2.getProgramInfoLog(program).trim();
    const vertexLog = gl2.getShaderInfoLog(glVertexShader).trim();
    const fragmentLog = gl2.getShaderInfoLog(glFragmentShader).trim();
    let runnable = true;
    let haveDiagnostics = true;
    if (gl2.getProgramParameter(program, 35714) === false) {
      runnable = false;
      const vertexErrors = getShaderErrors(gl2, glVertexShader, "vertex");
      const fragmentErrors = getShaderErrors(gl2, glFragmentShader, "fragment");
      console.error("THREE.WebGLProgram: Shader Error " + gl2.getError() + " - VALIDATE_STATUS " + gl2.getProgramParameter(program, 35715) + "\n\nProgram Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors);
    } else if (programLog !== "") {
      console.warn("THREE.WebGLProgram: Program Info Log:", programLog);
    } else if (vertexLog === "" || fragmentLog === "") {
      haveDiagnostics = false;
    }
    if (haveDiagnostics) {
      this.diagnostics = {
        runnable,
        programLog,
        vertexShader: {
          log: vertexLog,
          prefix: prefixVertex
        },
        fragmentShader: {
          log: fragmentLog,
          prefix: prefixFragment
        }
      };
    }
  }
  gl2.deleteShader(glVertexShader);
  gl2.deleteShader(glFragmentShader);
  let cachedUniforms;
  this.getUniforms = function() {
    if (cachedUniforms === void 0) {
      cachedUniforms = new WebGLUniforms(gl2, program);
    }
    return cachedUniforms;
  };
  let cachedAttributes;
  this.getAttributes = function() {
    if (cachedAttributes === void 0) {
      cachedAttributes = fetchAttributeLocations(gl2, program);
    }
    return cachedAttributes;
  };
  this.destroy = function() {
    bindingStates.releaseStatesOfProgram(this);
    gl2.deleteProgram(program);
    this.program = void 0;
  };
  this.name = parameters.shaderName;
  this.id = programIdCount++;
  this.cacheKey = cacheKey;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}
function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
  const programs = [];
  const isWebGL2 = capabilities.isWebGL2;
  const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
  const floatVertexTextures = capabilities.floatVertexTextures;
  const maxVertexUniforms = capabilities.maxVertexUniforms;
  const vertexTextures = capabilities.vertexTextures;
  let precision = capabilities.precision;
  const shaderIDs = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  const parameterNames = [
    "precision",
    "isWebGL2",
    "supportsVertexTextures",
    "outputEncoding",
    "instancing",
    "instancingColor",
    "map",
    "mapEncoding",
    "matcap",
    "matcapEncoding",
    "envMap",
    "envMapMode",
    "envMapEncoding",
    "envMapCubeUV",
    "lightMap",
    "lightMapEncoding",
    "aoMap",
    "emissiveMap",
    "emissiveMapEncoding",
    "bumpMap",
    "normalMap",
    "objectSpaceNormalMap",
    "tangentSpaceNormalMap",
    "clearcoat",
    "clearcoatMap",
    "clearcoatRoughnessMap",
    "clearcoatNormalMap",
    "displacementMap",
    "specularMap",
    ,
    "roughnessMap",
    "metalnessMap",
    "gradientMap",
    "alphaMap",
    "alphaTest",
    "combine",
    "vertexColors",
    "vertexAlphas",
    "vertexTangents",
    "vertexUvs",
    "uvsVertexOnly",
    "fog",
    "useFog",
    "fogExp2",
    "flatShading",
    "sizeAttenuation",
    "logarithmicDepthBuffer",
    "skinning",
    "maxBones",
    "useVertexTexture",
    "morphTargets",
    "morphNormals",
    "morphTargetsCount",
    "premultipliedAlpha",
    "numDirLights",
    "numPointLights",
    "numSpotLights",
    "numHemiLights",
    "numRectAreaLights",
    "numDirLightShadows",
    "numPointLightShadows",
    "numSpotLightShadows",
    "shadowMapEnabled",
    "shadowMapType",
    "toneMapping",
    "physicallyCorrectLights",
    "doubleSided",
    "flipSided",
    "numClippingPlanes",
    "numClipIntersection",
    "depthPacking",
    "dithering",
    "format",
    "specularIntensityMap",
    "specularColorMap",
    "specularColorMapEncoding",
    "transmission",
    "transmissionMap",
    "thicknessMap",
    "sheen",
    "sheenColorMap",
    "sheenColorMapEncoding",
    "sheenRoughnessMap"
  ];
  function getMaxBones(object) {
    const skeleton = object.skeleton;
    const bones = skeleton.bones;
    if (floatVertexTextures) {
      return 1024;
    } else {
      const nVertexUniforms = maxVertexUniforms;
      const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
      const maxBones = Math.min(nVertexMatrices, bones.length);
      if (maxBones < bones.length) {
        console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + ".");
        return 0;
      }
      return maxBones;
    }
  }
  function getTextureEncodingFromMap(map2) {
    let encoding;
    if (map2 && map2.isTexture) {
      encoding = map2.encoding;
    } else if (map2 && map2.isWebGLRenderTarget) {
      console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
      encoding = map2.texture.encoding;
    } else {
      encoding = LinearEncoding;
    }
    if (isWebGL2 && map2 && map2.isTexture && map2.format === RGBAFormat && map2.type === UnsignedByteType && map2.encoding === sRGBEncoding) {
      encoding = LinearEncoding;
    }
    return encoding;
  }
  function getParameters(material, lights, shadows, scene, object) {
    const fog = scene.fog;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
    const shaderID = shaderIDs[material.type];
    const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;
    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);
      if (precision !== material.precision) {
        console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
      }
    }
    let vertexShader, fragmentShader;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      vertexShader = shader.vertexShader;
      fragmentShader = shader.fragmentShader;
    } else {
      vertexShader = material.vertexShader;
      fragmentShader = material.fragmentShader;
    }
    const currentRenderTarget = renderer.getRenderTarget();
    const useAlphaTest = material.alphaTest > 0;
    const useClearcoat = material.clearcoat > 0;
    const parameters = {
      isWebGL2,
      shaderID,
      shaderName: material.type,
      vertexShader,
      fragmentShader,
      defines: material.defines,
      isRawShaderMaterial: material.isRawShaderMaterial === true,
      glslVersion: material.glslVersion,
      precision,
      instancing: object.isInstancedMesh === true,
      instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
      supportsVertexTextures: vertexTextures,
      outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
      map: !!material.map,
      mapEncoding: getTextureEncodingFromMap(material.map),
      matcap: !!material.matcap,
      matcapEncoding: getTextureEncodingFromMap(material.matcap),
      envMap: !!envMap,
      envMapMode: envMap && envMap.mapping,
      envMapEncoding: getTextureEncodingFromMap(envMap),
      envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
      lightMap: !!material.lightMap,
      lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
      aoMap: !!material.aoMap,
      emissiveMap: !!material.emissiveMap,
      emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
      bumpMap: !!material.bumpMap,
      normalMap: !!material.normalMap,
      objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
      tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
      clearcoat: useClearcoat,
      clearcoatMap: useClearcoat && !!material.clearcoatMap,
      clearcoatRoughnessMap: useClearcoat && !!material.clearcoatRoughnessMap,
      clearcoatNormalMap: useClearcoat && !!material.clearcoatNormalMap,
      displacementMap: !!material.displacementMap,
      roughnessMap: !!material.roughnessMap,
      metalnessMap: !!material.metalnessMap,
      specularMap: !!material.specularMap,
      specularIntensityMap: !!material.specularIntensityMap,
      specularColorMap: !!material.specularColorMap,
      specularColorMapEncoding: getTextureEncodingFromMap(material.specularColorMap),
      alphaMap: !!material.alphaMap,
      alphaTest: useAlphaTest,
      gradientMap: !!material.gradientMap,
      sheen: material.sheen > 0,
      sheenColorMap: !!material.sheenColorMap,
      sheenColorMapEncoding: getTextureEncodingFromMap(material.sheenColorMap),
      sheenRoughnessMap: !!material.sheenRoughnessMap,
      transmission: material.transmission > 0,
      transmissionMap: !!material.transmissionMap,
      thicknessMap: !!material.thicknessMap,
      combine: material.combine,
      vertexTangents: !!material.normalMap && !!object.geometry && !!object.geometry.attributes.tangent,
      vertexColors: material.vertexColors,
      vertexAlphas: material.vertexColors === true && !!object.geometry && !!object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,
      vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || !!material.sheenColorMap || material.sheenRoughnessMap,
      uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || material.transmission > 0 || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || !!material.sheen > 0 || !!material.sheenColorMap || !!material.sheenRoughnessMap) && !!material.displacementMap,
      fog: !!fog,
      useFog: material.fog,
      fogExp2: fog && fog.isFogExp2,
      flatShading: !!material.flatShading,
      sizeAttenuation: material.sizeAttenuation,
      logarithmicDepthBuffer,
      skinning: object.isSkinnedMesh === true && maxBones > 0,
      maxBones,
      useVertexTexture: floatVertexTextures,
      morphTargets: !!object.geometry && !!object.geometry.morphAttributes.position,
      morphNormals: !!object.geometry && !!object.geometry.morphAttributes.normal,
      morphTargetsCount: !!object.geometry && !!object.geometry.morphAttributes.position ? object.geometry.morphAttributes.position.length : 0,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numClippingPlanes: clipping.numPlanes,
      numClipIntersection: clipping.numIntersection,
      format: material.format,
      dithering: material.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
      physicallyCorrectLights: renderer.physicallyCorrectLights,
      premultipliedAlpha: material.premultipliedAlpha,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      depthPacking: material.depthPacking !== void 0 ? material.depthPacking : false,
      index0AttributeName: material.index0AttributeName,
      extensionDerivatives: material.extensions && material.extensions.derivatives,
      extensionFragDepth: material.extensions && material.extensions.fragDepth,
      extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
      extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: isWebGL2 || extensions.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: isWebGL2 || extensions.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: isWebGL2 || extensions.has("EXT_shader_texture_lod"),
      customProgramCacheKey: material.customProgramCacheKey()
    };
    return parameters;
  }
  function getProgramCacheKey(parameters) {
    const array = [];
    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(hashString(parameters.fragmentShader));
      array.push(hashString(parameters.vertexShader));
    }
    if (parameters.defines !== void 0) {
      for (const name2 in parameters.defines) {
        array.push(name2);
        array.push(parameters.defines[name2]);
      }
    }
    if (parameters.isRawShaderMaterial === false) {
      for (let i2 = 0; i2 < parameterNames.length; i2++) {
        array.push(parameters[parameterNames[i2]]);
      }
      array.push(renderer.outputEncoding);
      array.push(renderer.gammaFactor);
    }
    array.push(parameters.customProgramCacheKey);
    return array.join();
  }
  function getUniforms(material) {
    const shaderID = shaderIDs[material.type];
    let uniforms;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      uniforms = UniformsUtils.clone(shader.uniforms);
    } else {
      uniforms = material.uniforms;
    }
    return uniforms;
  }
  function acquireProgram(parameters, cacheKey) {
    let program;
    for (let p2 = 0, pl2 = programs.length; p2 < pl2; p2++) {
      const preexistingProgram = programs[p2];
      if (preexistingProgram.cacheKey === cacheKey) {
        program = preexistingProgram;
        ++program.usedTimes;
        break;
      }
    }
    if (program === void 0) {
      program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
      programs.push(program);
    }
    return program;
  }
  function releaseProgram(program) {
    if (--program.usedTimes === 0) {
      const i2 = programs.indexOf(program);
      programs[i2] = programs[programs.length - 1];
      programs.pop();
      program.destroy();
    }
  }
  return {
    getParameters,
    getProgramCacheKey,
    getUniforms,
    acquireProgram,
    releaseProgram,
    programs
  };
}
function WebGLProperties() {
  let properties = new WeakMap();
  function get2(object) {
    let map2 = properties.get(object);
    if (map2 === void 0) {
      map2 = {};
      properties.set(object, map2);
    }
    return map2;
  }
  function remove(object) {
    properties.delete(object);
  }
  function update(object, key, value) {
    properties.get(object)[key] = value;
  }
  function dispose() {
    properties = new WeakMap();
  }
  return {
    get: get2,
    remove,
    update,
    dispose
  };
}
function painterSortStable(a2, b2) {
  if (a2.groupOrder !== b2.groupOrder) {
    return a2.groupOrder - b2.groupOrder;
  } else if (a2.renderOrder !== b2.renderOrder) {
    return a2.renderOrder - b2.renderOrder;
  } else if (a2.program !== b2.program) {
    return a2.program.id - b2.program.id;
  } else if (a2.material.id !== b2.material.id) {
    return a2.material.id - b2.material.id;
  } else if (a2.z !== b2.z) {
    return a2.z - b2.z;
  } else {
    return a2.id - b2.id;
  }
}
function reversePainterSortStable(a2, b2) {
  if (a2.groupOrder !== b2.groupOrder) {
    return a2.groupOrder - b2.groupOrder;
  } else if (a2.renderOrder !== b2.renderOrder) {
    return a2.renderOrder - b2.renderOrder;
  } else if (a2.z !== b2.z) {
    return b2.z - a2.z;
  } else {
    return a2.id - b2.id;
  }
}
function WebGLRenderList(properties) {
  const renderItems = [];
  let renderItemsIndex = 0;
  const opaque = [];
  const transmissive = [];
  const transparent = [];
  const defaultProgram = { id: -1 };
  function init() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transmissive.length = 0;
    transparent.length = 0;
  }
  function getNextRenderItem(object, geometry2, material, groupOrder, z2, group) {
    let renderItem = renderItems[renderItemsIndex];
    const materialProperties = properties.get(material);
    if (renderItem === void 0) {
      renderItem = {
        id: object.id,
        object,
        geometry: geometry2,
        material,
        program: materialProperties.program || defaultProgram,
        groupOrder,
        renderOrder: object.renderOrder,
        z: z2,
        group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry2;
      renderItem.material = material;
      renderItem.program = materialProperties.program || defaultProgram;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z2;
      renderItem.group = group;
    }
    renderItemsIndex++;
    return renderItem;
  }
  function push(object, geometry2, material, groupOrder, z2, group) {
    const renderItem = getNextRenderItem(object, geometry2, material, groupOrder, z2, group);
    if (material.transmission > 0) {
      transmissive.push(renderItem);
    } else if (material.transparent === true) {
      transparent.push(renderItem);
    } else {
      opaque.push(renderItem);
    }
  }
  function unshift(object, geometry2, material, groupOrder, z2, group) {
    const renderItem = getNextRenderItem(object, geometry2, material, groupOrder, z2, group);
    if (material.transmission > 0) {
      transmissive.unshift(renderItem);
    } else if (material.transparent === true) {
      transparent.unshift(renderItem);
    } else {
      opaque.unshift(renderItem);
    }
  }
  function sort(customOpaqueSort, customTransparentSort) {
    if (opaque.length > 1)
      opaque.sort(customOpaqueSort || painterSortStable);
    if (transmissive.length > 1)
      transmissive.sort(customTransparentSort || reversePainterSortStable);
    if (transparent.length > 1)
      transparent.sort(customTransparentSort || reversePainterSortStable);
  }
  function finish() {
    for (let i2 = renderItemsIndex, il2 = renderItems.length; i2 < il2; i2++) {
      const renderItem = renderItems[i2];
      if (renderItem.id === null)
        break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.program = null;
      renderItem.group = null;
    }
  }
  return {
    opaque,
    transmissive,
    transparent,
    init,
    push,
    unshift,
    finish,
    sort
  };
}
function WebGLRenderLists(properties) {
  let lists = new WeakMap();
  function get2(scene, renderCallDepth) {
    let list;
    if (lists.has(scene) === false) {
      list = new WebGLRenderList(properties);
      lists.set(scene, [list]);
    } else {
      if (renderCallDepth >= lists.get(scene).length) {
        list = new WebGLRenderList(properties);
        lists.get(scene).push(list);
      } else {
        list = lists.get(scene)[renderCallDepth];
      }
    }
    return list;
  }
  function dispose() {
    lists = new WeakMap();
  }
  return {
    get: get2,
    dispose
  };
}
function UniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            direction: new Vector3(),
            color: new Color()
          };
          break;
        case "SpotLight":
          uniforms = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          uniforms = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          uniforms = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;
        case "RectAreaLight":
          uniforms = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3()
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
function ShadowUniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "SpotLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "PointLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
let nextVersion = 0;
function shadowCastingLightsFirst(lightA, lightB) {
  return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
}
function WebGLLights(extensions, capabilities) {
  const cache = new UniformsCache();
  const shadowCache = ShadowUniformsCache();
  const state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadow: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  };
  for (let i2 = 0; i2 < 9; i2++)
    state.probe.push(new Vector3());
  const vector3 = new Vector3();
  const matrix4 = new Matrix4();
  const matrix42 = new Matrix4();
  function setup(lights, physicallyCorrectLights) {
    let r2 = 0, g2 = 0, b2 = 0;
    for (let i2 = 0; i2 < 9; i2++)
      state.probe[i2].set(0, 0, 0);
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    let numDirectionalShadows = 0;
    let numPointShadows = 0;
    let numSpotShadows = 0;
    lights.sort(shadowCastingLightsFirst);
    const scaleFactor = physicallyCorrectLights !== true ? Math.PI : 1;
    for (let i2 = 0, l2 = lights.length; i2 < l2; i2++) {
      const light = lights[i2];
      const color2 = light.color;
      const intensity = light.intensity;
      const distance = light.distance;
      const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
      if (light.isAmbientLight) {
        r2 += color2.r * intensity * scaleFactor;
        g2 += color2.g * intensity * scaleFactor;
        b2 += color2.b * intensity * scaleFactor;
      } else if (light.isLightProbe) {
        for (let j2 = 0; j2 < 9; j2++) {
          state.probe[j2].addScaledVector(light.sh.coefficients[j2], intensity);
        }
      } else if (light.isDirectionalLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.directionalShadow[directionalLength] = shadowUniforms;
          state.directionalShadowMap[directionalLength] = shadowMap;
          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
          numDirectionalShadows++;
        }
        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.color.copy(color2).multiplyScalar(intensity * scaleFactor);
        uniforms.distance = distance;
        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.spotShadow[spotLength] = shadowUniforms;
          state.spotShadowMap[spotLength] = shadowMap;
          state.spotShadowMatrix[spotLength] = light.shadow.matrix;
          numSpotShadows++;
        }
        state.spot[spotLength] = uniforms;
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(color2).multiplyScalar(intensity);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
        uniforms.distance = light.distance;
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          shadowUniforms.shadowCameraNear = shadow.camera.near;
          shadowUniforms.shadowCameraFar = shadow.camera.far;
          state.pointShadow[pointLength] = shadowUniforms;
          state.pointShadowMap[pointLength] = shadowMap;
          state.pointShadowMatrix[pointLength] = light.shadow.matrix;
          numPointShadows++;
        }
        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = cache.get(light);
        uniforms.skyColor.copy(light.color).multiplyScalar(intensity * scaleFactor);
        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity * scaleFactor);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }
    if (rectAreaLength > 0) {
      if (capabilities.isWebGL2) {
        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
      } else {
        if (extensions.has("OES_texture_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
        } else if (extensions.has("OES_texture_half_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
          state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
        } else {
          console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");
        }
      }
    }
    state.ambient[0] = r2;
    state.ambient[1] = g2;
    state.ambient[2] = b2;
    const hash = state.hash;
    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;
      state.directionalShadow.length = numDirectionalShadows;
      state.directionalShadowMap.length = numDirectionalShadows;
      state.pointShadow.length = numPointShadows;
      state.pointShadowMap.length = numPointShadows;
      state.spotShadow.length = numSpotShadows;
      state.spotShadowMap.length = numSpotShadows;
      state.directionalShadowMatrix.length = numDirectionalShadows;
      state.pointShadowMatrix.length = numPointShadows;
      state.spotShadowMatrix.length = numSpotShadows;
      hash.directionalLength = directionalLength;
      hash.pointLength = pointLength;
      hash.spotLength = spotLength;
      hash.rectAreaLength = rectAreaLength;
      hash.hemiLength = hemiLength;
      hash.numDirectionalShadows = numDirectionalShadows;
      hash.numPointShadows = numPointShadows;
      hash.numSpotShadows = numSpotShadows;
      state.version = nextVersion++;
    }
  }
  function setupView(lights, camera) {
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    const viewMatrix = camera.matrixWorldInverse;
    for (let i2 = 0, l2 = lights.length; i2 < l2; i2++) {
      const light = lights[i2];
      if (light.isDirectionalLight) {
        const uniforms = state.directional[directionalLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = state.spot[spotLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = state.rectArea[rectAreaLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        matrix42.identity();
        matrix4.copy(light.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        uniforms.halfWidth.applyMatrix4(matrix42);
        uniforms.halfHeight.applyMatrix4(matrix42);
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = state.point[pointLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = state.hemi[hemiLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.direction.normalize();
        hemiLength++;
      }
    }
  }
  return {
    setup,
    setupView,
    state
  };
}
function WebGLRenderState(extensions, capabilities) {
  const lights = new WebGLLights(extensions, capabilities);
  const lightsArray = [];
  const shadowsArray = [];
  function init() {
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }
  function pushLight(light) {
    lightsArray.push(light);
  }
  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }
  function setupLights(physicallyCorrectLights) {
    lights.setup(lightsArray, physicallyCorrectLights);
  }
  function setupLightsView(camera) {
    lights.setupView(lightsArray, camera);
  }
  const state = {
    lightsArray,
    shadowsArray,
    lights
  };
  return {
    init,
    state,
    setupLights,
    setupLightsView,
    pushLight,
    pushShadow
  };
}
function WebGLRenderStates(extensions, capabilities) {
  let renderStates = new WeakMap();
  function get2(scene, renderCallDepth = 0) {
    let renderState;
    if (renderStates.has(scene) === false) {
      renderState = new WebGLRenderState(extensions, capabilities);
      renderStates.set(scene, [renderState]);
    } else {
      if (renderCallDepth >= renderStates.get(scene).length) {
        renderState = new WebGLRenderState(extensions, capabilities);
        renderStates.get(scene).push(renderState);
      } else {
        renderState = renderStates.get(scene)[renderCallDepth];
      }
    }
    return renderState;
  }
  function dispose() {
    renderStates = new WeakMap();
  }
  return {
    get: get2,
    dispose
  };
}
class MeshDepthMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshDepthMaterial";
    this.depthPacking = BasicDepthPacking;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.setValues(parameters);
  }
  copy(source3) {
    super.copy(source3);
    this.depthPacking = source3.depthPacking;
    this.map = source3.map;
    this.alphaMap = source3.alphaMap;
    this.displacementMap = source3.displacementMap;
    this.displacementScale = source3.displacementScale;
    this.displacementBias = source3.displacementBias;
    this.wireframe = source3.wireframe;
    this.wireframeLinewidth = source3.wireframeLinewidth;
    return this;
  }
}
MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
class MeshDistanceMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshDistanceMaterial";
    this.referencePosition = new Vector3();
    this.nearDistance = 1;
    this.farDistance = 1e3;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.fog = false;
    this.setValues(parameters);
  }
  copy(source3) {
    super.copy(source3);
    this.referencePosition.copy(source3.referencePosition);
    this.nearDistance = source3.nearDistance;
    this.farDistance = source3.farDistance;
    this.map = source3.map;
    this.alphaMap = source3.alphaMap;
    this.displacementMap = source3.displacementMap;
    this.displacementScale = source3.displacementScale;
    this.displacementBias = source3.displacementBias;
    return this;
  }
}
MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
const vertex = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
const fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
function WebGLShadowMap(_renderer, _objects, _capabilities) {
  let _frustum = new Frustum();
  const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), _distanceMaterial = new MeshDistanceMaterial(), _materialCache = {}, _maxTextureSize = _capabilities.maxTextureSize;
  const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };
  const shadowMaterialVertical = new ShaderMaterial({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Vector2() },
      radius: { value: 4 }
    },
    vertexShader: vertex,
    fragmentShader: fragment
  });
  const shadowMaterialHorizontal = shadowMaterialVertical.clone();
  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
  const fullScreenTri = new BufferGeometry();
  fullScreenTri.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
  const scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;
  this.render = function(lights, scene, camera) {
    if (scope.enabled === false)
      return;
    if (scope.autoUpdate === false && scope.needsUpdate === false)
      return;
    if (lights.length === 0)
      return;
    const currentRenderTarget = _renderer.getRenderTarget();
    const activeCubeFace = _renderer.getActiveCubeFace();
    const activeMipmapLevel = _renderer.getActiveMipmapLevel();
    const _state = _renderer.state;
    _state.setBlending(NoBlending);
    _state.buffers.color.setClear(1, 1, 1, 1);
    _state.buffers.depth.setTest(true);
    _state.setScissorTest(false);
    for (let i2 = 0, il2 = lights.length; i2 < il2; i2++) {
      const light = lights[i2];
      const shadow = light.shadow;
      if (shadow === void 0) {
        console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
        continue;
      }
      if (shadow.autoUpdate === false && shadow.needsUpdate === false)
        continue;
      _shadowMapSize.copy(shadow.mapSize);
      const shadowFrameExtents = shadow.getFrameExtents();
      _shadowMapSize.multiply(shadowFrameExtents);
      _viewportSize.copy(shadow.mapSize);
      if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
        if (_shadowMapSize.x > _maxTextureSize) {
          _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
          shadow.mapSize.x = _viewportSize.x;
        }
        if (_shadowMapSize.y > _maxTextureSize) {
          _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
          shadow.mapSize.y = _viewportSize.y;
        }
      }
      if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
        const pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.camera.updateProjectionMatrix();
      }
      if (shadow.map === null) {
        const pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.camera.updateProjectionMatrix();
      }
      _renderer.setRenderTarget(shadow.map);
      _renderer.clear();
      const viewportCount = shadow.getViewportCount();
      for (let vp2 = 0; vp2 < viewportCount; vp2++) {
        const viewport = shadow.getViewport(vp2);
        _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
        _state.viewport(_viewport);
        shadow.updateMatrices(light, vp2);
        _frustum = shadow.getFrustum();
        renderObject(scene, camera, shadow.camera, light, this.type);
      }
      if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
        VSMPass(shadow, camera);
      }
      shadow.needsUpdate = false;
    }
    scope.needsUpdate = false;
    _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  };
  function VSMPass(shadow, camera) {
    const geometry2 = _objects.update(fullScreenMesh);
    if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
      shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialVertical.needsUpdate = true;
      shadowMaterialHorizontal.needsUpdate = true;
    }
    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialVertical.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.mapPass);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry2, shadowMaterialVertical, fullScreenMesh, null);
    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.map);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry2, shadowMaterialHorizontal, fullScreenMesh, null);
  }
  function getDepthMaterial(object, geometry2, material, light, shadowCameraNear, shadowCameraFar, type) {
    let result = null;
    const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
    if (customMaterial !== void 0) {
      result = customMaterial;
    } else {
      result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
    }
    if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0) {
      const keyA = result.uuid, keyB = material.uuid;
      let materialsForVariant = _materialCache[keyA];
      if (materialsForVariant === void 0) {
        materialsForVariant = {};
        _materialCache[keyA] = materialsForVariant;
      }
      let cachedMaterial = materialsForVariant[keyB];
      if (cachedMaterial === void 0) {
        cachedMaterial = result.clone();
        materialsForVariant[keyB] = cachedMaterial;
      }
      result = cachedMaterial;
    }
    result.visible = material.visible;
    result.wireframe = material.wireframe;
    if (type === VSMShadowMap) {
      result.side = material.shadowSide !== null ? material.shadowSide : material.side;
    } else {
      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
    }
    result.alphaMap = material.alphaMap;
    result.alphaTest = material.alphaTest;
    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.displacementMap = material.displacementMap;
    result.displacementScale = material.displacementScale;
    result.displacementBias = material.displacementBias;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;
    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
      result.referencePosition.setFromMatrixPosition(light.matrixWorld);
      result.nearDistance = shadowCameraNear;
      result.farDistance = shadowCameraFar;
    }
    return result;
  }
  function renderObject(object, camera, shadowCamera, light, type) {
    if (object.visible === false)
      return;
    const visible = object.layers.test(camera.layers);
    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
        const geometry2 = _objects.update(object);
        const material = object.material;
        if (Array.isArray(material)) {
          const groups = geometry2.groups;
          for (let k2 = 0, kl2 = groups.length; k2 < kl2; k2++) {
            const group = groups[k2];
            const groupMaterial = material[group.materialIndex];
            if (groupMaterial && groupMaterial.visible) {
              const depthMaterial = getDepthMaterial(object, geometry2, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
              _renderer.renderBufferDirect(shadowCamera, null, geometry2, depthMaterial, object, group);
            }
          }
        } else if (material.visible) {
          const depthMaterial = getDepthMaterial(object, geometry2, material, light, shadowCamera.near, shadowCamera.far, type);
          _renderer.renderBufferDirect(shadowCamera, null, geometry2, depthMaterial, object, null);
        }
      }
    }
    const children = object.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      renderObject(children[i2], camera, shadowCamera, light, type);
    }
  }
}
function WebGLState(gl2, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function ColorBuffer() {
    let locked = false;
    const color2 = new Vector4();
    let currentColorMask = null;
    const currentColorClear = new Vector4(0, 0, 0, 0);
    return {
      setMask: function(colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl2.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(r2, g2, b2, a2, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r2 *= a2;
          g2 *= a2;
          b2 *= a2;
        }
        color2.set(r2, g2, b2, a2);
        if (currentColorClear.equals(color2) === false) {
          gl2.clearColor(r2, g2, b2, a2);
          currentColorClear.copy(color2);
        }
      },
      reset: function() {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0);
      }
    };
  }
  function DepthBuffer() {
    let locked = false;
    let currentDepthMask = null;
    let currentDepthFunc = null;
    let currentDepthClear = null;
    return {
      setTest: function(depthTest) {
        if (depthTest) {
          enable(2929);
        } else {
          disable(2929);
        }
      },
      setMask: function(depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl2.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function(depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          if (depthFunc) {
            switch (depthFunc) {
              case NeverDepth:
                gl2.depthFunc(512);
                break;
              case AlwaysDepth:
                gl2.depthFunc(519);
                break;
              case LessDepth:
                gl2.depthFunc(513);
                break;
              case LessEqualDepth:
                gl2.depthFunc(515);
                break;
              case EqualDepth:
                gl2.depthFunc(514);
                break;
              case GreaterEqualDepth:
                gl2.depthFunc(518);
                break;
              case GreaterDepth:
                gl2.depthFunc(516);
                break;
              case NotEqualDepth:
                gl2.depthFunc(517);
                break;
              default:
                gl2.depthFunc(515);
            }
          } else {
            gl2.depthFunc(515);
          }
          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(depth) {
        if (currentDepthClear !== depth) {
          gl2.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function() {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
      }
    };
  }
  function StencilBuffer() {
    let locked = false;
    let currentStencilMask = null;
    let currentStencilFunc = null;
    let currentStencilRef = null;
    let currentStencilFuncMask = null;
    let currentStencilFail = null;
    let currentStencilZFail = null;
    let currentStencilZPass = null;
    let currentStencilClear = null;
    return {
      setTest: function(stencilTest) {
        if (!locked) {
          if (stencilTest) {
            enable(2960);
          } else {
            disable(2960);
          }
        }
      },
      setMask: function(stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl2.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function(stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl2.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function(stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl2.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(stencil) {
        if (currentStencilClear !== stencil) {
          gl2.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function() {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  }
  const colorBuffer = new ColorBuffer();
  const depthBuffer = new DepthBuffer();
  const stencilBuffer = new StencilBuffer();
  let enabledCapabilities = {};
  let xrFramebuffer = null;
  let currentBoundFramebuffers = {};
  let currentProgram = null;
  let currentBlendingEnabled = false;
  let currentBlending = null;
  let currentBlendEquation = null;
  let currentBlendSrc = null;
  let currentBlendDst = null;
  let currentBlendEquationAlpha = null;
  let currentBlendSrcAlpha = null;
  let currentBlendDstAlpha = null;
  let currentPremultipledAlpha = false;
  let currentFlipSided = null;
  let currentCullFace = null;
  let currentLineWidth = null;
  let currentPolygonOffsetFactor = null;
  let currentPolygonOffsetUnits = null;
  const maxTextures = gl2.getParameter(35661);
  let lineWidthAvailable = false;
  let version2 = 0;
  const glVersion = gl2.getParameter(7938);
  if (glVersion.indexOf("WebGL") !== -1) {
    version2 = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version2 >= 1;
  } else if (glVersion.indexOf("OpenGL ES") !== -1) {
    version2 = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version2 >= 2;
  }
  let currentTextureSlot = null;
  let currentBoundTextures = {};
  const scissorParam = gl2.getParameter(3088);
  const viewportParam = gl2.getParameter(2978);
  const currentScissor = new Vector4().fromArray(scissorParam);
  const currentViewport = new Vector4().fromArray(viewportParam);
  function createTexture(type, target, count) {
    const data = new Uint8Array(4);
    const texture = gl2.createTexture();
    gl2.bindTexture(type, texture);
    gl2.texParameteri(type, 10241, 9728);
    gl2.texParameteri(type, 10240, 9728);
    for (let i2 = 0; i2 < count; i2++) {
      gl2.texImage2D(target + i2, 0, 6408, 1, 1, 0, 6408, 5121, data);
    }
    return texture;
  }
  const emptyTextures = {};
  emptyTextures[3553] = createTexture(3553, 3553, 1);
  emptyTextures[34067] = createTexture(34067, 34069, 6);
  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(2929);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(2884);
  setBlending(NoBlending);
  function enable(id2) {
    if (enabledCapabilities[id2] !== true) {
      gl2.enable(id2);
      enabledCapabilities[id2] = true;
    }
  }
  function disable(id2) {
    if (enabledCapabilities[id2] !== false) {
      gl2.disable(id2);
      enabledCapabilities[id2] = false;
    }
  }
  function bindXRFramebuffer(framebuffer) {
    if (framebuffer !== xrFramebuffer) {
      gl2.bindFramebuffer(36160, framebuffer);
      xrFramebuffer = framebuffer;
    }
  }
  function bindFramebuffer(target, framebuffer) {
    if (framebuffer === null && xrFramebuffer !== null)
      framebuffer = xrFramebuffer;
    if (currentBoundFramebuffers[target] !== framebuffer) {
      gl2.bindFramebuffer(target, framebuffer);
      currentBoundFramebuffers[target] = framebuffer;
      if (isWebGL2) {
        if (target === 36009) {
          currentBoundFramebuffers[36160] = framebuffer;
        }
        if (target === 36160) {
          currentBoundFramebuffers[36009] = framebuffer;
        }
      }
      return true;
    }
    return false;
  }
  function useProgram(program) {
    if (currentProgram !== program) {
      gl2.useProgram(program);
      currentProgram = program;
      return true;
    }
    return false;
  }
  const equationToGL = {
    [AddEquation]: 32774,
    [SubtractEquation]: 32778,
    [ReverseSubtractEquation]: 32779
  };
  if (isWebGL2) {
    equationToGL[MinEquation] = 32775;
    equationToGL[MaxEquation] = 32776;
  } else {
    const extension = extensions.get("EXT_blend_minmax");
    if (extension !== null) {
      equationToGL[MinEquation] = extension.MIN_EXT;
      equationToGL[MaxEquation] = extension.MAX_EXT;
    }
  }
  const factorToGL = {
    [ZeroFactor]: 0,
    [OneFactor]: 1,
    [SrcColorFactor]: 768,
    [SrcAlphaFactor]: 770,
    [SrcAlphaSaturateFactor]: 776,
    [DstColorFactor]: 774,
    [DstAlphaFactor]: 772,
    [OneMinusSrcColorFactor]: 769,
    [OneMinusSrcAlphaFactor]: 771,
    [OneMinusDstColorFactor]: 775,
    [OneMinusDstAlphaFactor]: 773
  };
  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled === true) {
        disable(3042);
        currentBlendingEnabled = false;
      }
      return;
    }
    if (currentBlendingEnabled === false) {
      enable(3042);
      currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl2.blendEquation(32774);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl2.blendFuncSeparate(1, 771, 1, 771);
              break;
            case AdditiveBlending:
              gl2.blendFunc(1, 1);
              break;
            case SubtractiveBlending:
              gl2.blendFuncSeparate(0, 0, 769, 771);
              break;
            case MultiplyBlending:
              gl2.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl2.blendFuncSeparate(770, 771, 1, 771);
              break;
            case AdditiveBlending:
              gl2.blendFunc(770, 1);
              break;
            case SubtractiveBlending:
              gl2.blendFunc(0, 769);
              break;
            case MultiplyBlending:
              gl2.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        }
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }
    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl2.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl2.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }
    currentBlending = blending;
    currentPremultipledAlpha = null;
  }
  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable(2884) : enable(2884);
    let flipSided = material.side === BackSide;
    if (frontFaceCW)
      flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    const stencilWrite = material.stencilWrite;
    stencilBuffer.setTest(stencilWrite);
    if (stencilWrite) {
      stencilBuffer.setMask(material.stencilWriteMask);
      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }
    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    material.alphaToCoverage === true ? enable(32926) : disable(32926);
  }
  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl2.frontFace(2304);
      } else {
        gl2.frontFace(2305);
      }
      currentFlipSided = flipSided;
    }
  }
  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(2884);
      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl2.cullFace(1029);
        } else if (cullFace === CullFaceFront) {
          gl2.cullFace(1028);
        } else {
          gl2.cullFace(1032);
        }
      }
    } else {
      disable(2884);
    }
    currentCullFace = cullFace;
  }
  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable)
        gl2.lineWidth(width);
      currentLineWidth = width;
    }
  }
  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(32823);
      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
        gl2.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable(32823);
    }
  }
  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(3089);
    } else {
      disable(3089);
    }
  }
  function activeTexture(webglSlot) {
    if (webglSlot === void 0)
      webglSlot = 33984 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl2.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }
  function bindTexture(webglType, webglTexture) {
    if (currentTextureSlot === null) {
      activeTexture();
    }
    let boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture === void 0) {
      boundTexture = { type: void 0, texture: void 0 };
      currentBoundTextures[currentTextureSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      gl2.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  function unbindTexture() {
    const boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture !== void 0 && boundTexture.type !== void 0) {
      gl2.bindTexture(boundTexture.type, null);
      boundTexture.type = void 0;
      boundTexture.texture = void 0;
    }
  }
  function compressedTexImage2D() {
    try {
      gl2.compressedTexImage2D.apply(gl2, arguments);
    } catch (error2) {
      console.error("THREE.WebGLState:", error2);
    }
  }
  function texImage2D() {
    try {
      gl2.texImage2D.apply(gl2, arguments);
    } catch (error2) {
      console.error("THREE.WebGLState:", error2);
    }
  }
  function texImage3D() {
    try {
      gl2.texImage3D.apply(gl2, arguments);
    } catch (error2) {
      console.error("THREE.WebGLState:", error2);
    }
  }
  function scissor(scissor2) {
    if (currentScissor.equals(scissor2) === false) {
      gl2.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
      currentScissor.copy(scissor2);
    }
  }
  function viewport(viewport2) {
    if (currentViewport.equals(viewport2) === false) {
      gl2.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
      currentViewport.copy(viewport2);
    }
  }
  function reset() {
    gl2.disable(3042);
    gl2.disable(2884);
    gl2.disable(2929);
    gl2.disable(32823);
    gl2.disable(3089);
    gl2.disable(2960);
    gl2.disable(32926);
    gl2.blendEquation(32774);
    gl2.blendFunc(1, 0);
    gl2.blendFuncSeparate(1, 0, 1, 0);
    gl2.colorMask(true, true, true, true);
    gl2.clearColor(0, 0, 0, 0);
    gl2.depthMask(true);
    gl2.depthFunc(513);
    gl2.clearDepth(1);
    gl2.stencilMask(4294967295);
    gl2.stencilFunc(519, 0, 4294967295);
    gl2.stencilOp(7680, 7680, 7680);
    gl2.clearStencil(0);
    gl2.cullFace(1029);
    gl2.frontFace(2305);
    gl2.polygonOffset(0, 0);
    gl2.activeTexture(33984);
    gl2.bindFramebuffer(36160, null);
    if (isWebGL2 === true) {
      gl2.bindFramebuffer(36009, null);
      gl2.bindFramebuffer(36008, null);
    }
    gl2.useProgram(null);
    gl2.lineWidth(1);
    gl2.scissor(0, 0, gl2.canvas.width, gl2.canvas.height);
    gl2.viewport(0, 0, gl2.canvas.width, gl2.canvas.height);
    enabledCapabilities = {};
    currentTextureSlot = null;
    currentBoundTextures = {};
    xrFramebuffer = null;
    currentBoundFramebuffers = {};
    currentProgram = null;
    currentBlendingEnabled = false;
    currentBlending = null;
    currentBlendEquation = null;
    currentBlendSrc = null;
    currentBlendDst = null;
    currentBlendEquationAlpha = null;
    currentBlendSrcAlpha = null;
    currentBlendDstAlpha = null;
    currentPremultipledAlpha = false;
    currentFlipSided = null;
    currentCullFace = null;
    currentLineWidth = null;
    currentPolygonOffsetFactor = null;
    currentPolygonOffsetUnits = null;
    currentScissor.set(0, 0, gl2.canvas.width, gl2.canvas.height);
    currentViewport.set(0, 0, gl2.canvas.width, gl2.canvas.height);
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }
  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    enable,
    disable,
    bindFramebuffer,
    bindXRFramebuffer,
    useProgram,
    setBlending,
    setMaterial,
    setFlipSided,
    setCullFace,
    setLineWidth,
    setPolygonOffset,
    setScissorTest,
    activeTexture,
    bindTexture,
    unbindTexture,
    compressedTexImage2D,
    texImage2D,
    texImage3D,
    scissor,
    viewport,
    reset
  };
}
function WebGLTextures(_gl, extensions, state, properties, capabilities, utils2, info) {
  const isWebGL2 = capabilities.isWebGL2;
  const maxTextures = capabilities.maxTextures;
  const maxCubemapSize = capabilities.maxCubemapSize;
  const maxTextureSize = capabilities.maxTextureSize;
  const maxSamples = capabilities.maxSamples;
  const _videoTextures = new WeakMap();
  let _canvas2;
  let useOffscreenCanvas = false;
  try {
    useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch (err) {
  }
  function createCanvas(width, height) {
    return useOffscreenCanvas ? new OffscreenCanvas(width, height) : createElementNS("canvas");
  }
  function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
    let scale = 1;
    if (image.width > maxSize || image.height > maxSize) {
      scale = maxSize / Math.max(image.width, image.height);
    }
    if (scale < 1 || needsPowerOfTwo === true) {
      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
        const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
        const width = floor(scale * image.width);
        const height = floor(scale * image.height);
        if (_canvas2 === void 0)
          _canvas2 = createCanvas(width, height);
        const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas2;
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext("2d");
        context.drawImage(image, 0, 0, width, height);
        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width + "x" + height + ").");
        return canvas;
      } else {
        if ("data" in image) {
          console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
        }
        return image;
      }
    }
    return image;
  }
  function isPowerOfTwo$1(image) {
    return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);
  }
  function textureNeedsPowerOfTwo(texture) {
    if (isWebGL2)
      return false;
    return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function textureNeedsGenerateMipmaps(texture, supportsMips) {
    return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function generateMipmap(target, texture, width, height, depth = 1) {
    _gl.generateMipmap(target);
    const textureProperties = properties.get(texture);
    textureProperties.__maxMipLevel = Math.log2(Math.max(width, height, depth));
  }
  function getInternalFormat(internalFormatName, glFormat, glType, encoding) {
    if (isWebGL2 === false)
      return glFormat;
    if (internalFormatName !== null) {
      if (_gl[internalFormatName] !== void 0)
        return _gl[internalFormatName];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
    }
    let internalFormat = glFormat;
    if (glFormat === 6403) {
      if (glType === 5126)
        internalFormat = 33326;
      if (glType === 5131)
        internalFormat = 33325;
      if (glType === 5121)
        internalFormat = 33321;
    }
    if (glFormat === 6407) {
      if (glType === 5126)
        internalFormat = 34837;
      if (glType === 5131)
        internalFormat = 34843;
      if (glType === 5121)
        internalFormat = 32849;
    }
    if (glFormat === 6408) {
      if (glType === 5126)
        internalFormat = 34836;
      if (glType === 5131)
        internalFormat = 34842;
      if (glType === 5121)
        internalFormat = encoding === sRGBEncoding ? 35907 : 32856;
    }
    if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836) {
      extensions.get("EXT_color_buffer_float");
    }
    return internalFormat;
  }
  function filterFallback(f2) {
    if (f2 === NearestFilter || f2 === NearestMipmapNearestFilter || f2 === NearestMipmapLinearFilter) {
      return 9728;
    }
    return 9729;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    deallocateTexture(texture);
    if (texture.isVideoTexture) {
      _videoTextures.delete(texture);
    }
    info.memory.textures--;
  }
  function onRenderTargetDispose(event) {
    const renderTarget = event.target;
    renderTarget.removeEventListener("dispose", onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
  }
  function deallocateTexture(texture) {
    const textureProperties = properties.get(texture);
    if (textureProperties.__webglInit === void 0)
      return;
    _gl.deleteTexture(textureProperties.__webglTexture);
    properties.remove(texture);
  }
  function deallocateRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    if (!renderTarget)
      return;
    if (textureProperties.__webglTexture !== void 0) {
      _gl.deleteTexture(textureProperties.__webglTexture);
      info.memory.textures--;
    }
    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
    }
    if (renderTarget.isWebGLCubeRenderTarget) {
      for (let i2 = 0; i2 < 6; i2++) {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i2]);
        if (renderTargetProperties.__webglDepthbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i2]);
      }
    } else {
      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
      if (renderTargetProperties.__webglDepthbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      if (renderTargetProperties.__webglMultisampledFramebuffer)
        _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
      if (renderTargetProperties.__webglColorRenderbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
      if (renderTargetProperties.__webglDepthRenderbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
    }
    if (renderTarget.isWebGLMultipleRenderTargets) {
      for (let i2 = 0, il2 = texture.length; i2 < il2; i2++) {
        const attachmentProperties = properties.get(texture[i2]);
        if (attachmentProperties.__webglTexture) {
          _gl.deleteTexture(attachmentProperties.__webglTexture);
          info.memory.textures--;
        }
        properties.remove(texture[i2]);
      }
    }
    properties.remove(texture);
    properties.remove(renderTarget);
  }
  let textureUnits = 0;
  function resetTextureUnits() {
    textureUnits = 0;
  }
  function allocateTextureUnit() {
    const textureUnit = textureUnits;
    if (textureUnit >= maxTextures) {
      console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
    }
    textureUnits += 1;
    return textureUnit;
  }
  function setTexture2D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.isVideoTexture)
      updateVideoTexture(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      const image = texture.image;
      if (image === void 0) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
      } else if (image.complete === false) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(3553, textureProperties.__webglTexture);
  }
  function setTexture2DArray(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(35866, textureProperties.__webglTexture);
  }
  function setTexture3D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(32879, textureProperties.__webglTexture);
  }
  function setTextureCube(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadCubeTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);
  }
  const wrappingToGL = {
    [RepeatWrapping]: 10497,
    [ClampToEdgeWrapping]: 33071,
    [MirroredRepeatWrapping]: 33648
  };
  const filterToGL = {
    [NearestFilter]: 9728,
    [NearestMipmapNearestFilter]: 9984,
    [NearestMipmapLinearFilter]: 9986,
    [LinearFilter]: 9729,
    [LinearMipmapNearestFilter]: 9985,
    [LinearMipmapLinearFilter]: 9987
  };
  function setTextureParameters(textureType, texture, supportsMips) {
    if (supportsMips) {
      _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);
      _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
      }
      _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);
      _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
    } else {
      _gl.texParameteri(textureType, 10242, 33071);
      _gl.texParameteri(textureType, 10243, 33071);
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, 33071);
      }
      if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
      }
      _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
      _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
      if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
      }
    }
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false)
        return;
      if (isWebGL2 === false && (texture.type === HalfFloatType && extensions.has("OES_texture_half_float_linear") === false))
        return;
      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }
  function initTexture(textureProperties, texture) {
    if (textureProperties.__webglInit === void 0) {
      textureProperties.__webglInit = true;
      texture.addEventListener("dispose", onTextureDispose);
      textureProperties.__webglTexture = _gl.createTexture();
      info.memory.textures++;
    }
  }
  function uploadTexture(textureProperties, texture, slot) {
    let textureType = 3553;
    if (texture.isDataTexture2DArray)
      textureType = 35866;
    if (texture.isDataTexture3D)
      textureType = 32879;
    initTexture(textureProperties, texture);
    state.activeTexture(33984 + slot);
    state.bindTexture(textureType, textureProperties.__webglTexture);
    _gl.pixelStorei(37440, texture.flipY);
    _gl.pixelStorei(37441, texture.premultiplyAlpha);
    _gl.pixelStorei(3317, texture.unpackAlignment);
    _gl.pixelStorei(37443, 0);
    const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;
    const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
    const supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils2.convert(texture.format);
    let glType = utils2.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
    setTextureParameters(textureType, texture, supportsMips);
    let mipmap;
    const mipmaps = texture.mipmaps;
    if (texture.isDepthTexture) {
      glInternalFormat = 6402;
      if (isWebGL2) {
        if (texture.type === FloatType) {
          glInternalFormat = 36012;
        } else if (texture.type === UnsignedIntType) {
          glInternalFormat = 33190;
        } else if (texture.type === UnsignedInt248Type) {
          glInternalFormat = 35056;
        } else {
          glInternalFormat = 33189;
        }
      } else {
        if (texture.type === FloatType) {
          console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
        }
      }
      if (texture.format === DepthFormat && glInternalFormat === 6402) {
        if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
          console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
          texture.type = UnsignedShortType;
          glType = utils2.convert(texture.type);
        }
      }
      if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {
        glInternalFormat = 34041;
        if (texture.type !== UnsignedInt248Type) {
          console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
          texture.type = UnsignedInt248Type;
          glType = utils2.convert(texture.type);
        }
      }
      state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
    } else if (texture.isDataTexture) {
      if (mipmaps.length > 0 && supportsMips) {
        for (let i2 = 0, il2 = mipmaps.length; i2 < il2; i2++) {
          mipmap = mipmaps[i2];
          state.texImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
        textureProperties.__maxMipLevel = 0;
      }
    } else if (texture.isCompressedTexture) {
      for (let i2 = 0, il2 = mipmaps.length; i2 < il2; i2++) {
        mipmap = mipmaps[i2];
        if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
          if (glFormat !== null) {
            state.compressedTexImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
          } else {
            console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
          }
        } else {
          state.texImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
      }
      textureProperties.__maxMipLevel = mipmaps.length - 1;
    } else if (texture.isDataTexture2DArray) {
      state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
      textureProperties.__maxMipLevel = 0;
    } else if (texture.isDataTexture3D) {
      state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
      textureProperties.__maxMipLevel = 0;
    } else {
      if (mipmaps.length > 0 && supportsMips) {
        for (let i2 = 0, il2 = mipmaps.length; i2 < il2; i2++) {
          mipmap = mipmaps[i2];
          state.texImage2D(3553, i2, glInternalFormat, glFormat, glType, mipmap);
        }
        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
        textureProperties.__maxMipLevel = 0;
      }
    }
    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      generateMipmap(textureType, texture, image.width, image.height);
    }
    textureProperties.__version = texture.version;
    if (texture.onUpdate)
      texture.onUpdate(texture);
  }
  function uploadCubeTexture(textureProperties, texture, slot) {
    if (texture.image.length !== 6)
      return;
    initTexture(textureProperties, texture);
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);
    _gl.pixelStorei(37440, texture.flipY);
    _gl.pixelStorei(37441, texture.premultiplyAlpha);
    _gl.pixelStorei(3317, texture.unpackAlignment);
    _gl.pixelStorei(37443, 0);
    const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
    const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
    const cubeImage = [];
    for (let i2 = 0; i2 < 6; i2++) {
      if (!isCompressed && !isDataTexture) {
        cubeImage[i2] = resizeImage(texture.image[i2], false, true, maxCubemapSize);
      } else {
        cubeImage[i2] = isDataTexture ? texture.image[i2].image : texture.image[i2];
      }
    }
    const image = cubeImage[0], supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils2.convert(texture.format), glType = utils2.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
    setTextureParameters(34067, texture, supportsMips);
    let mipmaps;
    if (isCompressed) {
      for (let i2 = 0; i2 < 6; i2++) {
        mipmaps = cubeImage[i2].mipmaps;
        for (let j2 = 0; j2 < mipmaps.length; j2++) {
          const mipmap = mipmaps[j2];
          if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
            if (glFormat !== null) {
              state.compressedTexImage2D(34069 + i2, j2, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
            } else {
              console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
            }
          } else {
            state.texImage2D(34069 + i2, j2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
          }
        }
      }
      textureProperties.__maxMipLevel = mipmaps.length - 1;
    } else {
      mipmaps = texture.mipmaps;
      for (let i2 = 0; i2 < 6; i2++) {
        if (isDataTexture) {
          state.texImage2D(34069 + i2, 0, glInternalFormat, cubeImage[i2].width, cubeImage[i2].height, 0, glFormat, glType, cubeImage[i2].data);
          for (let j2 = 0; j2 < mipmaps.length; j2++) {
            const mipmap = mipmaps[j2];
            const mipmapImage = mipmap.image[i2].image;
            state.texImage2D(34069 + i2, j2 + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
          }
        } else {
          state.texImage2D(34069 + i2, 0, glInternalFormat, glFormat, glType, cubeImage[i2]);
          for (let j2 = 0; j2 < mipmaps.length; j2++) {
            const mipmap = mipmaps[j2];
            state.texImage2D(34069 + i2, j2 + 1, glInternalFormat, glFormat, glType, mipmap.image[i2]);
          }
        }
      }
      textureProperties.__maxMipLevel = mipmaps.length;
    }
    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      generateMipmap(34067, texture, image.width, image.height);
    }
    textureProperties.__version = texture.version;
    if (texture.onUpdate)
      texture.onUpdate(texture);
  }
  function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {
    const glFormat = utils2.convert(texture.format);
    const glType = utils2.convert(texture.type);
    const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
    if (textureTarget === 32879 || textureTarget === 35866) {
      state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
    } else {
      state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
    }
    state.bindFramebuffer(36160, framebuffer);
    _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0);
    state.bindFramebuffer(36160, null);
  }
  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(36161, renderbuffer);
    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      let glInternalFormat = 33189;
      if (isMultisample) {
        const depthTexture = renderTarget.depthTexture;
        if (depthTexture && depthTexture.isDepthTexture) {
          if (depthTexture.type === FloatType) {
            glInternalFormat = 36012;
          } else if (depthTexture.type === UnsignedIntType) {
            glInternalFormat = 33190;
          }
        }
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      if (isMultisample) {
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
    } else {
      const texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[0] : renderTarget.texture;
      const glFormat = utils2.convert(texture.format);
      const glType = utils2.convert(texture.type);
      const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
      if (isMultisample) {
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
    }
    _gl.bindRenderbuffer(36161, null);
  }
  function setupDepthTexture(framebuffer, renderTarget) {
    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
    if (isCube)
      throw new Error("Depth Texture with cube render targets is not supported");
    state.bindFramebuffer(36160, framebuffer);
    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    }
    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }
    setTexture2D(renderTarget.depthTexture, 0);
    const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
    if (renderTarget.depthTexture.format === DepthFormat) {
      _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
    } else {
      throw new Error("Unknown depthTexture format");
    }
  }
  function setupDepthRenderbuffer(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    if (renderTarget.depthTexture) {
      if (isCube)
        throw new Error("target.depthTexture not supported in Cube render targets");
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];
        for (let i2 = 0; i2 < 6; i2++) {
          state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i2]);
          renderTargetProperties.__webglDepthbuffer[i2] = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i2], renderTarget, false);
        }
      } else {
        state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
      }
    }
    state.bindFramebuffer(36160, null);
  }
  function setupRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    renderTarget.addEventListener("dispose", onRenderTargetDispose);
    if (renderTarget.isWebGLMultipleRenderTargets !== true) {
      textureProperties.__webglTexture = _gl.createTexture();
      textureProperties.__version = texture.version;
      info.memory.textures++;
    }
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
    const isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
    const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;
    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
    if (isWebGL2 && texture.format === RGBFormat && (texture.type === FloatType || texture.type === HalfFloatType)) {
      texture.format = RGBAFormat;
      console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.");
    }
    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];
      for (let i2 = 0; i2 < 6; i2++) {
        renderTargetProperties.__webglFramebuffer[i2] = _gl.createFramebuffer();
      }
    } else {
      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
      if (isMultipleRenderTargets) {
        if (capabilities.drawBuffers) {
          const textures = renderTarget.texture;
          for (let i2 = 0, il2 = textures.length; i2 < il2; i2++) {
            const attachmentProperties = properties.get(textures[i2]);
            if (attachmentProperties.__webglTexture === void 0) {
              attachmentProperties.__webglTexture = _gl.createTexture();
              info.memory.textures++;
            }
          }
        } else {
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
        }
      } else if (isMultisample) {
        if (isWebGL2) {
          renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
          renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
          _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);
          const glFormat = utils2.convert(texture.format);
          const glType = utils2.convert(texture.type);
          const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
          const samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
          _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);
          _gl.bindRenderbuffer(36161, null);
          if (renderTarget.depthBuffer) {
            renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
          }
          state.bindFramebuffer(36160, null);
        } else {
          console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
        }
      }
    }
    if (isCube) {
      state.bindTexture(34067, textureProperties.__webglTexture);
      setTextureParameters(34067, texture, supportsMips);
      for (let i2 = 0; i2 < 6; i2++) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i2], renderTarget, texture, 36064, 34069 + i2);
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(34067, texture, renderTarget.width, renderTarget.height);
      }
      state.unbindTexture();
    } else if (isMultipleRenderTargets) {
      const textures = renderTarget.texture;
      for (let i2 = 0, il2 = textures.length; i2 < il2; i2++) {
        const attachment = textures[i2];
        const attachmentProperties = properties.get(attachment);
        state.bindTexture(3553, attachmentProperties.__webglTexture);
        setTextureParameters(3553, attachment, supportsMips);
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, 36064 + i2, 3553);
        if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
          generateMipmap(3553, attachment, renderTarget.width, renderTarget.height);
        }
      }
      state.unbindTexture();
    } else {
      let glTextureType = 3553;
      if (isRenderTarget3D) {
        if (isWebGL2) {
          const isTexture3D = texture.isDataTexture3D;
          glTextureType = isTexture3D ? 32879 : 35866;
        } else {
          console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
        }
      }
      state.bindTexture(glTextureType, textureProperties.__webglTexture);
      setTextureParameters(glTextureType, texture, supportsMips);
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, 36064, glTextureType);
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(glTextureType, texture, renderTarget.width, renderTarget.height, renderTarget.depth);
      }
      state.unbindTexture();
    }
    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function updateRenderTargetMipmap(renderTarget) {
    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
    const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
    for (let i2 = 0, il2 = textures.length; i2 < il2; i2++) {
      const texture = textures[i2];
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
        const webglTexture = properties.get(texture).__webglTexture;
        state.bindTexture(target, webglTexture);
        generateMipmap(target, texture, renderTarget.width, renderTarget.height);
        state.unbindTexture();
      }
    }
  }
  function updateMultisampleRenderTarget(renderTarget) {
    if (renderTarget.isWebGLMultisampleRenderTarget) {
      if (isWebGL2) {
        const width = renderTarget.width;
        const height = renderTarget.height;
        let mask = 16384;
        if (renderTarget.depthBuffer)
          mask |= 256;
        if (renderTarget.stencilBuffer)
          mask |= 1024;
        const renderTargetProperties = properties.get(renderTarget);
        state.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
        state.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
        _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);
        state.bindFramebuffer(36008, null);
        state.bindFramebuffer(36009, renderTargetProperties.__webglMultisampledFramebuffer);
      } else {
        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
      }
    }
  }
  function getRenderTargetSamples(renderTarget) {
    return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
  }
  function updateVideoTexture(texture) {
    const frame = info.render.frame;
    if (_videoTextures.get(texture) !== frame) {
      _videoTextures.set(texture, frame);
      texture.update();
    }
  }
  let warnedTexture2D = false;
  let warnedTextureCube = false;
  function safeSetTexture2D(texture, slot) {
    if (texture && texture.isWebGLRenderTarget) {
      if (warnedTexture2D === false) {
        console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
        warnedTexture2D = true;
      }
      texture = texture.texture;
    }
    setTexture2D(texture, slot);
  }
  function safeSetTextureCube(texture, slot) {
    if (texture && texture.isWebGLCubeRenderTarget) {
      if (warnedTextureCube === false) {
        console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
        warnedTextureCube = true;
      }
      texture = texture.texture;
    }
    setTextureCube(texture, slot);
  }
  this.allocateTextureUnit = allocateTextureUnit;
  this.resetTextureUnits = resetTextureUnits;
  this.setTexture2D = setTexture2D;
  this.setTexture2DArray = setTexture2DArray;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  this.safeSetTexture2D = safeSetTexture2D;
  this.safeSetTextureCube = safeSetTextureCube;
}
function WebGLUtils(gl2, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function convert2(p2) {
    let extension;
    if (p2 === UnsignedByteType)
      return 5121;
    if (p2 === UnsignedShort4444Type)
      return 32819;
    if (p2 === UnsignedShort5551Type)
      return 32820;
    if (p2 === UnsignedShort565Type)
      return 33635;
    if (p2 === ByteType)
      return 5120;
    if (p2 === ShortType)
      return 5122;
    if (p2 === UnsignedShortType)
      return 5123;
    if (p2 === IntType)
      return 5124;
    if (p2 === UnsignedIntType)
      return 5125;
    if (p2 === FloatType)
      return 5126;
    if (p2 === HalfFloatType) {
      if (isWebGL2)
        return 5131;
      extension = extensions.get("OES_texture_half_float");
      if (extension !== null) {
        return extension.HALF_FLOAT_OES;
      } else {
        return null;
      }
    }
    if (p2 === AlphaFormat)
      return 6406;
    if (p2 === RGBFormat)
      return 6407;
    if (p2 === RGBAFormat)
      return 6408;
    if (p2 === LuminanceFormat)
      return 6409;
    if (p2 === LuminanceAlphaFormat)
      return 6410;
    if (p2 === DepthFormat)
      return 6402;
    if (p2 === DepthStencilFormat)
      return 34041;
    if (p2 === RedFormat)
      return 6403;
    if (p2 === RedIntegerFormat)
      return 36244;
    if (p2 === RGFormat)
      return 33319;
    if (p2 === RGIntegerFormat)
      return 33320;
    if (p2 === RGBIntegerFormat)
      return 36248;
    if (p2 === RGBAIntegerFormat)
      return 36249;
    if (p2 === RGB_S3TC_DXT1_Format || p2 === RGBA_S3TC_DXT1_Format || p2 === RGBA_S3TC_DXT3_Format || p2 === RGBA_S3TC_DXT5_Format) {
      extension = extensions.get("WEBGL_compressed_texture_s3tc");
      if (extension !== null) {
        if (p2 === RGB_S3TC_DXT1_Format)
          return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (p2 === RGBA_S3TC_DXT1_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (p2 === RGBA_S3TC_DXT3_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (p2 === RGBA_S3TC_DXT5_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else {
        return null;
      }
    }
    if (p2 === RGB_PVRTC_4BPPV1_Format || p2 === RGB_PVRTC_2BPPV1_Format || p2 === RGBA_PVRTC_4BPPV1_Format || p2 === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_pvrtc");
      if (extension !== null) {
        if (p2 === RGB_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p2 === RGB_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p2 === RGBA_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p2 === RGBA_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }
    if (p2 === RGB_ETC1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc1");
      if (extension !== null) {
        return extension.COMPRESSED_RGB_ETC1_WEBGL;
      } else {
        return null;
      }
    }
    if (p2 === RGB_ETC2_Format || p2 === RGBA_ETC2_EAC_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc");
      if (extension !== null) {
        if (p2 === RGB_ETC2_Format)
          return extension.COMPRESSED_RGB8_ETC2;
        if (p2 === RGBA_ETC2_EAC_Format)
          return extension.COMPRESSED_RGBA8_ETC2_EAC;
      }
    }
    if (p2 === RGBA_ASTC_4x4_Format || p2 === RGBA_ASTC_5x4_Format || p2 === RGBA_ASTC_5x5_Format || p2 === RGBA_ASTC_6x5_Format || p2 === RGBA_ASTC_6x6_Format || p2 === RGBA_ASTC_8x5_Format || p2 === RGBA_ASTC_8x6_Format || p2 === RGBA_ASTC_8x8_Format || p2 === RGBA_ASTC_10x5_Format || p2 === RGBA_ASTC_10x6_Format || p2 === RGBA_ASTC_10x8_Format || p2 === RGBA_ASTC_10x10_Format || p2 === RGBA_ASTC_12x10_Format || p2 === RGBA_ASTC_12x12_Format || p2 === SRGB8_ALPHA8_ASTC_4x4_Format || p2 === SRGB8_ALPHA8_ASTC_5x4_Format || p2 === SRGB8_ALPHA8_ASTC_5x5_Format || p2 === SRGB8_ALPHA8_ASTC_6x5_Format || p2 === SRGB8_ALPHA8_ASTC_6x6_Format || p2 === SRGB8_ALPHA8_ASTC_8x5_Format || p2 === SRGB8_ALPHA8_ASTC_8x6_Format || p2 === SRGB8_ALPHA8_ASTC_8x8_Format || p2 === SRGB8_ALPHA8_ASTC_10x5_Format || p2 === SRGB8_ALPHA8_ASTC_10x6_Format || p2 === SRGB8_ALPHA8_ASTC_10x8_Format || p2 === SRGB8_ALPHA8_ASTC_10x10_Format || p2 === SRGB8_ALPHA8_ASTC_12x10_Format || p2 === SRGB8_ALPHA8_ASTC_12x12_Format) {
      extension = extensions.get("WEBGL_compressed_texture_astc");
      if (extension !== null) {
        return p2;
      } else {
        return null;
      }
    }
    if (p2 === RGBA_BPTC_Format) {
      extension = extensions.get("EXT_texture_compression_bptc");
      if (extension !== null) {
        return p2;
      } else {
        return null;
      }
    }
    if (p2 === UnsignedInt248Type) {
      if (isWebGL2)
        return 34042;
      extension = extensions.get("WEBGL_depth_texture");
      if (extension !== null) {
        return extension.UNSIGNED_INT_24_8_WEBGL;
      } else {
        return null;
      }
    }
  }
  return { convert: convert2 };
}
class ArrayCamera extends PerspectiveCamera {
  constructor(array = []) {
    super();
    this.cameras = array;
  }
}
ArrayCamera.prototype.isArrayCamera = true;
class Group extends Object3D {
  constructor() {
    super();
    this.type = "Group";
  }
}
Group.prototype.isGroup = true;
const _moveEvent = { type: "move" };
class WebXRController {
  constructor() {
    this._targetRay = null;
    this._grip = null;
    this._hand = null;
  }
  getHandSpace() {
    if (this._hand === null) {
      this._hand = new Group();
      this._hand.matrixAutoUpdate = false;
      this._hand.visible = false;
      this._hand.joints = {};
      this._hand.inputState = { pinching: false };
    }
    return this._hand;
  }
  getTargetRaySpace() {
    if (this._targetRay === null) {
      this._targetRay = new Group();
      this._targetRay.matrixAutoUpdate = false;
      this._targetRay.visible = false;
      this._targetRay.hasLinearVelocity = false;
      this._targetRay.linearVelocity = new Vector3();
      this._targetRay.hasAngularVelocity = false;
      this._targetRay.angularVelocity = new Vector3();
    }
    return this._targetRay;
  }
  getGripSpace() {
    if (this._grip === null) {
      this._grip = new Group();
      this._grip.matrixAutoUpdate = false;
      this._grip.visible = false;
      this._grip.hasLinearVelocity = false;
      this._grip.linearVelocity = new Vector3();
      this._grip.hasAngularVelocity = false;
      this._grip.angularVelocity = new Vector3();
    }
    return this._grip;
  }
  dispatchEvent(event) {
    if (this._targetRay !== null) {
      this._targetRay.dispatchEvent(event);
    }
    if (this._grip !== null) {
      this._grip.dispatchEvent(event);
    }
    if (this._hand !== null) {
      this._hand.dispatchEvent(event);
    }
    return this;
  }
  disconnect(inputSource) {
    this.dispatchEvent({ type: "disconnected", data: inputSource });
    if (this._targetRay !== null) {
      this._targetRay.visible = false;
    }
    if (this._grip !== null) {
      this._grip.visible = false;
    }
    if (this._hand !== null) {
      this._hand.visible = false;
    }
    return this;
  }
  update(inputSource, frame, referenceSpace) {
    let inputPose = null;
    let gripPose = null;
    let handPose = null;
    const targetRay = this._targetRay;
    const grip = this._grip;
    const hand = this._hand;
    if (inputSource && frame.session.visibilityState !== "visible-blurred") {
      if (targetRay !== null) {
        inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
        if (inputPose !== null) {
          targetRay.matrix.fromArray(inputPose.transform.matrix);
          targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
          if (inputPose.linearVelocity) {
            targetRay.hasLinearVelocity = true;
            targetRay.linearVelocity.copy(inputPose.linearVelocity);
          } else {
            targetRay.hasLinearVelocity = false;
          }
          if (inputPose.angularVelocity) {
            targetRay.hasAngularVelocity = true;
            targetRay.angularVelocity.copy(inputPose.angularVelocity);
          } else {
            targetRay.hasAngularVelocity = false;
          }
          this.dispatchEvent(_moveEvent);
        }
      }
      if (hand && inputSource.hand) {
        handPose = true;
        for (const inputjoint of inputSource.hand.values()) {
          const jointPose = frame.getJointPose(inputjoint, referenceSpace);
          if (hand.joints[inputjoint.jointName] === void 0) {
            const joint2 = new Group();
            joint2.matrixAutoUpdate = false;
            joint2.visible = false;
            hand.joints[inputjoint.jointName] = joint2;
            hand.add(joint2);
          }
          const joint = hand.joints[inputjoint.jointName];
          if (jointPose !== null) {
            joint.matrix.fromArray(jointPose.transform.matrix);
            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
            joint.jointRadius = jointPose.radius;
          }
          joint.visible = jointPose !== null;
        }
        const indexTip = hand.joints["index-finger-tip"];
        const thumbTip = hand.joints["thumb-tip"];
        const distance = indexTip.position.distanceTo(thumbTip.position);
        const distanceToPinch = 0.02;
        const threshold = 5e-3;
        if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
          hand.inputState.pinching = false;
          this.dispatchEvent({
            type: "pinchend",
            handedness: inputSource.handedness,
            target: this
          });
        } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
          hand.inputState.pinching = true;
          this.dispatchEvent({
            type: "pinchstart",
            handedness: inputSource.handedness,
            target: this
          });
        }
      } else {
        if (grip !== null && inputSource.gripSpace) {
          gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
          if (gripPose !== null) {
            grip.matrix.fromArray(gripPose.transform.matrix);
            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
            if (gripPose.linearVelocity) {
              grip.hasLinearVelocity = true;
              grip.linearVelocity.copy(gripPose.linearVelocity);
            } else {
              grip.hasLinearVelocity = false;
            }
            if (gripPose.angularVelocity) {
              grip.hasAngularVelocity = true;
              grip.angularVelocity.copy(gripPose.angularVelocity);
            } else {
              grip.hasAngularVelocity = false;
            }
          }
        }
      }
    }
    if (targetRay !== null) {
      targetRay.visible = inputPose !== null;
    }
    if (grip !== null) {
      grip.visible = gripPose !== null;
    }
    if (hand !== null) {
      hand.visible = handPose !== null;
    }
    return this;
  }
}
class WebXRManager extends EventDispatcher {
  constructor(renderer, gl2) {
    super();
    const scope = this;
    const state = renderer.state;
    let session = null;
    let framebufferScaleFactor = 1;
    let referenceSpace = null;
    let referenceSpaceType = "local-floor";
    let pose = null;
    let glBinding = null;
    let glFramebuffer = null;
    let glProjLayer = null;
    let glBaseLayer = null;
    let isMultisample = false;
    let glMultisampledFramebuffer = null;
    let glColorRenderbuffer = null;
    let glDepthRenderbuffer = null;
    let xrFrame = null;
    let depthStyle = null;
    let clearStyle = null;
    const controllers = [];
    const inputSourcesMap = new Map();
    const cameraL = new PerspectiveCamera();
    cameraL.layers.enable(1);
    cameraL.viewport = new Vector4();
    const cameraR = new PerspectiveCamera();
    cameraR.layers.enable(2);
    cameraR.viewport = new Vector4();
    const cameras = [cameraL, cameraR];
    const cameraVR = new ArrayCamera();
    cameraVR.layers.enable(1);
    cameraVR.layers.enable(2);
    let _currentDepthNear = null;
    let _currentDepthFar = null;
    this.cameraAutoUpdate = true;
    this.enabled = false;
    this.isPresenting = false;
    this.getController = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getTargetRaySpace();
    };
    this.getControllerGrip = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getGripSpace();
    };
    this.getHand = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getHandSpace();
    };
    function onSessionEvent(event) {
      const controller = inputSourcesMap.get(event.inputSource);
      if (controller) {
        controller.dispatchEvent({ type: event.type, data: event.inputSource });
      }
    }
    function onSessionEnd() {
      inputSourcesMap.forEach(function(controller, inputSource) {
        controller.disconnect(inputSource);
      });
      inputSourcesMap.clear();
      _currentDepthNear = null;
      _currentDepthFar = null;
      state.bindXRFramebuffer(null);
      renderer.setRenderTarget(renderer.getRenderTarget());
      if (glFramebuffer)
        gl2.deleteFramebuffer(glFramebuffer);
      if (glMultisampledFramebuffer)
        gl2.deleteFramebuffer(glMultisampledFramebuffer);
      if (glColorRenderbuffer)
        gl2.deleteRenderbuffer(glColorRenderbuffer);
      if (glDepthRenderbuffer)
        gl2.deleteRenderbuffer(glDepthRenderbuffer);
      glFramebuffer = null;
      glMultisampledFramebuffer = null;
      glColorRenderbuffer = null;
      glDepthRenderbuffer = null;
      glBaseLayer = null;
      glProjLayer = null;
      glBinding = null;
      session = null;
      animation.stop();
      scope.isPresenting = false;
      scope.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(value) {
      framebufferScaleFactor = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
      }
    };
    this.setReferenceSpaceType = function(value) {
      referenceSpaceType = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
      }
    };
    this.getReferenceSpace = function() {
      return referenceSpace;
    };
    this.getBaseLayer = function() {
      return glProjLayer !== null ? glProjLayer : glBaseLayer;
    };
    this.getBinding = function() {
      return glBinding;
    };
    this.getFrame = function() {
      return xrFrame;
    };
    this.getSession = function() {
      return session;
    };
    this.setSession = async function(value) {
      session = value;
      if (session !== null) {
        session.addEventListener("select", onSessionEvent);
        session.addEventListener("selectstart", onSessionEvent);
        session.addEventListener("selectend", onSessionEvent);
        session.addEventListener("squeeze", onSessionEvent);
        session.addEventListener("squeezestart", onSessionEvent);
        session.addEventListener("squeezeend", onSessionEvent);
        session.addEventListener("end", onSessionEnd);
        session.addEventListener("inputsourceschange", onInputSourcesChange);
        const attributes = gl2.getContextAttributes();
        if (attributes.xrCompatible !== true) {
          await gl2.makeXRCompatible();
        }
        if (session.renderState.layers === void 0) {
          const layerInit = {
            antialias: attributes.antialias,
            alpha: attributes.alpha,
            depth: attributes.depth,
            stencil: attributes.stencil,
            framebufferScaleFactor
          };
          glBaseLayer = new XRWebGLLayer(session, gl2, layerInit);
          session.updateRenderState({ baseLayer: glBaseLayer });
        } else if (gl2 instanceof WebGLRenderingContext) {
          const layerInit = {
            antialias: true,
            alpha: attributes.alpha,
            depth: attributes.depth,
            stencil: attributes.stencil,
            framebufferScaleFactor
          };
          glBaseLayer = new XRWebGLLayer(session, gl2, layerInit);
          session.updateRenderState({ layers: [glBaseLayer] });
        } else {
          isMultisample = attributes.antialias;
          let depthFormat = null;
          if (attributes.depth) {
            clearStyle = 256;
            if (attributes.stencil)
              clearStyle |= 1024;
            depthStyle = attributes.stencil ? 33306 : 36096;
            depthFormat = attributes.stencil ? 35056 : 33190;
          }
          const projectionlayerInit = {
            colorFormat: attributes.alpha ? 32856 : 32849,
            depthFormat,
            scaleFactor: framebufferScaleFactor
          };
          glBinding = new XRWebGLBinding(session, gl2);
          glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
          glFramebuffer = gl2.createFramebuffer();
          session.updateRenderState({ layers: [glProjLayer] });
          if (isMultisample) {
            glMultisampledFramebuffer = gl2.createFramebuffer();
            glColorRenderbuffer = gl2.createRenderbuffer();
            gl2.bindRenderbuffer(36161, glColorRenderbuffer);
            gl2.renderbufferStorageMultisample(36161, 4, 32856, glProjLayer.textureWidth, glProjLayer.textureHeight);
            state.bindFramebuffer(36160, glMultisampledFramebuffer);
            gl2.framebufferRenderbuffer(36160, 36064, 36161, glColorRenderbuffer);
            gl2.bindRenderbuffer(36161, null);
            if (depthFormat !== null) {
              glDepthRenderbuffer = gl2.createRenderbuffer();
              gl2.bindRenderbuffer(36161, glDepthRenderbuffer);
              gl2.renderbufferStorageMultisample(36161, 4, depthFormat, glProjLayer.textureWidth, glProjLayer.textureHeight);
              gl2.framebufferRenderbuffer(36160, depthStyle, 36161, glDepthRenderbuffer);
              gl2.bindRenderbuffer(36161, null);
            }
            state.bindFramebuffer(36160, null);
          }
        }
        referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
        animation.setContext(session);
        animation.start();
        scope.isPresenting = true;
        scope.dispatchEvent({ type: "sessionstart" });
      }
    };
    function onInputSourcesChange(event) {
      const inputSources = session.inputSources;
      for (let i2 = 0; i2 < controllers.length; i2++) {
        inputSourcesMap.set(inputSources[i2], controllers[i2]);
      }
      for (let i2 = 0; i2 < event.removed.length; i2++) {
        const inputSource = event.removed[i2];
        const controller = inputSourcesMap.get(inputSource);
        if (controller) {
          controller.dispatchEvent({ type: "disconnected", data: inputSource });
          inputSourcesMap.delete(inputSource);
        }
      }
      for (let i2 = 0; i2 < event.added.length; i2++) {
        const inputSource = event.added[i2];
        const controller = inputSourcesMap.get(inputSource);
        if (controller) {
          controller.dispatchEvent({ type: "connected", data: inputSource });
        }
      }
    }
    const cameraLPos = new Vector3();
    const cameraRPos = new Vector3();
    function setProjectionFromUnion(camera, cameraL2, cameraR2) {
      cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
      cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
      const ipd = cameraLPos.distanceTo(cameraRPos);
      const projL = cameraL2.projectionMatrix.elements;
      const projR = cameraR2.projectionMatrix.elements;
      const near = projL[14] / (projL[10] - 1);
      const far = projL[14] / (projL[10] + 1);
      const topFov = (projL[9] + 1) / projL[5];
      const bottomFov = (projL[9] - 1) / projL[5];
      const leftFov = (projL[8] - 1) / projL[0];
      const rightFov = (projR[8] + 1) / projR[0];
      const left2 = near * leftFov;
      const right = near * rightFov;
      const zOffset = ipd / (-leftFov + rightFov);
      const xOffset = zOffset * -leftFov;
      cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
      camera.translateX(xOffset);
      camera.translateZ(zOffset);
      camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
      const near2 = near + zOffset;
      const far2 = far + zOffset;
      const left22 = left2 - xOffset;
      const right2 = right + (ipd - xOffset);
      const top2 = topFov * far / far2 * near2;
      const bottom2 = bottomFov * far / far2 * near2;
      camera.projectionMatrix.makePerspective(left22, right2, top2, bottom2, near2, far2);
    }
    function updateCamera(camera, parent) {
      if (parent === null) {
        camera.matrixWorld.copy(camera.matrix);
      } else {
        camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
      }
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
    }
    this.updateCamera = function(camera) {
      if (session === null)
        return;
      cameraVR.near = cameraR.near = cameraL.near = camera.near;
      cameraVR.far = cameraR.far = cameraL.far = camera.far;
      if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
        session.updateRenderState({
          depthNear: cameraVR.near,
          depthFar: cameraVR.far
        });
        _currentDepthNear = cameraVR.near;
        _currentDepthFar = cameraVR.far;
      }
      const parent = camera.parent;
      const cameras2 = cameraVR.cameras;
      updateCamera(cameraVR, parent);
      for (let i2 = 0; i2 < cameras2.length; i2++) {
        updateCamera(cameras2[i2], parent);
      }
      cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale);
      camera.position.copy(cameraVR.position);
      camera.quaternion.copy(cameraVR.quaternion);
      camera.scale.copy(cameraVR.scale);
      camera.matrix.copy(cameraVR.matrix);
      camera.matrixWorld.copy(cameraVR.matrixWorld);
      const children = camera.children;
      for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
        children[i2].updateMatrixWorld(true);
      }
      if (cameras2.length === 2) {
        setProjectionFromUnion(cameraVR, cameraL, cameraR);
      } else {
        cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
      }
    };
    this.getCamera = function() {
      return cameraVR;
    };
    this.getFoveation = function() {
      if (glProjLayer !== null) {
        return glProjLayer.fixedFoveation;
      }
      if (glBaseLayer !== null) {
        return glBaseLayer.fixedFoveation;
      }
      return void 0;
    };
    this.setFoveation = function(foveation) {
      if (glProjLayer !== null) {
        glProjLayer.fixedFoveation = foveation;
      }
      if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== void 0) {
        glBaseLayer.fixedFoveation = foveation;
      }
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time, frame) {
      pose = frame.getViewerPose(referenceSpace);
      xrFrame = frame;
      if (pose !== null) {
        const views = pose.views;
        if (glBaseLayer !== null) {
          state.bindXRFramebuffer(glBaseLayer.framebuffer);
        }
        let cameraVRNeedsUpdate = false;
        if (views.length !== cameraVR.cameras.length) {
          cameraVR.cameras.length = 0;
          cameraVRNeedsUpdate = true;
        }
        for (let i2 = 0; i2 < views.length; i2++) {
          const view = views[i2];
          let viewport = null;
          if (glBaseLayer !== null) {
            viewport = glBaseLayer.getViewport(view);
          } else {
            const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
            state.bindXRFramebuffer(glFramebuffer);
            if (glSubImage.depthStencilTexture !== void 0) {
              gl2.framebufferTexture2D(36160, depthStyle, 3553, glSubImage.depthStencilTexture, 0);
            }
            gl2.framebufferTexture2D(36160, 36064, 3553, glSubImage.colorTexture, 0);
            viewport = glSubImage.viewport;
          }
          const camera = cameras[i2];
          camera.matrix.fromArray(view.transform.matrix);
          camera.projectionMatrix.fromArray(view.projectionMatrix);
          camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
          if (i2 === 0) {
            cameraVR.matrix.copy(camera.matrix);
          }
          if (cameraVRNeedsUpdate === true) {
            cameraVR.cameras.push(camera);
          }
        }
        if (isMultisample) {
          state.bindXRFramebuffer(glMultisampledFramebuffer);
          if (clearStyle !== null)
            gl2.clear(clearStyle);
        }
      }
      const inputSources = session.inputSources;
      for (let i2 = 0; i2 < controllers.length; i2++) {
        const controller = controllers[i2];
        const inputSource = inputSources[i2];
        controller.update(inputSource, frame, referenceSpace);
      }
      if (onAnimationFrameCallback)
        onAnimationFrameCallback(time, frame);
      if (isMultisample) {
        const width = glProjLayer.textureWidth;
        const height = glProjLayer.textureHeight;
        state.bindFramebuffer(36008, glMultisampledFramebuffer);
        state.bindFramebuffer(36009, glFramebuffer);
        gl2.invalidateFramebuffer(36008, [depthStyle]);
        gl2.invalidateFramebuffer(36009, [depthStyle]);
        gl2.blitFramebuffer(0, 0, width, height, 0, 0, width, height, 16384, 9728);
        gl2.invalidateFramebuffer(36008, [36064]);
        state.bindFramebuffer(36008, null);
        state.bindFramebuffer(36009, null);
        state.bindFramebuffer(36160, glMultisampledFramebuffer);
      }
      xrFrame = null;
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
    };
    this.dispose = function() {
    };
  }
}
function WebGLMaterials(properties) {
  function refreshFogUniforms(uniforms, fog) {
    uniforms.fogColor.value.copy(fog.color);
    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }
  function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
    if (material.isMeshBasicMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshLambertMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsLambert(uniforms, material);
    } else if (material.isMeshToonMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsToon(uniforms, material);
    } else if (material.isMeshPhongMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsPhong(uniforms, material);
    } else if (material.isMeshStandardMaterial) {
      refreshUniformsCommon(uniforms, material);
      if (material.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
      } else {
        refreshUniformsStandard(uniforms, material);
      }
    } else if (material.isMeshMatcapMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsMatcap(uniforms, material);
    } else if (material.isMeshDepthMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDepth(uniforms, material);
    } else if (material.isMeshDistanceMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDistance(uniforms, material);
    } else if (material.isMeshNormalMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsNormal(uniforms, material);
    } else if (material.isLineBasicMaterial) {
      refreshUniformsLine(uniforms, material);
      if (material.isLineDashedMaterial) {
        refreshUniformsDash(uniforms, material);
      }
    } else if (material.isPointsMaterial) {
      refreshUniformsPoints(uniforms, material, pixelRatio, height);
    } else if (material.isSpriteMaterial) {
      refreshUniformsSprites(uniforms, material);
    } else if (material.isShadowMaterial) {
      uniforms.color.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    } else if (material.isShaderMaterial) {
      material.uniformsNeedUpdate = false;
    }
  }
  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;
    if (material.color) {
      uniforms.diffuse.value.copy(material.color);
    }
    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMap.value = envMap;
      uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.ior.value = material.ior;
      uniforms.refractionRatio.value = material.refractionRatio;
      const maxMipLevel = properties.get(envMap).__maxMipLevel;
      if (maxMipLevel !== void 0) {
        uniforms.maxMipLevel.value = maxMipLevel;
      }
    }
    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;
    }
    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.specularMap) {
      uvScaleMap = material.specularMap;
    } else if (material.displacementMap) {
      uvScaleMap = material.displacementMap;
    } else if (material.normalMap) {
      uvScaleMap = material.normalMap;
    } else if (material.bumpMap) {
      uvScaleMap = material.bumpMap;
    } else if (material.roughnessMap) {
      uvScaleMap = material.roughnessMap;
    } else if (material.metalnessMap) {
      uvScaleMap = material.metalnessMap;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    } else if (material.emissiveMap) {
      uvScaleMap = material.emissiveMap;
    } else if (material.clearcoatMap) {
      uvScaleMap = material.clearcoatMap;
    } else if (material.clearcoatNormalMap) {
      uvScaleMap = material.clearcoatNormalMap;
    } else if (material.clearcoatRoughnessMap) {
      uvScaleMap = material.clearcoatRoughnessMap;
    } else if (material.specularIntensityMap) {
      uvScaleMap = material.specularIntensityMap;
    } else if (material.specularColorMap) {
      uvScaleMap = material.specularColorMap;
    } else if (material.transmissionMap) {
      uvScaleMap = material.transmissionMap;
    } else if (material.thicknessMap) {
      uvScaleMap = material.thicknessMap;
    } else if (material.sheenColorMap) {
      uvScaleMap = material.sheenColorMap;
    } else if (material.sheenRoughnessMap) {
      uvScaleMap = material.sheenRoughnessMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.isWebGLRenderTarget) {
        uvScaleMap = uvScaleMap.texture;
      }
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
    let uv2ScaleMap;
    if (material.aoMap) {
      uv2ScaleMap = material.aoMap;
    } else if (material.lightMap) {
      uv2ScaleMap = material.lightMap;
    }
    if (uv2ScaleMap !== void 0) {
      if (uv2ScaleMap.isWebGLRenderTarget) {
        uv2ScaleMap = uv2ScaleMap.texture;
      }
      if (uv2ScaleMap.matrixAutoUpdate === true) {
        uv2ScaleMap.updateMatrix();
      }
      uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
    }
  }
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
  }
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }
  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * pixelRatio;
    uniforms.scale.value = height * 0.5;
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  function refreshUniformsLambert(uniforms, material) {
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
  }
  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular);
    uniforms.shininess.value = Math.max(material.shininess, 1e-4);
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsToon(uniforms, material) {
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsStandard(uniforms, material) {
    uniforms.roughness.value = material.roughness;
    uniforms.metalness.value = material.metalness;
    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
    }
    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }
  function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
    refreshUniformsStandard(uniforms, material);
    uniforms.ior.value = material.ior;
    if (material.sheen > 0) {
      uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
      uniforms.sheenRoughness.value = material.sheenRoughness;
      if (material.sheenColorMap) {
        uniforms.sheenColorMap.value = material.sheenColorMap;
      }
      if (material.sheenRoughnessMap) {
        uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
      }
    }
    if (material.clearcoat > 0) {
      uniforms.clearcoat.value = material.clearcoat;
      uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
      if (material.clearcoatMap) {
        uniforms.clearcoatMap.value = material.clearcoatMap;
      }
      if (material.clearcoatRoughnessMap) {
        uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
      }
      if (material.clearcoatNormalMap) {
        uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
        uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
        if (material.side === BackSide) {
          uniforms.clearcoatNormalScale.value.negate();
        }
      }
    }
    if (material.transmission > 0) {
      uniforms.transmission.value = material.transmission;
      uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
      uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
      if (material.transmissionMap) {
        uniforms.transmissionMap.value = material.transmissionMap;
      }
      uniforms.thickness.value = material.thickness;
      if (material.thicknessMap) {
        uniforms.thicknessMap.value = material.thicknessMap;
      }
      uniforms.attenuationDistance.value = material.attenuationDistance;
      uniforms.attenuationColor.value.copy(material.attenuationColor);
    }
    uniforms.specularIntensity.value = material.specularIntensity;
    uniforms.specularColor.value.copy(material.specularColor);
    if (material.specularIntensityMap) {
      uniforms.specularIntensityMap.value = material.specularIntensityMap;
    }
    if (material.specularColorMap) {
      uniforms.specularColorMap.value = material.specularColorMap;
    }
  }
  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsDepth(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsDistance(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    uniforms.referencePosition.value.copy(material.referencePosition);
    uniforms.nearDistance.value = material.nearDistance;
    uniforms.farDistance.value = material.farDistance;
  }
  function refreshUniformsNormal(uniforms, material) {
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  return {
    refreshFogUniforms,
    refreshMaterialUniforms
  };
}
function createCanvasElement() {
  const canvas = createElementNS("canvas");
  canvas.style.display = "block";
  return canvas;
}
function WebGLRenderer(parameters = {}) {
  const _canvas2 = parameters.canvas !== void 0 ? parameters.canvas : createCanvasElement(), _context2 = parameters.context !== void 0 ? parameters.context : null, _alpha = parameters.alpha !== void 0 ? parameters.alpha : false, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== void 0 ? parameters.powerPreference : "default", _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== void 0 ? parameters.failIfMajorPerformanceCaveat : false;
  let currentRenderList = null;
  let currentRenderState = null;
  const renderListStack = [];
  const renderStateStack = [];
  this.domElement = _canvas2;
  this.debug = {
    checkShaderErrors: true
  };
  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true;
  this.sortObjects = true;
  this.clippingPlanes = [];
  this.localClippingEnabled = false;
  this.gammaFactor = 2;
  this.outputEncoding = LinearEncoding;
  this.physicallyCorrectLights = false;
  this.toneMapping = NoToneMapping;
  this.toneMappingExposure = 1;
  const _this = this;
  let _isContextLost = false;
  let _currentActiveCubeFace = 0;
  let _currentActiveMipmapLevel = 0;
  let _currentRenderTarget = null;
  let _currentMaterialId = -1;
  let _currentCamera = null;
  const _currentViewport = new Vector4();
  const _currentScissor = new Vector4();
  let _currentScissorTest = null;
  let _width = _canvas2.width;
  let _height = _canvas2.height;
  let _pixelRatio = 1;
  let _opaqueSort = null;
  let _transparentSort = null;
  const _viewport = new Vector4(0, 0, _width, _height);
  const _scissor = new Vector4(0, 0, _width, _height);
  let _scissorTest = false;
  const _currentDrawBuffers = [];
  const _frustum = new Frustum();
  let _clippingEnabled = false;
  let _localClippingEnabled = false;
  let _transmissionRenderTarget = null;
  const _projScreenMatrix2 = new Matrix4();
  const _vector3 = new Vector3();
  const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
  function getTargetPixelRatio() {
    return _currentRenderTarget === null ? _pixelRatio : 1;
  }
  let _gl = _context2;
  function getContext(contextNames, contextAttributes) {
    for (let i2 = 0; i2 < contextNames.length; i2++) {
      const contextName = contextNames[i2];
      const context = _canvas2.getContext(contextName, contextAttributes);
      if (context !== null)
        return context;
    }
    return null;
  }
  try {
    const contextAttributes = {
      alpha: _alpha,
      depth: _depth,
      stencil: _stencil,
      antialias: _antialias,
      premultipliedAlpha: _premultipliedAlpha,
      preserveDrawingBuffer: _preserveDrawingBuffer,
      powerPreference: _powerPreference,
      failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
    };
    _canvas2.addEventListener("webglcontextlost", onContextLost, false);
    _canvas2.addEventListener("webglcontextrestored", onContextRestore, false);
    if (_gl === null) {
      const contextNames = ["webgl2", "webgl", "experimental-webgl"];
      if (_this.isWebGL1Renderer === true) {
        contextNames.shift();
      }
      _gl = getContext(contextNames, contextAttributes);
      if (_gl === null) {
        if (getContext(contextNames)) {
          throw new Error("Error creating WebGL context with your selected attributes.");
        } else {
          throw new Error("Error creating WebGL context.");
        }
      }
    }
    if (_gl.getShaderPrecisionFormat === void 0) {
      _gl.getShaderPrecisionFormat = function() {
        return { "rangeMin": 1, "rangeMax": 1, "precision": 1 };
      };
    }
  } catch (error2) {
    console.error("THREE.WebGLRenderer: " + error2.message);
    throw error2;
  }
  let extensions, capabilities, state, info;
  let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
  let programCache, materials, renderLists, renderStates, clipping, shadowMap;
  let background, morphtargets, bufferRenderer, indexedBufferRenderer;
  let utils2, bindingStates;
  function initGLContext() {
    extensions = new WebGLExtensions(_gl);
    capabilities = new WebGLCapabilities(_gl, extensions, parameters);
    extensions.init(capabilities);
    utils2 = new WebGLUtils(_gl, extensions, capabilities);
    state = new WebGLState(_gl, extensions, capabilities);
    _currentDrawBuffers[0] = 1029;
    info = new WebGLInfo(_gl);
    properties = new WebGLProperties();
    textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils2, info);
    cubemaps = new WebGLCubeMaps(_this);
    cubeuvmaps = new WebGLCubeUVMaps(_this);
    attributes = new WebGLAttributes(_gl, capabilities);
    bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
    geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
    objects = new WebGLObjects(_gl, geometries, attributes, info);
    morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
    clipping = new WebGLClipping(properties);
    programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
    materials = new WebGLMaterials(properties);
    renderLists = new WebGLRenderLists(properties);
    renderStates = new WebGLRenderStates(extensions, capabilities);
    background = new WebGLBackground(_this, cubemaps, state, objects, _premultipliedAlpha);
    shadowMap = new WebGLShadowMap(_this, objects, capabilities);
    bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
    indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
    info.programs = programCache.programs;
    _this.capabilities = capabilities;
    _this.extensions = extensions;
    _this.properties = properties;
    _this.renderLists = renderLists;
    _this.shadowMap = shadowMap;
    _this.state = state;
    _this.info = info;
  }
  initGLContext();
  const xr2 = new WebXRManager(_this, _gl);
  this.xr = xr2;
  this.getContext = function() {
    return _gl;
  };
  this.getContextAttributes = function() {
    return _gl.getContextAttributes();
  };
  this.forceContextLoss = function() {
    const extension = extensions.get("WEBGL_lose_context");
    if (extension)
      extension.loseContext();
  };
  this.forceContextRestore = function() {
    const extension = extensions.get("WEBGL_lose_context");
    if (extension)
      extension.restoreContext();
  };
  this.getPixelRatio = function() {
    return _pixelRatio;
  };
  this.setPixelRatio = function(value) {
    if (value === void 0)
      return;
    _pixelRatio = value;
    this.setSize(_width, _height, false);
  };
  this.getSize = function(target) {
    return target.set(_width, _height);
  };
  this.setSize = function(width, height, updateStyle) {
    if (xr2.isPresenting) {
      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
      return;
    }
    _width = width;
    _height = height;
    _canvas2.width = Math.floor(width * _pixelRatio);
    _canvas2.height = Math.floor(height * _pixelRatio);
    if (updateStyle !== false) {
      _canvas2.style.width = width + "px";
      _canvas2.style.height = height + "px";
    }
    this.setViewport(0, 0, width, height);
  };
  this.getDrawingBufferSize = function(target) {
    return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
  };
  this.setDrawingBufferSize = function(width, height, pixelRatio) {
    _width = width;
    _height = height;
    _pixelRatio = pixelRatio;
    _canvas2.width = Math.floor(width * pixelRatio);
    _canvas2.height = Math.floor(height * pixelRatio);
    this.setViewport(0, 0, width, height);
  };
  this.getCurrentViewport = function(target) {
    return target.copy(_currentViewport);
  };
  this.getViewport = function(target) {
    return target.copy(_viewport);
  };
  this.setViewport = function(x2, y2, width, height) {
    if (x2.isVector4) {
      _viewport.set(x2.x, x2.y, x2.z, x2.w);
    } else {
      _viewport.set(x2, y2, width, height);
    }
    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
  };
  this.getScissor = function(target) {
    return target.copy(_scissor);
  };
  this.setScissor = function(x2, y2, width, height) {
    if (x2.isVector4) {
      _scissor.set(x2.x, x2.y, x2.z, x2.w);
    } else {
      _scissor.set(x2, y2, width, height);
    }
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
  };
  this.getScissorTest = function() {
    return _scissorTest;
  };
  this.setScissorTest = function(boolean) {
    state.setScissorTest(_scissorTest = boolean);
  };
  this.setOpaqueSort = function(method) {
    _opaqueSort = method;
  };
  this.setTransparentSort = function(method) {
    _transparentSort = method;
  };
  this.getClearColor = function(target) {
    return target.copy(background.getClearColor());
  };
  this.setClearColor = function() {
    background.setClearColor.apply(background, arguments);
  };
  this.getClearAlpha = function() {
    return background.getClearAlpha();
  };
  this.setClearAlpha = function() {
    background.setClearAlpha.apply(background, arguments);
  };
  this.clear = function(color2, depth, stencil) {
    let bits = 0;
    if (color2 === void 0 || color2)
      bits |= 16384;
    if (depth === void 0 || depth)
      bits |= 256;
    if (stencil === void 0 || stencil)
      bits |= 1024;
    _gl.clear(bits);
  };
  this.clearColor = function() {
    this.clear(true, false, false);
  };
  this.clearDepth = function() {
    this.clear(false, true, false);
  };
  this.clearStencil = function() {
    this.clear(false, false, true);
  };
  this.dispose = function() {
    _canvas2.removeEventListener("webglcontextlost", onContextLost, false);
    _canvas2.removeEventListener("webglcontextrestored", onContextRestore, false);
    renderLists.dispose();
    renderStates.dispose();
    properties.dispose();
    cubemaps.dispose();
    cubeuvmaps.dispose();
    objects.dispose();
    bindingStates.dispose();
    xr2.dispose();
    xr2.removeEventListener("sessionstart", onXRSessionStart);
    xr2.removeEventListener("sessionend", onXRSessionEnd);
    if (_transmissionRenderTarget) {
      _transmissionRenderTarget.dispose();
      _transmissionRenderTarget = null;
    }
    animation.stop();
  };
  function onContextLost(event) {
    event.preventDefault();
    console.log("THREE.WebGLRenderer: Context Lost.");
    _isContextLost = true;
  }
  function onContextRestore() {
    console.log("THREE.WebGLRenderer: Context Restored.");
    _isContextLost = false;
    const infoAutoReset = info.autoReset;
    const shadowMapEnabled = shadowMap.enabled;
    const shadowMapAutoUpdate = shadowMap.autoUpdate;
    const shadowMapNeedsUpdate = shadowMap.needsUpdate;
    const shadowMapType = shadowMap.type;
    initGLContext();
    info.autoReset = infoAutoReset;
    shadowMap.enabled = shadowMapEnabled;
    shadowMap.autoUpdate = shadowMapAutoUpdate;
    shadowMap.needsUpdate = shadowMapNeedsUpdate;
    shadowMap.type = shadowMapType;
  }
  function onMaterialDispose(event) {
    const material = event.target;
    material.removeEventListener("dispose", onMaterialDispose);
    deallocateMaterial(material);
  }
  function deallocateMaterial(material) {
    releaseMaterialProgramReferences(material);
    properties.remove(material);
  }
  function releaseMaterialProgramReferences(material) {
    const programs = properties.get(material).programs;
    if (programs !== void 0) {
      programs.forEach(function(program) {
        programCache.releaseProgram(program);
      });
    }
  }
  this.renderBufferDirect = function(camera, scene, geometry2, material, object, group) {
    if (scene === null)
      scene = _emptyScene;
    const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
    const program = setProgram(camera, scene, geometry2, material, object);
    state.setMaterial(material, frontFaceCW);
    let index = geometry2.index;
    const position = geometry2.attributes.position;
    if (index === null) {
      if (position === void 0 || position.count === 0)
        return;
    } else if (index.count === 0) {
      return;
    }
    let rangeFactor = 1;
    if (material.wireframe === true) {
      index = geometries.getWireframeAttribute(geometry2);
      rangeFactor = 2;
    }
    bindingStates.setup(object, material, program, geometry2, index);
    let attribute;
    let renderer = bufferRenderer;
    if (index !== null) {
      attribute = attributes.get(index);
      renderer = indexedBufferRenderer;
      renderer.setIndex(attribute);
    }
    const dataCount = index !== null ? index.count : position.count;
    const rangeStart = geometry2.drawRange.start * rangeFactor;
    const rangeCount = geometry2.drawRange.count * rangeFactor;
    const groupStart = group !== null ? group.start * rangeFactor : 0;
    const groupCount = group !== null ? group.count * rangeFactor : Infinity;
    const drawStart = Math.max(rangeStart, groupStart);
    const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
    const drawCount = Math.max(0, drawEnd - drawStart + 1);
    if (drawCount === 0)
      return;
    if (object.isMesh) {
      if (material.wireframe === true) {
        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
        renderer.setMode(1);
      } else {
        renderer.setMode(4);
      }
    } else if (object.isLine) {
      let lineWidth = material.linewidth;
      if (lineWidth === void 0)
        lineWidth = 1;
      state.setLineWidth(lineWidth * getTargetPixelRatio());
      if (object.isLineSegments) {
        renderer.setMode(1);
      } else if (object.isLineLoop) {
        renderer.setMode(2);
      } else {
        renderer.setMode(3);
      }
    } else if (object.isPoints) {
      renderer.setMode(0);
    } else if (object.isSprite) {
      renderer.setMode(4);
    }
    if (object.isInstancedMesh) {
      renderer.renderInstances(drawStart, drawCount, object.count);
    } else if (geometry2.isInstancedBufferGeometry) {
      const instanceCount = Math.min(geometry2.instanceCount, geometry2._maxInstanceCount);
      renderer.renderInstances(drawStart, drawCount, instanceCount);
    } else {
      renderer.render(drawStart, drawCount);
    }
  };
  this.compile = function(scene, camera) {
    currentRenderState = renderStates.get(scene);
    currentRenderState.init();
    renderStateStack.push(currentRenderState);
    scene.traverseVisible(function(object) {
      if (object.isLight && object.layers.test(camera.layers)) {
        currentRenderState.pushLight(object);
        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      }
    });
    currentRenderState.setupLights(_this.physicallyCorrectLights);
    scene.traverse(function(object) {
      const material = object.material;
      if (material) {
        if (Array.isArray(material)) {
          for (let i2 = 0; i2 < material.length; i2++) {
            const material2 = material[i2];
            getProgram(material2, scene, object);
          }
        } else {
          getProgram(material, scene, object);
        }
      }
    });
    renderStateStack.pop();
    currentRenderState = null;
  };
  let onAnimationFrameCallback = null;
  function onAnimationFrame(time) {
    if (onAnimationFrameCallback)
      onAnimationFrameCallback(time);
  }
  function onXRSessionStart() {
    animation.stop();
  }
  function onXRSessionEnd() {
    animation.start();
  }
  const animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);
  if (typeof window !== "undefined")
    animation.setContext(window);
  this.setAnimationLoop = function(callback) {
    onAnimationFrameCallback = callback;
    xr2.setAnimationLoop(callback);
    callback === null ? animation.stop() : animation.start();
  };
  xr2.addEventListener("sessionstart", onXRSessionStart);
  xr2.addEventListener("sessionend", onXRSessionEnd);
  this.render = function(scene, camera) {
    if (camera !== void 0 && camera.isCamera !== true) {
      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      return;
    }
    if (_isContextLost === true)
      return;
    if (scene.autoUpdate === true)
      scene.updateMatrixWorld();
    if (camera.parent === null)
      camera.updateMatrixWorld();
    if (xr2.enabled === true && xr2.isPresenting === true) {
      if (xr2.cameraAutoUpdate === true)
        xr2.updateCamera(camera);
      camera = xr2.getCamera();
    }
    if (scene.isScene === true)
      scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
    currentRenderState = renderStates.get(scene, renderStateStack.length);
    currentRenderState.init();
    renderStateStack.push(currentRenderState);
    _projScreenMatrix2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    _frustum.setFromProjectionMatrix(_projScreenMatrix2);
    _localClippingEnabled = this.localClippingEnabled;
    _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
    currentRenderList = renderLists.get(scene, renderListStack.length);
    currentRenderList.init();
    renderListStack.push(currentRenderList);
    projectObject(scene, camera, 0, _this.sortObjects);
    currentRenderList.finish();
    if (_this.sortObjects === true) {
      currentRenderList.sort(_opaqueSort, _transparentSort);
    }
    if (_clippingEnabled === true)
      clipping.beginShadows();
    const shadowsArray = currentRenderState.state.shadowsArray;
    shadowMap.render(shadowsArray, scene, camera);
    if (_clippingEnabled === true)
      clipping.endShadows();
    if (this.info.autoReset === true)
      this.info.reset();
    background.render(currentRenderList, scene);
    currentRenderState.setupLights(_this.physicallyCorrectLights);
    if (camera.isArrayCamera) {
      const cameras = camera.cameras;
      for (let i2 = 0, l2 = cameras.length; i2 < l2; i2++) {
        const camera2 = cameras[i2];
        renderScene(currentRenderList, scene, camera2, camera2.viewport);
      }
    } else {
      renderScene(currentRenderList, scene, camera);
    }
    if (_currentRenderTarget !== null) {
      textures.updateMultisampleRenderTarget(_currentRenderTarget);
      textures.updateRenderTargetMipmap(_currentRenderTarget);
    }
    if (scene.isScene === true)
      scene.onAfterRender(_this, scene, camera);
    state.buffers.depth.setTest(true);
    state.buffers.depth.setMask(true);
    state.buffers.color.setMask(true);
    state.setPolygonOffset(false);
    bindingStates.resetDefaultState();
    _currentMaterialId = -1;
    _currentCamera = null;
    renderStateStack.pop();
    if (renderStateStack.length > 0) {
      currentRenderState = renderStateStack[renderStateStack.length - 1];
    } else {
      currentRenderState = null;
    }
    renderListStack.pop();
    if (renderListStack.length > 0) {
      currentRenderList = renderListStack[renderListStack.length - 1];
    } else {
      currentRenderList = null;
    }
  };
  function projectObject(object, camera, groupOrder, sortObjects) {
    if (object.visible === false)
      return;
    const visible = object.layers.test(camera.layers);
    if (visible) {
      if (object.isGroup) {
        groupOrder = object.renderOrder;
      } else if (object.isLOD) {
        if (object.autoUpdate === true)
          object.update(camera);
      } else if (object.isLight) {
        currentRenderState.pushLight(object);
        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      } else if (object.isSprite) {
        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
          }
          const geometry2 = objects.update(object);
          const material = object.material;
          if (material.visible) {
            currentRenderList.push(object, geometry2, material, groupOrder, _vector3.z, null);
          }
        }
      } else if (object.isMesh || object.isLine || object.isPoints) {
        if (object.isSkinnedMesh) {
          if (object.skeleton.frame !== info.render.frame) {
            object.skeleton.update();
            object.skeleton.frame = info.render.frame;
          }
        }
        if (!object.frustumCulled || _frustum.intersectsObject(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
          }
          const geometry2 = objects.update(object);
          const material = object.material;
          if (Array.isArray(material)) {
            const groups = geometry2.groups;
            for (let i2 = 0, l2 = groups.length; i2 < l2; i2++) {
              const group = groups[i2];
              const groupMaterial = material[group.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                currentRenderList.push(object, geometry2, groupMaterial, groupOrder, _vector3.z, group);
              }
            }
          } else if (material.visible) {
            currentRenderList.push(object, geometry2, material, groupOrder, _vector3.z, null);
          }
        }
      }
    }
    const children = object.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      projectObject(children[i2], camera, groupOrder, sortObjects);
    }
  }
  function renderScene(currentRenderList2, scene, camera, viewport) {
    const opaqueObjects = currentRenderList2.opaque;
    const transmissiveObjects = currentRenderList2.transmissive;
    const transparentObjects = currentRenderList2.transparent;
    currentRenderState.setupLightsView(camera);
    if (transmissiveObjects.length > 0)
      renderTransmissionPass(opaqueObjects, scene, camera);
    if (viewport)
      state.viewport(_currentViewport.copy(viewport));
    if (opaqueObjects.length > 0)
      renderObjects(opaqueObjects, scene, camera);
    if (transmissiveObjects.length > 0)
      renderObjects(transmissiveObjects, scene, camera);
    if (transparentObjects.length > 0)
      renderObjects(transparentObjects, scene, camera);
  }
  function renderTransmissionPass(opaqueObjects, scene, camera) {
    if (_transmissionRenderTarget === null) {
      const needsAntialias = _antialias === true && capabilities.isWebGL2 === true;
      const renderTargetType = needsAntialias ? WebGLMultisampleRenderTarget : WebGLRenderTarget;
      _transmissionRenderTarget = new renderTargetType(1024, 1024, {
        generateMipmaps: true,
        type: utils2.convert(HalfFloatType) !== null ? HalfFloatType : UnsignedByteType,
        minFilter: LinearMipmapLinearFilter,
        magFilter: NearestFilter,
        wrapS: ClampToEdgeWrapping,
        wrapT: ClampToEdgeWrapping
      });
    }
    const currentRenderTarget = _this.getRenderTarget();
    _this.setRenderTarget(_transmissionRenderTarget);
    _this.clear();
    const currentToneMapping = _this.toneMapping;
    _this.toneMapping = NoToneMapping;
    renderObjects(opaqueObjects, scene, camera);
    _this.toneMapping = currentToneMapping;
    textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
    textures.updateRenderTargetMipmap(_transmissionRenderTarget);
    _this.setRenderTarget(currentRenderTarget);
  }
  function renderObjects(renderList, scene, camera) {
    const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
    for (let i2 = 0, l2 = renderList.length; i2 < l2; i2++) {
      const renderItem = renderList[i2];
      const object = renderItem.object;
      const geometry2 = renderItem.geometry;
      const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
      const group = renderItem.group;
      if (object.layers.test(camera.layers)) {
        renderObject(object, scene, camera, geometry2, material, group);
      }
    }
  }
  function renderObject(object, scene, camera, geometry2, material, group) {
    object.onBeforeRender(_this, scene, camera, geometry2, material, group);
    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
    material.onBeforeRender(_this, scene, camera, geometry2, object, group);
    if (material.transparent === true && material.side === DoubleSide) {
      material.side = BackSide;
      material.needsUpdate = true;
      _this.renderBufferDirect(camera, scene, geometry2, material, object, group);
      material.side = FrontSide;
      material.needsUpdate = true;
      _this.renderBufferDirect(camera, scene, geometry2, material, object, group);
      material.side = DoubleSide;
    } else {
      _this.renderBufferDirect(camera, scene, geometry2, material, object, group);
    }
    object.onAfterRender(_this, scene, camera, geometry2, material, group);
  }
  function getProgram(material, scene, object) {
    if (scene.isScene !== true)
      scene = _emptyScene;
    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;
    const shadowsArray = currentRenderState.state.shadowsArray;
    const lightsStateVersion = lights.state.version;
    const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
    const programCacheKey = programCache.getProgramCacheKey(parameters2);
    let programs = materialProperties.programs;
    materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
    materialProperties.fog = scene.fog;
    materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
    if (programs === void 0) {
      material.addEventListener("dispose", onMaterialDispose);
      programs = new Map();
      materialProperties.programs = programs;
    }
    let program = programs.get(programCacheKey);
    if (program !== void 0) {
      if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
        updateCommonMaterialProperties(material, parameters2);
        return program;
      }
    } else {
      parameters2.uniforms = programCache.getUniforms(material);
      material.onBuild(object, parameters2, _this);
      material.onBeforeCompile(parameters2, _this);
      program = programCache.acquireProgram(parameters2, programCacheKey);
      programs.set(programCacheKey, program);
      materialProperties.uniforms = parameters2.uniforms;
    }
    const uniforms = materialProperties.uniforms;
    if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
      uniforms.clippingPlanes = clipping.uniform;
    }
    updateCommonMaterialProperties(material, parameters2);
    materialProperties.needsLights = materialNeedsLights(material);
    materialProperties.lightsStateVersion = lightsStateVersion;
    if (materialProperties.needsLights) {
      uniforms.ambientLightColor.value = lights.state.ambient;
      uniforms.lightProbe.value = lights.state.probe;
      uniforms.directionalLights.value = lights.state.directional;
      uniforms.directionalLightShadows.value = lights.state.directionalShadow;
      uniforms.spotLights.value = lights.state.spot;
      uniforms.spotLightShadows.value = lights.state.spotShadow;
      uniforms.rectAreaLights.value = lights.state.rectArea;
      uniforms.ltc_1.value = lights.state.rectAreaLTC1;
      uniforms.ltc_2.value = lights.state.rectAreaLTC2;
      uniforms.pointLights.value = lights.state.point;
      uniforms.pointLightShadows.value = lights.state.pointShadow;
      uniforms.hemisphereLights.value = lights.state.hemi;
      uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
      uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
      uniforms.spotShadowMap.value = lights.state.spotShadowMap;
      uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
      uniforms.pointShadowMap.value = lights.state.pointShadowMap;
      uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
    }
    const progUniforms = program.getUniforms();
    const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
    materialProperties.currentProgram = program;
    materialProperties.uniformsList = uniformsList;
    return program;
  }
  function updateCommonMaterialProperties(material, parameters2) {
    const materialProperties = properties.get(material);
    materialProperties.outputEncoding = parameters2.outputEncoding;
    materialProperties.instancing = parameters2.instancing;
    materialProperties.skinning = parameters2.skinning;
    materialProperties.morphTargets = parameters2.morphTargets;
    materialProperties.morphNormals = parameters2.morphNormals;
    materialProperties.morphTargetsCount = parameters2.morphTargetsCount;
    materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
    materialProperties.numIntersection = parameters2.numClipIntersection;
    materialProperties.vertexAlphas = parameters2.vertexAlphas;
    materialProperties.vertexTangents = parameters2.vertexTangents;
  }
  function setProgram(camera, scene, geometry2, material, object) {
    if (scene.isScene !== true)
      scene = _emptyScene;
    textures.resetTextureUnits();
    const fog = scene.fog;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
    const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
    const vertexAlphas = material.vertexColors === true && !!geometry2.attributes.color && geometry2.attributes.color.itemSize === 4;
    const vertexTangents = !!material.normalMap && !!geometry2.attributes.tangent;
    const morphTargets = !!geometry2.morphAttributes.position;
    const morphNormals = !!geometry2.morphAttributes.normal;
    const morphTargetsCount = !!geometry2.morphAttributes.position ? geometry2.morphAttributes.position.length : 0;
    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;
    if (_clippingEnabled === true) {
      if (_localClippingEnabled === true || camera !== _currentCamera) {
        const useCache = camera === _currentCamera && material.id === _currentMaterialId;
        clipping.setState(material, camera, useCache);
      }
    }
    let needsProgramChange = false;
    if (material.version === materialProperties.__version) {
      if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
        needsProgramChange = true;
      } else if (materialProperties.outputEncoding !== encoding) {
        needsProgramChange = true;
      } else if (object.isInstancedMesh && materialProperties.instancing === false) {
        needsProgramChange = true;
      } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
        needsProgramChange = true;
      } else if (object.isSkinnedMesh && materialProperties.skinning === false) {
        needsProgramChange = true;
      } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
        needsProgramChange = true;
      } else if (materialProperties.envMap !== envMap) {
        needsProgramChange = true;
      } else if (material.fog && materialProperties.fog !== fog) {
        needsProgramChange = true;
      } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
        needsProgramChange = true;
      } else if (materialProperties.vertexAlphas !== vertexAlphas) {
        needsProgramChange = true;
      } else if (materialProperties.vertexTangents !== vertexTangents) {
        needsProgramChange = true;
      } else if (materialProperties.morphTargets !== morphTargets) {
        needsProgramChange = true;
      } else if (materialProperties.morphNormals !== morphNormals) {
        needsProgramChange = true;
      } else if (capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount) {
        needsProgramChange = true;
      }
    } else {
      needsProgramChange = true;
      materialProperties.__version = material.version;
    }
    let program = materialProperties.currentProgram;
    if (needsProgramChange === true) {
      program = getProgram(material, scene, object);
    }
    let refreshProgram = false;
    let refreshMaterial = false;
    let refreshLights = false;
    const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
    if (state.useProgram(program.program)) {
      refreshProgram = true;
      refreshMaterial = true;
      refreshLights = true;
    }
    if (material.id !== _currentMaterialId) {
      _currentMaterialId = material.id;
      refreshMaterial = true;
    }
    if (refreshProgram || _currentCamera !== camera) {
      p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
      if (capabilities.logarithmicDepthBuffer) {
        p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera.far + 1) / Math.LN2));
      }
      if (_currentCamera !== camera) {
        _currentCamera = camera;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
        const uCamPos = p_uniforms.map.cameraPosition;
        if (uCamPos !== void 0) {
          uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
        }
      }
      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
        p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
      }
      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object.isSkinnedMesh) {
        p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
      }
    }
    if (object.isSkinnedMesh) {
      p_uniforms.setOptional(_gl, object, "bindMatrix");
      p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
      const skeleton = object.skeleton;
      if (skeleton) {
        if (capabilities.floatVertexTextures) {
          if (skeleton.boneTexture === null)
            skeleton.computeBoneTexture();
          p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
          p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
        } else {
          p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
        }
      }
    }
    if (!!geometry2 && (geometry2.morphAttributes.position !== void 0 || geometry2.morphAttributes.normal !== void 0)) {
      morphtargets.update(object, geometry2, material, program);
    }
    if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
      materialProperties.receiveShadow = object.receiveShadow;
      p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
    }
    if (refreshMaterial) {
      p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
      if (materialProperties.needsLights) {
        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
      }
      if (fog && material.fog) {
        materials.refreshFogUniforms(m_uniforms, fog);
      }
      materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
    }
    if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
      material.uniformsNeedUpdate = false;
    }
    if (material.isSpriteMaterial) {
      p_uniforms.setValue(_gl, "center", object.center);
    }
    p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
    p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
    p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
    return program;
  }
  function markUniformsLightsNeedsUpdate(uniforms, value) {
    uniforms.ambientLightColor.needsUpdate = value;
    uniforms.lightProbe.needsUpdate = value;
    uniforms.directionalLights.needsUpdate = value;
    uniforms.directionalLightShadows.needsUpdate = value;
    uniforms.pointLights.needsUpdate = value;
    uniforms.pointLightShadows.needsUpdate = value;
    uniforms.spotLights.needsUpdate = value;
    uniforms.spotLightShadows.needsUpdate = value;
    uniforms.rectAreaLights.needsUpdate = value;
    uniforms.hemisphereLights.needsUpdate = value;
  }
  function materialNeedsLights(material) {
    return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
  }
  this.getActiveCubeFace = function() {
    return _currentActiveCubeFace;
  };
  this.getActiveMipmapLevel = function() {
    return _currentActiveMipmapLevel;
  };
  this.getRenderTarget = function() {
    return _currentRenderTarget;
  };
  this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
    _currentRenderTarget = renderTarget;
    _currentActiveCubeFace = activeCubeFace;
    _currentActiveMipmapLevel = activeMipmapLevel;
    if (renderTarget && properties.get(renderTarget).__webglFramebuffer === void 0) {
      textures.setupRenderTarget(renderTarget);
    }
    let framebuffer = null;
    let isCube = false;
    let isRenderTarget3D = false;
    if (renderTarget) {
      const texture = renderTarget.texture;
      if (texture.isDataTexture3D || texture.isDataTexture2DArray) {
        isRenderTarget3D = true;
      }
      const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget) {
        framebuffer = __webglFramebuffer[activeCubeFace];
        isCube = true;
      } else if (renderTarget.isWebGLMultisampleRenderTarget) {
        framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
      } else {
        framebuffer = __webglFramebuffer;
      }
      _currentViewport.copy(renderTarget.viewport);
      _currentScissor.copy(renderTarget.scissor);
      _currentScissorTest = renderTarget.scissorTest;
    } else {
      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
      _currentScissorTest = _scissorTest;
    }
    const framebufferBound = state.bindFramebuffer(36160, framebuffer);
    if (framebufferBound && capabilities.drawBuffers) {
      let needsUpdate = false;
      if (renderTarget) {
        if (renderTarget.isWebGLMultipleRenderTargets) {
          const textures2 = renderTarget.texture;
          if (_currentDrawBuffers.length !== textures2.length || _currentDrawBuffers[0] !== 36064) {
            for (let i2 = 0, il2 = textures2.length; i2 < il2; i2++) {
              _currentDrawBuffers[i2] = 36064 + i2;
            }
            _currentDrawBuffers.length = textures2.length;
            needsUpdate = true;
          }
        } else {
          if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== 36064) {
            _currentDrawBuffers[0] = 36064;
            _currentDrawBuffers.length = 1;
            needsUpdate = true;
          }
        }
      } else {
        if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== 1029) {
          _currentDrawBuffers[0] = 1029;
          _currentDrawBuffers.length = 1;
          needsUpdate = true;
        }
      }
      if (needsUpdate) {
        if (capabilities.isWebGL2) {
          _gl.drawBuffers(_currentDrawBuffers);
        } else {
          extensions.get("WEBGL_draw_buffers").drawBuffersWEBGL(_currentDrawBuffers);
        }
      }
    }
    state.viewport(_currentViewport);
    state.scissor(_currentScissor);
    state.setScissorTest(_currentScissorTest);
    if (isCube) {
      const textureProperties = properties.get(renderTarget.texture);
      _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
    } else if (isRenderTarget3D) {
      const textureProperties = properties.get(renderTarget.texture);
      const layer = activeCubeFace || 0;
      _gl.framebufferTextureLayer(36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
    }
    _currentMaterialId = -1;
  };
  this.readRenderTargetPixels = function(renderTarget, x2, y2, width, height, buffer, activeCubeFaceIndex) {
    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      return;
    }
    let framebuffer = properties.get(renderTarget).__webglFramebuffer;
    if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
      framebuffer = framebuffer[activeCubeFaceIndex];
    }
    if (framebuffer) {
      state.bindFramebuffer(36160, framebuffer);
      try {
        const texture = renderTarget.texture;
        const textureFormat = texture.format;
        const textureType = texture.type;
        if (textureFormat !== RGBAFormat && utils2.convert(textureFormat) !== _gl.getParameter(35739)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          return;
        }
        const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || capabilities.isWebGL2 && extensions.has("EXT_color_buffer_float"));
        if (textureType !== UnsignedByteType && utils2.convert(textureType) !== _gl.getParameter(35738) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has("OES_texture_float") || extensions.has("WEBGL_color_buffer_float"))) && !halfFloatSupportedByExt) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          return;
        }
        if (_gl.checkFramebufferStatus(36160) === 36053) {
          if (x2 >= 0 && x2 <= renderTarget.width - width && (y2 >= 0 && y2 <= renderTarget.height - height)) {
            _gl.readPixels(x2, y2, width, height, utils2.convert(textureFormat), utils2.convert(textureType), buffer);
          }
        } else {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
        }
      } finally {
        const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
        state.bindFramebuffer(36160, framebuffer2);
      }
    }
  };
  this.copyFramebufferToTexture = function(position, texture, level = 0) {
    const levelScale = Math.pow(2, -level);
    const width = Math.floor(texture.image.width * levelScale);
    const height = Math.floor(texture.image.height * levelScale);
    let glFormat = utils2.convert(texture.format);
    if (capabilities.isWebGL2) {
      if (glFormat === 6407)
        glFormat = 32849;
      if (glFormat === 6408)
        glFormat = 32856;
    }
    textures.setTexture2D(texture, 0);
    _gl.copyTexImage2D(3553, level, glFormat, position.x, position.y, width, height, 0);
    state.unbindTexture();
  };
  this.copyTextureToTexture = function(position, srcTexture, dstTexture, level = 0) {
    const width = srcTexture.image.width;
    const height = srcTexture.image.height;
    const glFormat = utils2.convert(dstTexture.format);
    const glType = utils2.convert(dstTexture.type);
    textures.setTexture2D(dstTexture, 0);
    _gl.pixelStorei(37440, dstTexture.flipY);
    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
    _gl.pixelStorei(3317, dstTexture.unpackAlignment);
    if (srcTexture.isDataTexture) {
      _gl.texSubImage2D(3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
    } else {
      if (srcTexture.isCompressedTexture) {
        _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
      } else {
        _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);
      }
    }
    if (level === 0 && dstTexture.generateMipmaps)
      _gl.generateMipmap(3553);
    state.unbindTexture();
  };
  this.copyTextureToTexture3D = function(sourceBox, position, srcTexture, dstTexture, level = 0) {
    if (_this.isWebGL1Renderer) {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
      return;
    }
    const width = sourceBox.max.x - sourceBox.min.x + 1;
    const height = sourceBox.max.y - sourceBox.min.y + 1;
    const depth = sourceBox.max.z - sourceBox.min.z + 1;
    const glFormat = utils2.convert(dstTexture.format);
    const glType = utils2.convert(dstTexture.type);
    let glTarget;
    if (dstTexture.isDataTexture3D) {
      textures.setTexture3D(dstTexture, 0);
      glTarget = 32879;
    } else if (dstTexture.isDataTexture2DArray) {
      textures.setTexture2DArray(dstTexture, 0);
      glTarget = 35866;
    } else {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
      return;
    }
    _gl.pixelStorei(37440, dstTexture.flipY);
    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
    _gl.pixelStorei(3317, dstTexture.unpackAlignment);
    const unpackRowLen = _gl.getParameter(3314);
    const unpackImageHeight = _gl.getParameter(32878);
    const unpackSkipPixels = _gl.getParameter(3316);
    const unpackSkipRows = _gl.getParameter(3315);
    const unpackSkipImages = _gl.getParameter(32877);
    const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;
    _gl.pixelStorei(3314, image.width);
    _gl.pixelStorei(32878, image.height);
    _gl.pixelStorei(3316, sourceBox.min.x);
    _gl.pixelStorei(3315, sourceBox.min.y);
    _gl.pixelStorei(32877, sourceBox.min.z);
    if (srcTexture.isDataTexture || srcTexture.isDataTexture3D) {
      _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data);
    } else {
      if (srcTexture.isCompressedTexture) {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.");
        _gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data);
      } else {
        _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image);
      }
    }
    _gl.pixelStorei(3314, unpackRowLen);
    _gl.pixelStorei(32878, unpackImageHeight);
    _gl.pixelStorei(3316, unpackSkipPixels);
    _gl.pixelStorei(3315, unpackSkipRows);
    _gl.pixelStorei(32877, unpackSkipImages);
    if (level === 0 && dstTexture.generateMipmaps)
      _gl.generateMipmap(glTarget);
    state.unbindTexture();
  };
  this.initTexture = function(texture) {
    textures.setTexture2D(texture, 0);
    state.unbindTexture();
  };
  this.resetState = function() {
    _currentActiveCubeFace = 0;
    _currentActiveMipmapLevel = 0;
    _currentRenderTarget = null;
    state.reset();
    bindingStates.reset();
  };
  if (typeof __THREE_DEVTOOLS__ !== "undefined") {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
}
WebGLRenderer.prototype.isWebGLRenderer = true;
class WebGL1Renderer extends WebGLRenderer {
}
WebGL1Renderer.prototype.isWebGL1Renderer = true;
class Scene extends Object3D {
  constructor() {
    super();
    this.type = "Scene";
    this.background = null;
    this.environment = null;
    this.fog = null;
    this.overrideMaterial = null;
    this.autoUpdate = true;
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
  }
  copy(source3, recursive) {
    super.copy(source3, recursive);
    if (source3.background !== null)
      this.background = source3.background.clone();
    if (source3.environment !== null)
      this.environment = source3.environment.clone();
    if (source3.fog !== null)
      this.fog = source3.fog.clone();
    if (source3.overrideMaterial !== null)
      this.overrideMaterial = source3.overrideMaterial.clone();
    this.autoUpdate = source3.autoUpdate;
    this.matrixAutoUpdate = source3.matrixAutoUpdate;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.fog !== null)
      data.object.fog = this.fog.toJSON();
    return data;
  }
}
Scene.prototype.isScene = true;
class InterleavedBuffer {
  constructor(array, stride) {
    this.array = array;
    this.stride = stride;
    this.count = array !== void 0 ? array.length / stride : 0;
    this.usage = StaticDrawUsage;
    this.updateRange = { offset: 0, count: -1 };
    this.version = 0;
    this.uuid = generateUUID();
  }
  onUploadCallback() {
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  copy(source3) {
    this.array = new source3.array.constructor(source3.array);
    this.count = source3.count;
    this.stride = source3.stride;
    this.usage = source3.usage;
    return this;
  }
  copyAt(index1, attribute, index2) {
    index1 *= this.stride;
    index2 *= attribute.stride;
    for (let i2 = 0, l2 = this.stride; i2 < l2; i2++) {
      this.array[index1 + i2] = attribute.array[index2 + i2];
    }
    return this;
  }
  set(value, offset2 = 0) {
    this.array.set(value, offset2);
    return this;
  }
  clone(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
    }
    const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
    const ib2 = new this.constructor(array, this.stride);
    ib2.setUsage(this.usage);
    return ib2;
  }
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  toJSON(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
    }
    return {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
InterleavedBuffer.prototype.isInterleavedBuffer = true;
const _vector$6 = /* @__PURE__ */ new Vector3();
class InterleavedBufferAttribute {
  constructor(interleavedBuffer, itemSize, offset2, normalized = false) {
    this.name = "";
    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset2;
    this.normalized = normalized === true;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(value) {
    this.data.needsUpdate = value;
  }
  applyMatrix4(m2) {
    for (let i2 = 0, l2 = this.data.count; i2 < l2; i2++) {
      _vector$6.x = this.getX(i2);
      _vector$6.y = this.getY(i2);
      _vector$6.z = this.getZ(i2);
      _vector$6.applyMatrix4(m2);
      this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  }
  applyNormalMatrix(m2) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$6.x = this.getX(i2);
      _vector$6.y = this.getY(i2);
      _vector$6.z = this.getZ(i2);
      _vector$6.applyNormalMatrix(m2);
      this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  }
  transformDirection(m2) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$6.x = this.getX(i2);
      _vector$6.y = this.getY(i2);
      _vector$6.z = this.getZ(i2);
      _vector$6.transformDirection(m2);
      this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  }
  setX(index, x2) {
    this.data.array[index * this.data.stride + this.offset] = x2;
    return this;
  }
  setY(index, y2) {
    this.data.array[index * this.data.stride + this.offset + 1] = y2;
    return this;
  }
  setZ(index, z2) {
    this.data.array[index * this.data.stride + this.offset + 2] = z2;
    return this;
  }
  setW(index, w2) {
    this.data.array[index * this.data.stride + this.offset + 3] = w2;
    return this;
  }
  getX(index) {
    return this.data.array[index * this.data.stride + this.offset];
  }
  getY(index) {
    return this.data.array[index * this.data.stride + this.offset + 1];
  }
  getZ(index) {
    return this.data.array[index * this.data.stride + this.offset + 2];
  }
  getW(index) {
    return this.data.array[index * this.data.stride + this.offset + 3];
  }
  setXY(index, x2, y2) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x2;
    this.data.array[index + 1] = y2;
    return this;
  }
  setXYZ(index, x2, y2, z2) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x2;
    this.data.array[index + 1] = y2;
    this.data.array[index + 2] = z2;
    return this;
  }
  setXYZW(index, x2, y2, z2, w2) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x2;
    this.data.array[index + 1] = y2;
    this.data.array[index + 2] = z2;
    this.data.array[index + 3] = w2;
    return this;
  }
  clone(data) {
    if (data === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
      const array = [];
      for (let i2 = 0; i2 < this.count; i2++) {
        const index = i2 * this.data.stride + this.offset;
        for (let j2 = 0; j2 < this.itemSize; j2++) {
          array.push(this.data.array[index + j2]);
        }
      }
      return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
      }
      return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
  }
  toJSON(data) {
    if (data === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
      const array = [];
      for (let i2 = 0; i2 < this.count; i2++) {
        const index = i2 * this.data.stride + this.offset;
        for (let j2 = 0; j2 < this.itemSize; j2++) {
          array.push(this.data.array[index + j2]);
        }
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array,
        normalized: this.normalized
      };
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
      }
      return {
        isInterleavedBufferAttribute: true,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
    }
  }
}
InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;
class SpriteMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "SpriteMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.rotation = 0;
    this.sizeAttenuation = true;
    this.transparent = true;
    this.setValues(parameters);
  }
  copy(source3) {
    super.copy(source3);
    this.color.copy(source3.color);
    this.map = source3.map;
    this.alphaMap = source3.alphaMap;
    this.rotation = source3.rotation;
    this.sizeAttenuation = source3.sizeAttenuation;
    return this;
  }
}
SpriteMaterial.prototype.isSpriteMaterial = true;
let _geometry;
const _intersectPoint = /* @__PURE__ */ new Vector3();
const _worldScale = /* @__PURE__ */ new Vector3();
const _mvPosition = /* @__PURE__ */ new Vector3();
const _alignedPosition = /* @__PURE__ */ new Vector2();
const _rotatedPosition = /* @__PURE__ */ new Vector2();
const _viewWorldMatrix = /* @__PURE__ */ new Matrix4();
const _vA$2 = /* @__PURE__ */ new Vector3();
const _vB$2 = /* @__PURE__ */ new Vector3();
const _vC$2 = /* @__PURE__ */ new Vector3();
const _uvA = /* @__PURE__ */ new Vector2();
const _uvB = /* @__PURE__ */ new Vector2();
const _uvC = /* @__PURE__ */ new Vector2();
class Sprite extends Object3D {
  constructor(material) {
    super();
    this.type = "Sprite";
    if (_geometry === void 0) {
      _geometry = new BufferGeometry();
      const float32Array = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]);
      const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
      _geometry.setIndex([0, 1, 2, 0, 2, 3]);
      _geometry.setAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
      _geometry.setAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
    }
    this.geometry = _geometry;
    this.material = material !== void 0 ? material : new SpriteMaterial();
    this.center = new Vector2(0.5, 0.5);
  }
  raycast(raycaster, intersects2) {
    if (raycaster.camera === null) {
      console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
    }
    _worldScale.setFromMatrixScale(this.matrixWorld);
    _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
    this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
    _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
    if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
      _worldScale.multiplyScalar(-_mvPosition.z);
    }
    const rotation = this.material.rotation;
    let sin, cos;
    if (rotation !== 0) {
      cos = Math.cos(rotation);
      sin = Math.sin(rotation);
    }
    const center = this.center;
    transformVertex(_vA$2.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    transformVertex(_vB$2.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    transformVertex(_vC$2.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    _uvA.set(0, 0);
    _uvB.set(1, 0);
    _uvC.set(1, 1);
    let intersect = raycaster.ray.intersectTriangle(_vA$2, _vB$2, _vC$2, false, _intersectPoint);
    if (intersect === null) {
      transformVertex(_vB$2.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
      _uvB.set(0, 1);
      intersect = raycaster.ray.intersectTriangle(_vA$2, _vC$2, _vB$2, false, _intersectPoint);
      if (intersect === null) {
        return;
      }
    }
    const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far)
      return;
    intersects2.push({
      distance,
      point: _intersectPoint.clone(),
      uv: Triangle.getUV(_intersectPoint, _vA$2, _vB$2, _vC$2, _uvA, _uvB, _uvC, new Vector2()),
      face: null,
      object: this
    });
  }
  copy(source3) {
    super.copy(source3);
    if (source3.center !== void 0)
      this.center.copy(source3.center);
    this.material = source3.material;
    return this;
  }
}
Sprite.prototype.isSprite = true;
function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
  _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
  if (sin !== void 0) {
    _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
    _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
  } else {
    _rotatedPosition.copy(_alignedPosition);
  }
  vertexPosition.copy(mvPosition);
  vertexPosition.x += _rotatedPosition.x;
  vertexPosition.y += _rotatedPosition.y;
  vertexPosition.applyMatrix4(_viewWorldMatrix);
}
const _basePosition = /* @__PURE__ */ new Vector3();
const _skinIndex = /* @__PURE__ */ new Vector4();
const _skinWeight = /* @__PURE__ */ new Vector4();
const _vector$5 = /* @__PURE__ */ new Vector3();
const _matrix = /* @__PURE__ */ new Matrix4();
class SkinnedMesh extends Mesh {
  constructor(geometry2, material) {
    super(geometry2, material);
    this.type = "SkinnedMesh";
    this.bindMode = "attached";
    this.bindMatrix = new Matrix4();
    this.bindMatrixInverse = new Matrix4();
  }
  copy(source3) {
    super.copy(source3);
    this.bindMode = source3.bindMode;
    this.bindMatrix.copy(source3.bindMatrix);
    this.bindMatrixInverse.copy(source3.bindMatrixInverse);
    this.skeleton = source3.skeleton;
    return this;
  }
  bind(skeleton, bindMatrix) {
    this.skeleton = skeleton;
    if (bindMatrix === void 0) {
      this.updateMatrixWorld(true);
      this.skeleton.calculateInverses();
      bindMatrix = this.matrixWorld;
    }
    this.bindMatrix.copy(bindMatrix);
    this.bindMatrixInverse.copy(bindMatrix).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const vector = new Vector4();
    const skinWeight = this.geometry.attributes.skinWeight;
    for (let i2 = 0, l2 = skinWeight.count; i2 < l2; i2++) {
      vector.x = skinWeight.getX(i2);
      vector.y = skinWeight.getY(i2);
      vector.z = skinWeight.getZ(i2);
      vector.w = skinWeight.getW(i2);
      const scale = 1 / vector.manhattanLength();
      if (scale !== Infinity) {
        vector.multiplyScalar(scale);
      } else {
        vector.set(1, 0, 0, 0);
      }
      skinWeight.setXYZW(i2, vector.x, vector.y, vector.z, vector.w);
    }
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (this.bindMode === "attached") {
      this.bindMatrixInverse.copy(this.matrixWorld).invert();
    } else if (this.bindMode === "detached") {
      this.bindMatrixInverse.copy(this.bindMatrix).invert();
    } else {
      console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
  }
  boneTransform(index, target) {
    const skeleton = this.skeleton;
    const geometry2 = this.geometry;
    _skinIndex.fromBufferAttribute(geometry2.attributes.skinIndex, index);
    _skinWeight.fromBufferAttribute(geometry2.attributes.skinWeight, index);
    _basePosition.copy(target).applyMatrix4(this.bindMatrix);
    target.set(0, 0, 0);
    for (let i2 = 0; i2 < 4; i2++) {
      const weight = _skinWeight.getComponent(i2);
      if (weight !== 0) {
        const boneIndex = _skinIndex.getComponent(i2);
        _matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
        target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight);
      }
    }
    return target.applyMatrix4(this.bindMatrixInverse);
  }
}
SkinnedMesh.prototype.isSkinnedMesh = true;
class Bone extends Object3D {
  constructor() {
    super();
    this.type = "Bone";
  }
}
Bone.prototype.isBone = true;
class DataTexture extends Texture {
  constructor(data = null, width = 1, height = 1, format2, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy, encoding);
    this.image = { data, width, height };
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
  }
}
DataTexture.prototype.isDataTexture = true;
class InstancedBufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized, meshPerAttribute = 1) {
    if (typeof normalized === "number") {
      meshPerAttribute = normalized;
      normalized = false;
      console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.");
    }
    super(array, itemSize, normalized);
    this.meshPerAttribute = meshPerAttribute;
  }
  copy(source3) {
    super.copy(source3);
    this.meshPerAttribute = source3.meshPerAttribute;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.meshPerAttribute = this.meshPerAttribute;
    data.isInstancedBufferAttribute = true;
    return data;
  }
}
InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;
const _instanceLocalMatrix = /* @__PURE__ */ new Matrix4();
const _instanceWorldMatrix = /* @__PURE__ */ new Matrix4();
const _instanceIntersects = [];
const _mesh = /* @__PURE__ */ new Mesh();
class InstancedMesh extends Mesh {
  constructor(geometry2, material, count) {
    super(geometry2, material);
    this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);
    this.instanceColor = null;
    this.count = count;
    this.frustumCulled = false;
  }
  copy(source3) {
    super.copy(source3);
    this.instanceMatrix.copy(source3.instanceMatrix);
    if (source3.instanceColor !== null)
      this.instanceColor = source3.instanceColor.clone();
    this.count = source3.count;
    return this;
  }
  getColorAt(index, color2) {
    color2.fromArray(this.instanceColor.array, index * 3);
  }
  getMatrixAt(index, matrix) {
    matrix.fromArray(this.instanceMatrix.array, index * 16);
  }
  raycast(raycaster, intersects2) {
    const matrixWorld = this.matrixWorld;
    const raycastTimes = this.count;
    _mesh.geometry = this.geometry;
    _mesh.material = this.material;
    if (_mesh.material === void 0)
      return;
    for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
      this.getMatrixAt(instanceId, _instanceLocalMatrix);
      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
      _mesh.matrixWorld = _instanceWorldMatrix;
      _mesh.raycast(raycaster, _instanceIntersects);
      for (let i2 = 0, l2 = _instanceIntersects.length; i2 < l2; i2++) {
        const intersect = _instanceIntersects[i2];
        intersect.instanceId = instanceId;
        intersect.object = this;
        intersects2.push(intersect);
      }
      _instanceIntersects.length = 0;
    }
  }
  setColorAt(index, color2) {
    if (this.instanceColor === null) {
      this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);
    }
    color2.toArray(this.instanceColor.array, index * 3);
  }
  setMatrixAt(index, matrix) {
    matrix.toArray(this.instanceMatrix.array, index * 16);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
InstancedMesh.prototype.isInstancedMesh = true;
class LineBasicMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "LineBasicMaterial";
    this.color = new Color(16777215);
    this.linewidth = 1;
    this.linecap = "round";
    this.linejoin = "round";
    this.setValues(parameters);
  }
  copy(source3) {
    super.copy(source3);
    this.color.copy(source3.color);
    this.linewidth = source3.linewidth;
    this.linecap = source3.linecap;
    this.linejoin = source3.linejoin;
    return this;
  }
}
LineBasicMaterial.prototype.isLineBasicMaterial = true;
const _start$1 = /* @__PURE__ */ new Vector3();
const _end$1 = /* @__PURE__ */ new Vector3();
const _inverseMatrix$1 = /* @__PURE__ */ new Matrix4();
const _ray$1 = /* @__PURE__ */ new Ray();
const _sphere$1 = /* @__PURE__ */ new Sphere();
class Line extends Object3D {
  constructor(geometry2 = new BufferGeometry(), material = new LineBasicMaterial()) {
    super();
    this.type = "Line";
    this.geometry = geometry2;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source3) {
    super.copy(source3);
    this.material = source3.material;
    this.geometry = source3.geometry;
    return this;
  }
  computeLineDistances() {
    const geometry2 = this.geometry;
    if (geometry2.isBufferGeometry) {
      if (geometry2.index === null) {
        const positionAttribute = geometry2.attributes.position;
        const lineDistances = [0];
        for (let i2 = 1, l2 = positionAttribute.count; i2 < l2; i2++) {
          _start$1.fromBufferAttribute(positionAttribute, i2 - 1);
          _end$1.fromBufferAttribute(positionAttribute, i2);
          lineDistances[i2] = lineDistances[i2 - 1];
          lineDistances[i2] += _start$1.distanceTo(_end$1);
        }
        geometry2.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      }
    } else if (geometry2.isGeometry) {
      console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    return this;
  }
  raycast(raycaster, intersects2) {
    const geometry2 = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Line.threshold;
    const drawRange = geometry2.drawRange;
    if (geometry2.boundingSphere === null)
      geometry2.computeBoundingSphere();
    _sphere$1.copy(geometry2.boundingSphere);
    _sphere$1.applyMatrix4(matrixWorld);
    _sphere$1.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere$1) === false)
      return;
    _inverseMatrix$1.copy(matrixWorld).invert();
    _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const vStart = new Vector3();
    const vEnd = new Vector3();
    const interSegment = new Vector3();
    const interRay = new Vector3();
    const step = this.isLineSegments ? 2 : 1;
    if (geometry2.isBufferGeometry) {
      const index = geometry2.index;
      const attributes = geometry2.attributes;
      const positionAttribute = attributes.position;
      if (index !== null) {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(index.count, drawRange.start + drawRange.count);
        for (let i2 = start, l2 = end - 1; i2 < l2; i2 += step) {
          const a2 = index.getX(i2);
          const b2 = index.getX(i2 + 1);
          vStart.fromBufferAttribute(positionAttribute, a2);
          vEnd.fromBufferAttribute(positionAttribute, b2);
          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
          if (distSq > localThresholdSq)
            continue;
          interRay.applyMatrix4(this.matrixWorld);
          const distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far)
            continue;
          intersects2.push({
            distance,
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i2,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
        for (let i2 = start, l2 = end - 1; i2 < l2; i2 += step) {
          vStart.fromBufferAttribute(positionAttribute, i2);
          vEnd.fromBufferAttribute(positionAttribute, i2 + 1);
          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
          if (distSq > localThresholdSq)
            continue;
          interRay.applyMatrix4(this.matrixWorld);
          const distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far)
            continue;
          intersects2.push({
            distance,
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i2,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      }
    } else if (geometry2.isGeometry) {
      console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
  updateMorphTargets() {
    const geometry2 = this.geometry;
    if (geometry2.isBufferGeometry) {
      const morphAttributes = geometry2.morphAttributes;
      const keys2 = Object.keys(morphAttributes);
      if (keys2.length > 0) {
        const morphAttribute = morphAttributes[keys2[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m2 = 0, ml2 = morphAttribute.length; m2 < ml2; m2++) {
            const name2 = morphAttribute[m2].name || String(m2);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name2] = m2;
          }
        }
      }
    } else {
      const morphTargets = geometry2.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
}
Line.prototype.isLine = true;
const _start = /* @__PURE__ */ new Vector3();
const _end = /* @__PURE__ */ new Vector3();
class LineSegments extends Line {
  constructor(geometry2, material) {
    super(geometry2, material);
    this.type = "LineSegments";
  }
  computeLineDistances() {
    const geometry2 = this.geometry;
    if (geometry2.isBufferGeometry) {
      if (geometry2.index === null) {
        const positionAttribute = geometry2.attributes.position;
        const lineDistances = [];
        for (let i2 = 0, l2 = positionAttribute.count; i2 < l2; i2 += 2) {
          _start.fromBufferAttribute(positionAttribute, i2);
          _end.fromBufferAttribute(positionAttribute, i2 + 1);
          lineDistances[i2] = i2 === 0 ? 0 : lineDistances[i2 - 1];
          lineDistances[i2 + 1] = lineDistances[i2] + _start.distanceTo(_end);
        }
        geometry2.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      }
    } else if (geometry2.isGeometry) {
      console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    return this;
  }
}
LineSegments.prototype.isLineSegments = true;
class LineLoop extends Line {
  constructor(geometry2, material) {
    super(geometry2, material);
    this.type = "LineLoop";
  }
}
LineLoop.prototype.isLineLoop = true;
class PointsMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "PointsMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.size = 1;
    this.sizeAttenuation = true;
    this.setValues(parameters);
  }
  copy(source3) {
    super.copy(source3);
    this.color.copy(source3.color);
    this.map = source3.map;
    this.alphaMap = source3.alphaMap;
    this.size = source3.size;
    this.sizeAttenuation = source3.sizeAttenuation;
    return this;
  }
}
PointsMaterial.prototype.isPointsMaterial = true;
const _inverseMatrix = /* @__PURE__ */ new Matrix4();
const _ray = /* @__PURE__ */ new Ray();
const _sphere = /* @__PURE__ */ new Sphere();
const _position$2 = /* @__PURE__ */ new Vector3();
class Points extends Object3D {
  constructor(geometry2 = new BufferGeometry(), material = new PointsMaterial()) {
    super();
    this.type = "Points";
    this.geometry = geometry2;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source3) {
    super.copy(source3);
    this.material = source3.material;
    this.geometry = source3.geometry;
    return this;
  }
  raycast(raycaster, intersects2) {
    const geometry2 = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Points.threshold;
    const drawRange = geometry2.drawRange;
    if (geometry2.boundingSphere === null)
      geometry2.computeBoundingSphere();
    _sphere.copy(geometry2.boundingSphere);
    _sphere.applyMatrix4(matrixWorld);
    _sphere.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere) === false)
      return;
    _inverseMatrix.copy(matrixWorld).invert();
    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    if (geometry2.isBufferGeometry) {
      const index = geometry2.index;
      const attributes = geometry2.attributes;
      const positionAttribute = attributes.position;
      if (index !== null) {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(index.count, drawRange.start + drawRange.count);
        for (let i2 = start, il2 = end; i2 < il2; i2++) {
          const a2 = index.getX(i2);
          _position$2.fromBufferAttribute(positionAttribute, a2);
          testPoint(_position$2, a2, localThresholdSq, matrixWorld, raycaster, intersects2, this);
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
        for (let i2 = start, l2 = end; i2 < l2; i2++) {
          _position$2.fromBufferAttribute(positionAttribute, i2);
          testPoint(_position$2, i2, localThresholdSq, matrixWorld, raycaster, intersects2, this);
        }
      }
    } else {
      console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
  updateMorphTargets() {
    const geometry2 = this.geometry;
    if (geometry2.isBufferGeometry) {
      const morphAttributes = geometry2.morphAttributes;
      const keys2 = Object.keys(morphAttributes);
      if (keys2.length > 0) {
        const morphAttribute = morphAttributes[keys2[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m2 = 0, ml2 = morphAttribute.length; m2 < ml2; m2++) {
            const name2 = morphAttribute[m2].name || String(m2);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name2] = m2;
          }
        }
      }
    } else {
      const morphTargets = geometry2.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
}
Points.prototype.isPoints = true;
function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects2, object) {
  const rayPointDistanceSq = _ray.distanceSqToPoint(point);
  if (rayPointDistanceSq < localThresholdSq) {
    const intersectPoint = new Vector3();
    _ray.closestPointToPoint(point, intersectPoint);
    intersectPoint.applyMatrix4(matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far)
      return;
    intersects2.push({
      distance,
      distanceToRay: Math.sqrt(rayPointDistanceSq),
      point: intersectPoint,
      index,
      face: null,
      object
    });
  }
}
class VideoTexture extends Texture {
  constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy) {
    super(video, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy);
    this.format = format2 !== void 0 ? format2 : RGBFormat;
    this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter;
    this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
    this.generateMipmaps = false;
    const scope = this;
    function updateVideo() {
      scope.needsUpdate = true;
      video.requestVideoFrameCallback(updateVideo);
    }
    if ("requestVideoFrameCallback" in video) {
      video.requestVideoFrameCallback(updateVideo);
    }
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const video = this.image;
    const hasVideoFrameCallback = "requestVideoFrameCallback" in video;
    if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
      this.needsUpdate = true;
    }
  }
}
VideoTexture.prototype.isVideoTexture = true;
class CompressedTexture extends Texture {
  constructor(mipmaps, width, height, format2, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy, encoding);
    this.image = { width, height };
    this.mipmaps = mipmaps;
    this.flipY = false;
    this.generateMipmaps = false;
  }
}
CompressedTexture.prototype.isCompressedTexture = true;
class CanvasTexture extends Texture {
  constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy) {
    super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy);
    this.needsUpdate = true;
  }
}
CanvasTexture.prototype.isCanvasTexture = true;
class DepthTexture extends Texture {
  constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format2) {
    format2 = format2 !== void 0 ? format2 : DepthFormat;
    if (format2 !== DepthFormat && format2 !== DepthStencilFormat) {
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    }
    if (type === void 0 && format2 === DepthFormat)
      type = UnsignedShortType;
    if (type === void 0 && format2 === DepthStencilFormat)
      type = UnsignedInt248Type;
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy);
    this.image = { width, height };
    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
    this.flipY = false;
    this.generateMipmaps = false;
  }
}
DepthTexture.prototype.isDepthTexture = true;
new Vector3();
new Vector3();
new Vector3();
new Triangle();
class Curve {
  constructor() {
    this.type = "Curve";
    this.arcLengthDivisions = 200;
  }
  getPoint() {
    console.warn("THREE.Curve: .getPoint() not implemented.");
    return null;
  }
  getPointAt(u2, optionalTarget) {
    const t2 = this.getUtoTmapping(u2);
    return this.getPoint(t2, optionalTarget);
  }
  getPoints(divisions = 5) {
    const points = [];
    for (let d2 = 0; d2 <= divisions; d2++) {
      points.push(this.getPoint(d2 / divisions));
    }
    return points;
  }
  getSpacedPoints(divisions = 5) {
    const points = [];
    for (let d2 = 0; d2 <= divisions; d2++) {
      points.push(this.getPointAt(d2 / divisions));
    }
    return points;
  }
  getLength() {
    const lengths = this.getLengths();
    return lengths[lengths.length - 1];
  }
  getLengths(divisions = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
      return this.cacheArcLengths;
    }
    this.needsUpdate = false;
    const cache = [];
    let current, last = this.getPoint(0);
    let sum = 0;
    cache.push(0);
    for (let p2 = 1; p2 <= divisions; p2++) {
      current = this.getPoint(p2 / divisions);
      sum += current.distanceTo(last);
      cache.push(sum);
      last = current;
    }
    this.cacheArcLengths = cache;
    return cache;
  }
  updateArcLengths() {
    this.needsUpdate = true;
    this.getLengths();
  }
  getUtoTmapping(u2, distance) {
    const arcLengths = this.getLengths();
    let i2 = 0;
    const il2 = arcLengths.length;
    let targetArcLength;
    if (distance) {
      targetArcLength = distance;
    } else {
      targetArcLength = u2 * arcLengths[il2 - 1];
    }
    let low = 0, high = il2 - 1, comparison;
    while (low <= high) {
      i2 = Math.floor(low + (high - low) / 2);
      comparison = arcLengths[i2] - targetArcLength;
      if (comparison < 0) {
        low = i2 + 1;
      } else if (comparison > 0) {
        high = i2 - 1;
      } else {
        high = i2;
        break;
      }
    }
    i2 = high;
    if (arcLengths[i2] === targetArcLength) {
      return i2 / (il2 - 1);
    }
    const lengthBefore = arcLengths[i2];
    const lengthAfter = arcLengths[i2 + 1];
    const segmentLength = lengthAfter - lengthBefore;
    const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
    const t2 = (i2 + segmentFraction) / (il2 - 1);
    return t2;
  }
  getTangent(t2, optionalTarget) {
    const delta = 1e-4;
    let t1 = t2 - delta;
    let t22 = t2 + delta;
    if (t1 < 0)
      t1 = 0;
    if (t22 > 1)
      t22 = 1;
    const pt1 = this.getPoint(t1);
    const pt2 = this.getPoint(t22);
    const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
    tangent.copy(pt2).sub(pt1).normalize();
    return tangent;
  }
  getTangentAt(u2, optionalTarget) {
    const t2 = this.getUtoTmapping(u2);
    return this.getTangent(t2, optionalTarget);
  }
  computeFrenetFrames(segments, closed) {
    const normal = new Vector3();
    const tangents = [];
    const normals = [];
    const binormals = [];
    const vec = new Vector3();
    const mat = new Matrix4();
    for (let i2 = 0; i2 <= segments; i2++) {
      const u2 = i2 / segments;
      tangents[i2] = this.getTangentAt(u2, new Vector3());
    }
    normals[0] = new Vector3();
    binormals[0] = new Vector3();
    let min2 = Number.MAX_VALUE;
    const tx2 = Math.abs(tangents[0].x);
    const ty2 = Math.abs(tangents[0].y);
    const tz = Math.abs(tangents[0].z);
    if (tx2 <= min2) {
      min2 = tx2;
      normal.set(1, 0, 0);
    }
    if (ty2 <= min2) {
      min2 = ty2;
      normal.set(0, 1, 0);
    }
    if (tz <= min2) {
      normal.set(0, 0, 1);
    }
    vec.crossVectors(tangents[0], normal).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]);
    for (let i2 = 1; i2 <= segments; i2++) {
      normals[i2] = normals[i2 - 1].clone();
      binormals[i2] = binormals[i2 - 1].clone();
      vec.crossVectors(tangents[i2 - 1], tangents[i2]);
      if (vec.length() > Number.EPSILON) {
        vec.normalize();
        const theta = Math.acos(clamp(tangents[i2 - 1].dot(tangents[i2]), -1, 1));
        normals[i2].applyMatrix4(mat.makeRotationAxis(vec, theta));
      }
      binormals[i2].crossVectors(tangents[i2], normals[i2]);
    }
    if (closed === true) {
      let theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));
      theta /= segments;
      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
        theta = -theta;
      }
      for (let i2 = 1; i2 <= segments; i2++) {
        normals[i2].applyMatrix4(mat.makeRotationAxis(tangents[i2], theta * i2));
        binormals[i2].crossVectors(tangents[i2], normals[i2]);
      }
    }
    return {
      tangents,
      normals,
      binormals
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source3) {
    this.arcLengthDivisions = source3.arcLengthDivisions;
    return this;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.5,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    data.arcLengthDivisions = this.arcLengthDivisions;
    data.type = this.type;
    return data;
  }
  fromJSON(json) {
    this.arcLengthDivisions = json.arcLengthDivisions;
    return this;
  }
}
class EllipseCurve extends Curve {
  constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
    super();
    this.type = "EllipseCurve";
    this.aX = aX;
    this.aY = aY;
    this.xRadius = xRadius;
    this.yRadius = yRadius;
    this.aStartAngle = aStartAngle;
    this.aEndAngle = aEndAngle;
    this.aClockwise = aClockwise;
    this.aRotation = aRotation;
  }
  getPoint(t2, optionalTarget) {
    const point = optionalTarget || new Vector2();
    const twoPi = Math.PI * 2;
    let deltaAngle = this.aEndAngle - this.aStartAngle;
    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
    while (deltaAngle < 0)
      deltaAngle += twoPi;
    while (deltaAngle > twoPi)
      deltaAngle -= twoPi;
    if (deltaAngle < Number.EPSILON) {
      if (samePoints) {
        deltaAngle = 0;
      } else {
        deltaAngle = twoPi;
      }
    }
    if (this.aClockwise === true && !samePoints) {
      if (deltaAngle === twoPi) {
        deltaAngle = -twoPi;
      } else {
        deltaAngle = deltaAngle - twoPi;
      }
    }
    const angle = this.aStartAngle + t2 * deltaAngle;
    let x2 = this.aX + this.xRadius * Math.cos(angle);
    let y2 = this.aY + this.yRadius * Math.sin(angle);
    if (this.aRotation !== 0) {
      const cos = Math.cos(this.aRotation);
      const sin = Math.sin(this.aRotation);
      const tx2 = x2 - this.aX;
      const ty2 = y2 - this.aY;
      x2 = tx2 * cos - ty2 * sin + this.aX;
      y2 = tx2 * sin + ty2 * cos + this.aY;
    }
    return point.set(x2, y2);
  }
  copy(source3) {
    super.copy(source3);
    this.aX = source3.aX;
    this.aY = source3.aY;
    this.xRadius = source3.xRadius;
    this.yRadius = source3.yRadius;
    this.aStartAngle = source3.aStartAngle;
    this.aEndAngle = source3.aEndAngle;
    this.aClockwise = source3.aClockwise;
    this.aRotation = source3.aRotation;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.aX = this.aX;
    data.aY = this.aY;
    data.xRadius = this.xRadius;
    data.yRadius = this.yRadius;
    data.aStartAngle = this.aStartAngle;
    data.aEndAngle = this.aEndAngle;
    data.aClockwise = this.aClockwise;
    data.aRotation = this.aRotation;
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.aX = json.aX;
    this.aY = json.aY;
    this.xRadius = json.xRadius;
    this.yRadius = json.yRadius;
    this.aStartAngle = json.aStartAngle;
    this.aEndAngle = json.aEndAngle;
    this.aClockwise = json.aClockwise;
    this.aRotation = json.aRotation;
    return this;
  }
}
EllipseCurve.prototype.isEllipseCurve = true;
class ArcCurve extends EllipseCurve {
  constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    this.type = "ArcCurve";
  }
}
ArcCurve.prototype.isArcCurve = true;
function CubicPoly() {
  let c0 = 0, c1 = 0, c2 = 0, c3 = 0;
  function init(x0, x1, t0, t1) {
    c0 = x0;
    c1 = t0;
    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
    c3 = 2 * x0 - 2 * x1 + t0 + t1;
  }
  return {
    initCatmullRom: function(x0, x1, x2, x3, tension) {
      init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
    },
    initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
      let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
      let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
      t1 *= dt1;
      t2 *= dt1;
      init(x1, x2, t1, t2);
    },
    calc: function(t2) {
      const t22 = t2 * t2;
      const t3 = t22 * t2;
      return c0 + c1 * t2 + c2 * t22 + c3 * t3;
    }
  };
}
const tmp = new Vector3();
const px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();
class CatmullRomCurve3 extends Curve {
  constructor(points = [], closed = false, curveType = "centripetal", tension = 0.5) {
    super();
    this.type = "CatmullRomCurve3";
    this.points = points;
    this.closed = closed;
    this.curveType = curveType;
    this.tension = tension;
  }
  getPoint(t2, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const points = this.points;
    const l2 = points.length;
    const p2 = (l2 - (this.closed ? 0 : 1)) * t2;
    let intPoint = Math.floor(p2);
    let weight = p2 - intPoint;
    if (this.closed) {
      intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l2) + 1) * l2;
    } else if (weight === 0 && intPoint === l2 - 1) {
      intPoint = l2 - 2;
      weight = 1;
    }
    let p0, p3;
    if (this.closed || intPoint > 0) {
      p0 = points[(intPoint - 1) % l2];
    } else {
      tmp.subVectors(points[0], points[1]).add(points[0]);
      p0 = tmp;
    }
    const p1 = points[intPoint % l2];
    const p22 = points[(intPoint + 1) % l2];
    if (this.closed || intPoint + 2 < l2) {
      p3 = points[(intPoint + 2) % l2];
    } else {
      tmp.subVectors(points[l2 - 1], points[l2 - 2]).add(points[l2 - 1]);
      p3 = tmp;
    }
    if (this.curveType === "centripetal" || this.curveType === "chordal") {
      const pow = this.curveType === "chordal" ? 0.5 : 0.25;
      let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
      let dt1 = Math.pow(p1.distanceToSquared(p22), pow);
      let dt2 = Math.pow(p22.distanceToSquared(p3), pow);
      if (dt1 < 1e-4)
        dt1 = 1;
      if (dt0 < 1e-4)
        dt0 = dt1;
      if (dt2 < 1e-4)
        dt2 = dt1;
      px.initNonuniformCatmullRom(p0.x, p1.x, p22.x, p3.x, dt0, dt1, dt2);
      py.initNonuniformCatmullRom(p0.y, p1.y, p22.y, p3.y, dt0, dt1, dt2);
      pz.initNonuniformCatmullRom(p0.z, p1.z, p22.z, p3.z, dt0, dt1, dt2);
    } else if (this.curveType === "catmullrom") {
      px.initCatmullRom(p0.x, p1.x, p22.x, p3.x, this.tension);
      py.initCatmullRom(p0.y, p1.y, p22.y, p3.y, this.tension);
      pz.initCatmullRom(p0.z, p1.z, p22.z, p3.z, this.tension);
    }
    point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
    return point;
  }
  copy(source3) {
    super.copy(source3);
    this.points = [];
    for (let i2 = 0, l2 = source3.points.length; i2 < l2; i2++) {
      const point = source3.points[i2];
      this.points.push(point.clone());
    }
    this.closed = source3.closed;
    this.curveType = source3.curveType;
    this.tension = source3.tension;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.points = [];
    for (let i2 = 0, l2 = this.points.length; i2 < l2; i2++) {
      const point = this.points[i2];
      data.points.push(point.toArray());
    }
    data.closed = this.closed;
    data.curveType = this.curveType;
    data.tension = this.tension;
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];
    for (let i2 = 0, l2 = json.points.length; i2 < l2; i2++) {
      const point = json.points[i2];
      this.points.push(new Vector3().fromArray(point));
    }
    this.closed = json.closed;
    this.curveType = json.curveType;
    this.tension = json.tension;
    return this;
  }
}
CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
function CatmullRom(t2, p0, p1, p2, p3) {
  const v0 = (p2 - p0) * 0.5;
  const v1 = (p3 - p1) * 0.5;
  const t22 = t2 * t2;
  const t3 = t2 * t22;
  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t22 + v0 * t2 + p1;
}
function QuadraticBezierP0(t2, p2) {
  const k2 = 1 - t2;
  return k2 * k2 * p2;
}
function QuadraticBezierP1(t2, p2) {
  return 2 * (1 - t2) * t2 * p2;
}
function QuadraticBezierP2(t2, p2) {
  return t2 * t2 * p2;
}
function QuadraticBezier(t2, p0, p1, p2) {
  return QuadraticBezierP0(t2, p0) + QuadraticBezierP1(t2, p1) + QuadraticBezierP2(t2, p2);
}
function CubicBezierP0(t2, p2) {
  const k2 = 1 - t2;
  return k2 * k2 * k2 * p2;
}
function CubicBezierP1(t2, p2) {
  const k2 = 1 - t2;
  return 3 * k2 * k2 * t2 * p2;
}
function CubicBezierP2(t2, p2) {
  return 3 * (1 - t2) * t2 * t2 * p2;
}
function CubicBezierP3(t2, p2) {
  return t2 * t2 * t2 * p2;
}
function CubicBezier(t2, p0, p1, p2, p3) {
  return CubicBezierP0(t2, p0) + CubicBezierP1(t2, p1) + CubicBezierP2(t2, p2) + CubicBezierP3(t2, p3);
}
class CubicBezierCurve extends Curve {
  constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
    super();
    this.type = "CubicBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }
  getPoint(t2, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(CubicBezier(t2, v0.x, v1.x, v2.x, v3.x), CubicBezier(t2, v0.y, v1.y, v2.y, v3.y));
    return point;
  }
  copy(source3) {
    super.copy(source3);
    this.v0.copy(source3.v0);
    this.v1.copy(source3.v1);
    this.v2.copy(source3.v2);
    this.v3.copy(source3.v3);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }
}
CubicBezierCurve.prototype.isCubicBezierCurve = true;
class CubicBezierCurve3 extends Curve {
  constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
    super();
    this.type = "CubicBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }
  getPoint(t2, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(CubicBezier(t2, v0.x, v1.x, v2.x, v3.x), CubicBezier(t2, v0.y, v1.y, v2.y, v3.y), CubicBezier(t2, v0.z, v1.z, v2.z, v3.z));
    return point;
  }
  copy(source3) {
    super.copy(source3);
    this.v0.copy(source3.v0);
    this.v1.copy(source3.v1);
    this.v2.copy(source3.v2);
    this.v3.copy(source3.v3);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }
}
CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
class LineCurve extends Curve {
  constructor(v1 = new Vector2(), v2 = new Vector2()) {
    super();
    this.type = "LineCurve";
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t2, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    if (t2 === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t2).add(this.v1);
    }
    return point;
  }
  getPointAt(u2, optionalTarget) {
    return this.getPoint(u2, optionalTarget);
  }
  getTangent(t2, optionalTarget) {
    const tangent = optionalTarget || new Vector2();
    tangent.copy(this.v2).sub(this.v1).normalize();
    return tangent;
  }
  copy(source3) {
    super.copy(source3);
    this.v1.copy(source3.v1);
    this.v2.copy(source3.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
}
LineCurve.prototype.isLineCurve = true;
class LineCurve3 extends Curve {
  constructor(v1 = new Vector3(), v2 = new Vector3()) {
    super();
    this.type = "LineCurve3";
    this.isLineCurve3 = true;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t2, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    if (t2 === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t2).add(this.v1);
    }
    return point;
  }
  getPointAt(u2, optionalTarget) {
    return this.getPoint(u2, optionalTarget);
  }
  copy(source3) {
    super.copy(source3);
    this.v1.copy(source3.v1);
    this.v2.copy(source3.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
}
class QuadraticBezierCurve extends Curve {
  constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
    super();
    this.type = "QuadraticBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t2, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(QuadraticBezier(t2, v0.x, v1.x, v2.x), QuadraticBezier(t2, v0.y, v1.y, v2.y));
    return point;
  }
  copy(source3) {
    super.copy(source3);
    this.v0.copy(source3.v0);
    this.v1.copy(source3.v1);
    this.v2.copy(source3.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
}
QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
class QuadraticBezierCurve3 extends Curve {
  constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
    super();
    this.type = "QuadraticBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t2, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(QuadraticBezier(t2, v0.x, v1.x, v2.x), QuadraticBezier(t2, v0.y, v1.y, v2.y), QuadraticBezier(t2, v0.z, v1.z, v2.z));
    return point;
  }
  copy(source3) {
    super.copy(source3);
    this.v0.copy(source3.v0);
    this.v1.copy(source3.v1);
    this.v2.copy(source3.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
}
QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
class SplineCurve extends Curve {
  constructor(points = []) {
    super();
    this.type = "SplineCurve";
    this.points = points;
  }
  getPoint(t2, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const points = this.points;
    const p2 = (points.length - 1) * t2;
    const intPoint = Math.floor(p2);
    const weight = p2 - intPoint;
    const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
    const p1 = points[intPoint];
    const p22 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
    const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
    point.set(CatmullRom(weight, p0.x, p1.x, p22.x, p3.x), CatmullRom(weight, p0.y, p1.y, p22.y, p3.y));
    return point;
  }
  copy(source3) {
    super.copy(source3);
    this.points = [];
    for (let i2 = 0, l2 = source3.points.length; i2 < l2; i2++) {
      const point = source3.points[i2];
      this.points.push(point.clone());
    }
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.points = [];
    for (let i2 = 0, l2 = this.points.length; i2 < l2; i2++) {
      const point = this.points[i2];
      data.points.push(point.toArray());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];
    for (let i2 = 0, l2 = json.points.length; i2 < l2; i2++) {
      const point = json.points[i2];
      this.points.push(new Vector2().fromArray(point));
    }
    return this;
  }
}
SplineCurve.prototype.isSplineCurve = true;
var Curves = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve,
  CatmullRomCurve3,
  CubicBezierCurve,
  CubicBezierCurve3,
  EllipseCurve,
  LineCurve,
  LineCurve3,
  QuadraticBezierCurve,
  QuadraticBezierCurve3,
  SplineCurve
});
class CurvePath extends Curve {
  constructor() {
    super();
    this.type = "CurvePath";
    this.curves = [];
    this.autoClose = false;
  }
  add(curve) {
    this.curves.push(curve);
  }
  closePath() {
    const startPoint = this.curves[0].getPoint(0);
    const endPoint = this.curves[this.curves.length - 1].getPoint(1);
    if (!startPoint.equals(endPoint)) {
      this.curves.push(new LineCurve(endPoint, startPoint));
    }
  }
  getPoint(t2, optionalTarget) {
    const d2 = t2 * this.getLength();
    const curveLengths = this.getCurveLengths();
    let i2 = 0;
    while (i2 < curveLengths.length) {
      if (curveLengths[i2] >= d2) {
        const diff2 = curveLengths[i2] - d2;
        const curve = this.curves[i2];
        const segmentLength = curve.getLength();
        const u2 = segmentLength === 0 ? 0 : 1 - diff2 / segmentLength;
        return curve.getPointAt(u2, optionalTarget);
      }
      i2++;
    }
    return null;
  }
  getLength() {
    const lens = this.getCurveLengths();
    return lens[lens.length - 1];
  }
  updateArcLengths() {
    this.needsUpdate = true;
    this.cacheLengths = null;
    this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
      return this.cacheLengths;
    }
    const lengths = [];
    let sums = 0;
    for (let i2 = 0, l2 = this.curves.length; i2 < l2; i2++) {
      sums += this.curves[i2].getLength();
      lengths.push(sums);
    }
    this.cacheLengths = lengths;
    return lengths;
  }
  getSpacedPoints(divisions = 40) {
    const points = [];
    for (let i2 = 0; i2 <= divisions; i2++) {
      points.push(this.getPoint(i2 / divisions));
    }
    if (this.autoClose) {
      points.push(points[0]);
    }
    return points;
  }
  getPoints(divisions = 12) {
    const points = [];
    let last;
    for (let i2 = 0, curves = this.curves; i2 < curves.length; i2++) {
      const curve = curves[i2];
      const resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
      const pts = curve.getPoints(resolution);
      for (let j2 = 0; j2 < pts.length; j2++) {
        const point = pts[j2];
        if (last && last.equals(point))
          continue;
        points.push(point);
        last = point;
      }
    }
    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
      points.push(points[0]);
    }
    return points;
  }
  copy(source3) {
    super.copy(source3);
    this.curves = [];
    for (let i2 = 0, l2 = source3.curves.length; i2 < l2; i2++) {
      const curve = source3.curves[i2];
      this.curves.push(curve.clone());
    }
    this.autoClose = source3.autoClose;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.autoClose = this.autoClose;
    data.curves = [];
    for (let i2 = 0, l2 = this.curves.length; i2 < l2; i2++) {
      const curve = this.curves[i2];
      data.curves.push(curve.toJSON());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.autoClose = json.autoClose;
    this.curves = [];
    for (let i2 = 0, l2 = json.curves.length; i2 < l2; i2++) {
      const curve = json.curves[i2];
      this.curves.push(new Curves[curve.type]().fromJSON(curve));
    }
    return this;
  }
}
class Path extends CurvePath {
  constructor(points) {
    super();
    this.type = "Path";
    this.currentPoint = new Vector2();
    if (points) {
      this.setFromPoints(points);
    }
  }
  setFromPoints(points) {
    this.moveTo(points[0].x, points[0].y);
    for (let i2 = 1, l2 = points.length; i2 < l2; i2++) {
      this.lineTo(points[i2].x, points[i2].y);
    }
    return this;
  }
  moveTo(x2, y2) {
    this.currentPoint.set(x2, y2);
    return this;
  }
  lineTo(x2, y2) {
    const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x2, y2));
    this.curves.push(curve);
    this.currentPoint.set(x2, y2);
    return this;
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }
  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }
  splineThru(pts) {
    const npts = [this.currentPoint.clone()].concat(pts);
    const curve = new SplineCurve(npts);
    this.curves.push(curve);
    this.currentPoint.copy(pts[pts.length - 1]);
    return this;
  }
  arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  }
  absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  }
  ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    return this;
  }
  absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    if (this.curves.length > 0) {
      const firstPoint = curve.getPoint(0);
      if (!firstPoint.equals(this.currentPoint)) {
        this.lineTo(firstPoint.x, firstPoint.y);
      }
    }
    this.curves.push(curve);
    const lastPoint = curve.getPoint(1);
    this.currentPoint.copy(lastPoint);
    return this;
  }
  copy(source3) {
    super.copy(source3);
    this.currentPoint.copy(source3.currentPoint);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.currentPoint = this.currentPoint.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.currentPoint.fromArray(json.currentPoint);
    return this;
  }
}
class Shape extends Path {
  constructor(points) {
    super(points);
    this.uuid = generateUUID();
    this.type = "Shape";
    this.holes = [];
  }
  getPointsHoles(divisions) {
    const holesPts = [];
    for (let i2 = 0, l2 = this.holes.length; i2 < l2; i2++) {
      holesPts[i2] = this.holes[i2].getPoints(divisions);
    }
    return holesPts;
  }
  extractPoints(divisions) {
    return {
      shape: this.getPoints(divisions),
      holes: this.getPointsHoles(divisions)
    };
  }
  copy(source3) {
    super.copy(source3);
    this.holes = [];
    for (let i2 = 0, l2 = source3.holes.length; i2 < l2; i2++) {
      const hole = source3.holes[i2];
      this.holes.push(hole.clone());
    }
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.uuid = this.uuid;
    data.holes = [];
    for (let i2 = 0, l2 = this.holes.length; i2 < l2; i2++) {
      const hole = this.holes[i2];
      data.holes.push(hole.toJSON());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.uuid = json.uuid;
    this.holes = [];
    for (let i2 = 0, l2 = json.holes.length; i2 < l2; i2++) {
      const hole = json.holes[i2];
      this.holes.push(new Path().fromJSON(hole));
    }
    return this;
  }
}
const Earcut = {
  triangulate: function(data, holeIndices, dim = 2) {
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    let outerNode = linkedList(data, 0, outerLen, dim, true);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev)
      return triangles;
    let minX, minY, maxX, maxY, x2, y2, invSize;
    if (hasHoles)
      outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];
      for (let i2 = dim; i2 < outerLen; i2 += dim) {
        x2 = data[i2];
        y2 = data[i2 + 1];
        if (x2 < minX)
          minX = x2;
        if (y2 < minY)
          minY = y2;
        if (x2 > maxX)
          maxX = x2;
        if (y2 > maxY)
          maxY = y2;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 1 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
    return triangles;
  }
};
function linkedList(data, start, end, dim, clockwise) {
  let i2, last;
  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i2 = start; i2 < end; i2 += dim)
      last = insertNode(i2, data[i2], data[i2 + 1], last);
  } else {
    for (i2 = end - dim; i2 >= start; i2 -= dim)
      last = insertNode(i2, data[i2], data[i2 + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start, end) {
  if (!start)
    return start;
  if (!end)
    end = start;
  let p2 = start, again;
  do {
    again = false;
    if (!p2.steiner && (equals(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
      removeNode(p2);
      p2 = end = p2.prev;
      if (p2 === p2.next)
        break;
      again = true;
    } else {
      p2 = p2.next;
    }
  } while (again || p2 !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear)
    return;
  if (!pass && invSize)
    indexCurve(ear, minX, minY, invSize);
  let stop = ear, prev, next;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim);
      triangles.push(ear.i / dim);
      triangles.push(next.i / dim);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  const a2 = ear.prev, b2 = ear, c2 = ear.next;
  if (area(a2, b2, c2) >= 0)
    return false;
  let p2 = ear.next.next;
  while (p2 !== ear.prev) {
    if (pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
      return false;
    p2 = p2.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  const a2 = ear.prev, b2 = ear, c2 = ear.next;
  if (area(a2, b2, c2) >= 0)
    return false;
  const minTX = a2.x < b2.x ? a2.x < c2.x ? a2.x : c2.x : b2.x < c2.x ? b2.x : c2.x, minTY = a2.y < b2.y ? a2.y < c2.y ? a2.y : c2.y : b2.y < c2.y ? b2.y : c2.y, maxTX = a2.x > b2.x ? a2.x > c2.x ? a2.x : c2.x : b2.x > c2.x ? b2.x : c2.x, maxTY = a2.y > b2.y ? a2.y > c2.y ? a2.y : c2.y : b2.y > c2.y ? b2.y : c2.y;
  const minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
  let p2 = ear.prevZ, n2 = ear.nextZ;
  while (p2 && p2.z >= minZ && n2 && n2.z <= maxZ) {
    if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
      return false;
    p2 = p2.prevZ;
    if (n2 !== ear.prev && n2 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
      return false;
    n2 = n2.nextZ;
  }
  while (p2 && p2.z >= minZ) {
    if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
      return false;
    p2 = p2.prevZ;
  }
  while (n2 && n2.z <= maxZ) {
    if (n2 !== ear.prev && n2 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
      return false;
    n2 = n2.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles, dim) {
  let p2 = start;
  do {
    const a2 = p2.prev, b2 = p2.next.next;
    if (!equals(a2, b2) && intersects(a2, p2, p2.next, b2) && locallyInside(a2, b2) && locallyInside(b2, a2)) {
      triangles.push(a2.i / dim);
      triangles.push(p2.i / dim);
      triangles.push(b2.i / dim);
      removeNode(p2);
      removeNode(p2.next);
      p2 = start = b2;
    }
    p2 = p2.next;
  } while (p2 !== start);
  return filterPoints(p2);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  let a2 = start;
  do {
    let b2 = a2.next.next;
    while (b2 !== a2.prev) {
      if (a2.i !== b2.i && isValidDiagonal(a2, b2)) {
        let c2 = splitPolygon(a2, b2);
        a2 = filterPoints(a2, a2.next);
        c2 = filterPoints(c2, c2.next);
        earcutLinked(a2, triangles, dim, minX, minY, invSize);
        earcutLinked(c2, triangles, dim, minX, minY, invSize);
        return;
      }
      b2 = b2.next;
    }
    a2 = a2.next;
  } while (a2 !== start);
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  const queue = [];
  let i2, len, start, end, list;
  for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {
    start = holeIndices[i2] * dim;
    end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next)
      list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i2 = 0; i2 < queue.length; i2++) {
    eliminateHole(queue[i2], outerNode);
    outerNode = filterPoints(outerNode, outerNode.next);
  }
  return outerNode;
}
function compareX(a2, b2) {
  return a2.x - b2.x;
}
function eliminateHole(hole, outerNode) {
  outerNode = findHoleBridge(hole, outerNode);
  if (outerNode) {
    const b2 = splitPolygon(outerNode, hole);
    filterPoints(outerNode, outerNode.next);
    filterPoints(b2, b2.next);
  }
}
function findHoleBridge(hole, outerNode) {
  let p2 = outerNode;
  const hx2 = hole.x;
  const hy2 = hole.y;
  let qx2 = -Infinity, m2;
  do {
    if (hy2 <= p2.y && hy2 >= p2.next.y && p2.next.y !== p2.y) {
      const x2 = p2.x + (hy2 - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
      if (x2 <= hx2 && x2 > qx2) {
        qx2 = x2;
        if (x2 === hx2) {
          if (hy2 === p2.y)
            return p2;
          if (hy2 === p2.next.y)
            return p2.next;
        }
        m2 = p2.x < p2.next.x ? p2 : p2.next;
      }
    }
    p2 = p2.next;
  } while (p2 !== outerNode);
  if (!m2)
    return null;
  if (hx2 === qx2)
    return m2;
  const stop = m2, mx2 = m2.x, my2 = m2.y;
  let tanMin = Infinity, tan;
  p2 = m2;
  do {
    if (hx2 >= p2.x && p2.x >= mx2 && hx2 !== p2.x && pointInTriangle(hy2 < my2 ? hx2 : qx2, hy2, mx2, my2, hy2 < my2 ? qx2 : hx2, hy2, p2.x, p2.y)) {
      tan = Math.abs(hy2 - p2.y) / (hx2 - p2.x);
      if (locallyInside(p2, hole) && (tan < tanMin || tan === tanMin && (p2.x > m2.x || p2.x === m2.x && sectorContainsSector(m2, p2)))) {
        m2 = p2;
        tanMin = tan;
      }
    }
    p2 = p2.next;
  } while (p2 !== stop);
  return m2;
}
function sectorContainsSector(m2, p2) {
  return area(m2.prev, m2, p2.prev) < 0 && area(p2.next, m2, m2.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  let p2 = start;
  do {
    if (p2.z === null)
      p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
    p2.prevZ = p2.prev;
    p2.nextZ = p2.next;
    p2 = p2.next;
  } while (p2 !== start);
  p2.prevZ.nextZ = null;
  p2.prevZ = null;
  sortLinked(p2);
}
function sortLinked(list) {
  let i2, p2, q2, e20, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p2 = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p2) {
      numMerges++;
      q2 = p2;
      pSize = 0;
      for (i2 = 0; i2 < inSize; i2++) {
        pSize++;
        q2 = q2.nextZ;
        if (!q2)
          break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q2) {
        if (pSize !== 0 && (qSize === 0 || !q2 || p2.z <= q2.z)) {
          e20 = p2;
          p2 = p2.nextZ;
          pSize--;
        } else {
          e20 = q2;
          q2 = q2.nextZ;
          qSize--;
        }
        if (tail)
          tail.nextZ = e20;
        else
          list = e20;
        e20.prevZ = tail;
        tail = e20;
      }
      p2 = q2;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x2, y2, minX, minY, invSize) {
  x2 = 32767 * (x2 - minX) * invSize;
  y2 = 32767 * (y2 - minY) * invSize;
  x2 = (x2 | x2 << 8) & 16711935;
  x2 = (x2 | x2 << 4) & 252645135;
  x2 = (x2 | x2 << 2) & 858993459;
  x2 = (x2 | x2 << 1) & 1431655765;
  y2 = (y2 | y2 << 8) & 16711935;
  y2 = (y2 | y2 << 4) & 252645135;
  y2 = (y2 | y2 << 2) & 858993459;
  y2 = (y2 | y2 << 1) & 1431655765;
  return x2 | y2 << 1;
}
function getLeftmost(start) {
  let p2 = start, leftmost = start;
  do {
    if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y)
      leftmost = p2;
    p2 = p2.next;
  } while (p2 !== start);
  return leftmost;
}
function pointInTriangle(ax2, ay2, bx2, by2, cx2, cy2, px2, py2) {
  return (cx2 - px2) * (ay2 - py2) - (ax2 - px2) * (cy2 - py2) >= 0 && (ax2 - px2) * (by2 - py2) - (bx2 - px2) * (ay2 - py2) >= 0 && (bx2 - px2) * (cy2 - py2) - (cx2 - px2) * (by2 - py2) >= 0;
}
function isValidDiagonal(a2, b2) {
  return a2.next.i !== b2.i && a2.prev.i !== b2.i && !intersectsPolygon(a2, b2) && (locallyInside(a2, b2) && locallyInside(b2, a2) && middleInside(a2, b2) && (area(a2.prev, a2, b2.prev) || area(a2, b2.prev, b2)) || equals(a2, b2) && area(a2.prev, a2, a2.next) > 0 && area(b2.prev, b2, b2.next) > 0);
}
function area(p2, q2, r2) {
  return (q2.y - p2.y) * (r2.x - q2.x) - (q2.x - p2.x) * (r2.y - q2.y);
}
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  const o1 = sign(area(p1, q1, p2));
  const o2 = sign(area(p1, q1, q2));
  const o3 = sign(area(p2, q2, p1));
  const o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4)
    return true;
  if (o1 === 0 && onSegment(p1, p2, q1))
    return true;
  if (o2 === 0 && onSegment(p1, q2, q1))
    return true;
  if (o3 === 0 && onSegment(p2, p1, q2))
    return true;
  if (o4 === 0 && onSegment(p2, q1, q2))
    return true;
  return false;
}
function onSegment(p2, q2, r2) {
  return q2.x <= Math.max(p2.x, r2.x) && q2.x >= Math.min(p2.x, r2.x) && q2.y <= Math.max(p2.y, r2.y) && q2.y >= Math.min(p2.y, r2.y);
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a2, b2) {
  let p2 = a2;
  do {
    if (p2.i !== a2.i && p2.next.i !== a2.i && p2.i !== b2.i && p2.next.i !== b2.i && intersects(p2, p2.next, a2, b2))
      return true;
    p2 = p2.next;
  } while (p2 !== a2);
  return false;
}
function locallyInside(a2, b2) {
  return area(a2.prev, a2, a2.next) < 0 ? area(a2, b2, a2.next) >= 0 && area(a2, a2.prev, b2) >= 0 : area(a2, b2, a2.prev) < 0 || area(a2, a2.next, b2) < 0;
}
function middleInside(a2, b2) {
  let p2 = a2, inside = false;
  const px2 = (a2.x + b2.x) / 2, py2 = (a2.y + b2.y) / 2;
  do {
    if (p2.y > py2 !== p2.next.y > py2 && p2.next.y !== p2.y && px2 < (p2.next.x - p2.x) * (py2 - p2.y) / (p2.next.y - p2.y) + p2.x)
      inside = !inside;
    p2 = p2.next;
  } while (p2 !== a2);
  return inside;
}
function splitPolygon(a2, b2) {
  const a22 = new Node$1(a2.i, a2.x, a2.y), b22 = new Node$1(b2.i, b2.x, b2.y), an2 = a2.next, bp2 = b2.prev;
  a2.next = b2;
  b2.prev = a2;
  a22.next = an2;
  an2.prev = a22;
  b22.next = a22;
  a22.prev = b22;
  bp2.next = b22;
  b22.prev = bp2;
  return b22;
}
function insertNode(i2, x2, y2, last) {
  const p2 = new Node$1(i2, x2, y2);
  if (!last) {
    p2.prev = p2;
    p2.next = p2;
  } else {
    p2.next = last.next;
    p2.prev = last;
    last.next.prev = p2;
    last.next = p2;
  }
  return p2;
}
function removeNode(p2) {
  p2.next.prev = p2.prev;
  p2.prev.next = p2.next;
  if (p2.prevZ)
    p2.prevZ.nextZ = p2.nextZ;
  if (p2.nextZ)
    p2.nextZ.prevZ = p2.prevZ;
}
function Node$1(i2, x2, y2) {
  this.i = i2;
  this.x = x2;
  this.y = y2;
  this.prev = null;
  this.next = null;
  this.z = null;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
function signedArea(data, start, end, dim) {
  let sum = 0;
  for (let i2 = start, j2 = end - dim; i2 < end; i2 += dim) {
    sum += (data[j2] - data[i2]) * (data[i2 + 1] + data[j2 + 1]);
    j2 = i2;
  }
  return sum;
}
class ShapeUtils {
  static area(contour) {
    const n2 = contour.length;
    let a2 = 0;
    for (let p2 = n2 - 1, q2 = 0; q2 < n2; p2 = q2++) {
      a2 += contour[p2].x * contour[q2].y - contour[q2].x * contour[p2].y;
    }
    return a2 * 0.5;
  }
  static isClockWise(pts) {
    return ShapeUtils.area(pts) < 0;
  }
  static triangulateShape(contour, holes) {
    const vertices = [];
    const holeIndices = [];
    const faces = [];
    removeDupEndPts(contour);
    addContour(vertices, contour);
    let holeIndex = contour.length;
    holes.forEach(removeDupEndPts);
    for (let i2 = 0; i2 < holes.length; i2++) {
      holeIndices.push(holeIndex);
      holeIndex += holes[i2].length;
      addContour(vertices, holes[i2]);
    }
    const triangles = Earcut.triangulate(vertices, holeIndices);
    for (let i2 = 0; i2 < triangles.length; i2 += 3) {
      faces.push(triangles.slice(i2, i2 + 3));
    }
    return faces;
  }
}
function removeDupEndPts(points) {
  const l2 = points.length;
  if (l2 > 2 && points[l2 - 1].equals(points[0])) {
    points.pop();
  }
}
function addContour(vertices, contour) {
  for (let i2 = 0; i2 < contour.length; i2++) {
    vertices.push(contour[i2].x);
    vertices.push(contour[i2].y);
  }
}
class ExtrudeGeometry extends BufferGeometry {
  constructor(shapes = new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), options = {}) {
    super();
    this.type = "ExtrudeGeometry";
    this.parameters = {
      shapes,
      options
    };
    shapes = Array.isArray(shapes) ? shapes : [shapes];
    const scope = this;
    const verticesArray = [];
    const uvArray = [];
    for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
      const shape = shapes[i2];
      addShape(shape);
    }
    this.setAttribute("position", new Float32BufferAttribute(verticesArray, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvArray, 2));
    this.computeVertexNormals();
    function addShape(shape) {
      const placeholder = [];
      const curveSegments = options.curveSegments !== void 0 ? options.curveSegments : 12;
      const steps = options.steps !== void 0 ? options.steps : 1;
      let depth = options.depth !== void 0 ? options.depth : 1;
      let bevelEnabled = options.bevelEnabled !== void 0 ? options.bevelEnabled : true;
      let bevelThickness = options.bevelThickness !== void 0 ? options.bevelThickness : 0.2;
      let bevelSize = options.bevelSize !== void 0 ? options.bevelSize : bevelThickness - 0.1;
      let bevelOffset = options.bevelOffset !== void 0 ? options.bevelOffset : 0;
      let bevelSegments = options.bevelSegments !== void 0 ? options.bevelSegments : 3;
      const extrudePath = options.extrudePath;
      const uvgen = options.UVGenerator !== void 0 ? options.UVGenerator : WorldUVGenerator;
      if (options.amount !== void 0) {
        console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth.");
        depth = options.amount;
      }
      let extrudePts, extrudeByPath = false;
      let splineTube, binormal, normal, position2;
      if (extrudePath) {
        extrudePts = extrudePath.getSpacedPoints(steps);
        extrudeByPath = true;
        bevelEnabled = false;
        splineTube = extrudePath.computeFrenetFrames(steps, false);
        binormal = new Vector3();
        normal = new Vector3();
        position2 = new Vector3();
      }
      if (!bevelEnabled) {
        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;
        bevelOffset = 0;
      }
      const shapePoints = shape.extractPoints(curveSegments);
      let vertices = shapePoints.shape;
      const holes = shapePoints.holes;
      const reverse = !ShapeUtils.isClockWise(vertices);
      if (reverse) {
        vertices = vertices.reverse();
        for (let h2 = 0, hl2 = holes.length; h2 < hl2; h2++) {
          const ahole = holes[h2];
          if (ShapeUtils.isClockWise(ahole)) {
            holes[h2] = ahole.reverse();
          }
        }
      }
      const faces = ShapeUtils.triangulateShape(vertices, holes);
      const contour = vertices;
      for (let h2 = 0, hl2 = holes.length; h2 < hl2; h2++) {
        const ahole = holes[h2];
        vertices = vertices.concat(ahole);
      }
      function scalePt2(pt2, vec, size) {
        if (!vec)
          console.error("THREE.ExtrudeGeometry: vec does not exist");
        return vec.clone().multiplyScalar(size).add(pt2);
      }
      const vlen = vertices.length, flen = faces.length;
      function getBevelVec(inPt, inPrev, inNext) {
        let v_trans_x, v_trans_y, shrink_by;
        const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
        const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
        const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
        const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
        if (Math.abs(collinear0) > Number.EPSILON) {
          const v_prev_len = Math.sqrt(v_prev_lensq);
          const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
          const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
          const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
          const ptNextShift_x = inNext.x - v_next_y / v_next_len;
          const ptNextShift_y = inNext.y + v_next_x / v_next_len;
          const sf2 = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
          v_trans_x = ptPrevShift_x + v_prev_x * sf2 - inPt.x;
          v_trans_y = ptPrevShift_y + v_prev_y * sf2 - inPt.y;
          const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
          if (v_trans_lensq <= 2) {
            return new Vector2(v_trans_x, v_trans_y);
          } else {
            shrink_by = Math.sqrt(v_trans_lensq / 2);
          }
        } else {
          let direction_eq = false;
          if (v_prev_x > Number.EPSILON) {
            if (v_next_x > Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (v_prev_x < -Number.EPSILON) {
              if (v_next_x < -Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                direction_eq = true;
              }
            }
          }
          if (direction_eq) {
            v_trans_x = -v_prev_y;
            v_trans_y = v_prev_x;
            shrink_by = Math.sqrt(v_prev_lensq);
          } else {
            v_trans_x = v_prev_x;
            v_trans_y = v_prev_y;
            shrink_by = Math.sqrt(v_prev_lensq / 2);
          }
        }
        return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
      }
      const contourMovements = [];
      for (let i2 = 0, il2 = contour.length, j2 = il2 - 1, k2 = i2 + 1; i2 < il2; i2++, j2++, k2++) {
        if (j2 === il2)
          j2 = 0;
        if (k2 === il2)
          k2 = 0;
        contourMovements[i2] = getBevelVec(contour[i2], contour[j2], contour[k2]);
      }
      const holesMovements = [];
      let oneHoleMovements, verticesMovements = contourMovements.concat();
      for (let h2 = 0, hl2 = holes.length; h2 < hl2; h2++) {
        const ahole = holes[h2];
        oneHoleMovements = [];
        for (let i2 = 0, il2 = ahole.length, j2 = il2 - 1, k2 = i2 + 1; i2 < il2; i2++, j2++, k2++) {
          if (j2 === il2)
            j2 = 0;
          if (k2 === il2)
            k2 = 0;
          oneHoleMovements[i2] = getBevelVec(ahole[i2], ahole[j2], ahole[k2]);
        }
        holesMovements.push(oneHoleMovements);
        verticesMovements = verticesMovements.concat(oneHoleMovements);
      }
      for (let b2 = 0; b2 < bevelSegments; b2++) {
        const t2 = b2 / bevelSegments;
        const z2 = bevelThickness * Math.cos(t2 * Math.PI / 2);
        const bs3 = bevelSize * Math.sin(t2 * Math.PI / 2) + bevelOffset;
        for (let i2 = 0, il2 = contour.length; i2 < il2; i2++) {
          const vert = scalePt2(contour[i2], contourMovements[i2], bs3);
          v2(vert.x, vert.y, -z2);
        }
        for (let h2 = 0, hl2 = holes.length; h2 < hl2; h2++) {
          const ahole = holes[h2];
          oneHoleMovements = holesMovements[h2];
          for (let i2 = 0, il2 = ahole.length; i2 < il2; i2++) {
            const vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs3);
            v2(vert.x, vert.y, -z2);
          }
        }
      }
      const bs2 = bevelSize + bevelOffset;
      for (let i2 = 0; i2 < vlen; i2++) {
        const vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs2) : vertices[i2];
        if (!extrudeByPath) {
          v2(vert.x, vert.y, 0);
        } else {
          normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
          position2.copy(extrudePts[0]).add(normal).add(binormal);
          v2(position2.x, position2.y, position2.z);
        }
      }
      for (let s2 = 1; s2 <= steps; s2++) {
        for (let i2 = 0; i2 < vlen; i2++) {
          const vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs2) : vertices[i2];
          if (!extrudeByPath) {
            v2(vert.x, vert.y, depth / steps * s2);
          } else {
            normal.copy(splineTube.normals[s2]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[s2]).multiplyScalar(vert.y);
            position2.copy(extrudePts[s2]).add(normal).add(binormal);
            v2(position2.x, position2.y, position2.z);
          }
        }
      }
      for (let b2 = bevelSegments - 1; b2 >= 0; b2--) {
        const t2 = b2 / bevelSegments;
        const z2 = bevelThickness * Math.cos(t2 * Math.PI / 2);
        const bs3 = bevelSize * Math.sin(t2 * Math.PI / 2) + bevelOffset;
        for (let i2 = 0, il2 = contour.length; i2 < il2; i2++) {
          const vert = scalePt2(contour[i2], contourMovements[i2], bs3);
          v2(vert.x, vert.y, depth + z2);
        }
        for (let h2 = 0, hl2 = holes.length; h2 < hl2; h2++) {
          const ahole = holes[h2];
          oneHoleMovements = holesMovements[h2];
          for (let i2 = 0, il2 = ahole.length; i2 < il2; i2++) {
            const vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs3);
            if (!extrudeByPath) {
              v2(vert.x, vert.y, depth + z2);
            } else {
              v2(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z2);
            }
          }
        }
      }
      buildLidFaces();
      buildSideFaces();
      function buildLidFaces() {
        const start = verticesArray.length / 3;
        if (bevelEnabled) {
          let layer = 0;
          let offset2 = vlen * layer;
          for (let i2 = 0; i2 < flen; i2++) {
            const face = faces[i2];
            f3(face[2] + offset2, face[1] + offset2, face[0] + offset2);
          }
          layer = steps + bevelSegments * 2;
          offset2 = vlen * layer;
          for (let i2 = 0; i2 < flen; i2++) {
            const face = faces[i2];
            f3(face[0] + offset2, face[1] + offset2, face[2] + offset2);
          }
        } else {
          for (let i2 = 0; i2 < flen; i2++) {
            const face = faces[i2];
            f3(face[2], face[1], face[0]);
          }
          for (let i2 = 0; i2 < flen; i2++) {
            const face = faces[i2];
            f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
          }
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 0);
      }
      function buildSideFaces() {
        const start = verticesArray.length / 3;
        let layeroffset = 0;
        sidewalls(contour, layeroffset);
        layeroffset += contour.length;
        for (let h2 = 0, hl2 = holes.length; h2 < hl2; h2++) {
          const ahole = holes[h2];
          sidewalls(ahole, layeroffset);
          layeroffset += ahole.length;
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 1);
      }
      function sidewalls(contour2, layeroffset) {
        let i2 = contour2.length;
        while (--i2 >= 0) {
          const j2 = i2;
          let k2 = i2 - 1;
          if (k2 < 0)
            k2 = contour2.length - 1;
          for (let s2 = 0, sl2 = steps + bevelSegments * 2; s2 < sl2; s2++) {
            const slen1 = vlen * s2;
            const slen2 = vlen * (s2 + 1);
            const a2 = layeroffset + j2 + slen1, b2 = layeroffset + k2 + slen1, c2 = layeroffset + k2 + slen2, d2 = layeroffset + j2 + slen2;
            f4(a2, b2, c2, d2);
          }
        }
      }
      function v2(x2, y2, z2) {
        placeholder.push(x2);
        placeholder.push(y2);
        placeholder.push(z2);
      }
      function f3(a2, b2, c2) {
        addVertex(a2);
        addVertex(b2);
        addVertex(c2);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[2]);
      }
      function f4(a2, b2, c2, d2) {
        addVertex(a2);
        addVertex(b2);
        addVertex(d2);
        addVertex(b2);
        addVertex(c2);
        addVertex(d2);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[3]);
        addUV(uvs[1]);
        addUV(uvs[2]);
        addUV(uvs[3]);
      }
      function addVertex(index) {
        verticesArray.push(placeholder[index * 3 + 0]);
        verticesArray.push(placeholder[index * 3 + 1]);
        verticesArray.push(placeholder[index * 3 + 2]);
      }
      function addUV(vector2) {
        uvArray.push(vector2.x);
        uvArray.push(vector2.y);
      }
    }
  }
  toJSON() {
    const data = super.toJSON();
    const shapes = this.parameters.shapes;
    const options = this.parameters.options;
    return toJSON$1(shapes, options, data);
  }
  static fromJSON(data, shapes) {
    const geometryShapes = [];
    for (let j2 = 0, jl2 = data.shapes.length; j2 < jl2; j2++) {
      const shape = shapes[data.shapes[j2]];
      geometryShapes.push(shape);
    }
    const extrudePath = data.options.extrudePath;
    if (extrudePath !== void 0) {
      data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
    }
    return new ExtrudeGeometry(geometryShapes, data.options);
  }
}
const WorldUVGenerator = {
  generateTopUV: function(geometry2, vertices, indexA, indexB, indexC) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    return [
      new Vector2(a_x, a_y),
      new Vector2(b_x, b_y),
      new Vector2(c_x, c_y)
    ];
  },
  generateSideWallUV: function(geometry2, vertices, indexA, indexB, indexC, indexD) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const a_z = vertices[indexA * 3 + 2];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const b_z = vertices[indexB * 3 + 2];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    const c_z = vertices[indexC * 3 + 2];
    const d_x = vertices[indexD * 3];
    const d_y = vertices[indexD * 3 + 1];
    const d_z = vertices[indexD * 3 + 2];
    if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
      return [
        new Vector2(a_x, 1 - a_z),
        new Vector2(b_x, 1 - b_z),
        new Vector2(c_x, 1 - c_z),
        new Vector2(d_x, 1 - d_z)
      ];
    } else {
      return [
        new Vector2(a_y, 1 - a_z),
        new Vector2(b_y, 1 - b_z),
        new Vector2(c_y, 1 - c_z),
        new Vector2(d_y, 1 - d_z)
      ];
    }
  }
};
function toJSON$1(shapes, options, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
      const shape = shapes[i2];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  if (options.extrudePath !== void 0)
    data.options.extrudePath = options.extrudePath.toJSON();
  return data;
}
class ShapeGeometry extends BufferGeometry {
  constructor(shapes = new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), curveSegments = 12) {
    super();
    this.type = "ShapeGeometry";
    this.parameters = {
      shapes,
      curveSegments
    };
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let groupStart = 0;
    let groupCount = 0;
    if (Array.isArray(shapes) === false) {
      addShape(shapes);
    } else {
      for (let i2 = 0; i2 < shapes.length; i2++) {
        addShape(shapes[i2]);
        this.addGroup(groupStart, groupCount, i2);
        groupStart += groupCount;
        groupCount = 0;
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function addShape(shape) {
      const indexOffset = vertices.length / 3;
      const points = shape.extractPoints(curveSegments);
      let shapeVertices = points.shape;
      const shapeHoles = points.holes;
      if (ShapeUtils.isClockWise(shapeVertices) === false) {
        shapeVertices = shapeVertices.reverse();
      }
      for (let i2 = 0, l2 = shapeHoles.length; i2 < l2; i2++) {
        const shapeHole = shapeHoles[i2];
        if (ShapeUtils.isClockWise(shapeHole) === true) {
          shapeHoles[i2] = shapeHole.reverse();
        }
      }
      const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
      for (let i2 = 0, l2 = shapeHoles.length; i2 < l2; i2++) {
        const shapeHole = shapeHoles[i2];
        shapeVertices = shapeVertices.concat(shapeHole);
      }
      for (let i2 = 0, l2 = shapeVertices.length; i2 < l2; i2++) {
        const vertex2 = shapeVertices[i2];
        vertices.push(vertex2.x, vertex2.y, 0);
        normals.push(0, 0, 1);
        uvs.push(vertex2.x, vertex2.y);
      }
      for (let i2 = 0, l2 = faces.length; i2 < l2; i2++) {
        const face = faces[i2];
        const a2 = face[0] + indexOffset;
        const b2 = face[1] + indexOffset;
        const c2 = face[2] + indexOffset;
        indices.push(a2, b2, c2);
        groupCount += 3;
      }
    }
  }
  toJSON() {
    const data = super.toJSON();
    const shapes = this.parameters.shapes;
    return toJSON(shapes, data);
  }
  static fromJSON(data, shapes) {
    const geometryShapes = [];
    for (let j2 = 0, jl2 = data.shapes.length; j2 < jl2; j2++) {
      const shape = shapes[data.shapes[j2]];
      geometryShapes.push(shape);
    }
    return new ShapeGeometry(geometryShapes, data.curveSegments);
  }
}
function toJSON(shapes, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
      const shape = shapes[i2];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  return data;
}
class SphereGeometry extends BufferGeometry {
  constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
    super();
    this.type = "SphereGeometry";
    this.parameters = {
      radius,
      widthSegments,
      heightSegments,
      phiStart,
      phiLength,
      thetaStart,
      thetaLength
    };
    widthSegments = Math.max(3, Math.floor(widthSegments));
    heightSegments = Math.max(2, Math.floor(heightSegments));
    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
    let index = 0;
    const grid = [];
    const vertex2 = new Vector3();
    const normal = new Vector3();
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy2 = 0; iy2 <= heightSegments; iy2++) {
      const verticesRow = [];
      const v2 = iy2 / heightSegments;
      let uOffset = 0;
      if (iy2 == 0 && thetaStart == 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy2 == heightSegments && thetaEnd == Math.PI) {
        uOffset = -0.5 / widthSegments;
      }
      for (let ix2 = 0; ix2 <= widthSegments; ix2++) {
        const u2 = ix2 / widthSegments;
        vertex2.x = -radius * Math.cos(phiStart + u2 * phiLength) * Math.sin(thetaStart + v2 * thetaLength);
        vertex2.y = radius * Math.cos(thetaStart + v2 * thetaLength);
        vertex2.z = radius * Math.sin(phiStart + u2 * phiLength) * Math.sin(thetaStart + v2 * thetaLength);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normal.copy(vertex2).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u2 + uOffset, 1 - v2);
        verticesRow.push(index++);
      }
      grid.push(verticesRow);
    }
    for (let iy2 = 0; iy2 < heightSegments; iy2++) {
      for (let ix2 = 0; ix2 < widthSegments; ix2++) {
        const a2 = grid[iy2][ix2 + 1];
        const b2 = grid[iy2][ix2];
        const c2 = grid[iy2 + 1][ix2];
        const d2 = grid[iy2 + 1][ix2 + 1];
        if (iy2 !== 0 || thetaStart > 0)
          indices.push(a2, b2, d2);
        if (iy2 !== heightSegments - 1 || thetaEnd < Math.PI)
          indices.push(b2, c2, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  static fromJSON(data) {
    return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
  }
}
class ShadowMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "ShadowMaterial";
    this.color = new Color(0);
    this.transparent = true;
    this.setValues(parameters);
  }
  copy(source3) {
    super.copy(source3);
    this.color.copy(source3.color);
    return this;
  }
}
ShadowMaterial.prototype.isShadowMaterial = true;
class MeshStandardMaterial extends Material {
  constructor(parameters) {
    super();
    this.defines = { "STANDARD": "" };
    this.type = "MeshStandardMaterial";
    this.color = new Color(16777215);
    this.roughness = 1;
    this.metalness = 0;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.roughnessMap = null;
    this.metalnessMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapIntensity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source3) {
    super.copy(source3);
    this.defines = { "STANDARD": "" };
    this.color.copy(source3.color);
    this.roughness = source3.roughness;
    this.metalness = source3.metalness;
    this.map = source3.map;
    this.lightMap = source3.lightMap;
    this.lightMapIntensity = source3.lightMapIntensity;
    this.aoMap = source3.aoMap;
    this.aoMapIntensity = source3.aoMapIntensity;
    this.emissive.copy(source3.emissive);
    this.emissiveMap = source3.emissiveMap;
    this.emissiveIntensity = source3.emissiveIntensity;
    this.bumpMap = source3.bumpMap;
    this.bumpScale = source3.bumpScale;
    this.normalMap = source3.normalMap;
    this.normalMapType = source3.normalMapType;
    this.normalScale.copy(source3.normalScale);
    this.displacementMap = source3.displacementMap;
    this.displacementScale = source3.displacementScale;
    this.displacementBias = source3.displacementBias;
    this.roughnessMap = source3.roughnessMap;
    this.metalnessMap = source3.metalnessMap;
    this.alphaMap = source3.alphaMap;
    this.envMap = source3.envMap;
    this.envMapIntensity = source3.envMapIntensity;
    this.refractionRatio = source3.refractionRatio;
    this.wireframe = source3.wireframe;
    this.wireframeLinewidth = source3.wireframeLinewidth;
    this.wireframeLinecap = source3.wireframeLinecap;
    this.wireframeLinejoin = source3.wireframeLinejoin;
    this.flatShading = source3.flatShading;
    return this;
  }
}
MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
class MeshPhysicalMaterial extends MeshStandardMaterial {
  constructor(parameters) {
    super();
    this.defines = {
      "STANDARD": "",
      "PHYSICAL": ""
    };
    this.type = "MeshPhysicalMaterial";
    this.clearcoatMap = null;
    this.clearcoatRoughness = 0;
    this.clearcoatRoughnessMap = null;
    this.clearcoatNormalScale = new Vector2(1, 1);
    this.clearcoatNormalMap = null;
    this.ior = 1.5;
    Object.defineProperty(this, "reflectivity", {
      get: function() {
        return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(reflectivity) {
        this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
      }
    });
    this.sheenColor = new Color(0);
    this.sheenColorMap = null;
    this.sheenRoughness = 1;
    this.sheenRoughnessMap = null;
    this.transmissionMap = null;
    this.thickness = 0.01;
    this.thicknessMap = null;
    this.attenuationDistance = 0;
    this.attenuationColor = new Color(1, 1, 1);
    this.specularIntensity = 1;
    this.specularIntensityMap = null;
    this.specularColor = new Color(1, 1, 1);
    this.specularColorMap = null;
    this._sheen = 0;
    this._clearcoat = 0;
    this._transmission = 0;
    this.setValues(parameters);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(value) {
    if (this._sheen > 0 !== value > 0) {
      this.version++;
    }
    this._sheen = value;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(value) {
    if (this._clearcoat > 0 !== value > 0) {
      this.version++;
    }
    this._clearcoat = value;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(value) {
    if (this._transmission > 0 !== value > 0) {
      this.version++;
    }
    this._transmission = value;
  }
  copy(source3) {
    super.copy(source3);
    this.defines = {
      "STANDARD": "",
      "PHYSICAL": ""
    };
    this.clearcoat = source3.clearcoat;
    this.clearcoatMap = source3.clearcoatMap;
    this.clearcoatRoughness = source3.clearcoatRoughness;
    this.clearcoatRoughnessMap = source3.clearcoatRoughnessMap;
    this.clearcoatNormalMap = source3.clearcoatNormalMap;
    this.clearcoatNormalScale.copy(source3.clearcoatNormalScale);
    this.ior = source3.ior;
    this.sheen = source3.sheen;
    this.sheenColor.copy(source3.sheenColor);
    this.sheenColorMap = source3.sheenColorMap;
    this.sheenRoughness = source3.sheenRoughness;
    this.sheenRoughnessMap = source3.sheenRoughnessMap;
    this.transmission = source3.transmission;
    this.transmissionMap = source3.transmissionMap;
    this.thickness = source3.thickness;
    this.thicknessMap = source3.thicknessMap;
    this.attenuationDistance = source3.attenuationDistance;
    this.attenuationColor.copy(source3.attenuationColor);
    this.specularIntensity = source3.specularIntensity;
    this.specularIntensityMap = source3.specularIntensityMap;
    this.specularColor.copy(source3.specularColor);
    this.specularColorMap = source3.specularColorMap;
    return this;
  }
}
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
class MeshPhongMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshPhongMaterial";
    this.color = new Color(16777215);
    this.specular = new Color(1118481);
    this.shininess = 30;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source3) {
    super.copy(source3);
    this.color.copy(source3.color);
    this.specular.copy(source3.specular);
    this.shininess = source3.shininess;
    this.map = source3.map;
    this.lightMap = source3.lightMap;
    this.lightMapIntensity = source3.lightMapIntensity;
    this.aoMap = source3.aoMap;
    this.aoMapIntensity = source3.aoMapIntensity;
    this.emissive.copy(source3.emissive);
    this.emissiveMap = source3.emissiveMap;
    this.emissiveIntensity = source3.emissiveIntensity;
    this.bumpMap = source3.bumpMap;
    this.bumpScale = source3.bumpScale;
    this.normalMap = source3.normalMap;
    this.normalMapType = source3.normalMapType;
    this.normalScale.copy(source3.normalScale);
    this.displacementMap = source3.displacementMap;
    this.displacementScale = source3.displacementScale;
    this.displacementBias = source3.displacementBias;
    this.specularMap = source3.specularMap;
    this.alphaMap = source3.alphaMap;
    this.envMap = source3.envMap;
    this.combine = source3.combine;
    this.reflectivity = source3.reflectivity;
    this.refractionRatio = source3.refractionRatio;
    this.wireframe = source3.wireframe;
    this.wireframeLinewidth = source3.wireframeLinewidth;
    this.wireframeLinecap = source3.wireframeLinecap;
    this.wireframeLinejoin = source3.wireframeLinejoin;
    this.flatShading = source3.flatShading;
    return this;
  }
}
MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
class MeshToonMaterial extends Material {
  constructor(parameters) {
    super();
    this.defines = { "TOON": "" };
    this.type = "MeshToonMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.gradientMap = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.setValues(parameters);
  }
  copy(source3) {
    super.copy(source3);
    this.color.copy(source3.color);
    this.map = source3.map;
    this.gradientMap = source3.gradientMap;
    this.lightMap = source3.lightMap;
    this.lightMapIntensity = source3.lightMapIntensity;
    this.aoMap = source3.aoMap;
    this.aoMapIntensity = source3.aoMapIntensity;
    this.emissive.copy(source3.emissive);
    this.emissiveMap = source3.emissiveMap;
    this.emissiveIntensity = source3.emissiveIntensity;
    this.bumpMap = source3.bumpMap;
    this.bumpScale = source3.bumpScale;
    this.normalMap = source3.normalMap;
    this.normalMapType = source3.normalMapType;
    this.normalScale.copy(source3.normalScale);
    this.displacementMap = source3.displacementMap;
    this.displacementScale = source3.displacementScale;
    this.displacementBias = source3.displacementBias;
    this.alphaMap = source3.alphaMap;
    this.wireframe = source3.wireframe;
    this.wireframeLinewidth = source3.wireframeLinewidth;
    this.wireframeLinecap = source3.wireframeLinecap;
    this.wireframeLinejoin = source3.wireframeLinejoin;
    return this;
  }
}
MeshToonMaterial.prototype.isMeshToonMaterial = true;
class MeshNormalMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshNormalMaterial";
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source3) {
    super.copy(source3);
    this.bumpMap = source3.bumpMap;
    this.bumpScale = source3.bumpScale;
    this.normalMap = source3.normalMap;
    this.normalMapType = source3.normalMapType;
    this.normalScale.copy(source3.normalScale);
    this.displacementMap = source3.displacementMap;
    this.displacementScale = source3.displacementScale;
    this.displacementBias = source3.displacementBias;
    this.wireframe = source3.wireframe;
    this.wireframeLinewidth = source3.wireframeLinewidth;
    this.flatShading = source3.flatShading;
    return this;
  }
}
MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
class MeshLambertMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshLambertMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.setValues(parameters);
  }
  copy(source3) {
    super.copy(source3);
    this.color.copy(source3.color);
    this.map = source3.map;
    this.lightMap = source3.lightMap;
    this.lightMapIntensity = source3.lightMapIntensity;
    this.aoMap = source3.aoMap;
    this.aoMapIntensity = source3.aoMapIntensity;
    this.emissive.copy(source3.emissive);
    this.emissiveMap = source3.emissiveMap;
    this.emissiveIntensity = source3.emissiveIntensity;
    this.specularMap = source3.specularMap;
    this.alphaMap = source3.alphaMap;
    this.envMap = source3.envMap;
    this.combine = source3.combine;
    this.reflectivity = source3.reflectivity;
    this.refractionRatio = source3.refractionRatio;
    this.wireframe = source3.wireframe;
    this.wireframeLinewidth = source3.wireframeLinewidth;
    this.wireframeLinecap = source3.wireframeLinecap;
    this.wireframeLinejoin = source3.wireframeLinejoin;
    return this;
  }
}
MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
class MeshMatcapMaterial extends Material {
  constructor(parameters) {
    super();
    this.defines = { "MATCAP": "" };
    this.type = "MeshMatcapMaterial";
    this.color = new Color(16777215);
    this.matcap = null;
    this.map = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source3) {
    super.copy(source3);
    this.defines = { "MATCAP": "" };
    this.color.copy(source3.color);
    this.matcap = source3.matcap;
    this.map = source3.map;
    this.bumpMap = source3.bumpMap;
    this.bumpScale = source3.bumpScale;
    this.normalMap = source3.normalMap;
    this.normalMapType = source3.normalMapType;
    this.normalScale.copy(source3.normalScale);
    this.displacementMap = source3.displacementMap;
    this.displacementScale = source3.displacementScale;
    this.displacementBias = source3.displacementBias;
    this.alphaMap = source3.alphaMap;
    this.flatShading = source3.flatShading;
    return this;
  }
}
MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
class LineDashedMaterial extends LineBasicMaterial {
  constructor(parameters) {
    super();
    this.type = "LineDashedMaterial";
    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.setValues(parameters);
  }
  copy(source3) {
    super.copy(source3);
    this.scale = source3.scale;
    this.dashSize = source3.dashSize;
    this.gapSize = source3.gapSize;
    return this;
  }
}
LineDashedMaterial.prototype.isLineDashedMaterial = true;
const AnimationUtils = {
  arraySlice: function(array, from2, to2) {
    if (AnimationUtils.isTypedArray(array)) {
      return new array.constructor(array.subarray(from2, to2 !== void 0 ? to2 : array.length));
    }
    return array.slice(from2, to2);
  },
  convertArray: function(array, type, forceClone) {
    if (!array || !forceClone && array.constructor === type)
      return array;
    if (typeof type.BYTES_PER_ELEMENT === "number") {
      return new type(array);
    }
    return Array.prototype.slice.call(array);
  },
  isTypedArray: function(object) {
    return ArrayBuffer.isView(object) && !(object instanceof DataView);
  },
  getKeyframeOrder: function(times) {
    function compareTime(i2, j2) {
      return times[i2] - times[j2];
    }
    const n2 = times.length;
    const result = new Array(n2);
    for (let i2 = 0; i2 !== n2; ++i2)
      result[i2] = i2;
    result.sort(compareTime);
    return result;
  },
  sortedArray: function(values, stride, order) {
    const nValues = values.length;
    const result = new values.constructor(nValues);
    for (let i2 = 0, dstOffset = 0; dstOffset !== nValues; ++i2) {
      const srcOffset = order[i2] * stride;
      for (let j2 = 0; j2 !== stride; ++j2) {
        result[dstOffset++] = values[srcOffset + j2];
      }
    }
    return result;
  },
  flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
    let i2 = 1, key = jsonKeys[0];
    while (key !== void 0 && key[valuePropertyName] === void 0) {
      key = jsonKeys[i2++];
    }
    if (key === void 0)
      return;
    let value = key[valuePropertyName];
    if (value === void 0)
      return;
    if (Array.isArray(value)) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values.push.apply(values, value);
        }
        key = jsonKeys[i2++];
      } while (key !== void 0);
    } else if (value.toArray !== void 0) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          value.toArray(values, values.length);
        }
        key = jsonKeys[i2++];
      } while (key !== void 0);
    } else {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values.push(value);
        }
        key = jsonKeys[i2++];
      } while (key !== void 0);
    }
  },
  subclip: function(sourceClip, name2, startFrame, endFrame, fps = 30) {
    const clip = sourceClip.clone();
    clip.name = name2;
    const tracks = [];
    for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
      const track = clip.tracks[i2];
      const valueSize = track.getValueSize();
      const times = [];
      const values = [];
      for (let j2 = 0; j2 < track.times.length; ++j2) {
        const frame = track.times[j2] * fps;
        if (frame < startFrame || frame >= endFrame)
          continue;
        times.push(track.times[j2]);
        for (let k2 = 0; k2 < valueSize; ++k2) {
          values.push(track.values[j2 * valueSize + k2]);
        }
      }
      if (times.length === 0)
        continue;
      track.times = AnimationUtils.convertArray(times, track.times.constructor);
      track.values = AnimationUtils.convertArray(values, track.values.constructor);
      tracks.push(track);
    }
    clip.tracks = tracks;
    let minStartTime = Infinity;
    for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
      if (minStartTime > clip.tracks[i2].times[0]) {
        minStartTime = clip.tracks[i2].times[0];
      }
    }
    for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
      clip.tracks[i2].shift(-1 * minStartTime);
    }
    clip.resetDuration();
    return clip;
  },
  makeClipAdditive: function(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
    if (fps <= 0)
      fps = 30;
    const numTracks = referenceClip.tracks.length;
    const referenceTime = referenceFrame / fps;
    for (let i2 = 0; i2 < numTracks; ++i2) {
      const referenceTrack = referenceClip.tracks[i2];
      const referenceTrackType = referenceTrack.ValueTypeName;
      if (referenceTrackType === "bool" || referenceTrackType === "string")
        continue;
      const targetTrack = targetClip.tracks.find(function(track) {
        return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
      });
      if (targetTrack === void 0)
        continue;
      let referenceOffset = 0;
      const referenceValueSize = referenceTrack.getValueSize();
      if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        referenceOffset = referenceValueSize / 3;
      }
      let targetOffset = 0;
      const targetValueSize = targetTrack.getValueSize();
      if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        targetOffset = targetValueSize / 3;
      }
      const lastIndex = referenceTrack.times.length - 1;
      let referenceValue;
      if (referenceTime <= referenceTrack.times[0]) {
        const startIndex = referenceOffset;
        const endIndex = referenceValueSize - referenceOffset;
        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
      } else if (referenceTime >= referenceTrack.times[lastIndex]) {
        const startIndex = lastIndex * referenceValueSize + referenceOffset;
        const endIndex = startIndex + referenceValueSize - referenceOffset;
        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
      } else {
        const interpolant = referenceTrack.createInterpolant();
        const startIndex = referenceOffset;
        const endIndex = referenceValueSize - referenceOffset;
        interpolant.evaluate(referenceTime);
        referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
      }
      if (referenceTrackType === "quaternion") {
        const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
        referenceQuat.toArray(referenceValue);
      }
      const numTimes = targetTrack.times.length;
      for (let j2 = 0; j2 < numTimes; ++j2) {
        const valueStart = j2 * targetValueSize + targetOffset;
        if (referenceTrackType === "quaternion") {
          Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
        } else {
          const valueEnd = targetValueSize - targetOffset * 2;
          for (let k2 = 0; k2 < valueEnd; ++k2) {
            targetTrack.values[valueStart + k2] -= referenceValue[k2];
          }
        }
      }
    }
    targetClip.blendMode = AdditiveAnimationBlendMode;
    return targetClip;
  }
};
class Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    this.parameterPositions = parameterPositions;
    this._cachedIndex = 0;
    this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
    this.sampleValues = sampleValues;
    this.valueSize = sampleSize;
    this.settings = null;
    this.DefaultSettings_ = {};
  }
  evaluate(t2) {
    const pp2 = this.parameterPositions;
    let i1 = this._cachedIndex, t1 = pp2[i1], t0 = pp2[i1 - 1];
    validate_interval: {
      seek: {
        let right;
        linear_scan: {
          forward_scan:
            if (!(t2 < t1)) {
              for (let giveUpAt = i1 + 2; ; ) {
                if (t1 === void 0) {
                  if (t2 < t0)
                    break forward_scan;
                  i1 = pp2.length;
                  this._cachedIndex = i1;
                  return this.afterEnd_(i1 - 1, t2, t0);
                }
                if (i1 === giveUpAt)
                  break;
                t0 = t1;
                t1 = pp2[++i1];
                if (t2 < t1) {
                  break seek;
                }
              }
              right = pp2.length;
              break linear_scan;
            }
          if (!(t2 >= t0)) {
            const t1global = pp2[1];
            if (t2 < t1global) {
              i1 = 2;
              t0 = t1global;
            }
            for (let giveUpAt = i1 - 2; ; ) {
              if (t0 === void 0) {
                this._cachedIndex = 0;
                return this.beforeStart_(0, t2, t1);
              }
              if (i1 === giveUpAt)
                break;
              t1 = t0;
              t0 = pp2[--i1 - 1];
              if (t2 >= t0) {
                break seek;
              }
            }
            right = i1;
            i1 = 0;
            break linear_scan;
          }
          break validate_interval;
        }
        while (i1 < right) {
          const mid = i1 + right >>> 1;
          if (t2 < pp2[mid]) {
            right = mid;
          } else {
            i1 = mid + 1;
          }
        }
        t1 = pp2[i1];
        t0 = pp2[i1 - 1];
        if (t0 === void 0) {
          this._cachedIndex = 0;
          return this.beforeStart_(0, t2, t1);
        }
        if (t1 === void 0) {
          i1 = pp2.length;
          this._cachedIndex = i1;
          return this.afterEnd_(i1 - 1, t0, t2);
        }
      }
      this._cachedIndex = i1;
      this.intervalChanged_(i1, t0, t1);
    }
    return this.interpolate_(i1, t0, t2, t1);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(index) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset2 = index * stride;
    for (let i2 = 0; i2 !== stride; ++i2) {
      result[i2] = values[offset2 + i2];
    }
    return result;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;
Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;
class CubicInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    this._weightPrev = -0;
    this._offsetPrev = -0;
    this._weightNext = -0;
    this._offsetNext = -0;
    this.DefaultSettings_ = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
  }
  intervalChanged_(i1, t0, t1) {
    const pp2 = this.parameterPositions;
    let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp2[iPrev], tNext = pp2[iNext];
    if (tPrev === void 0) {
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          iPrev = i1;
          tPrev = 2 * t0 - t1;
          break;
        case WrapAroundEnding:
          iPrev = pp2.length - 2;
          tPrev = t0 + pp2[iPrev] - pp2[iPrev + 1];
          break;
        default:
          iPrev = i1;
          tPrev = t1;
      }
    }
    if (tNext === void 0) {
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          iNext = i1;
          tNext = 2 * t1 - t0;
          break;
        case WrapAroundEnding:
          iNext = 1;
          tNext = t1 + pp2[1] - pp2[0];
          break;
        default:
          iNext = i1 - 1;
          tNext = t0;
      }
    }
    const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
    this._weightPrev = halfDt / (t0 - tPrev);
    this._weightNext = halfDt / (tNext - t1);
    this._offsetPrev = iPrev * stride;
    this._offsetNext = iNext * stride;
  }
  interpolate_(i1, t0, t2, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP2 = this._offsetPrev, oN2 = this._offsetNext, wP2 = this._weightPrev, wN2 = this._weightNext, p2 = (t2 - t0) / (t1 - t0), pp2 = p2 * p2, ppp = pp2 * p2;
    const sP2 = -wP2 * ppp + 2 * wP2 * pp2 - wP2 * p2;
    const s0 = (1 + wP2) * ppp + (-1.5 - 2 * wP2) * pp2 + (-0.5 + wP2) * p2 + 1;
    const s1 = (-1 - wN2) * ppp + (1.5 + wN2) * pp2 + 0.5 * p2;
    const sN2 = wN2 * ppp - wN2 * pp2;
    for (let i2 = 0; i2 !== stride; ++i2) {
      result[i2] = sP2 * values[oP2 + i2] + s0 * values[o0 + i2] + s1 * values[o1 + i2] + sN2 * values[oN2 + i2];
    }
    return result;
  }
}
class LinearInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1, t0, t2, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t2 - t0) / (t1 - t0), weight0 = 1 - weight1;
    for (let i2 = 0; i2 !== stride; ++i2) {
      result[i2] = values[offset0 + i2] * weight0 + values[offset1 + i2] * weight1;
    }
    return result;
  }
}
class DiscreteInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1) {
    return this.copySampleValue_(i1 - 1);
  }
}
class KeyframeTrack {
  constructor(name2, times, values, interpolation) {
    if (name2 === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (times === void 0 || times.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name2);
    this.name = name2;
    this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
    this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
  }
  static toJSON(track) {
    const trackType = track.constructor;
    let json;
    if (trackType.toJSON !== this.toJSON) {
      json = trackType.toJSON(track);
    } else {
      json = {
        "name": track.name,
        "times": AnimationUtils.convertArray(track.times, Array),
        "values": AnimationUtils.convertArray(track.values, Array)
      };
      const interpolation = track.getInterpolation();
      if (interpolation !== track.DefaultInterpolation) {
        json.interpolation = interpolation;
      }
    }
    json.type = track.ValueTypeName;
    return json;
  }
  InterpolantFactoryMethodDiscrete(result) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodLinear(result) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodSmooth(result) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  setInterpolation(interpolation) {
    let factoryMethod;
    switch (interpolation) {
      case InterpolateDiscrete:
        factoryMethod = this.InterpolantFactoryMethodDiscrete;
        break;
      case InterpolateLinear:
        factoryMethod = this.InterpolantFactoryMethodLinear;
        break;
      case InterpolateSmooth:
        factoryMethod = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (factoryMethod === void 0) {
      const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0) {
        if (interpolation !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw new Error(message);
        }
      }
      console.warn("THREE.KeyframeTrack:", message);
      return this;
    }
    this.createInterpolant = factoryMethod;
    return this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(timeOffset) {
    if (timeOffset !== 0) {
      const times = this.times;
      for (let i2 = 0, n2 = times.length; i2 !== n2; ++i2) {
        times[i2] += timeOffset;
      }
    }
    return this;
  }
  scale(timeScale) {
    if (timeScale !== 1) {
      const times = this.times;
      for (let i2 = 0, n2 = times.length; i2 !== n2; ++i2) {
        times[i2] *= timeScale;
      }
    }
    return this;
  }
  trim(startTime, endTime) {
    const times = this.times, nKeys = times.length;
    let from2 = 0, to2 = nKeys - 1;
    while (from2 !== nKeys && times[from2] < startTime) {
      ++from2;
    }
    while (to2 !== -1 && times[to2] > endTime) {
      --to2;
    }
    ++to2;
    if (from2 !== 0 || to2 !== nKeys) {
      if (from2 >= to2) {
        to2 = Math.max(to2, 1);
        from2 = to2 - 1;
      }
      const stride = this.getValueSize();
      this.times = AnimationUtils.arraySlice(times, from2, to2);
      this.values = AnimationUtils.arraySlice(this.values, from2 * stride, to2 * stride);
    }
    return this;
  }
  validate() {
    let valid = true;
    const valueSize = this.getValueSize();
    if (valueSize - Math.floor(valueSize) !== 0) {
      console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
      valid = false;
    }
    const times = this.times, values = this.values, nKeys = times.length;
    if (nKeys === 0) {
      console.error("THREE.KeyframeTrack: Track is empty.", this);
      valid = false;
    }
    let prevTime = null;
    for (let i2 = 0; i2 !== nKeys; i2++) {
      const currTime = times[i2];
      if (typeof currTime === "number" && isNaN(currTime)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i2, currTime);
        valid = false;
        break;
      }
      if (prevTime !== null && prevTime > currTime) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, i2, currTime, prevTime);
        valid = false;
        break;
      }
      prevTime = currTime;
    }
    if (values !== void 0) {
      if (AnimationUtils.isTypedArray(values)) {
        for (let i2 = 0, n2 = values.length; i2 !== n2; ++i2) {
          const value = values[i2];
          if (isNaN(value)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i2, value);
            valid = false;
            break;
          }
        }
      }
    }
    return valid;
  }
  optimize() {
    const times = AnimationUtils.arraySlice(this.times), values = AnimationUtils.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
    let writeIndex = 1;
    for (let i2 = 1; i2 < lastIndex; ++i2) {
      let keep = false;
      const time = times[i2];
      const timeNext = times[i2 + 1];
      if (time !== timeNext && (i2 !== 1 || time !== times[0])) {
        if (!smoothInterpolation) {
          const offset2 = i2 * stride, offsetP = offset2 - stride, offsetN = offset2 + stride;
          for (let j2 = 0; j2 !== stride; ++j2) {
            const value = values[offset2 + j2];
            if (value !== values[offsetP + j2] || value !== values[offsetN + j2]) {
              keep = true;
              break;
            }
          }
        } else {
          keep = true;
        }
      }
      if (keep) {
        if (i2 !== writeIndex) {
          times[writeIndex] = times[i2];
          const readOffset = i2 * stride, writeOffset = writeIndex * stride;
          for (let j2 = 0; j2 !== stride; ++j2) {
            values[writeOffset + j2] = values[readOffset + j2];
          }
        }
        ++writeIndex;
      }
    }
    if (lastIndex > 0) {
      times[writeIndex] = times[lastIndex];
      for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j2 = 0; j2 !== stride; ++j2) {
        values[writeOffset + j2] = values[readOffset + j2];
      }
      ++writeIndex;
    }
    if (writeIndex !== times.length) {
      this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
      this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
    } else {
      this.times = times;
      this.values = values;
    }
    return this;
  }
  clone() {
    const times = AnimationUtils.arraySlice(this.times, 0);
    const values = AnimationUtils.arraySlice(this.values, 0);
    const TypedKeyframeTrack = this.constructor;
    const track = new TypedKeyframeTrack(this.name, times, values);
    track.createInterpolant = this.createInterpolant;
    return track;
  }
}
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
class BooleanKeyframeTrack extends KeyframeTrack {
}
BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class ColorKeyframeTrack extends KeyframeTrack {
}
ColorKeyframeTrack.prototype.ValueTypeName = "color";
class NumberKeyframeTrack extends KeyframeTrack {
}
NumberKeyframeTrack.prototype.ValueTypeName = "number";
class QuaternionLinearInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1, t0, t2, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t2 - t0) / (t1 - t0);
    let offset2 = i1 * stride;
    for (let end = offset2 + stride; offset2 !== end; offset2 += 4) {
      Quaternion.slerpFlat(result, 0, values, offset2 - stride, values, offset2, alpha);
    }
    return result;
  }
}
class QuaternionKeyframeTrack extends KeyframeTrack {
  InterpolantFactoryMethodLinear(result) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
}
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class StringKeyframeTrack extends KeyframeTrack {
}
StringKeyframeTrack.prototype.ValueTypeName = "string";
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class VectorKeyframeTrack extends KeyframeTrack {
}
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
class AnimationClip {
  constructor(name2, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
    this.name = name2;
    this.tracks = tracks;
    this.duration = duration;
    this.blendMode = blendMode;
    this.uuid = generateUUID();
    if (this.duration < 0) {
      this.resetDuration();
    }
  }
  static parse(json) {
    const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
    for (let i2 = 0, n2 = jsonTracks.length; i2 !== n2; ++i2) {
      tracks.push(parseKeyframeTrack(jsonTracks[i2]).scale(frameTime));
    }
    const clip = new this(json.name, json.duration, tracks, json.blendMode);
    clip.uuid = json.uuid;
    return clip;
  }
  static toJSON(clip) {
    const tracks = [], clipTracks = clip.tracks;
    const json = {
      "name": clip.name,
      "duration": clip.duration,
      "tracks": tracks,
      "uuid": clip.uuid,
      "blendMode": clip.blendMode
    };
    for (let i2 = 0, n2 = clipTracks.length; i2 !== n2; ++i2) {
      tracks.push(KeyframeTrack.toJSON(clipTracks[i2]));
    }
    return json;
  }
  static CreateFromMorphTargetSequence(name2, morphTargetSequence, fps, noLoop) {
    const numMorphTargets = morphTargetSequence.length;
    const tracks = [];
    for (let i2 = 0; i2 < numMorphTargets; i2++) {
      let times = [];
      let values = [];
      times.push((i2 + numMorphTargets - 1) % numMorphTargets, i2, (i2 + 1) % numMorphTargets);
      values.push(0, 1, 0);
      const order = AnimationUtils.getKeyframeOrder(times);
      times = AnimationUtils.sortedArray(times, 1, order);
      values = AnimationUtils.sortedArray(values, 1, order);
      if (!noLoop && times[0] === 0) {
        times.push(numMorphTargets);
        values.push(values[0]);
      }
      tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i2].name + "]", times, values).scale(1 / fps));
    }
    return new this(name2, -1, tracks);
  }
  static findByName(objectOrClipArray, name2) {
    let clipArray = objectOrClipArray;
    if (!Array.isArray(objectOrClipArray)) {
      const o2 = objectOrClipArray;
      clipArray = o2.geometry && o2.geometry.animations || o2.animations;
    }
    for (let i2 = 0; i2 < clipArray.length; i2++) {
      if (clipArray[i2].name === name2) {
        return clipArray[i2];
      }
    }
    return null;
  }
  static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
    const animationToMorphTargets = {};
    const pattern = /^([\w-]*?)([\d]+)$/;
    for (let i2 = 0, il2 = morphTargets.length; i2 < il2; i2++) {
      const morphTarget = morphTargets[i2];
      const parts = morphTarget.name.match(pattern);
      if (parts && parts.length > 1) {
        const name2 = parts[1];
        let animationMorphTargets = animationToMorphTargets[name2];
        if (!animationMorphTargets) {
          animationToMorphTargets[name2] = animationMorphTargets = [];
        }
        animationMorphTargets.push(morphTarget);
      }
    }
    const clips = [];
    for (const name2 in animationToMorphTargets) {
      clips.push(this.CreateFromMorphTargetSequence(name2, animationToMorphTargets[name2], fps, noLoop));
    }
    return clips;
  }
  static parseAnimation(animation, bones) {
    if (!animation) {
      console.error("THREE.AnimationClip: No animation in JSONLoader data.");
      return null;
    }
    const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
      if (animationKeys.length !== 0) {
        const times = [];
        const values = [];
        AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
        if (times.length !== 0) {
          destTracks.push(new trackType(trackName, times, values));
        }
      }
    };
    const tracks = [];
    const clipName = animation.name || "default";
    const fps = animation.fps || 30;
    const blendMode = animation.blendMode;
    let duration = animation.length || -1;
    const hierarchyTracks = animation.hierarchy || [];
    for (let h2 = 0; h2 < hierarchyTracks.length; h2++) {
      const animationKeys = hierarchyTracks[h2].keys;
      if (!animationKeys || animationKeys.length === 0)
        continue;
      if (animationKeys[0].morphTargets) {
        const morphTargetNames = {};
        let k2;
        for (k2 = 0; k2 < animationKeys.length; k2++) {
          if (animationKeys[k2].morphTargets) {
            for (let m2 = 0; m2 < animationKeys[k2].morphTargets.length; m2++) {
              morphTargetNames[animationKeys[k2].morphTargets[m2]] = -1;
            }
          }
        }
        for (const morphTargetName in morphTargetNames) {
          const times = [];
          const values = [];
          for (let m2 = 0; m2 !== animationKeys[k2].morphTargets.length; ++m2) {
            const animationKey = animationKeys[k2];
            times.push(animationKey.time);
            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
          }
          tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
        }
        duration = morphTargetNames.length * (fps || 1);
      } else {
        const boneName = ".bones[" + bones[h2].name + "]";
        addNonemptyTrack(VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks);
        addNonemptyTrack(QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks);
        addNonemptyTrack(VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks);
      }
    }
    if (tracks.length === 0) {
      return null;
    }
    const clip = new this(clipName, duration, tracks, blendMode);
    return clip;
  }
  resetDuration() {
    const tracks = this.tracks;
    let duration = 0;
    for (let i2 = 0, n2 = tracks.length; i2 !== n2; ++i2) {
      const track = this.tracks[i2];
      duration = Math.max(duration, track.times[track.times.length - 1]);
    }
    this.duration = duration;
    return this;
  }
  trim() {
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      this.tracks[i2].trim(0, this.duration);
    }
    return this;
  }
  validate() {
    let valid = true;
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      valid = valid && this.tracks[i2].validate();
    }
    return valid;
  }
  optimize() {
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      this.tracks[i2].optimize();
    }
    return this;
  }
  clone() {
    const tracks = [];
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      tracks.push(this.tracks[i2].clone());
    }
    return new this.constructor(this.name, this.duration, tracks, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function getTrackTypeForValueTypeName(typeName) {
  switch (typeName.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return VectorKeyframeTrack;
    case "color":
      return ColorKeyframeTrack;
    case "quaternion":
      return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
      return BooleanKeyframeTrack;
    case "string":
      return StringKeyframeTrack;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
}
function parseKeyframeTrack(json) {
  if (json.type === void 0) {
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  }
  const trackType = getTrackTypeForValueTypeName(json.type);
  if (json.times === void 0) {
    const times = [], values = [];
    AnimationUtils.flattenJSON(json.keys, times, values, "value");
    json.times = times;
    json.values = values;
  }
  if (trackType.parse !== void 0) {
    return trackType.parse(json);
  } else {
    return new trackType(json.name, json.times, json.values, json.interpolation);
  }
}
const Cache = {
  enabled: false,
  files: {},
  add: function(key, file) {
    if (this.enabled === false)
      return;
    this.files[key] = file;
  },
  get: function(key) {
    if (this.enabled === false)
      return;
    return this.files[key];
  },
  remove: function(key) {
    delete this.files[key];
  },
  clear: function() {
    this.files = {};
  }
};
class LoadingManager {
  constructor(onLoad, onProgress, onError) {
    const scope = this;
    let isLoading = false;
    let itemsLoaded = 0;
    let itemsTotal = 0;
    let urlModifier = void 0;
    const handlers = [];
    this.onStart = void 0;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;
    this.itemStart = function(url) {
      itemsTotal++;
      if (isLoading === false) {
        if (scope.onStart !== void 0) {
          scope.onStart(url, itemsLoaded, itemsTotal);
        }
      }
      isLoading = true;
    };
    this.itemEnd = function(url) {
      itemsLoaded++;
      if (scope.onProgress !== void 0) {
        scope.onProgress(url, itemsLoaded, itemsTotal);
      }
      if (itemsLoaded === itemsTotal) {
        isLoading = false;
        if (scope.onLoad !== void 0) {
          scope.onLoad();
        }
      }
    };
    this.itemError = function(url) {
      if (scope.onError !== void 0) {
        scope.onError(url);
      }
    };
    this.resolveURL = function(url) {
      if (urlModifier) {
        return urlModifier(url);
      }
      return url;
    };
    this.setURLModifier = function(transform) {
      urlModifier = transform;
      return this;
    };
    this.addHandler = function(regex, loader) {
      handlers.push(regex, loader);
      return this;
    };
    this.removeHandler = function(regex) {
      const index = handlers.indexOf(regex);
      if (index !== -1) {
        handlers.splice(index, 2);
      }
      return this;
    };
    this.getHandler = function(file) {
      for (let i2 = 0, l2 = handlers.length; i2 < l2; i2 += 2) {
        const regex = handlers[i2];
        const loader = handlers[i2 + 1];
        if (regex.global)
          regex.lastIndex = 0;
        if (regex.test(file)) {
          return loader;
        }
      }
      return null;
    };
  }
}
const DefaultLoadingManager = new LoadingManager();
class Loader {
  constructor(manager) {
    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
    this.crossOrigin = "anonymous";
    this.withCredentials = false;
    this.path = "";
    this.resourcePath = "";
    this.requestHeader = {};
  }
  load() {
  }
  loadAsync(url, onProgress) {
    const scope = this;
    return new Promise(function(resolve2, reject) {
      scope.load(url, resolve2, onProgress, reject);
    });
  }
  parse() {
  }
  setCrossOrigin(crossOrigin) {
    this.crossOrigin = crossOrigin;
    return this;
  }
  setWithCredentials(value) {
    this.withCredentials = value;
    return this;
  }
  setPath(path2) {
    this.path = path2;
    return this;
  }
  setResourcePath(resourcePath) {
    this.resourcePath = resourcePath;
    return this;
  }
  setRequestHeader(requestHeader) {
    this.requestHeader = requestHeader;
    return this;
  }
}
const loading = {};
class FileLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (url === void 0)
      url = "";
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const cached = Cache.get(url);
    if (cached !== void 0) {
      this.manager.itemStart(url);
      setTimeout(() => {
        if (onLoad)
          onLoad(cached);
        this.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    if (loading[url] !== void 0) {
      loading[url].push({
        onLoad,
        onProgress,
        onError
      });
      return;
    }
    loading[url] = [];
    loading[url].push({
      onLoad,
      onProgress,
      onError
    });
    const req = new Request(url, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin"
    });
    fetch(req).then((response) => {
      if (response.status === 200 || response.status === 0) {
        if (response.status === 0) {
          console.warn("THREE.FileLoader: HTTP Status 0 received.");
        }
        const callbacks = loading[url];
        const reader = response.body.getReader();
        const contentLength = response.headers.get("Content-Length");
        const total = contentLength ? parseInt(contentLength) : 0;
        const lengthComputable = total !== 0;
        let loaded = 0;
        return new ReadableStream({
          start(controller) {
            readData();
            function readData() {
              reader.read().then(({ done, value }) => {
                if (done) {
                  controller.close();
                } else {
                  loaded += value.byteLength;
                  const event = new ProgressEvent("progress", { lengthComputable, loaded, total });
                  for (let i2 = 0, il2 = callbacks.length; i2 < il2; i2++) {
                    const callback = callbacks[i2];
                    if (callback.onProgress)
                      callback.onProgress(event);
                  }
                  controller.enqueue(value);
                  readData();
                }
              });
            }
          }
        });
      } else {
        throw Error(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`);
      }
    }).then((stream) => {
      const response = new Response(stream);
      switch (this.responseType) {
        case "arraybuffer":
          return response.arrayBuffer();
        case "blob":
          return response.blob();
        case "document":
          return response.text().then((text) => {
            const parser = new DOMParser();
            return parser.parseFromString(text, this.mimeType);
          });
        case "json":
          return response.json();
        default:
          return response.text();
      }
    }).then((data) => {
      Cache.add(url, data);
      const callbacks = loading[url];
      delete loading[url];
      for (let i2 = 0, il2 = callbacks.length; i2 < il2; i2++) {
        const callback = callbacks[i2];
        if (callback.onLoad)
          callback.onLoad(data);
      }
      this.manager.itemEnd(url);
    }).catch((err) => {
      const callbacks = loading[url];
      delete loading[url];
      for (let i2 = 0, il2 = callbacks.length; i2 < il2; i2++) {
        const callback = callbacks[i2];
        if (callback.onError)
          callback.onError(err);
      }
      this.manager.itemError(url);
      this.manager.itemEnd(url);
    });
    this.manager.itemStart(url);
  }
  setResponseType(value) {
    this.responseType = value;
    return this;
  }
  setMimeType(value) {
    this.mimeType = value;
    return this;
  }
}
class ImageLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad)
          onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const image = createElementNS("img");
    function onImageLoad() {
      removeEventListeners();
      Cache.add(url, this);
      if (onLoad)
        onLoad(this);
      scope.manager.itemEnd(url);
    }
    function onImageError(event) {
      removeEventListeners();
      if (onError)
        onError(event);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    }
    function removeEventListeners() {
      image.removeEventListener("load", onImageLoad, false);
      image.removeEventListener("error", onImageError, false);
    }
    image.addEventListener("load", onImageLoad, false);
    image.addEventListener("error", onImageError, false);
    if (url.substr(0, 5) !== "data:") {
      if (this.crossOrigin !== void 0)
        image.crossOrigin = this.crossOrigin;
    }
    scope.manager.itemStart(url);
    image.src = url;
    return image;
  }
}
class CubeTextureLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(urls, onLoad, onProgress, onError) {
    const texture = new CubeTexture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    let loaded = 0;
    function loadTexture(i2) {
      loader.load(urls[i2], function(image) {
        texture.images[i2] = image;
        loaded++;
        if (loaded === 6) {
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture);
        }
      }, void 0, onError);
    }
    for (let i2 = 0; i2 < urls.length; ++i2) {
      loadTexture(i2);
    }
    return texture;
  }
}
class DataTextureLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const texture = new DataTexture();
    const loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setPath(this.path);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(buffer) {
      const texData = scope.parse(buffer);
      if (!texData)
        return;
      if (texData.image !== void 0) {
        texture.image = texData.image;
      } else if (texData.data !== void 0) {
        texture.image.width = texData.width;
        texture.image.height = texData.height;
        texture.image.data = texData.data;
      }
      texture.wrapS = texData.wrapS !== void 0 ? texData.wrapS : ClampToEdgeWrapping;
      texture.wrapT = texData.wrapT !== void 0 ? texData.wrapT : ClampToEdgeWrapping;
      texture.magFilter = texData.magFilter !== void 0 ? texData.magFilter : LinearFilter;
      texture.minFilter = texData.minFilter !== void 0 ? texData.minFilter : LinearFilter;
      texture.anisotropy = texData.anisotropy !== void 0 ? texData.anisotropy : 1;
      if (texData.encoding !== void 0) {
        texture.encoding = texData.encoding;
      }
      if (texData.flipY !== void 0) {
        texture.flipY = texData.flipY;
      }
      if (texData.format !== void 0) {
        texture.format = texData.format;
      }
      if (texData.type !== void 0) {
        texture.type = texData.type;
      }
      if (texData.mipmaps !== void 0) {
        texture.mipmaps = texData.mipmaps;
        texture.minFilter = LinearMipmapLinearFilter;
      }
      if (texData.mipmapCount === 1) {
        texture.minFilter = LinearFilter;
      }
      if (texData.generateMipmaps !== void 0) {
        texture.generateMipmaps = texData.generateMipmaps;
      }
      texture.needsUpdate = true;
      if (onLoad)
        onLoad(texture, texData);
    }, onProgress, onError);
    return texture;
  }
}
class TextureLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const texture = new Texture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    loader.load(url, function(image) {
      texture.image = image;
      texture.needsUpdate = true;
      if (onLoad !== void 0) {
        onLoad(texture);
      }
    }, onProgress, onError);
    return texture;
  }
}
class Light extends Object3D {
  constructor(color2, intensity = 1) {
    super();
    this.type = "Light";
    this.color = new Color(color2);
    this.intensity = intensity;
  }
  dispose() {
  }
  copy(source3) {
    super.copy(source3);
    this.color.copy(source3.color);
    this.intensity = source3.intensity;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    if (this.groundColor !== void 0)
      data.object.groundColor = this.groundColor.getHex();
    if (this.distance !== void 0)
      data.object.distance = this.distance;
    if (this.angle !== void 0)
      data.object.angle = this.angle;
    if (this.decay !== void 0)
      data.object.decay = this.decay;
    if (this.penumbra !== void 0)
      data.object.penumbra = this.penumbra;
    if (this.shadow !== void 0)
      data.object.shadow = this.shadow.toJSON();
    return data;
  }
}
Light.prototype.isLight = true;
class HemisphereLight extends Light {
  constructor(skyColor, groundColor, intensity) {
    super(skyColor, intensity);
    this.type = "HemisphereLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.groundColor = new Color(groundColor);
  }
  copy(source3) {
    Light.prototype.copy.call(this, source3);
    this.groundColor.copy(source3.groundColor);
    return this;
  }
}
HemisphereLight.prototype.isHemisphereLight = true;
const _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();
const _lightPositionWorld$1 = /* @__PURE__ */ new Vector3();
const _lookTarget$1 = /* @__PURE__ */ new Vector3();
class LightShadow {
  constructor(camera) {
    this.camera = camera;
    this.bias = 0;
    this.normalBias = 0;
    this.radius = 1;
    this.blurSamples = 8;
    this.mapSize = new Vector2(512, 512);
    this.map = null;
    this.mapPass = null;
    this.matrix = new Matrix4();
    this.autoUpdate = true;
    this.needsUpdate = false;
    this._frustum = new Frustum();
    this._frameExtents = new Vector2(1, 1);
    this._viewportCount = 1;
    this._viewports = [
      new Vector4(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(light) {
    const shadowCamera = this.camera;
    const shadowMatrix = this.matrix;
    _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
    shadowCamera.position.copy(_lightPositionWorld$1);
    _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
    shadowCamera.lookAt(_lookTarget$1);
    shadowCamera.updateMatrixWorld();
    _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
    shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
    shadowMatrix.multiply(shadowCamera.projectionMatrix);
    shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
  }
  getViewport(viewportIndex) {
    return this._viewports[viewportIndex];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    if (this.map) {
      this.map.dispose();
    }
    if (this.mapPass) {
      this.mapPass.dispose();
    }
  }
  copy(source3) {
    this.camera = source3.camera.clone();
    this.bias = source3.bias;
    this.radius = source3.radius;
    this.mapSize.copy(source3.mapSize);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const object = {};
    if (this.bias !== 0)
      object.bias = this.bias;
    if (this.normalBias !== 0)
      object.normalBias = this.normalBias;
    if (this.radius !== 1)
      object.radius = this.radius;
    if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
      object.mapSize = this.mapSize.toArray();
    object.camera = this.camera.toJSON(false).object;
    delete object.camera.matrix;
    return object;
  }
}
class SpotLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(50, 1, 0.5, 500));
    this.focus = 1;
  }
  updateMatrices(light) {
    const camera = this.camera;
    const fov2 = RAD2DEG * 2 * light.angle * this.focus;
    const aspect2 = this.mapSize.width / this.mapSize.height;
    const far = light.distance || camera.far;
    if (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) {
      camera.fov = fov2;
      camera.aspect = aspect2;
      camera.far = far;
      camera.updateProjectionMatrix();
    }
    super.updateMatrices(light);
  }
  copy(source3) {
    super.copy(source3);
    this.focus = source3.focus;
    return this;
  }
}
SpotLightShadow.prototype.isSpotLightShadow = true;
class SpotLight extends Light {
  constructor(color2, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1) {
    super(color2, intensity);
    this.type = "SpotLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.distance = distance;
    this.angle = angle;
    this.penumbra = penumbra;
    this.decay = decay;
    this.shadow = new SpotLightShadow();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(power) {
    this.intensity = power / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source3) {
    super.copy(source3);
    this.distance = source3.distance;
    this.angle = source3.angle;
    this.penumbra = source3.penumbra;
    this.decay = source3.decay;
    this.target = source3.target.clone();
    this.shadow = source3.shadow.clone();
    return this;
  }
}
SpotLight.prototype.isSpotLight = true;
const _projScreenMatrix = /* @__PURE__ */ new Matrix4();
const _lightPositionWorld = /* @__PURE__ */ new Vector3();
const _lookTarget = /* @__PURE__ */ new Vector3();
class PointLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(90, 1, 0.5, 500));
    this._frameExtents = new Vector2(4, 2);
    this._viewportCount = 6;
    this._viewports = [
      new Vector4(2, 1, 1, 1),
      new Vector4(0, 1, 1, 1),
      new Vector4(3, 1, 1, 1),
      new Vector4(1, 1, 1, 1),
      new Vector4(3, 0, 1, 1),
      new Vector4(1, 0, 1, 1)
    ];
    this._cubeDirections = [
      new Vector3(1, 0, 0),
      new Vector3(-1, 0, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1),
      new Vector3(0, 1, 0),
      new Vector3(0, -1, 0)
    ];
    this._cubeUps = [
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1)
    ];
  }
  updateMatrices(light, viewportIndex = 0) {
    const camera = this.camera;
    const shadowMatrix = this.matrix;
    const far = light.distance || camera.far;
    if (far !== camera.far) {
      camera.far = far;
      camera.updateProjectionMatrix();
    }
    _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
    camera.position.copy(_lightPositionWorld);
    _lookTarget.copy(camera.position);
    _lookTarget.add(this._cubeDirections[viewportIndex]);
    camera.up.copy(this._cubeUps[viewportIndex]);
    camera.lookAt(_lookTarget);
    camera.updateMatrixWorld();
    shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix);
  }
}
PointLightShadow.prototype.isPointLightShadow = true;
class PointLight extends Light {
  constructor(color2, intensity, distance = 0, decay = 1) {
    super(color2, intensity);
    this.type = "PointLight";
    this.distance = distance;
    this.decay = decay;
    this.shadow = new PointLightShadow();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(power) {
    this.intensity = power / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source3) {
    super.copy(source3);
    this.distance = source3.distance;
    this.decay = source3.decay;
    this.shadow = source3.shadow.clone();
    return this;
  }
}
PointLight.prototype.isPointLight = true;
class DirectionalLightShadow extends LightShadow {
  constructor() {
    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
  }
}
DirectionalLightShadow.prototype.isDirectionalLightShadow = true;
class DirectionalLight extends Light {
  constructor(color2, intensity) {
    super(color2, intensity);
    this.type = "DirectionalLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.shadow = new DirectionalLightShadow();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source3) {
    super.copy(source3);
    this.target = source3.target.clone();
    this.shadow = source3.shadow.clone();
    return this;
  }
}
DirectionalLight.prototype.isDirectionalLight = true;
class AmbientLight extends Light {
  constructor(color2, intensity) {
    super(color2, intensity);
    this.type = "AmbientLight";
  }
}
AmbientLight.prototype.isAmbientLight = true;
class RectAreaLight extends Light {
  constructor(color2, intensity, width = 10, height = 10) {
    super(color2, intensity);
    this.type = "RectAreaLight";
    this.width = width;
    this.height = height;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(power) {
    this.intensity = power / (this.width * this.height * Math.PI);
  }
  copy(source3) {
    super.copy(source3);
    this.width = source3.width;
    this.height = source3.height;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.width = this.width;
    data.object.height = this.height;
    return data;
  }
}
RectAreaLight.prototype.isRectAreaLight = true;
class SphericalHarmonics3 {
  constructor() {
    this.coefficients = [];
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients.push(new Vector3());
    }
  }
  set(coefficients) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].copy(coefficients[i2]);
    }
    return this;
  }
  zero() {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].set(0, 0, 0);
    }
    return this;
  }
  getAt(normal, target) {
    const x2 = normal.x, y2 = normal.y, z2 = normal.z;
    const coeff = this.coefficients;
    target.copy(coeff[0]).multiplyScalar(0.282095);
    target.addScaledVector(coeff[1], 0.488603 * y2);
    target.addScaledVector(coeff[2], 0.488603 * z2);
    target.addScaledVector(coeff[3], 0.488603 * x2);
    target.addScaledVector(coeff[4], 1.092548 * (x2 * y2));
    target.addScaledVector(coeff[5], 1.092548 * (y2 * z2));
    target.addScaledVector(coeff[6], 0.315392 * (3 * z2 * z2 - 1));
    target.addScaledVector(coeff[7], 1.092548 * (x2 * z2));
    target.addScaledVector(coeff[8], 0.546274 * (x2 * x2 - y2 * y2));
    return target;
  }
  getIrradianceAt(normal, target) {
    const x2 = normal.x, y2 = normal.y, z2 = normal.z;
    const coeff = this.coefficients;
    target.copy(coeff[0]).multiplyScalar(0.886227);
    target.addScaledVector(coeff[1], 2 * 0.511664 * y2);
    target.addScaledVector(coeff[2], 2 * 0.511664 * z2);
    target.addScaledVector(coeff[3], 2 * 0.511664 * x2);
    target.addScaledVector(coeff[4], 2 * 0.429043 * x2 * y2);
    target.addScaledVector(coeff[5], 2 * 0.429043 * y2 * z2);
    target.addScaledVector(coeff[6], 0.743125 * z2 * z2 - 0.247708);
    target.addScaledVector(coeff[7], 2 * 0.429043 * x2 * z2);
    target.addScaledVector(coeff[8], 0.429043 * (x2 * x2 - y2 * y2));
    return target;
  }
  add(sh2) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].add(sh2.coefficients[i2]);
    }
    return this;
  }
  addScaledSH(sh2, s2) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].addScaledVector(sh2.coefficients[i2], s2);
    }
    return this;
  }
  scale(s2) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].multiplyScalar(s2);
    }
    return this;
  }
  lerp(sh2, alpha) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].lerp(sh2.coefficients[i2], alpha);
    }
    return this;
  }
  equals(sh2) {
    for (let i2 = 0; i2 < 9; i2++) {
      if (!this.coefficients[i2].equals(sh2.coefficients[i2])) {
        return false;
      }
    }
    return true;
  }
  copy(sh2) {
    return this.set(sh2.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(array, offset2 = 0) {
    const coefficients = this.coefficients;
    for (let i2 = 0; i2 < 9; i2++) {
      coefficients[i2].fromArray(array, offset2 + i2 * 3);
    }
    return this;
  }
  toArray(array = [], offset2 = 0) {
    const coefficients = this.coefficients;
    for (let i2 = 0; i2 < 9; i2++) {
      coefficients[i2].toArray(array, offset2 + i2 * 3);
    }
    return array;
  }
  static getBasisAt(normal, shBasis) {
    const x2 = normal.x, y2 = normal.y, z2 = normal.z;
    shBasis[0] = 0.282095;
    shBasis[1] = 0.488603 * y2;
    shBasis[2] = 0.488603 * z2;
    shBasis[3] = 0.488603 * x2;
    shBasis[4] = 1.092548 * x2 * y2;
    shBasis[5] = 1.092548 * y2 * z2;
    shBasis[6] = 0.315392 * (3 * z2 * z2 - 1);
    shBasis[7] = 1.092548 * x2 * z2;
    shBasis[8] = 0.546274 * (x2 * x2 - y2 * y2);
  }
}
SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;
class LightProbe extends Light {
  constructor(sh2 = new SphericalHarmonics3(), intensity = 1) {
    super(void 0, intensity);
    this.sh = sh2;
  }
  copy(source3) {
    super.copy(source3);
    this.sh.copy(source3.sh);
    return this;
  }
  fromJSON(json) {
    this.intensity = json.intensity;
    this.sh.fromArray(json.sh);
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.sh = this.sh.toArray();
    return data;
  }
}
LightProbe.prototype.isLightProbe = true;
class LoaderUtils {
  static decodeText(array) {
    if (typeof TextDecoder !== "undefined") {
      return new TextDecoder().decode(array);
    }
    let s2 = "";
    for (let i2 = 0, il2 = array.length; i2 < il2; i2++) {
      s2 += String.fromCharCode(array[i2]);
    }
    try {
      return decodeURIComponent(escape(s2));
    } catch (e20) {
      return s2;
    }
  }
  static extractUrlBase(url) {
    const index = url.lastIndexOf("/");
    if (index === -1)
      return "./";
    return url.substr(0, index + 1);
  }
  static resolveURL(url, path2) {
    if (typeof url !== "string" || url === "")
      return "";
    if (/^https?:\/\//i.test(path2) && /^\//.test(url)) {
      path2 = path2.replace(/(^https?:\/\/[^\/]+).*/i, "$1");
    }
    if (/^(https?:)?\/\//i.test(url))
      return url;
    if (/^data:.*,.*$/i.test(url))
      return url;
    if (/^blob:.*$/i.test(url))
      return url;
    return path2 + url;
  }
}
class InstancedBufferGeometry extends BufferGeometry {
  constructor() {
    super();
    this.type = "InstancedBufferGeometry";
    this.instanceCount = Infinity;
  }
  copy(source3) {
    super.copy(source3);
    this.instanceCount = source3.instanceCount;
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const data = super.toJSON(this);
    data.instanceCount = this.instanceCount;
    data.isInstancedBufferGeometry = true;
    return data;
  }
}
InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;
class ImageBitmapLoader extends Loader {
  constructor(manager) {
    super(manager);
    if (typeof createImageBitmap === "undefined") {
      console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
    }
    if (typeof fetch === "undefined") {
      console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
    }
    this.options = { premultiplyAlpha: "none" };
  }
  setOptions(options) {
    this.options = options;
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    if (url === void 0)
      url = "";
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad)
          onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const fetchOptions = {};
    fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
    fetchOptions.headers = this.requestHeader;
    fetch(url, fetchOptions).then(function(res) {
      return res.blob();
    }).then(function(blob) {
      return createImageBitmap(blob, Object.assign(scope.options, { colorSpaceConversion: "none" }));
    }).then(function(imageBitmap) {
      Cache.add(url, imageBitmap);
      if (onLoad)
        onLoad(imageBitmap);
      scope.manager.itemEnd(url);
    }).catch(function(e20) {
      if (onError)
        onError(e20);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    });
    scope.manager.itemStart(url);
  }
}
ImageBitmapLoader.prototype.isImageBitmapLoader = true;
let _context;
const AudioContext = {
  getContext: function() {
    if (_context === void 0) {
      _context = new (window.AudioContext || window.webkitAudioContext)();
    }
    return _context;
  },
  setContext: function(value) {
    _context = value;
  }
};
class AudioLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(buffer) {
      try {
        const bufferCopy = buffer.slice(0);
        const context = AudioContext.getContext();
        context.decodeAudioData(bufferCopy, function(audioBuffer) {
          onLoad(audioBuffer);
        });
      } catch (e20) {
        if (onError) {
          onError(e20);
        } else {
          console.error(e20);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
}
class HemisphereLightProbe extends LightProbe {
  constructor(skyColor, groundColor, intensity = 1) {
    super(void 0, intensity);
    const color1 = new Color().set(skyColor);
    const color2 = new Color().set(groundColor);
    const sky = new Vector3(color1.r, color1.g, color1.b);
    const ground = new Vector3(color2.r, color2.g, color2.b);
    const c0 = Math.sqrt(Math.PI);
    const c1 = c0 * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
    this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
  }
}
HemisphereLightProbe.prototype.isHemisphereLightProbe = true;
class AmbientLightProbe extends LightProbe {
  constructor(color2, intensity = 1) {
    super(void 0, intensity);
    const color1 = new Color().set(color2);
    this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
  }
}
AmbientLightProbe.prototype.isAmbientLightProbe = true;
class Audio extends Object3D {
  constructor(listener) {
    super();
    this.type = "Audio";
    this.listener = listener;
    this.context = listener.context;
    this.gain = this.context.createGain();
    this.gain.connect(listener.getInput());
    this.autoplay = false;
    this.buffer = null;
    this.detune = 0;
    this.loop = false;
    this.loopStart = 0;
    this.loopEnd = 0;
    this.offset = 0;
    this.duration = void 0;
    this.playbackRate = 1;
    this.isPlaying = false;
    this.hasPlaybackControl = true;
    this.source = null;
    this.sourceType = "empty";
    this._startedAt = 0;
    this._progress = 0;
    this._connected = false;
    this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(audioNode) {
    this.hasPlaybackControl = false;
    this.sourceType = "audioNode";
    this.source = audioNode;
    this.connect();
    return this;
  }
  setMediaElementSource(mediaElement) {
    this.hasPlaybackControl = false;
    this.sourceType = "mediaNode";
    this.source = this.context.createMediaElementSource(mediaElement);
    this.connect();
    return this;
  }
  setMediaStreamSource(mediaStream) {
    this.hasPlaybackControl = false;
    this.sourceType = "mediaStreamNode";
    this.source = this.context.createMediaStreamSource(mediaStream);
    this.connect();
    return this;
  }
  setBuffer(audioBuffer) {
    this.buffer = audioBuffer;
    this.sourceType = "buffer";
    if (this.autoplay)
      this.play();
    return this;
  }
  play(delay = 0) {
    if (this.isPlaying === true) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + delay;
    const source3 = this.context.createBufferSource();
    source3.buffer = this.buffer;
    source3.loop = this.loop;
    source3.loopStart = this.loopStart;
    source3.loopEnd = this.loopEnd;
    source3.onended = this.onEnded.bind(this);
    source3.start(this._startedAt, this._progress + this.offset, this.duration);
    this.isPlaying = true;
    this.source = source3;
    this.setDetune(this.detune);
    this.setPlaybackRate(this.playbackRate);
    return this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    if (this.isPlaying === true) {
      this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
      if (this.loop === true) {
        this._progress = this._progress % (this.duration || this.buffer.duration);
      }
      this.source.stop();
      this.source.onended = null;
      this.isPlaying = false;
    }
    return this;
  }
  stop() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._progress = 0;
    this.source.stop();
    this.source.onended = null;
    this.isPlaying = false;
    return this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let i2 = 1, l2 = this.filters.length; i2 < l2; i2++) {
        this.filters[i2 - 1].connect(this.filters[i2]);
      }
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else {
      this.source.connect(this.getOutput());
    }
    this._connected = true;
    return this;
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let i2 = 1, l2 = this.filters.length; i2 < l2; i2++) {
        this.filters[i2 - 1].disconnect(this.filters[i2]);
      }
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else {
      this.source.disconnect(this.getOutput());
    }
    this._connected = false;
    return this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(value) {
    if (!value)
      value = [];
    if (this._connected === true) {
      this.disconnect();
      this.filters = value.slice();
      this.connect();
    } else {
      this.filters = value.slice();
    }
    return this;
  }
  setDetune(value) {
    this.detune = value;
    if (this.source.detune === void 0)
      return;
    if (this.isPlaying === true) {
      this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
    }
    return this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(filter2) {
    return this.setFilters(filter2 ? [filter2] : []);
  }
  setPlaybackRate(value) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.playbackRate = value;
    if (this.isPlaying === true) {
      this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
    }
    return this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = false;
  }
  getLoop() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return false;
    }
    return this.loop;
  }
  setLoop(value) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.loop = value;
    if (this.isPlaying === true) {
      this.source.loop = this.loop;
    }
    return this;
  }
  setLoopStart(value) {
    this.loopStart = value;
    return this;
  }
  setLoopEnd(value) {
    this.loopEnd = value;
    return this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  }
}
class PropertyMixer {
  constructor(binding, typeName, valueSize) {
    this.binding = binding;
    this.valueSize = valueSize;
    let mixFunction, mixFunctionAdditive, setIdentity;
    switch (typeName) {
      case "quaternion":
        mixFunction = this._slerp;
        mixFunctionAdditive = this._slerpAdditive;
        setIdentity = this._setAdditiveIdentityQuaternion;
        this.buffer = new Float64Array(valueSize * 6);
        this._workIndex = 5;
        break;
      case "string":
      case "bool":
        mixFunction = this._select;
        mixFunctionAdditive = this._select;
        setIdentity = this._setAdditiveIdentityOther;
        this.buffer = new Array(valueSize * 5);
        break;
      default:
        mixFunction = this._lerp;
        mixFunctionAdditive = this._lerpAdditive;
        setIdentity = this._setAdditiveIdentityNumeric;
        this.buffer = new Float64Array(valueSize * 5);
    }
    this._mixBufferRegion = mixFunction;
    this._mixBufferRegionAdditive = mixFunctionAdditive;
    this._setIdentity = setIdentity;
    this._origIndex = 3;
    this._addIndex = 4;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    this.useCount = 0;
    this.referenceCount = 0;
  }
  accumulate(accuIndex, weight) {
    const buffer = this.buffer, stride = this.valueSize, offset2 = accuIndex * stride + stride;
    let currentWeight = this.cumulativeWeight;
    if (currentWeight === 0) {
      for (let i2 = 0; i2 !== stride; ++i2) {
        buffer[offset2 + i2] = buffer[i2];
      }
      currentWeight = weight;
    } else {
      currentWeight += weight;
      const mix = weight / currentWeight;
      this._mixBufferRegion(buffer, offset2, 0, mix, stride);
    }
    this.cumulativeWeight = currentWeight;
  }
  accumulateAdditive(weight) {
    const buffer = this.buffer, stride = this.valueSize, offset2 = stride * this._addIndex;
    if (this.cumulativeWeightAdditive === 0) {
      this._setIdentity();
    }
    this._mixBufferRegionAdditive(buffer, offset2, 0, weight, stride);
    this.cumulativeWeightAdditive += weight;
  }
  apply(accuIndex) {
    const stride = this.valueSize, buffer = this.buffer, offset2 = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    if (weight < 1) {
      const originalValueOffset = stride * this._origIndex;
      this._mixBufferRegion(buffer, offset2, originalValueOffset, 1 - weight, stride);
    }
    if (weightAdditive > 0) {
      this._mixBufferRegionAdditive(buffer, offset2, this._addIndex * stride, 1, stride);
    }
    for (let i2 = stride, e20 = stride + stride; i2 !== e20; ++i2) {
      if (buffer[i2] !== buffer[i2 + stride]) {
        binding.setValue(buffer, offset2);
        break;
      }
    }
  }
  saveOriginalState() {
    const binding = this.binding;
    const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
    binding.getValue(buffer, originalValueOffset);
    for (let i2 = stride, e20 = originalValueOffset; i2 !== e20; ++i2) {
      buffer[i2] = buffer[originalValueOffset + i2 % stride];
    }
    this._setIdentity();
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
  }
  restoreOriginalState() {
    const originalValueOffset = this.valueSize * 3;
    this.binding.setValue(this.buffer, originalValueOffset);
  }
  _setAdditiveIdentityNumeric() {
    const startIndex = this._addIndex * this.valueSize;
    const endIndex = startIndex + this.valueSize;
    for (let i2 = startIndex; i2 < endIndex; i2++) {
      this.buffer[i2] = 0;
    }
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric();
    this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const startIndex = this._origIndex * this.valueSize;
    const targetIndex = this._addIndex * this.valueSize;
    for (let i2 = 0; i2 < this.valueSize; i2++) {
      this.buffer[targetIndex + i2] = this.buffer[startIndex + i2];
    }
  }
  _select(buffer, dstOffset, srcOffset, t2, stride) {
    if (t2 >= 0.5) {
      for (let i2 = 0; i2 !== stride; ++i2) {
        buffer[dstOffset + i2] = buffer[srcOffset + i2];
      }
    }
  }
  _slerp(buffer, dstOffset, srcOffset, t2) {
    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t2);
  }
  _slerpAdditive(buffer, dstOffset, srcOffset, t2, stride) {
    const workOffset = this._workIndex * stride;
    Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t2);
  }
  _lerp(buffer, dstOffset, srcOffset, t2, stride) {
    const s2 = 1 - t2;
    for (let i2 = 0; i2 !== stride; ++i2) {
      const j2 = dstOffset + i2;
      buffer[j2] = buffer[j2] * s2 + buffer[srcOffset + i2] * t2;
    }
  }
  _lerpAdditive(buffer, dstOffset, srcOffset, t2, stride) {
    for (let i2 = 0; i2 !== stride; ++i2) {
      const j2 = dstOffset + i2;
      buffer[j2] = buffer[j2] + buffer[srcOffset + i2] * t2;
    }
  }
}
const _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
const _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
const _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
const _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
const _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
const _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
const _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$");
const _supportedObjectNames = ["material", "materials", "bones"];
class Composite {
  constructor(targetGroup, path2, optionalParsedPath) {
    const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path2);
    this._targetGroup = targetGroup;
    this._bindings = targetGroup.subscribe_(path2, parsedPath);
  }
  getValue(array, offset2) {
    this.bind();
    const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
    if (binding !== void 0)
      binding.getValue(array, offset2);
  }
  setValue(array, offset2) {
    const bindings = this._bindings;
    for (let i2 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i2 !== n2; ++i2) {
      bindings[i2].setValue(array, offset2);
    }
  }
  bind() {
    const bindings = this._bindings;
    for (let i2 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i2 !== n2; ++i2) {
      bindings[i2].bind();
    }
  }
  unbind() {
    const bindings = this._bindings;
    for (let i2 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i2 !== n2; ++i2) {
      bindings[i2].unbind();
    }
  }
}
class PropertyBinding {
  constructor(rootNode, path2, parsedPath) {
    this.path = path2;
    this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path2);
    this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
    this.rootNode = rootNode;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
  static create(root, path2, parsedPath) {
    if (!(root && root.isAnimationObjectGroup)) {
      return new PropertyBinding(root, path2, parsedPath);
    } else {
      return new PropertyBinding.Composite(root, path2, parsedPath);
    }
  }
  static sanitizeNodeName(name2) {
    return name2.replace(/\s/g, "_").replace(_reservedRe, "");
  }
  static parseTrackName(trackName) {
    const matches2 = _trackRe.exec(trackName);
    if (!matches2) {
      throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
    }
    const results = {
      nodeName: matches2[2],
      objectName: matches2[3],
      objectIndex: matches2[4],
      propertyName: matches2[5],
      propertyIndex: matches2[6]
    };
    const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
    if (lastDot !== void 0 && lastDot !== -1) {
      const objectName = results.nodeName.substring(lastDot + 1);
      if (_supportedObjectNames.indexOf(objectName) !== -1) {
        results.nodeName = results.nodeName.substring(0, lastDot);
        results.objectName = objectName;
      }
    }
    if (results.propertyName === null || results.propertyName.length === 0) {
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
    }
    return results;
  }
  static findNode(root, nodeName) {
    if (!nodeName || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
      return root;
    }
    if (root.skeleton) {
      const bone = root.skeleton.getBoneByName(nodeName);
      if (bone !== void 0) {
        return bone;
      }
    }
    if (root.children) {
      const searchNodeSubtree = function(children) {
        for (let i2 = 0; i2 < children.length; i2++) {
          const childNode = children[i2];
          if (childNode.name === nodeName || childNode.uuid === nodeName) {
            return childNode;
          }
          const result = searchNodeSubtree(childNode.children);
          if (result)
            return result;
        }
        return null;
      };
      const subTreeNode = searchNodeSubtree(root.children);
      if (subTreeNode) {
        return subTreeNode;
      }
    }
    return null;
  }
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  _getValue_direct(buffer, offset2) {
    buffer[offset2] = this.targetObject[this.propertyName];
  }
  _getValue_array(buffer, offset2) {
    const source3 = this.resolvedProperty;
    for (let i2 = 0, n2 = source3.length; i2 !== n2; ++i2) {
      buffer[offset2++] = source3[i2];
    }
  }
  _getValue_arrayElement(buffer, offset2) {
    buffer[offset2] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(buffer, offset2) {
    this.resolvedProperty.toArray(buffer, offset2);
  }
  _setValue_direct(buffer, offset2) {
    this.targetObject[this.propertyName] = buffer[offset2];
  }
  _setValue_direct_setNeedsUpdate(buffer, offset2) {
    this.targetObject[this.propertyName] = buffer[offset2];
    this.targetObject.needsUpdate = true;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset2) {
    this.targetObject[this.propertyName] = buffer[offset2];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_array(buffer, offset2) {
    const dest = this.resolvedProperty;
    for (let i2 = 0, n2 = dest.length; i2 !== n2; ++i2) {
      dest[i2] = buffer[offset2++];
    }
  }
  _setValue_array_setNeedsUpdate(buffer, offset2) {
    const dest = this.resolvedProperty;
    for (let i2 = 0, n2 = dest.length; i2 !== n2; ++i2) {
      dest[i2] = buffer[offset2++];
    }
    this.targetObject.needsUpdate = true;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset2) {
    const dest = this.resolvedProperty;
    for (let i2 = 0, n2 = dest.length; i2 !== n2; ++i2) {
      dest[i2] = buffer[offset2++];
    }
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_arrayElement(buffer, offset2) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset2];
  }
  _setValue_arrayElement_setNeedsUpdate(buffer, offset2) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset2];
    this.targetObject.needsUpdate = true;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset2) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset2];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_fromArray(buffer, offset2) {
    this.resolvedProperty.fromArray(buffer, offset2);
  }
  _setValue_fromArray_setNeedsUpdate(buffer, offset2) {
    this.resolvedProperty.fromArray(buffer, offset2);
    this.targetObject.needsUpdate = true;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset2) {
    this.resolvedProperty.fromArray(buffer, offset2);
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _getValue_unbound(targetArray, offset2) {
    this.bind();
    this.getValue(targetArray, offset2);
  }
  _setValue_unbound(sourceArray, offset2) {
    this.bind();
    this.setValue(sourceArray, offset2);
  }
  bind() {
    let targetObject = this.node;
    const parsedPath = this.parsedPath;
    const objectName = parsedPath.objectName;
    const propertyName = parsedPath.propertyName;
    let propertyIndex = parsedPath.propertyIndex;
    if (!targetObject) {
      targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
      this.node = targetObject;
    }
    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable;
    if (!targetObject) {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      return;
    }
    if (objectName) {
      let objectIndex = parsedPath.objectIndex;
      switch (objectName) {
        case "materials":
          if (!targetObject.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!targetObject.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          targetObject = targetObject.material.materials;
          break;
        case "bones":
          if (!targetObject.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          targetObject = targetObject.skeleton.bones;
          for (let i2 = 0; i2 < targetObject.length; i2++) {
            if (targetObject[i2].name === objectIndex) {
              objectIndex = i2;
              break;
            }
          }
          break;
        default:
          if (targetObject[objectName] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          targetObject = targetObject[objectName];
      }
      if (objectIndex !== void 0) {
        if (targetObject[objectIndex] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
          return;
        }
        targetObject = targetObject[objectIndex];
      }
    }
    const nodeProperty = targetObject[propertyName];
    if (nodeProperty === void 0) {
      const nodeName = parsedPath.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
      return;
    }
    let versioning = this.Versioning.None;
    this.targetObject = targetObject;
    if (targetObject.needsUpdate !== void 0) {
      versioning = this.Versioning.NeedsUpdate;
    } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
      versioning = this.Versioning.MatrixWorldNeedsUpdate;
    }
    let bindingType = this.BindingType.Direct;
    if (propertyIndex !== void 0) {
      if (propertyName === "morphTargetInfluences") {
        if (!targetObject.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (targetObject.geometry.isBufferGeometry) {
          if (!targetObject.geometry.morphAttributes) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            return;
          }
          if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
            propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
          }
        } else {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
          return;
        }
      }
      bindingType = this.BindingType.ArrayElement;
      this.resolvedProperty = nodeProperty;
      this.propertyIndex = propertyIndex;
    } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
      bindingType = this.BindingType.HasFromToArray;
      this.resolvedProperty = nodeProperty;
    } else if (Array.isArray(nodeProperty)) {
      bindingType = this.BindingType.EntireArray;
      this.resolvedProperty = nodeProperty;
    } else {
      this.propertyName = propertyName;
    }
    this.getValue = this.GetterByBindingType[bindingType];
    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
  }
  unbind() {
    this.node = null;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
}
PropertyBinding.Composite = Composite;
PropertyBinding.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
PropertyBinding.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
PropertyBinding.prototype.GetterByBindingType = [
  PropertyBinding.prototype._getValue_direct,
  PropertyBinding.prototype._getValue_array,
  PropertyBinding.prototype._getValue_arrayElement,
  PropertyBinding.prototype._getValue_toArray
];
PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
  [
    PropertyBinding.prototype._setValue_direct,
    PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
    PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    PropertyBinding.prototype._setValue_array,
    PropertyBinding.prototype._setValue_array_setNeedsUpdate,
    PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    PropertyBinding.prototype._setValue_arrayElement,
    PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
    PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    PropertyBinding.prototype._setValue_fromArray,
    PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
    PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
class AnimationAction {
  constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
    this._mixer = mixer;
    this._clip = clip;
    this._localRoot = localRoot;
    this.blendMode = blendMode;
    const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
    const interpolantSettings = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
    for (let i2 = 0; i2 !== nTracks; ++i2) {
      const interpolant = tracks[i2].createInterpolant(null);
      interpolants[i2] = interpolant;
      interpolant.settings = interpolantSettings;
    }
    this._interpolantSettings = interpolantSettings;
    this._interpolants = interpolants;
    this._propertyBindings = new Array(nTracks);
    this._cacheIndex = null;
    this._byClipCacheIndex = null;
    this._timeScaleInterpolant = null;
    this._weightInterpolant = null;
    this.loop = LoopRepeat;
    this._loopCount = -1;
    this._startTime = null;
    this.time = 0;
    this.timeScale = 1;
    this._effectiveTimeScale = 1;
    this.weight = 1;
    this._effectiveWeight = 1;
    this.repetitions = Infinity;
    this.paused = false;
    this.enabled = true;
    this.clampWhenFinished = false;
    this.zeroSlopeAtStart = true;
    this.zeroSlopeAtEnd = true;
  }
  play() {
    this._mixer._activateAction(this);
    return this;
  }
  stop() {
    this._mixer._deactivateAction(this);
    return this.reset();
  }
  reset() {
    this.paused = false;
    this.enabled = true;
    this.time = 0;
    this._loopCount = -1;
    this._startTime = null;
    return this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(time) {
    this._startTime = time;
    return this;
  }
  setLoop(mode, repetitions) {
    this.loop = mode;
    this.repetitions = repetitions;
    return this;
  }
  setEffectiveWeight(weight) {
    this.weight = weight;
    this._effectiveWeight = this.enabled ? weight : 0;
    return this.stopFading();
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(duration) {
    return this._scheduleFading(duration, 0, 1);
  }
  fadeOut(duration) {
    return this._scheduleFading(duration, 1, 0);
  }
  crossFadeFrom(fadeOutAction, duration, warp) {
    fadeOutAction.fadeOut(duration);
    this.fadeIn(duration);
    if (warp) {
      const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
      fadeOutAction.warp(1, startEndRatio, duration);
      this.warp(endStartRatio, 1, duration);
    }
    return this;
  }
  crossFadeTo(fadeInAction, duration, warp) {
    return fadeInAction.crossFadeFrom(this, duration, warp);
  }
  stopFading() {
    const weightInterpolant = this._weightInterpolant;
    if (weightInterpolant !== null) {
      this._weightInterpolant = null;
      this._mixer._takeBackControlInterpolant(weightInterpolant);
    }
    return this;
  }
  setEffectiveTimeScale(timeScale) {
    this.timeScale = timeScale;
    this._effectiveTimeScale = this.paused ? 0 : timeScale;
    return this.stopWarping();
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(duration) {
    this.timeScale = this._clip.duration / duration;
    return this.stopWarping();
  }
  syncWith(action) {
    this.time = action.time;
    this.timeScale = action.timeScale;
    return this.stopWarping();
  }
  halt(duration) {
    return this.warp(this._effectiveTimeScale, 0, duration);
  }
  warp(startTimeScale, endTimeScale, duration) {
    const mixer = this._mixer, now2 = mixer.time, timeScale = this.timeScale;
    let interpolant = this._timeScaleInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._timeScaleInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now2;
    times[1] = now2 + duration;
    values[0] = startTimeScale / timeScale;
    values[1] = endTimeScale / timeScale;
    return this;
  }
  stopWarping() {
    const timeScaleInterpolant = this._timeScaleInterpolant;
    if (timeScaleInterpolant !== null) {
      this._timeScaleInterpolant = null;
      this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
    }
    return this;
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(time, deltaTime, timeDirection, accuIndex) {
    if (!this.enabled) {
      this._updateWeight(time);
      return;
    }
    const startTime = this._startTime;
    if (startTime !== null) {
      const timeRunning = (time - startTime) * timeDirection;
      if (timeRunning < 0 || timeDirection === 0) {
        return;
      }
      this._startTime = null;
      deltaTime = timeDirection * timeRunning;
    }
    deltaTime *= this._updateTimeScale(time);
    const clipTime = this._updateTime(deltaTime);
    const weight = this._updateWeight(time);
    if (weight > 0) {
      const interpolants = this._interpolants;
      const propertyMixers = this._propertyBindings;
      switch (this.blendMode) {
        case AdditiveAnimationBlendMode:
          for (let j2 = 0, m2 = interpolants.length; j2 !== m2; ++j2) {
            interpolants[j2].evaluate(clipTime);
            propertyMixers[j2].accumulateAdditive(weight);
          }
          break;
        case NormalAnimationBlendMode:
        default:
          for (let j2 = 0, m2 = interpolants.length; j2 !== m2; ++j2) {
            interpolants[j2].evaluate(clipTime);
            propertyMixers[j2].accumulate(accuIndex, weight);
          }
      }
    }
  }
  _updateWeight(time) {
    let weight = 0;
    if (this.enabled) {
      weight = this.weight;
      const interpolant = this._weightInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        weight *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopFading();
          if (interpolantValue === 0) {
            this.enabled = false;
          }
        }
      }
    }
    this._effectiveWeight = weight;
    return weight;
  }
  _updateTimeScale(time) {
    let timeScale = 0;
    if (!this.paused) {
      timeScale = this.timeScale;
      const interpolant = this._timeScaleInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        timeScale *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopWarping();
          if (timeScale === 0) {
            this.paused = true;
          } else {
            this.timeScale = timeScale;
          }
        }
      }
    }
    this._effectiveTimeScale = timeScale;
    return timeScale;
  }
  _updateTime(deltaTime) {
    const duration = this._clip.duration;
    const loop = this.loop;
    let time = this.time + deltaTime;
    let loopCount = this._loopCount;
    const pingPong = loop === LoopPingPong;
    if (deltaTime === 0) {
      if (loopCount === -1)
        return time;
      return pingPong && (loopCount & 1) === 1 ? duration - time : time;
    }
    if (loop === LoopOnce) {
      if (loopCount === -1) {
        this._loopCount = 0;
        this._setEndings(true, true, false);
      }
      handle_stop: {
        if (time >= duration) {
          time = duration;
        } else if (time < 0) {
          time = 0;
        } else {
          this.time = time;
          break handle_stop;
        }
        if (this.clampWhenFinished)
          this.paused = true;
        else
          this.enabled = false;
        this.time = time;
        this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: deltaTime < 0 ? -1 : 1
        });
      }
    } else {
      if (loopCount === -1) {
        if (deltaTime >= 0) {
          loopCount = 0;
          this._setEndings(true, this.repetitions === 0, pingPong);
        } else {
          this._setEndings(this.repetitions === 0, true, pingPong);
        }
      }
      if (time >= duration || time < 0) {
        const loopDelta = Math.floor(time / duration);
        time -= duration * loopDelta;
        loopCount += Math.abs(loopDelta);
        const pending = this.repetitions - loopCount;
        if (pending <= 0) {
          if (this.clampWhenFinished)
            this.paused = true;
          else
            this.enabled = false;
          time = deltaTime > 0 ? duration : 0;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: deltaTime > 0 ? 1 : -1
          });
        } else {
          if (pending === 1) {
            const atStart = deltaTime < 0;
            this._setEndings(atStart, !atStart, pingPong);
          } else {
            this._setEndings(false, false, pingPong);
          }
          this._loopCount = loopCount;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta
          });
        }
      } else {
        this.time = time;
      }
      if (pingPong && (loopCount & 1) === 1) {
        return duration - time;
      }
    }
    return time;
  }
  _setEndings(atStart, atEnd, pingPong) {
    const settings = this._interpolantSettings;
    if (pingPong) {
      settings.endingStart = ZeroSlopeEnding;
      settings.endingEnd = ZeroSlopeEnding;
    } else {
      if (atStart) {
        settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingStart = WrapAroundEnding;
      }
      if (atEnd) {
        settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingEnd = WrapAroundEnding;
      }
    }
  }
  _scheduleFading(duration, weightNow, weightThen) {
    const mixer = this._mixer, now2 = mixer.time;
    let interpolant = this._weightInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._weightInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now2;
    values[0] = weightNow;
    times[1] = now2 + duration;
    values[1] = weightThen;
    return this;
  }
}
class AnimationMixer extends EventDispatcher {
  constructor(root) {
    super();
    this._root = root;
    this._initMemoryManager();
    this._accuIndex = 0;
    this.time = 0;
    this.timeScale = 1;
  }
  _bindAction(action, prototypeAction) {
    const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
    let bindingsByName = bindingsByRoot[rootUuid];
    if (bindingsByName === void 0) {
      bindingsByName = {};
      bindingsByRoot[rootUuid] = bindingsByName;
    }
    for (let i2 = 0; i2 !== nTracks; ++i2) {
      const track = tracks[i2], trackName = track.name;
      let binding = bindingsByName[trackName];
      if (binding !== void 0) {
        bindings[i2] = binding;
      } else {
        binding = bindings[i2];
        if (binding !== void 0) {
          if (binding._cacheIndex === null) {
            ++binding.referenceCount;
            this._addInactiveBinding(binding, rootUuid, trackName);
          }
          continue;
        }
        const path2 = prototypeAction && prototypeAction._propertyBindings[i2].binding.parsedPath;
        binding = new PropertyMixer(PropertyBinding.create(root, trackName, path2), track.ValueTypeName, track.getValueSize());
        ++binding.referenceCount;
        this._addInactiveBinding(binding, rootUuid, trackName);
        bindings[i2] = binding;
      }
      interpolants[i2].resultBuffer = binding.buffer;
    }
  }
  _activateAction(action) {
    if (!this._isActiveAction(action)) {
      if (action._cacheIndex === null) {
        const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
        this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
        this._addInactiveAction(action, clipUuid, rootUuid);
      }
      const bindings = action._propertyBindings;
      for (let i2 = 0, n2 = bindings.length; i2 !== n2; ++i2) {
        const binding = bindings[i2];
        if (binding.useCount++ === 0) {
          this._lendBinding(binding);
          binding.saveOriginalState();
        }
      }
      this._lendAction(action);
    }
  }
  _deactivateAction(action) {
    if (this._isActiveAction(action)) {
      const bindings = action._propertyBindings;
      for (let i2 = 0, n2 = bindings.length; i2 !== n2; ++i2) {
        const binding = bindings[i2];
        if (--binding.useCount === 0) {
          binding.restoreOriginalState();
          this._takeBackBinding(binding);
        }
      }
      this._takeBackAction(action);
    }
  }
  _initMemoryManager() {
    this._actions = [];
    this._nActiveActions = 0;
    this._actionsByClip = {};
    this._bindings = [];
    this._nActiveBindings = 0;
    this._bindingsByRootAndName = {};
    this._controlInterpolants = [];
    this._nActiveControlInterpolants = 0;
    const scope = this;
    this.stats = {
      actions: {
        get total() {
          return scope._actions.length;
        },
        get inUse() {
          return scope._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return scope._bindings.length;
        },
        get inUse() {
          return scope._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return scope._controlInterpolants.length;
        },
        get inUse() {
          return scope._nActiveControlInterpolants;
        }
      }
    };
  }
  _isActiveAction(action) {
    const index = action._cacheIndex;
    return index !== null && index < this._nActiveActions;
  }
  _addInactiveAction(action, clipUuid, rootUuid) {
    const actions = this._actions, actionsByClip = this._actionsByClip;
    let actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip === void 0) {
      actionsForClip = {
        knownActions: [action],
        actionByRoot: {}
      };
      action._byClipCacheIndex = 0;
      actionsByClip[clipUuid] = actionsForClip;
    } else {
      const knownActions = actionsForClip.knownActions;
      action._byClipCacheIndex = knownActions.length;
      knownActions.push(action);
    }
    action._cacheIndex = actions.length;
    actions.push(action);
    actionsForClip.actionByRoot[rootUuid] = action;
  }
  _removeInactiveAction(action) {
    const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
    lastInactiveAction._cacheIndex = cacheIndex;
    actions[cacheIndex] = lastInactiveAction;
    actions.pop();
    action._cacheIndex = null;
    const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
    lastKnownAction._byClipCacheIndex = byClipCacheIndex;
    knownActionsForClip[byClipCacheIndex] = lastKnownAction;
    knownActionsForClip.pop();
    action._byClipCacheIndex = null;
    const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
    delete actionByRoot[rootUuid];
    if (knownActionsForClip.length === 0) {
      delete actionsByClip[clipUuid];
    }
    this._removeInactiveBindingsForAction(action);
  }
  _removeInactiveBindingsForAction(action) {
    const bindings = action._propertyBindings;
    for (let i2 = 0, n2 = bindings.length; i2 !== n2; ++i2) {
      const binding = bindings[i2];
      if (--binding.referenceCount === 0) {
        this._removeInactiveBinding(binding);
      }
    }
  }
  _lendAction(action) {
    const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
    action._cacheIndex = lastActiveIndex;
    actions[lastActiveIndex] = action;
    firstInactiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = firstInactiveAction;
  }
  _takeBackAction(action) {
    const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
    action._cacheIndex = firstInactiveIndex;
    actions[firstInactiveIndex] = action;
    lastActiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = lastActiveAction;
  }
  _addInactiveBinding(binding, rootUuid, trackName) {
    const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
    let bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName === void 0) {
      bindingByName = {};
      bindingsByRoot[rootUuid] = bindingByName;
    }
    bindingByName[trackName] = binding;
    binding._cacheIndex = bindings.length;
    bindings.push(binding);
  }
  _removeInactiveBinding(binding) {
    const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
    lastInactiveBinding._cacheIndex = cacheIndex;
    bindings[cacheIndex] = lastInactiveBinding;
    bindings.pop();
    delete bindingByName[trackName];
    if (Object.keys(bindingByName).length === 0) {
      delete bindingsByRoot[rootUuid];
    }
  }
  _lendBinding(binding) {
    const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
    binding._cacheIndex = lastActiveIndex;
    bindings[lastActiveIndex] = binding;
    firstInactiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = firstInactiveBinding;
  }
  _takeBackBinding(binding) {
    const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
    binding._cacheIndex = firstInactiveIndex;
    bindings[firstInactiveIndex] = binding;
    lastActiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = lastActiveBinding;
  }
  _lendControlInterpolant() {
    const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
    let interpolant = interpolants[lastActiveIndex];
    if (interpolant === void 0) {
      interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
      interpolant.__cacheIndex = lastActiveIndex;
      interpolants[lastActiveIndex] = interpolant;
    }
    return interpolant;
  }
  _takeBackControlInterpolant(interpolant) {
    const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
    interpolant.__cacheIndex = firstInactiveIndex;
    interpolants[firstInactiveIndex] = interpolant;
    lastActiveInterpolant.__cacheIndex = prevIndex;
    interpolants[prevIndex] = lastActiveInterpolant;
  }
  clipAction(clip, optionalRoot, blendMode) {
    const root = optionalRoot || this._root, rootUuid = root.uuid;
    let clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip;
    const clipUuid = clipObject !== null ? clipObject.uuid : clip;
    const actionsForClip = this._actionsByClip[clipUuid];
    let prototypeAction = null;
    if (blendMode === void 0) {
      if (clipObject !== null) {
        blendMode = clipObject.blendMode;
      } else {
        blendMode = NormalAnimationBlendMode;
      }
    }
    if (actionsForClip !== void 0) {
      const existingAction = actionsForClip.actionByRoot[rootUuid];
      if (existingAction !== void 0 && existingAction.blendMode === blendMode) {
        return existingAction;
      }
      prototypeAction = actionsForClip.knownActions[0];
      if (clipObject === null)
        clipObject = prototypeAction._clip;
    }
    if (clipObject === null)
      return null;
    const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
    this._bindAction(newAction, prototypeAction);
    this._addInactiveAction(newAction, clipUuid, rootUuid);
    return newAction;
  }
  existingAction(clip, optionalRoot) {
    const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      return actionsForClip.actionByRoot[rootUuid] || null;
    }
    return null;
  }
  stopAllAction() {
    const actions = this._actions, nActions = this._nActiveActions;
    for (let i2 = nActions - 1; i2 >= 0; --i2) {
      actions[i2].stop();
    }
    return this;
  }
  update(deltaTime) {
    deltaTime *= this.timeScale;
    const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
    for (let i2 = 0; i2 !== nActions; ++i2) {
      const action = actions[i2];
      action._update(time, deltaTime, timeDirection, accuIndex);
    }
    const bindings = this._bindings, nBindings = this._nActiveBindings;
    for (let i2 = 0; i2 !== nBindings; ++i2) {
      bindings[i2].apply(accuIndex);
    }
    return this;
  }
  setTime(timeInSeconds) {
    this.time = 0;
    for (let i2 = 0; i2 < this._actions.length; i2++) {
      this._actions[i2].time = 0;
    }
    return this.update(timeInSeconds);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(clip) {
    const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      const actionsToRemove = actionsForClip.knownActions;
      for (let i2 = 0, n2 = actionsToRemove.length; i2 !== n2; ++i2) {
        const action = actionsToRemove[i2];
        this._deactivateAction(action);
        const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
        action._cacheIndex = null;
        action._byClipCacheIndex = null;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        this._removeInactiveBindingsForAction(action);
      }
      delete actionsByClip[clipUuid];
    }
  }
  uncacheRoot(root) {
    const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
    for (const clipUuid in actionsByClip) {
      const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
      if (action !== void 0) {
        this._deactivateAction(action);
        this._removeInactiveAction(action);
      }
    }
    const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName !== void 0) {
      for (const trackName in bindingByName) {
        const binding = bindingByName[trackName];
        binding.restoreOriginalState();
        this._removeInactiveBinding(binding);
      }
    }
  }
  uncacheAction(clip, optionalRoot) {
    const action = this.existingAction(clip, optionalRoot);
    if (action !== null) {
      this._deactivateAction(action);
      this._removeInactiveAction(action);
    }
  }
}
AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
class Uniform {
  constructor(value) {
    if (typeof value === "string") {
      console.warn("THREE.Uniform: Type parameter is no longer needed.");
      value = arguments[1];
    }
    this.value = value;
  }
  clone() {
    return new Uniform(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}
class InstancedInterleavedBuffer extends InterleavedBuffer {
  constructor(array, stride, meshPerAttribute = 1) {
    super(array, stride);
    this.meshPerAttribute = meshPerAttribute;
  }
  copy(source3) {
    super.copy(source3);
    this.meshPerAttribute = source3.meshPerAttribute;
    return this;
  }
  clone(data) {
    const ib2 = super.clone(data);
    ib2.meshPerAttribute = this.meshPerAttribute;
    return ib2;
  }
  toJSON(data) {
    const json = super.toJSON(data);
    json.isInstancedInterleavedBuffer = true;
    json.meshPerAttribute = this.meshPerAttribute;
    return json;
  }
}
InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;
const _vector$2 = /* @__PURE__ */ new Vector3();
const _boneMatrix = /* @__PURE__ */ new Matrix4();
const _matrixWorldInv = /* @__PURE__ */ new Matrix4();
class SkeletonHelper extends LineSegments {
  constructor(object) {
    const bones = getBoneList(object);
    const geometry2 = new BufferGeometry();
    const vertices = [];
    const colors = [];
    const color1 = new Color(0, 0, 1);
    const color2 = new Color(0, 1, 0);
    for (let i2 = 0; i2 < bones.length; i2++) {
      const bone = bones[i2];
      if (bone.parent && bone.parent.isBone) {
        vertices.push(0, 0, 0);
        vertices.push(0, 0, 0);
        colors.push(color1.r, color1.g, color1.b);
        colors.push(color2.r, color2.g, color2.b);
      }
    }
    geometry2.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry2.setAttribute("color", new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true });
    super(geometry2, material);
    this.type = "SkeletonHelper";
    this.isSkeletonHelper = true;
    this.root = object;
    this.bones = bones;
    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;
  }
  updateMatrixWorld(force) {
    const bones = this.bones;
    const geometry2 = this.geometry;
    const position = geometry2.getAttribute("position");
    _matrixWorldInv.copy(this.root.matrixWorld).invert();
    for (let i2 = 0, j2 = 0; i2 < bones.length; i2++) {
      const bone = bones[i2];
      if (bone.parent && bone.parent.isBone) {
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
        _vector$2.setFromMatrixPosition(_boneMatrix);
        position.setXYZ(j2, _vector$2.x, _vector$2.y, _vector$2.z);
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
        _vector$2.setFromMatrixPosition(_boneMatrix);
        position.setXYZ(j2 + 1, _vector$2.x, _vector$2.y, _vector$2.z);
        j2 += 2;
      }
    }
    geometry2.getAttribute("position").needsUpdate = true;
    super.updateMatrixWorld(force);
  }
}
function getBoneList(object) {
  const boneList = [];
  if (object && object.isBone) {
    boneList.push(object);
  }
  for (let i2 = 0; i2 < object.children.length; i2++) {
    boneList.push.apply(boneList, getBoneList(object.children[i2]));
  }
  return boneList;
}
class GridHelper extends LineSegments {
  constructor(size = 10, divisions = 10, color1 = 4473924, color2 = 8947848) {
    color1 = new Color(color1);
    color2 = new Color(color2);
    const center = divisions / 2;
    const step = size / divisions;
    const halfSize = size / 2;
    const vertices = [], colors = [];
    for (let i2 = 0, j2 = 0, k2 = -halfSize; i2 <= divisions; i2++, k2 += step) {
      vertices.push(-halfSize, 0, k2, halfSize, 0, k2);
      vertices.push(k2, 0, -halfSize, k2, 0, halfSize);
      const color3 = i2 === center ? color1 : color2;
      color3.toArray(colors, j2);
      j2 += 3;
      color3.toArray(colors, j2);
      j2 += 3;
      color3.toArray(colors, j2);
      j2 += 3;
      color3.toArray(colors, j2);
      j2 += 3;
    }
    const geometry2 = new BufferGeometry();
    geometry2.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry2.setAttribute("color", new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
    super(geometry2, material);
    this.type = "GridHelper";
  }
}
const _vector = /* @__PURE__ */ new Vector3();
const _camera = /* @__PURE__ */ new Camera();
class CameraHelper extends LineSegments {
  constructor(camera) {
    const geometry2 = new BufferGeometry();
    const material = new LineBasicMaterial({ color: 16777215, vertexColors: true, toneMapped: false });
    const vertices = [];
    const colors = [];
    const pointMap = {};
    const colorFrustum = new Color(16755200);
    const colorCone = new Color(16711680);
    const colorUp = new Color(43775);
    const colorTarget = new Color(16777215);
    const colorCross = new Color(3355443);
    addLine("n1", "n2", colorFrustum);
    addLine("n2", "n4", colorFrustum);
    addLine("n4", "n3", colorFrustum);
    addLine("n3", "n1", colorFrustum);
    addLine("f1", "f2", colorFrustum);
    addLine("f2", "f4", colorFrustum);
    addLine("f4", "f3", colorFrustum);
    addLine("f3", "f1", colorFrustum);
    addLine("n1", "f1", colorFrustum);
    addLine("n2", "f2", colorFrustum);
    addLine("n3", "f3", colorFrustum);
    addLine("n4", "f4", colorFrustum);
    addLine("p", "n1", colorCone);
    addLine("p", "n2", colorCone);
    addLine("p", "n3", colorCone);
    addLine("p", "n4", colorCone);
    addLine("u1", "u2", colorUp);
    addLine("u2", "u3", colorUp);
    addLine("u3", "u1", colorUp);
    addLine("c", "t", colorTarget);
    addLine("p", "c", colorCross);
    addLine("cn1", "cn2", colorCross);
    addLine("cn3", "cn4", colorCross);
    addLine("cf1", "cf2", colorCross);
    addLine("cf3", "cf4", colorCross);
    function addLine(a2, b2, color2) {
      addPoint(a2, color2);
      addPoint(b2, color2);
    }
    function addPoint(id2, color2) {
      vertices.push(0, 0, 0);
      colors.push(color2.r, color2.g, color2.b);
      if (pointMap[id2] === void 0) {
        pointMap[id2] = [];
      }
      pointMap[id2].push(vertices.length / 3 - 1);
    }
    geometry2.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry2.setAttribute("color", new Float32BufferAttribute(colors, 3));
    super(geometry2, material);
    this.type = "CameraHelper";
    this.camera = camera;
    if (this.camera.updateProjectionMatrix)
      this.camera.updateProjectionMatrix();
    this.matrix = camera.matrixWorld;
    this.matrixAutoUpdate = false;
    this.pointMap = pointMap;
    this.update();
  }
  update() {
    const geometry2 = this.geometry;
    const pointMap = this.pointMap;
    const w2 = 1, h2 = 1;
    _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
    setPoint("c", pointMap, geometry2, _camera, 0, 0, -1);
    setPoint("t", pointMap, geometry2, _camera, 0, 0, 1);
    setPoint("n1", pointMap, geometry2, _camera, -w2, -h2, -1);
    setPoint("n2", pointMap, geometry2, _camera, w2, -h2, -1);
    setPoint("n3", pointMap, geometry2, _camera, -w2, h2, -1);
    setPoint("n4", pointMap, geometry2, _camera, w2, h2, -1);
    setPoint("f1", pointMap, geometry2, _camera, -w2, -h2, 1);
    setPoint("f2", pointMap, geometry2, _camera, w2, -h2, 1);
    setPoint("f3", pointMap, geometry2, _camera, -w2, h2, 1);
    setPoint("f4", pointMap, geometry2, _camera, w2, h2, 1);
    setPoint("u1", pointMap, geometry2, _camera, w2 * 0.7, h2 * 1.1, -1);
    setPoint("u2", pointMap, geometry2, _camera, -w2 * 0.7, h2 * 1.1, -1);
    setPoint("u3", pointMap, geometry2, _camera, 0, h2 * 2, -1);
    setPoint("cf1", pointMap, geometry2, _camera, -w2, 0, 1);
    setPoint("cf2", pointMap, geometry2, _camera, w2, 0, 1);
    setPoint("cf3", pointMap, geometry2, _camera, 0, -h2, 1);
    setPoint("cf4", pointMap, geometry2, _camera, 0, h2, 1);
    setPoint("cn1", pointMap, geometry2, _camera, -w2, 0, -1);
    setPoint("cn2", pointMap, geometry2, _camera, w2, 0, -1);
    setPoint("cn3", pointMap, geometry2, _camera, 0, -h2, -1);
    setPoint("cn4", pointMap, geometry2, _camera, 0, h2, -1);
    geometry2.getAttribute("position").needsUpdate = true;
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
}
function setPoint(point, pointMap, geometry2, camera, x2, y2, z2) {
  _vector.set(x2, y2, z2).unproject(camera);
  const points = pointMap[point];
  if (points !== void 0) {
    const position = geometry2.getAttribute("position");
    for (let i2 = 0, l2 = points.length; i2 < l2; i2++) {
      position.setXYZ(points[i2], _vector.x, _vector.y, _vector.z);
    }
  }
}
const _floatView = new Float32Array(1);
const _int32View = new Int32Array(_floatView.buffer);
class DataUtils {
  static toHalfFloat(val) {
    if (val > 65504) {
      console.warn("THREE.DataUtils.toHalfFloat(): value exceeds 65504.");
      val = 65504;
    }
    _floatView[0] = val;
    const x2 = _int32View[0];
    let bits = x2 >> 16 & 32768;
    let m2 = x2 >> 12 & 2047;
    const e20 = x2 >> 23 & 255;
    if (e20 < 103)
      return bits;
    if (e20 > 142) {
      bits |= 31744;
      bits |= (e20 == 255 ? 0 : 1) && x2 & 8388607;
      return bits;
    }
    if (e20 < 113) {
      m2 |= 2048;
      bits |= (m2 >> 114 - e20) + (m2 >> 113 - e20 & 1);
      return bits;
    }
    bits |= e20 - 112 << 10 | m2 >> 1;
    bits += m2 & 1;
    return bits;
  }
}
Curve.create = function(construct, getPoint) {
  console.log("THREE.Curve.create() has been deprecated");
  construct.prototype = Object.create(Curve.prototype);
  construct.prototype.constructor = construct;
  construct.prototype.getPoint = getPoint;
  return construct;
};
Path.prototype.fromPoints = function(points) {
  console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
  return this.setFromPoints(points);
};
GridHelper.prototype.setColors = function() {
  console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
};
SkeletonHelper.prototype.update = function() {
  console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
};
Loader.prototype.extractUrlBase = function(url) {
  console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
  return LoaderUtils.extractUrlBase(url);
};
Loader.Handlers = {
  add: function() {
    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
  },
  get: function() {
    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
  }
};
Box3.prototype.center = function(optionalTarget) {
  console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
  return this.getCenter(optionalTarget);
};
Box3.prototype.empty = function() {
  console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
  return this.isEmpty();
};
Box3.prototype.isIntersectionBox = function(box) {
  console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
  return this.intersectsBox(box);
};
Box3.prototype.isIntersectionSphere = function(sphere) {
  console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
  return this.intersectsSphere(sphere);
};
Box3.prototype.size = function(optionalTarget) {
  console.warn("THREE.Box3: .size() has been renamed to .getSize().");
  return this.getSize(optionalTarget);
};
Sphere.prototype.empty = function() {
  console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty().");
  return this.isEmpty();
};
Frustum.prototype.setFromMatrix = function(m2) {
  console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().");
  return this.setFromProjectionMatrix(m2);
};
Matrix3.prototype.flattenToArrayOffset = function(array, offset2) {
  console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
  return this.toArray(array, offset2);
};
Matrix3.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
  return vector.applyMatrix3(this);
};
Matrix3.prototype.multiplyVector3Array = function() {
  console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
};
Matrix3.prototype.applyToBufferAttribute = function(attribute) {
  console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.");
  return attribute.applyMatrix3(this);
};
Matrix3.prototype.applyToVector3Array = function() {
  console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
};
Matrix3.prototype.getInverse = function(matrix) {
  console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
  return this.copy(matrix).invert();
};
Matrix4.prototype.extractPosition = function(m2) {
  console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
  return this.copyPosition(m2);
};
Matrix4.prototype.flattenToArrayOffset = function(array, offset2) {
  console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
  return this.toArray(array, offset2);
};
Matrix4.prototype.getPosition = function() {
  console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
  return new Vector3().setFromMatrixColumn(this, 3);
};
Matrix4.prototype.setRotationFromQuaternion = function(q2) {
  console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
  return this.makeRotationFromQuaternion(q2);
};
Matrix4.prototype.multiplyToArray = function() {
  console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
};
Matrix4.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix4.prototype.multiplyVector4 = function(vector) {
  console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix4.prototype.multiplyVector3Array = function() {
  console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
};
Matrix4.prototype.rotateAxis = function(v2) {
  console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
  v2.transformDirection(this);
};
Matrix4.prototype.crossVector = function(vector) {
  console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix4.prototype.translate = function() {
  console.error("THREE.Matrix4: .translate() has been removed.");
};
Matrix4.prototype.rotateX = function() {
  console.error("THREE.Matrix4: .rotateX() has been removed.");
};
Matrix4.prototype.rotateY = function() {
  console.error("THREE.Matrix4: .rotateY() has been removed.");
};
Matrix4.prototype.rotateZ = function() {
  console.error("THREE.Matrix4: .rotateZ() has been removed.");
};
Matrix4.prototype.rotateByAxis = function() {
  console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
};
Matrix4.prototype.applyToBufferAttribute = function(attribute) {
  console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.");
  return attribute.applyMatrix4(this);
};
Matrix4.prototype.applyToVector3Array = function() {
  console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
};
Matrix4.prototype.makeFrustum = function(left2, right, bottom, top, near, far) {
  console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
  return this.makePerspective(left2, right, top, bottom, near, far);
};
Matrix4.prototype.getInverse = function(matrix) {
  console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
  return this.copy(matrix).invert();
};
Plane.prototype.isIntersectionLine = function(line) {
  console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
  return this.intersectsLine(line);
};
Quaternion.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
  return vector.applyQuaternion(this);
};
Quaternion.prototype.inverse = function() {
  console.warn("THREE.Quaternion: .inverse() has been renamed to invert().");
  return this.invert();
};
Ray.prototype.isIntersectionBox = function(box) {
  console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
  return this.intersectsBox(box);
};
Ray.prototype.isIntersectionPlane = function(plane) {
  console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
  return this.intersectsPlane(plane);
};
Ray.prototype.isIntersectionSphere = function(sphere) {
  console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
  return this.intersectsSphere(sphere);
};
Triangle.prototype.area = function() {
  console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
  return this.getArea();
};
Triangle.prototype.barycoordFromPoint = function(point, target) {
  console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
  return this.getBarycoord(point, target);
};
Triangle.prototype.midpoint = function(target) {
  console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
  return this.getMidpoint(target);
};
Triangle.prototypenormal = function(target) {
  console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
  return this.getNormal(target);
};
Triangle.prototype.plane = function(target) {
  console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
  return this.getPlane(target);
};
Triangle.barycoordFromPoint = function(point, a2, b2, c2, target) {
  console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
  return Triangle.getBarycoord(point, a2, b2, c2, target);
};
Triangle.normal = function(a2, b2, c2, target) {
  console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
  return Triangle.getNormal(a2, b2, c2, target);
};
Shape.prototype.extractAllPoints = function(divisions) {
  console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
  return this.extractPoints(divisions);
};
Shape.prototype.extrude = function(options) {
  console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
  return new ExtrudeGeometry(this, options);
};
Shape.prototype.makeGeometry = function(options) {
  console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
  return new ShapeGeometry(this, options);
};
Vector2.prototype.fromAttribute = function(attribute, index, offset2) {
  console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index, offset2);
};
Vector2.prototype.distanceToManhattan = function(v2) {
  console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
  return this.manhattanDistanceTo(v2);
};
Vector2.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Vector3.prototype.setEulerFromRotationMatrix = function() {
  console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
};
Vector3.prototype.setEulerFromQuaternion = function() {
  console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
};
Vector3.prototype.getPositionFromMatrix = function(m2) {
  console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
  return this.setFromMatrixPosition(m2);
};
Vector3.prototype.getScaleFromMatrix = function(m2) {
  console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
  return this.setFromMatrixScale(m2);
};
Vector3.prototype.getColumnFromMatrix = function(index, matrix) {
  console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
  return this.setFromMatrixColumn(matrix, index);
};
Vector3.prototype.applyProjection = function(m2) {
  console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
  return this.applyMatrix4(m2);
};
Vector3.prototype.fromAttribute = function(attribute, index, offset2) {
  console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index, offset2);
};
Vector3.prototype.distanceToManhattan = function(v2) {
  console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
  return this.manhattanDistanceTo(v2);
};
Vector3.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Vector4.prototype.fromAttribute = function(attribute, index, offset2) {
  console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index, offset2);
};
Vector4.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Object3D.prototype.getChildByName = function(name2) {
  console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
  return this.getObjectByName(name2);
};
Object3D.prototype.renderDepth = function() {
  console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
};
Object3D.prototype.translate = function(distance, axis) {
  console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
  return this.translateOnAxis(axis, distance);
};
Object3D.prototype.getWorldRotation = function() {
  console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
};
Object3D.prototype.applyMatrix = function(matrix) {
  console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().");
  return this.applyMatrix4(matrix);
};
Object.defineProperties(Object3D.prototype, {
  eulerOrder: {
    get: function() {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
      return this.rotation.order;
    },
    set: function(value) {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
      this.rotation.order = value;
    }
  },
  useQuaternion: {
    get: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    },
    set: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    }
  }
});
Mesh.prototype.setDrawMode = function() {
  console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
};
Object.defineProperties(Mesh.prototype, {
  drawMode: {
    get: function() {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.");
      return TrianglesDrawMode;
    },
    set: function() {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
    }
  }
});
SkinnedMesh.prototype.initBones = function() {
  console.error("THREE.SkinnedMesh: initBones() has been removed.");
};
PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
  console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
  if (filmGauge !== void 0)
    this.filmGauge = filmGauge;
  this.setFocalLength(focalLength);
};
Object.defineProperties(Light.prototype, {
  onlyShadow: {
    set: function() {
      console.warn("THREE.Light: .onlyShadow has been removed.");
    }
  },
  shadowCameraFov: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
      this.shadow.camera.fov = value;
    }
  },
  shadowCameraLeft: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
      this.shadow.camera.left = value;
    }
  },
  shadowCameraRight: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
      this.shadow.camera.right = value;
    }
  },
  shadowCameraTop: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
      this.shadow.camera.top = value;
    }
  },
  shadowCameraBottom: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
      this.shadow.camera.bottom = value;
    }
  },
  shadowCameraNear: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
      this.shadow.camera.near = value;
    }
  },
  shadowCameraFar: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
      this.shadow.camera.far = value;
    }
  },
  shadowCameraVisible: {
    set: function() {
      console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
    }
  },
  shadowBias: {
    set: function(value) {
      console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
      this.shadow.bias = value;
    }
  },
  shadowDarkness: {
    set: function() {
      console.warn("THREE.Light: .shadowDarkness has been removed.");
    }
  },
  shadowMapWidth: {
    set: function(value) {
      console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
      this.shadow.mapSize.width = value;
    }
  },
  shadowMapHeight: {
    set: function(value) {
      console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
      this.shadow.mapSize.height = value;
    }
  }
});
Object.defineProperties(BufferAttribute.prototype, {
  length: {
    get: function() {
      console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
      return this.array.length;
    }
  },
  dynamic: {
    get: function() {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
      return this.usage === DynamicDrawUsage;
    },
    set: function() {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
      this.setUsage(DynamicDrawUsage);
    }
  }
});
BufferAttribute.prototype.setDynamic = function(value) {
  console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.");
  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
  return this;
};
BufferAttribute.prototype.copyIndicesArray = function() {
  console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
}, BufferAttribute.prototype.setArray = function() {
  console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
};
BufferGeometry.prototype.addIndex = function(index) {
  console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
  this.setIndex(index);
};
BufferGeometry.prototype.addAttribute = function(name2, attribute) {
  console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().");
  if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
    console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
    return this.setAttribute(name2, new BufferAttribute(arguments[1], arguments[2]));
  }
  if (name2 === "index") {
    console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
    this.setIndex(attribute);
    return this;
  }
  return this.setAttribute(name2, attribute);
};
BufferGeometry.prototype.addDrawCall = function(start, count, indexOffset) {
  if (indexOffset !== void 0) {
    console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
  }
  console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
  this.addGroup(start, count);
};
BufferGeometry.prototype.clearDrawCalls = function() {
  console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
  this.clearGroups();
};
BufferGeometry.prototype.computeOffsets = function() {
  console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
};
BufferGeometry.prototype.removeAttribute = function(name2) {
  console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().");
  return this.deleteAttribute(name2);
};
BufferGeometry.prototype.applyMatrix = function(matrix) {
  console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().");
  return this.applyMatrix4(matrix);
};
Object.defineProperties(BufferGeometry.prototype, {
  drawcalls: {
    get: function() {
      console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
      return this.groups;
    }
  },
  offsets: {
    get: function() {
      console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
      return this.groups;
    }
  }
});
InterleavedBuffer.prototype.setDynamic = function(value) {
  console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.");
  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
  return this;
};
InterleavedBuffer.prototype.setArray = function() {
  console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
};
ExtrudeGeometry.prototype.getArrays = function() {
  console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
};
ExtrudeGeometry.prototype.addShapeList = function() {
  console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
};
ExtrudeGeometry.prototype.addShape = function() {
  console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
};
Scene.prototype.dispose = function() {
  console.error("THREE.Scene: .dispose() has been removed.");
};
Uniform.prototype.onUpdate = function() {
  console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
  return this;
};
Object.defineProperties(Material.prototype, {
  wrapAround: {
    get: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    }
  },
  overdraw: {
    get: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    }
  },
  wrapRGB: {
    get: function() {
      console.warn("THREE.Material: .wrapRGB has been removed.");
      return new Color();
    }
  },
  shading: {
    get: function() {
      console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
    },
    set: function(value) {
      console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
      this.flatShading = value === FlatShading;
    }
  },
  stencilMask: {
    get: function() {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
      return this.stencilFuncMask;
    },
    set: function(value) {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
      this.stencilFuncMask = value;
    }
  },
  vertexTangents: {
    get: function() {
      console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
    },
    set: function() {
      console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
    }
  }
});
Object.defineProperties(ShaderMaterial.prototype, {
  derivatives: {
    get: function() {
      console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
      return this.extensions.derivatives;
    },
    set: function(value) {
      console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
      this.extensions.derivatives = value;
    }
  }
});
WebGLRenderer.prototype.clearTarget = function(renderTarget, color2, depth, stencil) {
  console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
  this.setRenderTarget(renderTarget);
  this.clear(color2, depth, stencil);
};
WebGLRenderer.prototype.animate = function(callback) {
  console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
  this.setAnimationLoop(callback);
};
WebGLRenderer.prototype.getCurrentRenderTarget = function() {
  console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
  return this.getRenderTarget();
};
WebGLRenderer.prototype.getMaxAnisotropy = function() {
  console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
  return this.capabilities.getMaxAnisotropy();
};
WebGLRenderer.prototype.getPrecision = function() {
  console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
  return this.capabilities.precision;
};
WebGLRenderer.prototype.resetGLState = function() {
  console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
  return this.state.reset();
};
WebGLRenderer.prototype.supportsFloatTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
  return this.extensions.get("OES_texture_float");
};
WebGLRenderer.prototype.supportsHalfFloatTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
  return this.extensions.get("OES_texture_half_float");
};
WebGLRenderer.prototype.supportsStandardDerivatives = function() {
  console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
  return this.extensions.get("OES_standard_derivatives");
};
WebGLRenderer.prototype.supportsCompressedTextureS3TC = function() {
  console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
  return this.extensions.get("WEBGL_compressed_texture_s3tc");
};
WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function() {
  console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
  return this.extensions.get("WEBGL_compressed_texture_pvrtc");
};
WebGLRenderer.prototype.supportsBlendMinMax = function() {
  console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
  return this.extensions.get("EXT_blend_minmax");
};
WebGLRenderer.prototype.supportsVertexTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
  return this.capabilities.vertexTextures;
};
WebGLRenderer.prototype.supportsInstancedArrays = function() {
  console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
  return this.extensions.get("ANGLE_instanced_arrays");
};
WebGLRenderer.prototype.enableScissorTest = function(boolean) {
  console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
  this.setScissorTest(boolean);
};
WebGLRenderer.prototype.initMaterial = function() {
  console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
};
WebGLRenderer.prototype.addPrePlugin = function() {
  console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
};
WebGLRenderer.prototype.addPostPlugin = function() {
  console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
};
WebGLRenderer.prototype.updateShadowMap = function() {
  console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
};
WebGLRenderer.prototype.setFaceCulling = function() {
  console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
};
WebGLRenderer.prototype.allocTextureUnit = function() {
  console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
};
WebGLRenderer.prototype.setTexture = function() {
  console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
};
WebGLRenderer.prototype.setTexture2D = function() {
  console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
};
WebGLRenderer.prototype.setTextureCube = function() {
  console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
};
WebGLRenderer.prototype.getActiveMipMapLevel = function() {
  console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().");
  return this.getActiveMipmapLevel();
};
Object.defineProperties(WebGLRenderer.prototype, {
  shadowMapEnabled: {
    get: function() {
      return this.shadowMap.enabled;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
      this.shadowMap.enabled = value;
    }
  },
  shadowMapType: {
    get: function() {
      return this.shadowMap.type;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
      this.shadowMap.type = value;
    }
  },
  shadowMapCullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  context: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.");
      return this.getContext();
    }
  },
  vr: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr");
      return this.xr;
    }
  },
  gammaInput: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
      return false;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
    }
  },
  gammaOutput: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
      return false;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
      this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
    }
  },
  toneMappingWhitePoint: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
      return 1;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
    }
  }
});
Object.defineProperties(WebGLShadowMap.prototype, {
  cullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  renderReverseSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    }
  },
  renderSingleSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    }
  }
});
Object.defineProperties(WebGLRenderTarget.prototype, {
  wrapS: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
      return this.texture.wrapS;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
      this.texture.wrapS = value;
    }
  },
  wrapT: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
      return this.texture.wrapT;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
      this.texture.wrapT = value;
    }
  },
  magFilter: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
      return this.texture.magFilter;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
      this.texture.magFilter = value;
    }
  },
  minFilter: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
      return this.texture.minFilter;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
      this.texture.minFilter = value;
    }
  },
  anisotropy: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
      return this.texture.anisotropy;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
      this.texture.anisotropy = value;
    }
  },
  offset: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
      return this.texture.offset;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
      this.texture.offset = value;
    }
  },
  repeat: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
      return this.texture.repeat;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
      this.texture.repeat = value;
    }
  },
  format: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
      return this.texture.format;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
      this.texture.format = value;
    }
  },
  type: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
      return this.texture.type;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
      this.texture.type = value;
    }
  },
  generateMipmaps: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
      return this.texture.generateMipmaps;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
      this.texture.generateMipmaps = value;
    }
  }
});
Audio.prototype.load = function(file) {
  console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
  const scope = this;
  const audioLoader = new AudioLoader();
  audioLoader.load(file, function(buffer) {
    scope.setBuffer(buffer);
  });
  return this;
};
CubeCamera.prototype.updateCubeMap = function(renderer, scene) {
  console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
  return this.update(renderer, scene);
};
CubeCamera.prototype.clear = function(renderer, color2, depth, stencil) {
  console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear().");
  return this.renderTarget.clear(renderer, color2, depth, stencil);
};
ImageUtils.crossOrigin = void 0;
ImageUtils.loadTexture = function(url, mapping, onLoad, onError) {
  console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
  const loader = new TextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  const texture = loader.load(url, onLoad, void 0, onError);
  if (mapping)
    texture.mapping = mapping;
  return texture;
};
ImageUtils.loadTextureCube = function(urls, mapping, onLoad, onError) {
  console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
  const loader = new CubeTextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  const texture = loader.load(urls, onLoad, void 0, onError);
  if (mapping)
    texture.mapping = mapping;
  return texture;
};
ImageUtils.loadCompressedTexture = function() {
  console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
};
ImageUtils.loadCompressedTextureCube = function() {
  console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
};
if (typeof __THREE_DEVTOOLS__ !== "undefined") {
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
    revision: REVISION
  } }));
}
if (typeof window !== "undefined") {
  if (window.__THREE__) {
    console.warn("WARNING: Multiple instances of Three.js being imported.");
  } else {
    window.__THREE__ = REVISION;
  }
}
/**
* postprocessing v6.23.2 build Thu Oct 28 2021
* https://github.com/vanruesc/postprocessing
* Copyright 2021 Raoul van Rüschen
* @license Zlib
*/
var shader_default2 = "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}";
var shader_default7 = "#include <common>\n#include <dithering_pars_fragment>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;\n#include <dithering_fragment>\n}";
var shader_default8 = "uniform vec2 texelSize;uniform vec2 halfTexelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize*vec2(kernel)+halfTexelSize)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}";
var ConvolutionMaterial = class extends ShaderMaterial {
  constructor(texelSize = new Vector2()) {
    super({
      type: "ConvolutionMaterial",
      uniforms: {
        inputBuffer: new Uniform(null),
        texelSize: new Uniform(new Vector2()),
        halfTexelSize: new Uniform(new Vector2()),
        kernel: new Uniform(0),
        scale: new Uniform(1)
      },
      fragmentShader: shader_default7,
      vertexShader: shader_default8,
      blending: NoBlending,
      depthWrite: false,
      depthTest: false
    });
    this.toneMapped = false;
    this.setTexelSize(texelSize.x, texelSize.y);
    this.kernelSize = KernelSize.LARGE;
  }
  getKernel() {
    return kernelPresets[this.kernelSize];
  }
  setTexelSize(x2, y2) {
    this.uniforms.texelSize.value.set(x2, y2);
    this.uniforms.halfTexelSize.value.set(x2, y2).multiplyScalar(0.5);
  }
};
var kernelPresets = [
  new Float32Array([0, 0]),
  new Float32Array([0, 1, 1]),
  new Float32Array([0, 1, 1, 2]),
  new Float32Array([0, 1, 2, 2, 3]),
  new Float32Array([0, 1, 2, 3, 4, 4, 5]),
  new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])
];
var KernelSize = {
  VERY_SMALL: 0,
  SMALL: 1,
  MEDIUM: 2,
  LARGE: 3,
  VERY_LARGE: 4,
  HUGE: 5
};
var shader_default9 = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;\n#include <encodings_fragment>\n}";
var CopyMaterial = class extends ShaderMaterial {
  constructor() {
    super({
      type: "CopyMaterial",
      uniforms: {
        inputBuffer: new Uniform(null),
        opacity: new Uniform(1)
      },
      fragmentShader: shader_default9,
      vertexShader: shader_default2,
      blending: NoBlending,
      depthWrite: false,
      depthTest: false
    });
    this.toneMapped = false;
  }
};
var shader_default10 = "#include <packing>\n#include <clipping_planes_pars_fragment>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform float cameraNear;uniform float cameraFar;varying float vViewZ;varying vec4 vProjTexCoord;void main(){\n#include <clipping_planes_fragment>\nvec2 projTexCoord=(vProjTexCoord.xy/vProjTexCoord.w)*0.5+0.5;projTexCoord=clamp(projTexCoord,0.002,0.998);float fragCoordZ=unpackRGBAToDepth(texture2D(depthBuffer,projTexCoord));\n#ifdef PERSPECTIVE_CAMERA\nfloat viewZ=perspectiveDepthToViewZ(fragCoordZ,cameraNear,cameraFar);\n#else\nfloat viewZ=orthographicDepthToViewZ(fragCoordZ,cameraNear,cameraFar);\n#endif\nfloat depthTest=(-vViewZ>-viewZ)? 1.0 : 0.0;gl_FragColor.rg=vec2(0.0,depthTest);}";
var shader_default11 = "#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying float vViewZ;varying vec4 vProjTexCoord;void main(){\n#include <skinbase_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <project_vertex>\nvViewZ=mvPosition.z;vProjTexCoord=gl_Position;\n#include <clipping_planes_vertex>\n}";
var DepthComparisonMaterial = class extends ShaderMaterial {
  constructor(depthTexture = null, camera) {
    super({
      type: "DepthComparisonMaterial",
      uniforms: {
        depthBuffer: new Uniform(depthTexture),
        cameraNear: new Uniform(0.3),
        cameraFar: new Uniform(1e3)
      },
      fragmentShader: shader_default10,
      vertexShader: shader_default11,
      blending: NoBlending,
      depthWrite: false,
      depthTest: false
    });
    this.toneMapped = false;
    this.adoptCameraSettings(camera);
  }
  adoptCameraSettings(camera = null) {
    if (camera !== null) {
      this.uniforms.cameraNear.value = camera.near;
      this.uniforms.cameraFar.value = camera.far;
      if (camera instanceof PerspectiveCamera) {
        this.defines.PERSPECTIVE_CAMERA = "1";
      } else {
        delete this.defines.PERSPECTIVE_CAMERA;
      }
    }
  }
};
var shader_default17 = "#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}FRAGMENT_HEADvoid main(){FRAGMENT_MAIN_UVvec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGEgl_FragColor=color0;\n#ifdef ENCODE_OUTPUT\n#include <encodings_fragment>\n#endif\n#include <dithering_fragment>\n}";
var shader_default18 = "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEADvoid main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORTgl_Position=vec4(position.xy,1.0,1.0);}";
var EffectMaterial = class extends ShaderMaterial {
  constructor(shaderParts = null, defines = null, uniforms = null, camera, dithering = false) {
    super({
      type: "EffectMaterial",
      defines: {
        DEPTH_PACKING: "0",
        ENCODE_OUTPUT: "1"
      },
      uniforms: {
        inputBuffer: new Uniform(null),
        depthBuffer: new Uniform(null),
        resolution: new Uniform(new Vector2()),
        texelSize: new Uniform(new Vector2()),
        cameraNear: new Uniform(0.3),
        cameraFar: new Uniform(1e3),
        aspect: new Uniform(1),
        time: new Uniform(0)
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      dithering
    });
    this.toneMapped = false;
    if (shaderParts !== null) {
      this.setShaderParts(shaderParts);
    }
    if (defines !== null) {
      this.setDefines(defines);
    }
    if (uniforms !== null) {
      this.setUniforms(uniforms);
    }
    this.adoptCameraSettings(camera);
  }
  get depthPacking() {
    return Number(this.defines.DEPTH_PACKING);
  }
  set depthPacking(value) {
    this.defines.DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  setShaderParts(shaderParts) {
    this.fragmentShader = shader_default17.replace(Section.FRAGMENT_HEAD, shaderParts.get(Section.FRAGMENT_HEAD)).replace(Section.FRAGMENT_MAIN_UV, shaderParts.get(Section.FRAGMENT_MAIN_UV)).replace(Section.FRAGMENT_MAIN_IMAGE, shaderParts.get(Section.FRAGMENT_MAIN_IMAGE));
    this.vertexShader = shader_default18.replace(Section.VERTEX_HEAD, shaderParts.get(Section.VERTEX_HEAD)).replace(Section.VERTEX_MAIN_SUPPORT, shaderParts.get(Section.VERTEX_MAIN_SUPPORT));
    this.needsUpdate = true;
    return this;
  }
  setDefines(defines) {
    for (const entry of defines.entries()) {
      this.defines[entry[0]] = entry[1];
    }
    this.needsUpdate = true;
    return this;
  }
  setUniforms(uniforms) {
    for (const entry of uniforms.entries()) {
      this.uniforms[entry[0]] = entry[1];
    }
    return this;
  }
  adoptCameraSettings(camera = null) {
    if (camera !== null) {
      this.uniforms.cameraNear.value = camera.near;
      this.uniforms.cameraFar.value = camera.far;
      if (camera instanceof PerspectiveCamera) {
        this.defines.PERSPECTIVE_CAMERA = "1";
      } else {
        delete this.defines.PERSPECTIVE_CAMERA;
      }
      this.needsUpdate = true;
    }
  }
  setSize(width, height) {
    const w2 = Math.max(width, 1);
    const h2 = Math.max(height, 1);
    this.uniforms.resolution.value.set(w2, h2);
    this.uniforms.texelSize.value.set(1 / w2, 1 / h2);
    this.uniforms.aspect.value = w2 / h2;
  }
};
var Section = {
  FRAGMENT_HEAD: "FRAGMENT_HEAD",
  FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
  FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
  VERTEX_HEAD: "VERTEX_HEAD",
  VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT"
};
var shader_default22 = "uniform lowp sampler2D inputBuffer;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 c0=texture2D(inputBuffer,vUv0).rg;vec2 c1=texture2D(inputBuffer,vUv1).rg;vec2 c2=texture2D(inputBuffer,vUv2).rg;vec2 c3=texture2D(inputBuffer,vUv3).rg;float d0=(c0.x-c1.x)*0.5;float d1=(c2.x-c3.x)*0.5;float d=length(vec2(d0,d1));float a0=min(c0.y,c1.y);float a1=min(c2.y,c3.y);float visibilityFactor=min(a0,a1);gl_FragColor.rg=(1.0-visibilityFactor>0.001)? vec2(d,0.0): vec2(0.0,d);}";
var shader_default23 = "uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=vec2(uv.x+texelSize.x,uv.y);vUv1=vec2(uv.x-texelSize.x,uv.y);vUv2=vec2(uv.x,uv.y+texelSize.y);vUv3=vec2(uv.x,uv.y-texelSize.y);gl_Position=vec4(position.xy,1.0,1.0);}";
var OutlineMaterial = class extends ShaderMaterial {
  constructor(texelSize = new Vector2()) {
    super({
      type: "OutlineMaterial",
      uniforms: {
        inputBuffer: new Uniform(null),
        texelSize: new Uniform(new Vector2())
      },
      fragmentShader: shader_default22,
      vertexShader: shader_default23,
      blending: NoBlending,
      depthWrite: false,
      depthTest: false
    });
    this.toneMapped = false;
    this.setTexelSize(texelSize.x, texelSize.y);
    this.uniforms.maskTexture = this.uniforms.inputBuffer;
  }
  setTexelSize(x2, y2) {
    this.uniforms.texelSize.value.set(x2, y2);
  }
};
var dummyCamera = new Camera();
var geometry = null;
function getFullscreenTriangle() {
  if (geometry === null) {
    const vertices = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]);
    const uvs = new Float32Array([0, 0, 2, 0, 0, 2]);
    geometry = new BufferGeometry();
    if (geometry.setAttribute !== void 0) {
      geometry.setAttribute("position", new BufferAttribute(vertices, 3));
      geometry.setAttribute("uv", new BufferAttribute(uvs, 2));
    } else {
      geometry.addAttribute("position", new BufferAttribute(vertices, 3));
      geometry.addAttribute("uv", new BufferAttribute(uvs, 2));
    }
  }
  return geometry;
}
var Pass = class {
  constructor(name2 = "Pass", scene = new Scene(), camera = dummyCamera) {
    this.name = name2;
    this.scene = scene;
    this.camera = camera;
    this.screen = null;
    this.rtt = true;
    this.needsSwap = true;
    this.needsDepthTexture = false;
    this.enabled = true;
  }
  get renderToScreen() {
    return !this.rtt;
  }
  set renderToScreen(value) {
    if (this.rtt === value) {
      const material = this.getFullscreenMaterial();
      if (material !== null) {
        material.needsUpdate = true;
      }
      this.rtt = !value;
    }
  }
  isEnabled() {
    return this.enabled;
  }
  setEnabled(enabled) {
    this.enabled = enabled;
  }
  getFullscreenMaterial() {
    return this.screen !== null ? this.screen.material : null;
  }
  setFullscreenMaterial(material) {
    let screen = this.screen;
    if (screen !== null) {
      screen.material = material;
    } else {
      screen = new Mesh(getFullscreenTriangle(), material);
      screen.frustumCulled = false;
      if (this.scene === null) {
        this.scene = new Scene();
      }
      this.scene.add(screen);
      this.screen = screen;
    }
  }
  getDepthTexture() {
    return null;
  }
  setDepthTexture(depthTexture, depthPacking = 0) {
  }
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    throw new Error("Render method not implemented!");
  }
  setSize(width, height) {
  }
  initialize(renderer, alpha, frameBufferType) {
  }
  dispose() {
    const material = this.getFullscreenMaterial();
    if (material !== null) {
      material.dispose();
    }
    for (const key of Object.keys(this)) {
      const property2 = this[key];
      if (property2 !== null && typeof property2.dispose === "function") {
        if (property2 instanceof Scene) {
          continue;
        }
        this[key].dispose();
      }
    }
  }
};
var AUTO_SIZE = -1;
var Resizer = class {
  constructor(resizable, width = AUTO_SIZE, height = AUTO_SIZE, scale = 1) {
    this.resizable = resizable;
    this.base = new Vector2(1, 1);
    this.target = new Vector2(width, height);
    this.s = scale;
  }
  get scale() {
    return this.s;
  }
  set scale(value) {
    this.s = value;
    this.target.x = AUTO_SIZE;
    this.target.y = AUTO_SIZE;
    this.resizable.setSize(this.base.x, this.base.y);
  }
  get width() {
    const base = this.base;
    const target = this.target;
    let result;
    if (target.x !== AUTO_SIZE) {
      result = target.x;
    } else if (target.y !== AUTO_SIZE) {
      result = Math.round(target.y * (base.x / base.y));
    } else {
      result = Math.round(base.x * this.s);
    }
    return result;
  }
  set width(value) {
    this.target.x = value;
    this.resizable.setSize(this.base.x, this.base.y);
  }
  get height() {
    const base = this.base;
    const target = this.target;
    let result;
    if (target.y !== AUTO_SIZE) {
      result = target.y;
    } else if (target.x !== AUTO_SIZE) {
      result = Math.round(target.x / (base.x / base.y));
    } else {
      result = Math.round(base.y * this.s);
    }
    return result;
  }
  set height(value) {
    this.target.y = value;
    this.resizable.setSize(this.base.x, this.base.y);
  }
  static get AUTO_SIZE() {
    return AUTO_SIZE;
  }
};
var BlurPass = class extends Pass {
  constructor({
    resolutionScale = 0.5,
    width = Resizer.AUTO_SIZE,
    height = Resizer.AUTO_SIZE,
    kernelSize = KernelSize.LARGE
  } = {}) {
    super("BlurPass");
    this.renderTargetA = new WebGLRenderTarget(1, 1, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      stencilBuffer: false,
      depthBuffer: false
    });
    this.renderTargetA.texture.name = "Blur.Target.A";
    this.renderTargetB = this.renderTargetA.clone();
    this.renderTargetB.texture.name = "Blur.Target.B";
    this.resolution = new Resizer(this, width, height, resolutionScale);
    this.convolutionMaterial = new ConvolutionMaterial();
    this.ditheredConvolutionMaterial = new ConvolutionMaterial();
    this.ditheredConvolutionMaterial.dithering = true;
    this.dithering = false;
    this.kernelSize = kernelSize;
  }
  get width() {
    return this.resolution.width;
  }
  set width(value) {
    this.resolution.width = value;
  }
  get height() {
    return this.resolution.height;
  }
  set height(value) {
    this.resolution.height = value;
  }
  get scale() {
    return this.convolutionMaterial.uniforms.scale.value;
  }
  set scale(value) {
    this.convolutionMaterial.uniforms.scale.value = value;
    this.ditheredConvolutionMaterial.uniforms.scale.value = value;
  }
  get kernelSize() {
    return this.convolutionMaterial.kernelSize;
  }
  set kernelSize(value) {
    this.convolutionMaterial.kernelSize = value;
    this.ditheredConvolutionMaterial.kernelSize = value;
  }
  getResolutionScale() {
    return this.resolution.scale;
  }
  setResolutionScale(scale) {
    this.resolution.scale = scale;
  }
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const scene = this.scene;
    const camera = this.camera;
    const renderTargetA = this.renderTargetA;
    const renderTargetB = this.renderTargetB;
    let material = this.convolutionMaterial;
    let uniforms = material.uniforms;
    const kernel = material.getKernel();
    let lastRT = inputBuffer;
    let destRT;
    let i2, l2;
    this.setFullscreenMaterial(material);
    for (i2 = 0, l2 = kernel.length - 1; i2 < l2; ++i2) {
      destRT = (i2 & 1) === 0 ? renderTargetA : renderTargetB;
      uniforms.kernel.value = kernel[i2];
      uniforms.inputBuffer.value = lastRT.texture;
      renderer.setRenderTarget(destRT);
      renderer.render(scene, camera);
      lastRT = destRT;
    }
    if (this.dithering) {
      material = this.ditheredConvolutionMaterial;
      uniforms = material.uniforms;
      this.setFullscreenMaterial(material);
    }
    uniforms.kernel.value = kernel[i2];
    uniforms.inputBuffer.value = lastRT.texture;
    renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);
    renderer.render(scene, camera);
  }
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.base.set(width, height);
    const w2 = resolution.width;
    const h2 = resolution.height;
    this.renderTargetA.setSize(w2, h2);
    this.renderTargetB.setSize(w2, h2);
    this.convolutionMaterial.setTexelSize(1 / w2, 1 / h2);
    this.ditheredConvolutionMaterial.setTexelSize(1 / w2, 1 / h2);
  }
  initialize(renderer, alpha, frameBufferType) {
    if (!alpha && frameBufferType === UnsignedByteType) {
      this.renderTargetA.texture.format = RGBFormat;
      this.renderTargetB.texture.format = RGBFormat;
    }
    if (frameBufferType !== void 0) {
      this.renderTargetA.texture.type = frameBufferType;
      this.renderTargetB.texture.type = frameBufferType;
      if (frameBufferType !== UnsignedByteType) {
        const m0 = this.convolutionMaterial;
        const m1 = this.ditheredConvolutionMaterial;
        m0.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
        m1.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
      }
    }
  }
  static get AUTO_SIZE() {
    return Resizer.AUTO_SIZE;
  }
};
var ClearMaskPass = class extends Pass {
  constructor() {
    super("ClearMaskPass", null, null);
    this.needsSwap = false;
  }
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const stencil = renderer.state.buffers.stencil;
    stencil.setLocked(false);
    stencil.setTest(false);
  }
};
var color = new Color();
var ClearPass = class extends Pass {
  constructor(color2 = true, depth = true, stencil = false) {
    super("ClearPass", null, null);
    this.needsSwap = false;
    this.color = color2;
    this.depth = depth;
    this.stencil = stencil;
    this.overrideClearColor = null;
    this.overrideClearAlpha = -1;
  }
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const overrideClearColor = this.overrideClearColor;
    const overrideClearAlpha = this.overrideClearAlpha;
    const clearAlpha = renderer.getClearAlpha();
    const hasOverrideClearColor = overrideClearColor !== null;
    const hasOverrideClearAlpha = overrideClearAlpha >= 0;
    if (hasOverrideClearColor) {
      color.copy(renderer.getClearColor(color));
      renderer.setClearColor(overrideClearColor, hasOverrideClearAlpha ? overrideClearAlpha : clearAlpha);
    } else if (hasOverrideClearAlpha) {
      renderer.setClearAlpha(overrideClearAlpha);
    }
    renderer.setRenderTarget(this.renderToScreen ? null : inputBuffer);
    renderer.clear(this.color, this.depth, this.stencil);
    if (hasOverrideClearColor) {
      renderer.setClearColor(color, clearAlpha);
    } else if (hasOverrideClearAlpha) {
      renderer.setClearAlpha(clearAlpha);
    }
  }
};
var workaroundEnabled = false;
var OverrideMaterialManager = class {
  constructor(material = null) {
    this.originalMaterials = new Map();
    this.material = null;
    this.materials = null;
    this.materialsBackSide = null;
    this.materialsDoubleSide = null;
    this.materialsFlatShaded = null;
    this.materialsFlatShadedBackSide = null;
    this.materialsFlatShadedDoubleSide = null;
    this.setMaterial(material);
    this.meshCount = 0;
    this.replaceMaterial = (node) => {
      if (node.isMesh) {
        let materials;
        if (node.material.flatShading) {
          switch (node.material.side) {
            case DoubleSide:
              materials = this.materialsFlatShadedDoubleSide;
              break;
            case BackSide:
              materials = this.materialsFlatShadedBackSide;
              break;
            default:
              materials = this.materialsFlatShaded;
              break;
          }
        } else {
          switch (node.material.side) {
            case DoubleSide:
              materials = this.materialsDoubleSide;
              break;
            case BackSide:
              materials = this.materialsBackSide;
              break;
            default:
              materials = this.materials;
              break;
          }
        }
        this.originalMaterials.set(node, node.material);
        if (node.isSkinnedMesh) {
          node.material = materials[2];
        } else if (node.isInstancedMesh) {
          node.material = materials[1];
        } else {
          node.material = materials[0];
        }
        ++this.meshCount;
      }
    };
  }
  setMaterial(material) {
    this.disposeMaterials();
    this.material = material;
    if (material !== null) {
      const materials = this.materials = [
        material.clone(),
        material.clone(),
        material.clone()
      ];
      for (const m2 of materials) {
        m2.uniforms = Object.assign({}, material.uniforms);
        m2.side = FrontSide;
      }
      materials[2].skinning = true;
      this.materialsBackSide = materials.map((m2) => {
        const c2 = m2.clone();
        c2.uniforms = Object.assign({}, material.uniforms);
        c2.side = BackSide;
        return c2;
      });
      this.materialsDoubleSide = materials.map((m2) => {
        const c2 = m2.clone();
        c2.uniforms = Object.assign({}, material.uniforms);
        c2.side = DoubleSide;
        return c2;
      });
      this.materialsFlatShaded = materials.map((m2) => {
        const c2 = m2.clone();
        c2.uniforms = Object.assign({}, material.uniforms);
        c2.flatShading = true;
        return c2;
      });
      this.materialsFlatShadedBackSide = materials.map((m2) => {
        const c2 = m2.clone();
        c2.uniforms = Object.assign({}, material.uniforms);
        c2.flatShading = true;
        c2.side = BackSide;
        return c2;
      });
      this.materialsFlatShadedDoubleSide = materials.map((m2) => {
        const c2 = m2.clone();
        c2.uniforms = Object.assign({}, material.uniforms);
        c2.flatShading = true;
        c2.side = DoubleSide;
        return c2;
      });
    }
  }
  render(renderer, scene, camera) {
    const shadowMapEnabled = renderer.shadowMap.enabled;
    renderer.shadowMap.enabled = false;
    if (workaroundEnabled) {
      const originalMaterials = this.originalMaterials;
      this.meshCount = 0;
      scene.traverse(this.replaceMaterial);
      renderer.render(scene, camera);
      for (const entry of originalMaterials) {
        entry[0].material = entry[1];
      }
      if (this.meshCount !== originalMaterials.size) {
        originalMaterials.clear();
      }
    } else {
      const overrideMaterial = scene.overrideMaterial;
      scene.overrideMaterial = this.material;
      renderer.render(scene, camera);
      scene.overrideMaterial = overrideMaterial;
    }
    renderer.shadowMap.enabled = shadowMapEnabled;
  }
  disposeMaterials() {
    if (this.material !== null) {
      const materials = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);
      for (const m2 of materials) {
        m2.dispose();
      }
    }
  }
  dispose() {
    this.originalMaterials.clear();
    this.disposeMaterials();
  }
  static get workaroundEnabled() {
    return workaroundEnabled;
  }
  static set workaroundEnabled(value) {
    workaroundEnabled = value;
  }
};
var RenderPass = class extends Pass {
  constructor(scene, camera, overrideMaterial = null) {
    super("RenderPass", scene, camera);
    this.needsSwap = false;
    this.clearPass = new ClearPass();
    this.overrideMaterialManager = overrideMaterial === null ? null : new OverrideMaterialManager(overrideMaterial);
    this.backgroundDisabled = false;
    this.shadowMapDisabled = false;
    this.selection = null;
  }
  get renderToScreen() {
    return super.renderToScreen;
  }
  set renderToScreen(value) {
    super.renderToScreen = value;
    this.clearPass.renderToScreen = value;
  }
  get overrideMaterial() {
    const manager = this.overrideMaterialManager;
    return manager !== null ? manager.material : null;
  }
  set overrideMaterial(value) {
    const manager = this.overrideMaterialManager;
    if (value !== null) {
      if (manager !== null) {
        manager.setMaterial(value);
      } else {
        this.overrideMaterialManager = new OverrideMaterialManager(value);
      }
    } else if (manager !== null) {
      manager.dispose();
      this.overrideMaterialManager = null;
    }
  }
  get clear() {
    return this.clearPass.enabled;
  }
  set clear(value) {
    this.clearPass.enabled = value;
  }
  getSelection() {
    return this.selection;
  }
  setSelection(selection) {
    this.selection = selection;
  }
  isBackgroundDisabled() {
    return this.backgroundDisabled;
  }
  setBackgroundDisabled(disabled) {
    this.backgroundDisabled = disabled;
  }
  isShadowMapDisabled() {
    return this.shadowMapDisabled;
  }
  setShadowMapDisabled(disabled) {
    this.shadowMapDisabled = disabled;
  }
  getClearPass() {
    return this.clearPass;
  }
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const scene = this.scene;
    const camera = this.camera;
    const selection = this.selection;
    const mask = camera.layers.mask;
    const background = scene.background;
    const shadowMapAutoUpdate = renderer.shadowMap.autoUpdate;
    const renderTarget = this.renderToScreen ? null : inputBuffer;
    if (selection !== null) {
      camera.layers.set(selection.getLayer());
    }
    if (this.shadowMapDisabled) {
      renderer.shadowMap.autoUpdate = false;
    }
    if (this.backgroundDisabled || this.clearPass.overrideClearColor !== null) {
      scene.background = null;
    }
    if (this.clear) {
      this.clearPass.render(renderer, inputBuffer);
    }
    renderer.setRenderTarget(renderTarget);
    if (this.overrideMaterialManager !== null) {
      this.overrideMaterialManager.render(renderer, scene, camera);
    } else {
      renderer.render(scene, camera);
    }
    camera.layers.mask = mask;
    scene.background = background;
    renderer.shadowMap.autoUpdate = shadowMapAutoUpdate;
  }
};
var DepthPass = class extends Pass {
  constructor(scene, camera, {
    resolutionScale = 1,
    width = Resizer.AUTO_SIZE,
    height = Resizer.AUTO_SIZE,
    renderTarget
  } = {}) {
    super("DepthPass");
    this.needsSwap = false;
    this.renderPass = new RenderPass(scene, camera, new MeshDepthMaterial({
      depthPacking: RGBADepthPacking
    }));
    const renderPass = this.renderPass;
    renderPass.setBackgroundDisabled(true);
    renderPass.setShadowMapDisabled(true);
    const clearPass = renderPass.getClearPass();
    clearPass.overrideClearColor = new Color(16777215);
    clearPass.overrideClearAlpha = 1;
    this.renderTarget = renderTarget;
    if (this.renderTarget === void 0) {
      this.renderTarget = new WebGLRenderTarget(1, 1, {
        minFilter: NearestFilter,
        magFilter: NearestFilter,
        stencilBuffer: false
      });
      this.renderTarget.texture.name = "DepthPass.Target";
    }
    this.resolution = new Resizer(this, width, height, resolutionScale);
  }
  get texture() {
    return this.renderTarget.texture;
  }
  getResolutionScale() {
    return this.resolutionScale;
  }
  setResolutionScale(scale) {
    this.resolutionScale = scale;
    this.setSize(this.resolution.base.x, this.resolution.base.y);
  }
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const renderTarget = this.renderToScreen ? null : this.renderTarget;
    this.renderPass.render(renderer, renderTarget);
  }
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.base.set(width, height);
    this.renderTarget.setSize(resolution.width, resolution.height);
  }
};
var BlendFunction = {
  SKIP: 0,
  ADD: 1,
  ALPHA: 2,
  AVERAGE: 3,
  COLOR_BURN: 4,
  COLOR_DODGE: 5,
  DARKEN: 6,
  DIFFERENCE: 7,
  EXCLUSION: 8,
  LIGHTEN: 9,
  MULTIPLY: 10,
  DIVIDE: 11,
  NEGATION: 12,
  NORMAL: 13,
  OVERLAY: 14,
  REFLECT: 15,
  SCREEN: 16,
  SOFT_LIGHT: 17,
  SUBTRACT: 18
};
var shader_default28 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return min(x+y,1.0)*opacity+x*(1.0-opacity);}";
var shader_default29 = "vec3 blend(const in vec3 x,const in vec3 y,const in float opacity){return y*opacity+x*(1.0-opacity);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){float a=min(y.a,opacity);return vec4(blend(x.rgb,y.rgb,a),max(x.a,a));}";
var shader_default30 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(x+y)*0.5*opacity+x*(1.0-opacity);}";
var shader_default31 = "float blend(const in float x,const in float y){return(y==0.0)? y : max(1.0-(1.0-x)/y,0.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}";
var shader_default32 = "float blend(const in float x,const in float y){return(y==1.0)? y : min(x/(1.0-y),1.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}";
var shader_default33 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return min(x,y)*opacity+x*(1.0-opacity);}";
var shader_default34 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return abs(x-y)*opacity+x*(1.0-opacity);}";
var shader_default35 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(x+y-2.0*x*y)*opacity+x*(1.0-opacity);}";
var shader_default36 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return max(x,y)*opacity+x*(1.0-opacity);}";
var shader_default37 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return x*y*opacity+x*(1.0-opacity);}";
var shader_default38 = "float blend(const in float x,const in float y){return(y>0.0)? min(x/y,1.0): 1.0;}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}";
var shader_default39 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(1.0-abs(1.0-x-y))*opacity+x*(1.0-opacity);}";
var shader_default40 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y*opacity+x*(1.0-opacity);}";
var shader_default41 = "float blend(const in float x,const in float y){return(x<0.5)?(2.0*x*y):(1.0-2.0*(1.0-x)*(1.0-y));}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}";
var shader_default42 = "float blend(const in float x,const in float y){return(y==1.0)? y : min(x*x/(1.0-y),1.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}";
var shader_default43 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(1.0-(1.0-x)*(1.0-y))*opacity+x*(1.0-opacity);}";
var shader_default44 = "float blend(const in float x,const in float y){return(y<0.5)?(2.0*x*y+x*x*(1.0-2.0*y)):(sqrt(x)*(2.0*y-1.0)+2.0*x*(1.0-y));}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}";
var shader_default45 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return max(x+y-1.0,0.0)*opacity+x*(1.0-opacity);}";
var blendFunctions = new Map([
  [BlendFunction.SKIP, null],
  [BlendFunction.ADD, shader_default28],
  [BlendFunction.ALPHA, shader_default29],
  [BlendFunction.AVERAGE, shader_default30],
  [BlendFunction.COLOR_BURN, shader_default31],
  [BlendFunction.COLOR_DODGE, shader_default32],
  [BlendFunction.DARKEN, shader_default33],
  [BlendFunction.DIFFERENCE, shader_default34],
  [BlendFunction.EXCLUSION, shader_default35],
  [BlendFunction.LIGHTEN, shader_default36],
  [BlendFunction.MULTIPLY, shader_default37],
  [BlendFunction.DIVIDE, shader_default38],
  [BlendFunction.NEGATION, shader_default39],
  [BlendFunction.NORMAL, shader_default40],
  [BlendFunction.OVERLAY, shader_default41],
  [BlendFunction.REFLECT, shader_default42],
  [BlendFunction.SCREEN, shader_default43],
  [BlendFunction.SOFT_LIGHT, shader_default44],
  [BlendFunction.SUBTRACT, shader_default45]
]);
var BlendMode = class extends EventDispatcher {
  constructor(blendFunction, opacity = 1) {
    super();
    this.blendFunction = blendFunction;
    this.opacity = new Uniform(opacity);
  }
  getBlendFunction() {
    return this.blendFunction;
  }
  setBlendFunction(blendFunction) {
    this.blendFunction = blendFunction;
    this.dispatchEvent({ type: "change" });
  }
  getShaderCode() {
    return blendFunctions.get(this.blendFunction);
  }
};
var Effect = class extends EventDispatcher {
  constructor(name2, fragmentShader, {
    attributes = EffectAttribute.NONE,
    blendFunction = BlendFunction.SCREEN,
    defines = new Map(),
    uniforms = new Map(),
    extensions = null,
    vertexShader = null
  } = {}) {
    super();
    this.name = name2;
    this.attributes = attributes;
    this.fragmentShader = fragmentShader;
    this.vertexShader = vertexShader;
    this.defines = defines;
    this.uniforms = uniforms;
    this.extensions = extensions;
    this.blendMode = new BlendMode(blendFunction);
    this.blendMode.addEventListener("change", (event) => this.setChanged());
  }
  setChanged() {
    this.dispatchEvent({ type: "change" });
  }
  getAttributes() {
    return this.attributes;
  }
  setAttributes(attributes) {
    this.attributes = attributes;
    this.setChanged();
  }
  getFragmentShader() {
    return this.fragmentShader;
  }
  setFragmentShader(fragmentShader) {
    this.fragmentShader = fragmentShader;
    this.setChanged();
  }
  getVertexShader() {
    return this.vertexShader;
  }
  setVertexShader(vertexShader) {
    this.vertexShader = vertexShader;
    this.setChanged();
  }
  setDepthTexture(depthTexture, depthPacking = 0) {
  }
  update(renderer, inputBuffer, deltaTime) {
  }
  setSize(width, height) {
  }
  initialize(renderer, alpha, frameBufferType) {
  }
  dispose() {
    for (const key of Object.keys(this)) {
      const property2 = this[key];
      if (property2 !== null && typeof property2.dispose === "function") {
        if (property2 instanceof Scene) {
          continue;
        }
        this[key].dispose();
      }
    }
  }
};
var EffectAttribute = {
  NONE: 0,
  DEPTH: 1,
  CONVOLUTION: 2
};
function findSubstrings(regExp, string2) {
  const substrings = [];
  let result;
  while ((result = regExp.exec(string2)) !== null) {
    substrings.push(result[1]);
  }
  return substrings;
}
function prefixSubstrings(prefix, substrings, strings) {
  let prefixed, regExp;
  for (const substring of substrings) {
    prefixed = "$1" + prefix + substring.charAt(0).toUpperCase() + substring.slice(1);
    regExp = new RegExp("([^\\.])(\\b" + substring + "\\b)", "g");
    for (const entry of strings.entries()) {
      if (entry[1] !== null) {
        strings.set(entry[0], entry[1].replace(regExp, prefixed));
      }
    }
  }
}
function integrateEffect(prefix, effect, shaderParts, blendModes, defines, uniforms, attributes) {
  const functionRegExp = /(?:\w+\s+(\w+)\([\w\s,]*\)\s*{[^}]+})/g;
  const varyingRegExp = /(?:varying\s+\w+\s+(\w*))/g;
  const blendMode = effect.blendMode;
  const shaders = new Map([
    ["fragment", effect.getFragmentShader()],
    ["vertex", effect.getVertexShader()]
  ]);
  const mainImageExists = shaders.get("fragment") !== void 0 && /mainImage/.test(shaders.get("fragment"));
  const mainUvExists = shaders.get("fragment") !== void 0 && /mainUv/.test(shaders.get("fragment"));
  let varyings = [], names = [];
  let transformedUv = false;
  let readDepth = false;
  if (shaders.get("fragment") === void 0) {
    console.error("Missing fragment shader", effect);
  } else if (mainUvExists && (attributes & EffectAttribute.CONVOLUTION) !== 0) {
    console.error("Effects that transform UV coordinates are incompatible with convolution effects", effect);
  } else if (!mainImageExists && !mainUvExists) {
    console.error("The fragment shader contains neither a mainImage nor a mainUv function", effect);
  } else {
    if (mainUvExists) {
      shaderParts.set(Section.FRAGMENT_MAIN_UV, shaderParts.get(Section.FRAGMENT_MAIN_UV) + "	" + prefix + "MainUv(UV);\n");
      transformedUv = true;
    }
    if (shaders.get("vertex") !== null && /mainSupport/.test(shaders.get("vertex"))) {
      let string2 = "	" + prefix + "MainSupport(";
      if (/mainSupport *\([\w\s]*?uv\s*?\)/.test(shaders.get("vertex"))) {
        string2 += "vUv";
      }
      string2 += ");\n";
      shaderParts.set(Section.VERTEX_MAIN_SUPPORT, shaderParts.get(Section.VERTEX_MAIN_SUPPORT) + string2);
      varyings = varyings.concat(findSubstrings(varyingRegExp, shaders.get("vertex")));
      names = names.concat(varyings).concat(findSubstrings(functionRegExp, shaders.get("vertex")));
    }
    names = names.concat(findSubstrings(functionRegExp, shaders.get("fragment")));
    names = names.concat(Array.from(effect.defines.keys()).map((s2) => s2.replace(/\([\w\s,]*\)/g, "")));
    names = names.concat(Array.from(effect.uniforms.keys()));
    effect.uniforms.forEach((value, key) => uniforms.set(prefix + key.charAt(0).toUpperCase() + key.slice(1), value));
    effect.defines.forEach((value, key) => defines.set(prefix + key.charAt(0).toUpperCase() + key.slice(1), value));
    prefixSubstrings(prefix, names, defines);
    prefixSubstrings(prefix, names, shaders);
    blendModes.set(blendMode.blendFunction, blendMode);
    if (mainImageExists) {
      const depthParamRegExp = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;
      let string2 = prefix + "MainImage(color0, UV, ";
      if ((attributes & EffectAttribute.DEPTH) !== 0 && depthParamRegExp.test(shaders.get("fragment"))) {
        string2 += "depth, ";
        readDepth = true;
      }
      string2 += "color1);\n	";
      const blendOpacity = prefix + "BlendOpacity";
      uniforms.set(blendOpacity, blendMode.opacity);
      string2 += "color0 = blend" + blendMode.getBlendFunction() + "(color0, color1, " + blendOpacity + ");\n\n	";
      shaderParts.set(Section.FRAGMENT_MAIN_IMAGE, shaderParts.get(Section.FRAGMENT_MAIN_IMAGE) + string2);
      shaderParts.set(Section.FRAGMENT_HEAD, shaderParts.get(Section.FRAGMENT_HEAD) + "uniform float " + blendOpacity + ";\n\n");
    }
    shaderParts.set(Section.FRAGMENT_HEAD, shaderParts.get(Section.FRAGMENT_HEAD) + shaders.get("fragment") + "\n");
    if (shaders.get("vertex") !== null) {
      shaderParts.set(Section.VERTEX_HEAD, shaderParts.get(Section.VERTEX_HEAD) + shaders.get("vertex") + "\n");
    }
  }
  return { varyings, transformedUv, readDepth };
}
var EffectPass = class extends Pass {
  constructor(camera, ...effects) {
    super("EffectPass");
    this.setFullscreenMaterial(new EffectMaterial(null, null, null, camera));
    this.effects = effects.sort((a2, b2) => b2.attributes - a2.attributes);
    this.skipRendering = false;
    this.uniforms = 0;
    this.varyings = 0;
    this.minTime = 1;
    this.maxTime = Number.POSITIVE_INFINITY;
  }
  get encodeOutput() {
    return this.getFullscreenMaterial().defines.ENCODE_OUTPUT !== void 0;
  }
  set encodeOutput(value) {
    if (this.encodeOutput !== value) {
      const material = this.getFullscreenMaterial();
      material.needsUpdate = true;
      if (value) {
        material.defines.ENCODE_OUTPUT = "1";
      } else {
        delete material.defines.ENCODE_OUTPUT;
      }
    }
  }
  get dithering() {
    return this.getFullscreenMaterial().dithering;
  }
  set dithering(value) {
    const material = this.getFullscreenMaterial();
    if (material.dithering !== value) {
      material.dithering = value;
      material.needsUpdate = true;
    }
  }
  verifyResources(renderer) {
    const capabilities = renderer.capabilities;
    let max2 = Math.min(capabilities.maxFragmentUniforms, capabilities.maxVertexUniforms);
    if (this.uniforms > max2) {
      console.warn("The current rendering context doesn't support more than " + max2 + " uniforms, but " + this.uniforms + " were defined");
    }
    max2 = capabilities.maxVaryings;
    if (this.varyings > max2) {
      console.warn("The current rendering context doesn't support more than " + max2 + " varyings, but " + this.varyings + " were defined");
    }
  }
  updateMaterial() {
    const blendRegExp = /\bblend\b/g;
    const shaderParts = new Map([
      [Section.FRAGMENT_HEAD, ""],
      [Section.FRAGMENT_MAIN_UV, ""],
      [Section.FRAGMENT_MAIN_IMAGE, ""],
      [Section.VERTEX_HEAD, ""],
      [Section.VERTEX_MAIN_SUPPORT, ""]
    ]);
    const blendModes = new Map();
    const defines = new Map();
    const uniforms = new Map();
    const extensions = new Set();
    let id2 = 0, varyings = 0, attributes = 0;
    let transformedUv = false;
    let readDepth = false;
    let result;
    for (const effect of this.effects) {
      if (effect.blendMode.getBlendFunction() === BlendFunction.SKIP) {
        attributes |= effect.getAttributes() & EffectAttribute.DEPTH;
      } else if ((attributes & EffectAttribute.CONVOLUTION) !== 0 && (effect.getAttributes() & EffectAttribute.CONVOLUTION) !== 0) {
        console.error("Convolution effects cannot be merged", effect);
      } else {
        attributes |= effect.getAttributes();
        result = integrateEffect("e" + id2++, effect, shaderParts, blendModes, defines, uniforms, attributes);
        varyings += result.varyings.length;
        transformedUv = transformedUv || result.transformedUv;
        readDepth = readDepth || result.readDepth;
        if (effect.extensions !== null) {
          for (const extension of effect.extensions) {
            extensions.add(extension);
          }
        }
      }
    }
    for (const blendMode of blendModes.values()) {
      shaderParts.set(Section.FRAGMENT_HEAD, shaderParts.get(Section.FRAGMENT_HEAD) + blendMode.getShaderCode().replace(blendRegExp, "blend" + blendMode.getBlendFunction()) + "\n");
    }
    if ((attributes & EffectAttribute.DEPTH) !== 0) {
      if (readDepth) {
        shaderParts.set(Section.FRAGMENT_MAIN_IMAGE, "float depth = readDepth(UV);\n\n	" + shaderParts.get(Section.FRAGMENT_MAIN_IMAGE));
      }
      this.needsDepthTexture = this.getDepthTexture() === null;
    } else {
      this.needsDepthTexture = false;
    }
    if (transformedUv) {
      shaderParts.set(Section.FRAGMENT_MAIN_UV, "vec2 transformedUv = vUv;\n" + shaderParts.get(Section.FRAGMENT_MAIN_UV));
      defines.set("UV", "transformedUv");
    } else {
      defines.set("UV", "vUv");
    }
    shaderParts.forEach((value, key, map2) => map2.set(key, value.trim().replace(/^#/, "\n#")));
    this.uniforms = uniforms.size;
    this.varyings = varyings;
    this.skipRendering = id2 === 0;
    this.needsSwap = !this.skipRendering;
    const material = this.getFullscreenMaterial();
    material.setShaderParts(shaderParts);
    material.setDefines(defines);
    material.setUniforms(uniforms);
    material.extensions = {};
    if (extensions.size > 0) {
      for (const extension of extensions) {
        material.extensions[extension] = true;
      }
    }
    this.needsUpdate = false;
  }
  recompile(renderer) {
    this.updateMaterial();
    if (renderer !== void 0) {
      this.verifyResources(renderer);
    }
  }
  getDepthTexture() {
    return this.getFullscreenMaterial().uniforms.depthBuffer.value;
  }
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
    const material = this.getFullscreenMaterial();
    material.uniforms.depthBuffer.value = depthTexture;
    material.depthPacking = depthPacking;
    material.needsUpdate = true;
    for (const effect of this.effects) {
      effect.setDepthTexture(depthTexture, depthPacking);
    }
  }
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const material = this.getFullscreenMaterial();
    const time = material.uniforms.time.value + deltaTime;
    if (this.needsUpdate) {
      this.recompile(renderer);
    }
    for (const effect of this.effects) {
      effect.update(renderer, inputBuffer, deltaTime);
    }
    if (!this.skipRendering || this.renderToScreen) {
      material.uniforms.inputBuffer.value = inputBuffer.texture;
      material.uniforms.time.value = time <= this.maxTime ? time : this.minTime;
      renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);
      renderer.render(this.scene, this.camera);
    }
  }
  setSize(width, height) {
    this.getFullscreenMaterial().setSize(width, height);
    for (const effect of this.effects) {
      effect.setSize(width, height);
    }
  }
  initialize(renderer, alpha, frameBufferType) {
    for (const effect of this.effects) {
      effect.initialize(renderer, alpha, frameBufferType);
      effect.addEventListener("change", (event) => this.handleEvent(event));
    }
    this.updateMaterial();
    this.verifyResources(renderer);
    if (frameBufferType !== void 0 && frameBufferType !== UnsignedByteType) {
      const material = this.getFullscreenMaterial();
      material.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
    }
  }
  dispose() {
    super.dispose();
    for (const effect of this.effects) {
      effect.dispose();
    }
  }
  handleEvent(event) {
    switch (event.type) {
      case "change":
        this.needsUpdate = true;
        break;
    }
  }
};
var MaskPass = class extends Pass {
  constructor(scene, camera) {
    super("MaskPass", scene, camera);
    this.needsSwap = false;
    this.clearPass = new ClearPass(false, false, true);
    this.inverse = false;
  }
  get clear() {
    return this.clearPass.enabled;
  }
  set clear(value) {
    this.clearPass.enabled = value;
  }
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const context = renderer.getContext();
    const buffers = renderer.state.buffers;
    const scene = this.scene;
    const camera = this.camera;
    const clearPass = this.clearPass;
    const writeValue = this.inverse ? 0 : 1;
    const clearValue = 1 - writeValue;
    buffers.color.setMask(false);
    buffers.depth.setMask(false);
    buffers.color.setLocked(true);
    buffers.depth.setLocked(true);
    buffers.stencil.setTest(true);
    buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);
    buffers.stencil.setFunc(context.ALWAYS, writeValue, 4294967295);
    buffers.stencil.setClear(clearValue);
    buffers.stencil.setLocked(true);
    if (this.clear) {
      if (this.renderToScreen) {
        clearPass.render(renderer, null);
      } else {
        clearPass.render(renderer, inputBuffer);
        clearPass.render(renderer, outputBuffer);
      }
    }
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      renderer.render(scene, camera);
    } else {
      renderer.setRenderTarget(inputBuffer);
      renderer.render(scene, camera);
      renderer.setRenderTarget(outputBuffer);
      renderer.render(scene, camera);
    }
    buffers.color.setLocked(false);
    buffers.depth.setLocked(false);
    buffers.stencil.setLocked(false);
    buffers.stencil.setFunc(context.EQUAL, 1, 4294967295);
    buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);
    buffers.stencil.setLocked(true);
  }
};
var ShaderPass = class extends Pass {
  constructor(material, input = "inputBuffer") {
    super("ShaderPass");
    this.setFullscreenMaterial(material);
    this.uniform = null;
    this.setInput(input);
  }
  setInput(input) {
    const material = this.getFullscreenMaterial();
    this.uniform = null;
    if (material !== null) {
      const uniforms = material.uniforms;
      if (uniforms !== void 0 && uniforms[input] !== void 0) {
        this.uniform = uniforms[input];
      }
    }
  }
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    if (this.uniform !== null && inputBuffer !== null) {
      this.uniform.value = inputBuffer.texture;
    }
    renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);
    renderer.render(this.scene, this.camera);
  }
  initialize(renderer, alpha, frameBufferType) {
    if (frameBufferType !== void 0 && frameBufferType !== UnsignedByteType) {
      const material = this.getFullscreenMaterial();
      material.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
    }
  }
};
var MILLISECONDS_TO_SECONDS = 1 / 1e3;
var SECONDS_TO_MILLISECONDS = 1e3;
var Timer = class {
  constructor() {
    this.previousTime = 0;
    this.currentTime = 0;
    this.delta = 0;
    this.fixedDelta = 1e3 / 60;
    this.elapsed = 0;
    this.timescale = 1;
    this.fixedDeltaEnabled = false;
  }
  setFixedDeltaEnabled(enabled) {
    this.fixedDeltaEnabled = enabled;
    return this;
  }
  setAutoResetEnabled(enabled) {
    if (typeof document !== "undefined" && document.hidden !== void 0) {
      if (enabled) {
        document.addEventListener("visibilitychange", this);
      } else {
        document.removeEventListener("visibilitychange", this);
      }
    }
    return this;
  }
  getDelta() {
    return this.delta * MILLISECONDS_TO_SECONDS;
  }
  getFixedDelta() {
    return this.fixedDelta * MILLISECONDS_TO_SECONDS;
  }
  setFixedDelta(fixedDelta) {
    this.fixedDelta = fixedDelta * SECONDS_TO_MILLISECONDS;
    return this;
  }
  getElapsed() {
    return this.elapsed * MILLISECONDS_TO_SECONDS;
  }
  getTimescale() {
    return this.timescale;
  }
  setTimescale(timescale) {
    this.timescale = timescale;
    return this;
  }
  update(timestamp) {
    if (this.fixedDeltaEnabled) {
      this.delta = this.fixedDelta;
    } else {
      this.previousTime = this.currentTime;
      this.currentTime = timestamp !== void 0 ? timestamp : performance.now();
      this.delta = this.currentTime - this.previousTime;
    }
    this.delta *= this.timescale;
    this.elapsed += this.deltaTime;
    return this;
  }
  reset() {
    this.delta = 0;
    this.elapsed = 0;
    this.currentTime = performance.now();
    return this;
  }
  handleEvent(event) {
    if (!document.hidden) {
      this.currentTime = performance.now();
    }
  }
  dispose() {
    if (typeof document !== "undefined") {
      document.removeEventListener("visibilitychange", this);
    }
  }
};
var EffectComposer = class {
  constructor(renderer = null, {
    depthBuffer = true,
    stencilBuffer = false,
    alpha = false,
    multisampling = 0,
    frameBufferType
  } = {}) {
    this.renderer = renderer;
    this.inputBuffer = null;
    this.outputBuffer = null;
    if (this.renderer !== null) {
      this.renderer.autoClear = false;
      this.inputBuffer = this.createBuffer(depthBuffer, stencilBuffer, frameBufferType, multisampling);
      this.outputBuffer = this.inputBuffer.clone();
    }
    this.copyPass = new ShaderPass(new CopyMaterial());
    this.alpha = alpha;
    this.depthTexture = null;
    this.passes = [];
    this.timer = new Timer();
    this.autoRenderToScreen = true;
  }
  get multisampling() {
    return this.inputBuffer instanceof WebGLMultisampleRenderTarget ? this.inputBuffer.samples : 0;
  }
  set multisampling(value) {
    const buffer = this.inputBuffer;
    const multisampling = this.multisampling;
    if (multisampling > 0 && value > 0) {
      this.inputBuffer.samples = value;
      this.outputBuffer.samples = value;
    } else if (multisampling !== value) {
      this.inputBuffer.dispose();
      this.outputBuffer.dispose();
      this.inputBuffer = this.createBuffer(buffer.depthBuffer, buffer.stencilBuffer, buffer.texture.type, value);
      this.inputBuffer.depthTexture = this.depthTexture;
      this.outputBuffer = this.inputBuffer.clone();
    }
  }
  getTimer() {
    return this.timer;
  }
  getRenderer() {
    return this.renderer;
  }
  replaceRenderer(renderer, updateDOM = true) {
    const oldRenderer = this.renderer;
    if (oldRenderer !== null && oldRenderer !== renderer) {
      const oldSize = oldRenderer.getSize(new Vector2());
      const newSize = renderer.getSize(new Vector2());
      const parent = oldRenderer.domElement.parentNode;
      this.renderer = renderer;
      this.renderer.autoClear = false;
      if (!oldSize.equals(newSize)) {
        this.setSize();
      }
      if (updateDOM && parent !== null) {
        parent.removeChild(oldRenderer.domElement);
        parent.appendChild(renderer.domElement);
      }
    }
    return oldRenderer;
  }
  createDepthTexture() {
    const depthTexture = this.depthTexture = new DepthTexture();
    this.inputBuffer.depthTexture = depthTexture;
    this.inputBuffer.dispose();
    if (this.inputBuffer.stencilBuffer) {
      depthTexture.format = DepthStencilFormat;
      depthTexture.type = UnsignedInt248Type;
    } else {
      depthTexture.type = UnsignedIntType;
    }
    return depthTexture;
  }
  deleteDepthTexture() {
    if (this.depthTexture !== null) {
      this.depthTexture.dispose();
      this.depthTexture = null;
      this.inputBuffer.depthTexture = null;
      this.inputBuffer.dispose();
      for (const pass of this.passes) {
        pass.setDepthTexture(null);
      }
    }
  }
  createBuffer(depthBuffer, stencilBuffer, type, multisampling) {
    const renderer = this.renderer;
    const context = renderer.getContext();
    const size = renderer.getDrawingBufferSize(new Vector2());
    const alpha = this.alpha || context.getContextAttributes().alpha;
    const options = {
      format: !alpha && type === UnsignedByteType ? RGBFormat : RGBAFormat,
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      stencilBuffer,
      depthBuffer,
      type
    };
    const renderTarget = multisampling > 0 ? new WebGLMultisampleRenderTarget(size.width, size.height, options) : new WebGLRenderTarget(size.width, size.height, options);
    if (multisampling > 0) {
      renderTarget.samples = multisampling;
    }
    renderTarget.texture.name = "EffectComposer.Buffer";
    renderTarget.texture.generateMipmaps = false;
    return renderTarget;
  }
  addPass(pass, index) {
    const passes = this.passes;
    const renderer = this.renderer;
    const drawingBufferSize = renderer.getDrawingBufferSize(new Vector2());
    const alpha = renderer.getContext().getContextAttributes().alpha;
    const frameBufferType = this.inputBuffer.texture.type;
    pass.setSize(drawingBufferSize.width, drawingBufferSize.height);
    pass.initialize(renderer, alpha, frameBufferType);
    if (this.autoRenderToScreen) {
      if (passes.length > 0) {
        passes[passes.length - 1].renderToScreen = false;
      }
      if (pass.renderToScreen) {
        this.autoRenderToScreen = false;
      }
    }
    if (index !== void 0) {
      passes.splice(index, 0, pass);
    } else {
      passes.push(pass);
    }
    if (this.autoRenderToScreen) {
      passes[passes.length - 1].renderToScreen = true;
    }
    if (pass.needsDepthTexture || this.depthTexture !== null) {
      if (this.depthTexture === null) {
        const depthTexture = this.createDepthTexture();
        for (pass of passes) {
          pass.setDepthTexture(depthTexture);
        }
      } else {
        pass.setDepthTexture(this.depthTexture);
      }
    }
  }
  removePass(pass) {
    const passes = this.passes;
    const index = passes.indexOf(pass);
    const exists = index !== -1;
    const removed = exists && passes.splice(index, 1).length > 0;
    if (removed) {
      if (this.depthTexture !== null) {
        const reducer = (a2, b2) => a2 || b2.needsDepthTexture;
        const depthTextureRequired = passes.reduce(reducer, false);
        if (!depthTextureRequired) {
          if (pass.getDepthTexture() === this.depthTexture) {
            pass.setDepthTexture(null);
          }
          this.deleteDepthTexture();
        }
      }
      if (this.autoRenderToScreen) {
        if (index === passes.length) {
          pass.renderToScreen = false;
          if (passes.length > 0) {
            passes[passes.length - 1].renderToScreen = true;
          }
        }
      }
    }
  }
  removeAllPasses() {
    const passes = this.passes;
    this.deleteDepthTexture();
    if (passes.length > 0) {
      if (this.autoRenderToScreen) {
        passes[passes.length - 1].renderToScreen = false;
      }
      this.passes = [];
    }
  }
  render(deltaTime) {
    const renderer = this.renderer;
    const copyPass = this.copyPass;
    let inputBuffer = this.inputBuffer;
    let outputBuffer = this.outputBuffer;
    let stencilTest = false;
    let context, stencil, buffer;
    if (deltaTime === void 0) {
      deltaTime = this.timer.update().getDelta();
    }
    for (const pass of this.passes) {
      if (pass.isEnabled()) {
        pass.render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest);
        if (pass.needsSwap) {
          if (stencilTest) {
            copyPass.renderToScreen = pass.renderToScreen;
            context = renderer.getContext();
            stencil = renderer.state.buffers.stencil;
            stencil.setFunc(context.NOTEQUAL, 1, 4294967295);
            copyPass.render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest);
            stencil.setFunc(context.EQUAL, 1, 4294967295);
          }
          buffer = inputBuffer;
          inputBuffer = outputBuffer;
          outputBuffer = buffer;
        }
        if (pass instanceof MaskPass) {
          stencilTest = true;
        } else if (pass instanceof ClearMaskPass) {
          stencilTest = false;
        }
      }
    }
  }
  setSize(width, height, updateStyle) {
    const renderer = this.renderer;
    if (width === void 0 || height === void 0) {
      const size = renderer.getSize(new Vector2());
      width = size.width;
      height = size.height;
    } else {
      renderer.setSize(width, height, updateStyle);
    }
    const drawingBufferSize = renderer.getDrawingBufferSize(new Vector2());
    const inputBuffer = this.inputBuffer;
    const outputBuffer = this.outputBuffer;
    inputBuffer.setSize(drawingBufferSize.width, drawingBufferSize.height);
    outputBuffer.setSize(drawingBufferSize.width, drawingBufferSize.height);
    for (const pass of this.passes) {
      pass.setSize(drawingBufferSize.width, drawingBufferSize.height);
    }
  }
  reset() {
    this.dispose();
    this.autoRenderToScreen = true;
  }
  dispose() {
    for (const pass of this.passes) {
      pass.dispose();
    }
    this.passes = [];
    if (this.inputBuffer !== null) {
      this.inputBuffer.dispose();
    }
    if (this.outputBuffer !== null) {
      this.outputBuffer.dispose();
    }
    this.deleteDepthTexture();
    this.copyPass.dispose();
    this.timer.dispose();
  }
};
var Selection = class extends Set {
  constructor(iterable, layer = 10) {
    super();
    this.currentLayer = layer;
    this.exclusive = false;
    if (iterable !== void 0) {
      this.set(iterable);
    }
  }
  get layer() {
    return this.currentLayer;
  }
  set layer(value) {
    this.setLayer(value);
  }
  getLayer() {
    return this.currentLayer;
  }
  setLayer(value) {
    const currentLayer = this.currentLayer;
    for (const object of this) {
      object.layers.disable(currentLayer);
      object.layers.enable(value);
    }
    this.currentLayer = value;
  }
  clear() {
    const layer = this.layer;
    for (const object of this) {
      object.layers.disable(layer);
    }
    return super.clear();
  }
  set(objects) {
    this.clear();
    for (const object of objects) {
      this.add(object);
    }
    return this;
  }
  indexOf(object) {
    return this.has(object) ? 0 : -1;
  }
  add(object) {
    if (this.exclusive) {
      object.layers.set(this.layer);
    } else {
      object.layers.enable(this.layer);
    }
    return super.add(object);
  }
  delete(object) {
    if (this.has(object)) {
      object.layers.disable(this.layer);
    }
    return super.delete(object);
  }
  setVisible(visible) {
    for (const object of this) {
      if (visible) {
        object.layers.enable(0);
      } else {
        object.layers.disable(0);
      }
    }
    return this;
  }
};
function getNoise(size, format2, type) {
  const channels = new Map([
    [LuminanceFormat, 1],
    [RedFormat, 1],
    [RGFormat, 2],
    [RGBFormat, 3],
    [RGBAFormat, 4]
  ]);
  let data;
  if (!channels.has(format2)) {
    console.error("Invalid noise texture format");
  }
  if (type === UnsignedByteType) {
    data = new Uint8Array(size * channels.get(format2));
    for (let i2 = 0, l2 = data.length; i2 < l2; ++i2) {
      data[i2] = Math.random() * 255;
    }
  } else {
    data = new Float32Array(size * channels.get(format2));
    for (let i2 = 0, l2 = data.length; i2 < l2; ++i2) {
      data[i2] = Math.random();
    }
  }
  return data;
}
var NoiseTexture = class extends DataTexture {
  constructor(width, height, format2 = LuminanceFormat, type = UnsignedByteType) {
    super(getNoise(width * height, format2, type), width, height, format2, type);
  }
};
var shader_default57 = "uniform lowp sampler2D perturbationMap;uniform bool active;uniform float columns;uniform float random;uniform vec2 seed;uniform vec2 distortion;void mainUv(inout vec2 uv){if(active){if(uv.y<distortion.x+columns&&uv.y>distortion.x-columns*random){float sx=clamp(ceil(seed.x),0.0,1.0);uv.y=sx*(1.0-(uv.y+distortion.y))+(1.0-sx)*distortion.y;}if(uv.x<distortion.y+columns&&uv.x>distortion.y-columns*random){float sy=clamp(ceil(seed.y),0.0,1.0);uv.x=sy*distortion.x+(1.0-sy)*(1.0-(uv.x+distortion.x));}vec2 normal=texture2D(perturbationMap,uv*random*random).rg;uv+=normal*seed*(random*0.2);}}";
var tag = "Glitch.Generated";
function randomFloat(low, high) {
  return low + Math.random() * (high - low);
}
var GlitchEffect = class extends Effect {
  constructor({
    blendFunction = BlendFunction.NORMAL,
    chromaticAberrationOffset = null,
    delay = new Vector2(1.5, 3.5),
    duration = new Vector2(0.6, 1),
    strength = new Vector2(0.3, 1),
    columns = 0.05,
    ratio = 0.85,
    perturbationMap = null,
    dtSize = 64
  } = {}) {
    super("GlitchEffect", shader_default57, {
      blendFunction,
      uniforms: new Map([
        ["perturbationMap", new Uniform(null)],
        ["columns", new Uniform(columns)],
        ["active", new Uniform(false)],
        ["random", new Uniform(1)],
        ["seed", new Uniform(new Vector2())],
        ["distortion", new Uniform(new Vector2())]
      ])
    });
    this.setPerturbationMap(perturbationMap === null ? this.generatePerturbationMap(dtSize) : perturbationMap);
    this.delay = delay;
    this.duration = duration;
    this.breakPoint = new Vector2(randomFloat(this.delay.x, this.delay.y), randomFloat(this.duration.x, this.duration.y));
    this.time = 0;
    this.seed = this.uniforms.get("seed").value;
    this.distortion = this.uniforms.get("distortion").value;
    this.mode = GlitchMode.SPORADIC;
    this.strength = strength;
    this.ratio = ratio;
    this.chromaticAberrationOffset = chromaticAberrationOffset;
  }
  get active() {
    return this.uniforms.get("active").value;
  }
  getPerturbationMap() {
    return this.uniforms.get("perturbationMap").value;
  }
  setPerturbationMap(map2) {
    const currentMap = this.getPerturbationMap();
    if (currentMap !== null && currentMap.name === tag) {
      currentMap.dispose();
    }
    map2.minFilter = map2.magFilter = NearestFilter;
    map2.wrapS = map2.wrapT = RepeatWrapping;
    map2.generateMipmaps = false;
    this.uniforms.get("perturbationMap").value = map2;
  }
  generatePerturbationMap(size = 64) {
    const map2 = new NoiseTexture(size, size, RGBFormat);
    map2.name = tag;
    return map2;
  }
  update(renderer, inputBuffer, deltaTime) {
    const mode = this.mode;
    const breakPoint = this.breakPoint;
    const offset2 = this.chromaticAberrationOffset;
    const s2 = this.strength;
    let time = this.time;
    let active = false;
    let r2 = 0, a2 = 0;
    let trigger;
    if (mode !== GlitchMode.DISABLED) {
      if (mode === GlitchMode.SPORADIC) {
        time += deltaTime;
        trigger = time > breakPoint.x;
        if (time >= breakPoint.x + breakPoint.y) {
          breakPoint.set(randomFloat(this.delay.x, this.delay.y), randomFloat(this.duration.x, this.duration.y));
          time = 0;
        }
      }
      r2 = Math.random();
      this.uniforms.get("random").value = r2;
      if (trigger && r2 > this.ratio || mode === GlitchMode.CONSTANT_WILD) {
        active = true;
        r2 *= s2.y * 0.03;
        a2 = randomFloat(-Math.PI, Math.PI);
        this.seed.set(randomFloat(-s2.y, s2.y), randomFloat(-s2.y, s2.y));
        this.distortion.set(randomFloat(0, 1), randomFloat(0, 1));
      } else if (trigger || mode === GlitchMode.CONSTANT_MILD) {
        active = true;
        r2 *= s2.x * 0.03;
        a2 = randomFloat(-Math.PI, Math.PI);
        this.seed.set(randomFloat(-s2.x, s2.x), randomFloat(-s2.x, s2.x));
        this.distortion.set(randomFloat(0, 1), randomFloat(0, 1));
      }
      this.time = time;
    }
    if (offset2 !== null) {
      if (active) {
        offset2.set(Math.cos(a2), Math.sin(a2)).multiplyScalar(r2);
      } else {
        offset2.set(0, 0);
      }
    }
    this.uniforms.get("active").value = active;
  }
};
var GlitchMode = {
  DISABLED: 0,
  SPORADIC: 1,
  CONSTANT_MILD: 2,
  CONSTANT_WILD: 3
};
new Vector3();
new Matrix4();
new Color();
function getTextureDecoding(texture, isWebGL2) {
  let decoding = "texel";
  if (texture !== null) {
    const revision = Number.parseInt(REVISION);
    const sRGB8Alpha8 = revision >= 133 && isWebGL2 && texture.format === RGBAFormat && texture.type === UnsignedByteType && texture.encoding === sRGBEncoding;
    if (!sRGB8Alpha8) {
      switch (texture.encoding) {
        case sRGBEncoding:
          decoding = "sRGBToLinear(texel)";
          break;
        case LinearEncoding:
          decoding = "texel";
          break;
        default:
          throw new Error(`Unsupported encoding: ${texture.encoding}`);
      }
    }
  }
  return decoding;
}
var shader_default63 = "uniform lowp sampler2D edgeTexture;uniform lowp sampler2D maskTexture;uniform vec3 visibleEdgeColor;uniform vec3 hiddenEdgeColor;uniform float pulse;uniform float edgeStrength;\n#ifdef USE_PATTERN\nuniform lowp sampler2D patternTexture;varying vec2 vUvPattern;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 edge=texture2D(edgeTexture,uv).rg;vec2 mask=texture2D(maskTexture,uv).rg;\n#ifndef X_RAY\nedge.y=0.0;\n#endif\nedge*=(edgeStrength*mask.x*pulse);vec3 color=edge.x*visibleEdgeColor+edge.y*hiddenEdgeColor;float visibilityFactor=0.0;\n#ifdef USE_PATTERN\nvec4 patternColor=texelToLinear(texture2D(patternTexture,vUvPattern));\n#ifdef X_RAY\nfloat hiddenFactor=0.5;\n#else\nfloat hiddenFactor=0.0;\n#endif\nvisibilityFactor=(1.0-mask.y>0.0)? 1.0 : hiddenFactor;visibilityFactor*=(1.0-mask.x)*patternColor.a;color+=visibilityFactor*patternColor.rgb;\n#endif\nfloat alpha=max(max(edge.x,edge.y),visibilityFactor);\n#ifdef ALPHA\noutputColor=vec4(color,alpha);\n#else\noutputColor=vec4(color,max(alpha,inputColor.a));\n#endif\n}";
var shader_default64 = "uniform float patternScale;varying vec2 vUvPattern;void mainSupport(const in vec2 uv){vUvPattern=uv*vec2(aspect,1.0)*patternScale;}";
var OutlineEffect = class extends Effect {
  constructor(scene, camera, {
    blendFunction = BlendFunction.SCREEN,
    patternTexture = null,
    edgeStrength = 1,
    pulseSpeed = 0,
    visibleEdgeColor = 16777215,
    hiddenEdgeColor = 2230538,
    resolutionScale = 0.5,
    width = Resizer.AUTO_SIZE,
    height = Resizer.AUTO_SIZE,
    kernelSize = KernelSize.VERY_SMALL,
    blur = false,
    xRay = true
  } = {}) {
    super("OutlineEffect", shader_default63, {
      uniforms: new Map([
        ["maskTexture", new Uniform(null)],
        ["edgeTexture", new Uniform(null)],
        ["edgeStrength", new Uniform(edgeStrength)],
        ["visibleEdgeColor", new Uniform(new Color(visibleEdgeColor))],
        ["hiddenEdgeColor", new Uniform(new Color(hiddenEdgeColor))],
        ["pulse", new Uniform(1)],
        ["patternScale", new Uniform(1)],
        ["patternTexture", new Uniform(null)]
      ])
    });
    this.blendMode.addEventListener("change", (event) => {
      if (this.blendMode.getBlendFunction() === BlendFunction.ALPHA) {
        this.defines.set("ALPHA", "1");
      } else {
        this.defines.delete("ALPHA");
      }
      this.setChanged();
    });
    this.blendMode.setBlendFunction(blendFunction);
    this.setPatternTexture(patternTexture);
    this.xRay = xRay;
    this.scene = scene;
    this.camera = camera;
    this.renderTargetMask = new WebGLRenderTarget(1, 1, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      stencilBuffer: false,
      format: RGBFormat
    });
    this.renderTargetMask.texture.name = "Outline.Mask";
    this.uniforms.get("maskTexture").value = this.renderTargetMask.texture;
    this.renderTargetOutline = this.renderTargetMask.clone();
    this.renderTargetOutline.texture.name = "Outline.Edges";
    this.renderTargetOutline.depthBuffer = false;
    this.renderTargetBlurredOutline = this.renderTargetOutline.clone();
    this.renderTargetBlurredOutline.texture.name = "Outline.BlurredEdges";
    this.clearPass = new ClearPass();
    this.clearPass.overrideClearColor = new Color(0);
    this.clearPass.overrideClearAlpha = 1;
    this.depthPass = new DepthPass(scene, camera);
    this.maskPass = new RenderPass(scene, camera, new DepthComparisonMaterial(this.depthPass.texture, camera));
    const clearPass = this.maskPass.getClearPass();
    clearPass.overrideClearColor = new Color(16777215);
    clearPass.overrideClearAlpha = 1;
    this.blurPass = new BlurPass({ resolutionScale, width, height, kernelSize });
    this.blurPass.resolution.resizable = this;
    this.blur = blur;
    this.outlinePass = new ShaderPass(new OutlineMaterial());
    const outlineMaterial = this.outlinePass.getFullscreenMaterial();
    outlineMaterial.uniforms.inputBuffer.value = this.renderTargetMask.texture;
    this.time = 0;
    this.selection = new Selection();
    this.selection.setLayer(10);
    this.pulseSpeed = pulseSpeed;
    this.isWebGL2 = false;
  }
  get resolution() {
    return this.blurPass.resolution;
  }
  get width() {
    return this.resolution.width;
  }
  set width(value) {
    this.resolution.width = value;
  }
  get height() {
    return this.resolution.height;
  }
  set height(value) {
    this.resolution.height = value;
  }
  get selectionLayer() {
    return this.selection.layer;
  }
  set selectionLayer(value) {
    this.selection.layer = value;
  }
  get dithering() {
    return this.blurPass.dithering;
  }
  set dithering(value) {
    this.blurPass.dithering = value;
  }
  get kernelSize() {
    return this.blurPass.kernelSize;
  }
  set kernelSize(value) {
    this.blurPass.kernelSize = value;
  }
  get blur() {
    return this.blurPass.isEnabled();
  }
  set blur(value) {
    this.blurPass.setEnabled(value);
    this.uniforms.get("edgeTexture").value = value ? this.renderTargetBlurredOutline.texture : this.renderTargetOutline.texture;
  }
  get xRay() {
    return this.defines.has("X_RAY");
  }
  set xRay(value) {
    if (this.xRay !== value) {
      if (value) {
        this.defines.set("X_RAY", "1");
      } else {
        this.defines.delete("X_RAY");
      }
      this.setChanged();
    }
  }
  setPatternTexture(texture) {
    if (texture !== null) {
      texture.wrapS = texture.wrapT = RepeatWrapping;
      this.defines.set("USE_PATTERN", "1");
      this.uniforms.get("patternTexture").value = texture;
      this.setVertexShader(shader_default64);
    } else {
      this.defines.delete("USE_PATTERN");
      this.uniforms.get("patternTexture").value = null;
      this.setVertexShader(null);
    }
    const decoding = getTextureDecoding(texture, this.isWebGL2);
    this.defines.set("texelToLinear(texel)", decoding);
    this.setChanged();
  }
  getResolutionScale() {
    return this.resolution.scale;
  }
  setResolutionScale(scale) {
    this.resolution.scale = scale;
  }
  setSelection(objects) {
    this.selection.set(objects);
    return this;
  }
  clearSelection() {
    this.selection.clear();
    return this;
  }
  selectObject(object) {
    this.selection.add(object);
    return this;
  }
  deselectObject(object) {
    this.selection.delete(object);
    return this;
  }
  update(renderer, inputBuffer, deltaTime) {
    const scene = this.scene;
    const camera = this.camera;
    const selection = this.selection;
    const pulse = this.uniforms.get("pulse");
    const background = scene.background;
    const mask = camera.layers.mask;
    if (selection.size > 0) {
      scene.background = null;
      pulse.value = 1;
      if (this.pulseSpeed > 0) {
        pulse.value = Math.cos(this.time * this.pulseSpeed * 10) * 0.375 + 0.625;
      }
      this.time += deltaTime;
      selection.setVisible(false);
      this.depthPass.render(renderer);
      selection.setVisible(true);
      camera.layers.set(selection.getLayer());
      this.maskPass.render(renderer, this.renderTargetMask);
      camera.layers.mask = mask;
      scene.background = background;
      this.outlinePass.render(renderer, null, this.renderTargetOutline);
      if (this.blur) {
        this.blurPass.render(renderer, this.renderTargetOutline, this.renderTargetBlurredOutline);
      }
    } else if (this.time > 0) {
      this.clearPass.render(renderer, this.renderTargetMask);
      this.time = 0;
    }
  }
  setSize(width, height) {
    this.blurPass.setSize(width, height);
    this.renderTargetMask.setSize(width, height);
    const w2 = this.resolution.width;
    const h2 = this.resolution.height;
    this.depthPass.setSize(w2, h2);
    this.renderTargetOutline.setSize(w2, h2);
    this.renderTargetBlurredOutline.setSize(w2, h2);
    this.outlinePass.getFullscreenMaterial().setTexelSize(1 / w2, 1 / h2);
  }
  initialize(renderer, alpha, frameBufferType) {
    this.isWebGL2 = renderer.capabilities.isWebGL2;
    const texture = this.uniforms.get("patternTexture").value;
    const decoding = getTextureDecoding(texture, this.isWebGL2);
    this.defines.set("texelToLinear(texel)", decoding);
    this.blurPass.initialize(renderer, alpha, UnsignedByteType);
    if (frameBufferType !== void 0) {
      this.depthPass.initialize(renderer, alpha, frameBufferType);
      this.maskPass.initialize(renderer, alpha, frameBufferType);
      this.outlinePass.initialize(renderer, alpha, frameBufferType);
    }
  }
};
new Vector3();
new Vector3();
function __perlin() {
  var module2 = {};
  function Grad(x2, y2, z2) {
    this.x = x2;
    this.y = y2;
    this.z = z2;
  }
  Grad.prototype.dot2 = function(x2, y2) {
    return this.x * x2 + this.y * y2;
  };
  Grad.prototype.dot3 = function(x2, y2, z2) {
    return this.x * x2 + this.y * y2 + this.z * z2;
  };
  var grad3 = [
    new Grad(1, 1, 0),
    new Grad(-1, 1, 0),
    new Grad(1, -1, 0),
    new Grad(-1, -1, 0),
    new Grad(1, 0, 1),
    new Grad(-1, 0, 1),
    new Grad(1, 0, -1),
    new Grad(-1, 0, -1),
    new Grad(0, 1, 1),
    new Grad(0, -1, 1),
    new Grad(0, 1, -1),
    new Grad(0, -1, -1)
  ];
  var p2 = [
    151,
    160,
    137,
    91,
    90,
    15,
    131,
    13,
    201,
    95,
    96,
    53,
    194,
    233,
    7,
    225,
    140,
    36,
    103,
    30,
    69,
    142,
    8,
    99,
    37,
    240,
    21,
    10,
    23,
    190,
    6,
    148,
    247,
    120,
    234,
    75,
    0,
    26,
    197,
    62,
    94,
    252,
    219,
    203,
    117,
    35,
    11,
    32,
    57,
    177,
    33,
    88,
    237,
    149,
    56,
    87,
    174,
    20,
    125,
    136,
    171,
    168,
    68,
    175,
    74,
    165,
    71,
    134,
    139,
    48,
    27,
    166,
    77,
    146,
    158,
    231,
    83,
    111,
    229,
    122,
    60,
    211,
    133,
    230,
    220,
    105,
    92,
    41,
    55,
    46,
    245,
    40,
    244,
    102,
    143,
    54,
    65,
    25,
    63,
    161,
    1,
    216,
    80,
    73,
    209,
    76,
    132,
    187,
    208,
    89,
    18,
    169,
    200,
    196,
    135,
    130,
    116,
    188,
    159,
    86,
    164,
    100,
    109,
    198,
    173,
    186,
    3,
    64,
    52,
    217,
    226,
    250,
    124,
    123,
    5,
    202,
    38,
    147,
    118,
    126,
    255,
    82,
    85,
    212,
    207,
    206,
    59,
    227,
    47,
    16,
    58,
    17,
    182,
    189,
    28,
    42,
    223,
    183,
    170,
    213,
    119,
    248,
    152,
    2,
    44,
    154,
    163,
    70,
    221,
    153,
    101,
    155,
    167,
    43,
    172,
    9,
    129,
    22,
    39,
    253,
    19,
    98,
    108,
    110,
    79,
    113,
    224,
    232,
    178,
    185,
    112,
    104,
    218,
    246,
    97,
    228,
    251,
    34,
    242,
    193,
    238,
    210,
    144,
    12,
    191,
    179,
    162,
    241,
    81,
    51,
    145,
    235,
    249,
    14,
    239,
    107,
    49,
    192,
    214,
    31,
    181,
    199,
    106,
    157,
    184,
    84,
    204,
    176,
    115,
    121,
    50,
    45,
    127,
    4,
    150,
    254,
    138,
    236,
    205,
    93,
    222,
    114,
    67,
    29,
    24,
    72,
    243,
    141,
    128,
    195,
    78,
    66,
    215,
    61,
    156,
    180
  ];
  var perm = new Array(512);
  var gradP = new Array(512);
  module2.seed = function(seed) {
    if (seed > 0 && seed < 1) {
      seed *= 65536;
    }
    seed = Math.floor(seed);
    if (seed < 256) {
      seed |= seed << 8;
    }
    for (var i2 = 0; i2 < 256; i2++) {
      var v2;
      if (i2 & 1) {
        v2 = p2[i2] ^ seed & 255;
      } else {
        v2 = p2[i2] ^ seed >> 8 & 255;
      }
      perm[i2] = perm[i2 + 256] = v2;
      gradP[i2] = gradP[i2 + 256] = grad3[v2 % 12];
    }
  };
  module2.seed(0);
  var F2 = 0.5 * (Math.sqrt(3) - 1);
  var G2 = (3 - Math.sqrt(3)) / 6;
  var F3 = 1 / 3;
  var G3 = 1 / 6;
  module2.simplex2 = function(xin, yin) {
    var n0, n1, n2;
    var s2 = (xin + yin) * F2;
    var i2 = Math.floor(xin + s2);
    var j2 = Math.floor(yin + s2);
    var t2 = (i2 + j2) * G2;
    var x0 = xin - i2 + t2;
    var y0 = yin - j2 + t2;
    var i1, j1;
    if (x0 > y0) {
      i1 = 1;
      j1 = 0;
    } else {
      i1 = 0;
      j1 = 1;
    }
    var x1 = x0 - i1 + G2;
    var y1 = y0 - j1 + G2;
    var x2 = x0 - 1 + 2 * G2;
    var y2 = y0 - 1 + 2 * G2;
    i2 &= 255;
    j2 &= 255;
    var gi0 = gradP[i2 + perm[j2]];
    var gi1 = gradP[i2 + i1 + perm[j2 + j1]];
    var gi2 = gradP[i2 + 1 + perm[j2 + 1]];
    var t0 = 0.5 - x0 * x0 - y0 * y0;
    if (t0 < 0) {
      n0 = 0;
    } else {
      t0 *= t0;
      n0 = t0 * t0 * gi0.dot2(x0, y0);
    }
    var t1 = 0.5 - x1 * x1 - y1 * y1;
    if (t1 < 0) {
      n1 = 0;
    } else {
      t1 *= t1;
      n1 = t1 * t1 * gi1.dot2(x1, y1);
    }
    var t22 = 0.5 - x2 * x2 - y2 * y2;
    if (t22 < 0) {
      n2 = 0;
    } else {
      t22 *= t22;
      n2 = t22 * t22 * gi2.dot2(x2, y2);
    }
    return 70 * (n0 + n1 + n2);
  };
  module2.simplex3 = function(xin, yin, zin) {
    var n0, n1, n2, n3;
    var s2 = (xin + yin + zin) * F3;
    var i2 = Math.floor(xin + s2);
    var j2 = Math.floor(yin + s2);
    var k2 = Math.floor(zin + s2);
    var t2 = (i2 + j2 + k2) * G3;
    var x0 = xin - i2 + t2;
    var y0 = yin - j2 + t2;
    var z0 = zin - k2 + t2;
    var i1, j1, k1;
    var i22, j22, k22;
    if (x0 >= y0) {
      if (y0 >= z0) {
        i1 = 1;
        j1 = 0;
        k1 = 0;
        i22 = 1;
        j22 = 1;
        k22 = 0;
      } else if (x0 >= z0) {
        i1 = 1;
        j1 = 0;
        k1 = 0;
        i22 = 1;
        j22 = 0;
        k22 = 1;
      } else {
        i1 = 0;
        j1 = 0;
        k1 = 1;
        i22 = 1;
        j22 = 0;
        k22 = 1;
      }
    } else {
      if (y0 < z0) {
        i1 = 0;
        j1 = 0;
        k1 = 1;
        i22 = 0;
        j22 = 1;
        k22 = 1;
      } else if (x0 < z0) {
        i1 = 0;
        j1 = 1;
        k1 = 0;
        i22 = 0;
        j22 = 1;
        k22 = 1;
      } else {
        i1 = 0;
        j1 = 1;
        k1 = 0;
        i22 = 1;
        j22 = 1;
        k22 = 0;
      }
    }
    var x1 = x0 - i1 + G3;
    var y1 = y0 - j1 + G3;
    var z1 = z0 - k1 + G3;
    var x2 = x0 - i22 + 2 * G3;
    var y2 = y0 - j22 + 2 * G3;
    var z2 = z0 - k22 + 2 * G3;
    var x3 = x0 - 1 + 3 * G3;
    var y3 = y0 - 1 + 3 * G3;
    var z3 = z0 - 1 + 3 * G3;
    i2 &= 255;
    j2 &= 255;
    k2 &= 255;
    var gi0 = gradP[i2 + perm[j2 + perm[k2]]];
    var gi1 = gradP[i2 + i1 + perm[j2 + j1 + perm[k2 + k1]]];
    var gi2 = gradP[i2 + i22 + perm[j2 + j22 + perm[k2 + k22]]];
    var gi3 = gradP[i2 + 1 + perm[j2 + 1 + perm[k2 + 1]]];
    var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
    if (t0 < 0) {
      n0 = 0;
    } else {
      t0 *= t0;
      n0 = t0 * t0 * gi0.dot3(x0, y0, z0);
    }
    var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
    if (t1 < 0) {
      n1 = 0;
    } else {
      t1 *= t1;
      n1 = t1 * t1 * gi1.dot3(x1, y1, z1);
    }
    var t22 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
    if (t22 < 0) {
      n2 = 0;
    } else {
      t22 *= t22;
      n2 = t22 * t22 * gi2.dot3(x2, y2, z2);
    }
    var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
    if (t3 < 0) {
      n3 = 0;
    } else {
      t3 *= t3;
      n3 = t3 * t3 * gi3.dot3(x3, y3, z3);
    }
    return 32 * (n0 + n1 + n2 + n3);
  };
  function fade(t2) {
    return t2 * t2 * t2 * (t2 * (t2 * 6 - 15) + 10);
  }
  function lerp2(a2, b2, t2) {
    return (1 - t2) * a2 + t2 * b2;
  }
  module2.perlin2 = function(x2, y2) {
    var X2 = Math.floor(x2), Y2 = Math.floor(y2);
    x2 = x2 - X2;
    y2 = y2 - Y2;
    X2 = X2 & 255;
    Y2 = Y2 & 255;
    var n00 = gradP[X2 + perm[Y2]].dot2(x2, y2);
    var n01 = gradP[X2 + perm[Y2 + 1]].dot2(x2, y2 - 1);
    var n10 = gradP[X2 + 1 + perm[Y2]].dot2(x2 - 1, y2);
    var n11 = gradP[X2 + 1 + perm[Y2 + 1]].dot2(x2 - 1, y2 - 1);
    var u2 = fade(x2);
    return lerp2(lerp2(n00, n10, u2), lerp2(n01, n11, u2), fade(y2));
  };
  module2.perlin3 = function(x2, y2, z2) {
    var X2 = Math.floor(x2), Y2 = Math.floor(y2), Z2 = Math.floor(z2);
    x2 = x2 - X2;
    y2 = y2 - Y2;
    z2 = z2 - Z2;
    X2 = X2 & 255;
    Y2 = Y2 & 255;
    Z2 = Z2 & 255;
    var n000 = gradP[X2 + perm[Y2 + perm[Z2]]].dot3(x2, y2, z2);
    var n001 = gradP[X2 + perm[Y2 + perm[Z2 + 1]]].dot3(x2, y2, z2 - 1);
    var n010 = gradP[X2 + perm[Y2 + 1 + perm[Z2]]].dot3(x2, y2 - 1, z2);
    var n011 = gradP[X2 + perm[Y2 + 1 + perm[Z2 + 1]]].dot3(x2, y2 - 1, z2 - 1);
    var n100 = gradP[X2 + 1 + perm[Y2 + perm[Z2]]].dot3(x2 - 1, y2, z2);
    var n101 = gradP[X2 + 1 + perm[Y2 + perm[Z2 + 1]]].dot3(x2 - 1, y2, z2 - 1);
    var n110 = gradP[X2 + 1 + perm[Y2 + 1 + perm[Z2]]].dot3(x2 - 1, y2 - 1, z2);
    var n111 = gradP[X2 + 1 + perm[Y2 + 1 + perm[Z2 + 1]]].dot3(x2 - 1, y2 - 1, z2 - 1);
    var u2 = fade(x2);
    var v2 = fade(y2);
    var w2 = fade(z2);
    return lerp2(lerp2(lerp2(n000, n100, u2), lerp2(n001, n101, u2), w2), lerp2(lerp2(n010, n110, u2), lerp2(n011, n111, u2), w2), v2);
  };
  return module2;
}
class RGBELoader extends DataTextureLoader {
  constructor(manager) {
    super(manager);
    this.type = HalfFloatType;
  }
  parse(buffer) {
    const RGBE_RETURN_FAILURE = -1, rgbe_read_error = 1, rgbe_write_error = 2, rgbe_format_error = 3, rgbe_memory_error = 4, rgbe_error = function(rgbe_error_code, msg) {
      switch (rgbe_error_code) {
        case rgbe_read_error:
          console.error("THREE.RGBELoader Read Error: " + (msg || ""));
          break;
        case rgbe_write_error:
          console.error("THREE.RGBELoader Write Error: " + (msg || ""));
          break;
        case rgbe_format_error:
          console.error("THREE.RGBELoader Bad File Format: " + (msg || ""));
          break;
        default:
        case rgbe_memory_error:
          console.error("THREE.RGBELoader: Error: " + (msg || ""));
      }
      return RGBE_RETURN_FAILURE;
    }, RGBE_VALID_PROGRAMTYPE = 1, RGBE_VALID_FORMAT = 2, RGBE_VALID_DIMENSIONS = 4, NEWLINE = "\n", fgets = function(buffer2, lineLimit, consume) {
      const chunkSize = 128;
      lineLimit = !lineLimit ? 1024 : lineLimit;
      let p2 = buffer2.pos, i2 = -1, len = 0, s2 = "", chunk = String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p2, p2 + chunkSize)));
      while (0 > (i2 = chunk.indexOf(NEWLINE)) && len < lineLimit && p2 < buffer2.byteLength) {
        s2 += chunk;
        len += chunk.length;
        p2 += chunkSize;
        chunk += String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p2, p2 + chunkSize)));
      }
      if (-1 < i2) {
        if (consume !== false)
          buffer2.pos += len + i2 + 1;
        return s2 + chunk.slice(0, i2);
      }
      return false;
    }, RGBE_ReadHeader = function(buffer2) {
      const magic_token_re = /^#\?(\S+)/, gamma_re = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, exposure_re = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, format_re = /^\s*FORMAT=(\S+)\s*$/, dimensions_re = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, header = {
        valid: 0,
        string: "",
        comments: "",
        programtype: "RGBE",
        format: "",
        gamma: 1,
        exposure: 1,
        width: 0,
        height: 0
      };
      let line, match5;
      if (buffer2.pos >= buffer2.byteLength || !(line = fgets(buffer2))) {
        return rgbe_error(rgbe_read_error, "no header found");
      }
      if (!(match5 = line.match(magic_token_re))) {
        return rgbe_error(rgbe_format_error, "bad initial token");
      }
      header.valid |= RGBE_VALID_PROGRAMTYPE;
      header.programtype = match5[1];
      header.string += line + "\n";
      while (true) {
        line = fgets(buffer2);
        if (line === false)
          break;
        header.string += line + "\n";
        if (line.charAt(0) === "#") {
          header.comments += line + "\n";
          continue;
        }
        if (match5 = line.match(gamma_re)) {
          header.gamma = parseFloat(match5[1], 10);
        }
        if (match5 = line.match(exposure_re)) {
          header.exposure = parseFloat(match5[1], 10);
        }
        if (match5 = line.match(format_re)) {
          header.valid |= RGBE_VALID_FORMAT;
          header.format = match5[1];
        }
        if (match5 = line.match(dimensions_re)) {
          header.valid |= RGBE_VALID_DIMENSIONS;
          header.height = parseInt(match5[1], 10);
          header.width = parseInt(match5[2], 10);
        }
        if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS)
          break;
      }
      if (!(header.valid & RGBE_VALID_FORMAT)) {
        return rgbe_error(rgbe_format_error, "missing format specifier");
      }
      if (!(header.valid & RGBE_VALID_DIMENSIONS)) {
        return rgbe_error(rgbe_format_error, "missing image size specifier");
      }
      return header;
    }, RGBE_ReadPixels_RLE = function(buffer2, w2, h2) {
      const scanline_width = w2;
      if (scanline_width < 8 || scanline_width > 32767 || (buffer2[0] !== 2 || buffer2[1] !== 2 || buffer2[2] & 128)) {
        return new Uint8Array(buffer2);
      }
      if (scanline_width !== (buffer2[2] << 8 | buffer2[3])) {
        return rgbe_error(rgbe_format_error, "wrong scanline width");
      }
      const data_rgba = new Uint8Array(4 * w2 * h2);
      if (!data_rgba.length) {
        return rgbe_error(rgbe_memory_error, "unable to allocate buffer space");
      }
      let offset2 = 0, pos = 0;
      const ptr_end = 4 * scanline_width;
      const rgbeStart = new Uint8Array(4);
      const scanline_buffer = new Uint8Array(ptr_end);
      let num_scanlines = h2;
      while (num_scanlines > 0 && pos < buffer2.byteLength) {
        if (pos + 4 > buffer2.byteLength) {
          return rgbe_error(rgbe_read_error);
        }
        rgbeStart[0] = buffer2[pos++];
        rgbeStart[1] = buffer2[pos++];
        rgbeStart[2] = buffer2[pos++];
        rgbeStart[3] = buffer2[pos++];
        if (rgbeStart[0] != 2 || rgbeStart[1] != 2 || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {
          return rgbe_error(rgbe_format_error, "bad rgbe scanline format");
        }
        let ptr = 0, count;
        while (ptr < ptr_end && pos < buffer2.byteLength) {
          count = buffer2[pos++];
          const isEncodedRun = count > 128;
          if (isEncodedRun)
            count -= 128;
          if (count === 0 || ptr + count > ptr_end) {
            return rgbe_error(rgbe_format_error, "bad scanline data");
          }
          if (isEncodedRun) {
            const byteValue = buffer2[pos++];
            for (let i2 = 0; i2 < count; i2++) {
              scanline_buffer[ptr++] = byteValue;
            }
          } else {
            scanline_buffer.set(buffer2.subarray(pos, pos + count), ptr);
            ptr += count;
            pos += count;
          }
        }
        const l2 = scanline_width;
        for (let i2 = 0; i2 < l2; i2++) {
          let off = 0;
          data_rgba[offset2] = scanline_buffer[i2 + off];
          off += scanline_width;
          data_rgba[offset2 + 1] = scanline_buffer[i2 + off];
          off += scanline_width;
          data_rgba[offset2 + 2] = scanline_buffer[i2 + off];
          off += scanline_width;
          data_rgba[offset2 + 3] = scanline_buffer[i2 + off];
          offset2 += 4;
        }
        num_scanlines--;
      }
      return data_rgba;
    };
    const RGBEByteToRGBFloat = function(sourceArray, sourceOffset, destArray, destOffset) {
      const e20 = sourceArray[sourceOffset + 3];
      const scale = Math.pow(2, e20 - 128) / 255;
      destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;
      destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;
      destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;
    };
    const RGBEByteToRGBHalf = function(sourceArray, sourceOffset, destArray, destOffset) {
      const e20 = sourceArray[sourceOffset + 3];
      const scale = Math.pow(2, e20 - 128) / 255;
      destArray[destOffset + 0] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));
      destArray[destOffset + 1] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));
      destArray[destOffset + 2] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));
    };
    const byteArray = new Uint8Array(buffer);
    byteArray.pos = 0;
    const rgbe_header_info = RGBE_ReadHeader(byteArray);
    if (RGBE_RETURN_FAILURE !== rgbe_header_info) {
      const w2 = rgbe_header_info.width, h2 = rgbe_header_info.height, image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w2, h2);
      if (RGBE_RETURN_FAILURE !== image_rgba_data) {
        let data, format2, type;
        let numElements;
        switch (this.type) {
          case UnsignedByteType:
            data = image_rgba_data;
            format2 = RGBEFormat;
            type = UnsignedByteType;
            break;
          case FloatType:
            numElements = image_rgba_data.length / 4;
            const floatArray = new Float32Array(numElements * 3);
            for (let j2 = 0; j2 < numElements; j2++) {
              RGBEByteToRGBFloat(image_rgba_data, j2 * 4, floatArray, j2 * 3);
            }
            data = floatArray;
            format2 = RGBFormat;
            type = FloatType;
            break;
          case HalfFloatType:
            numElements = image_rgba_data.length / 4;
            const halfArray = new Uint16Array(numElements * 3);
            for (let j2 = 0; j2 < numElements; j2++) {
              RGBEByteToRGBHalf(image_rgba_data, j2 * 4, halfArray, j2 * 3);
            }
            data = halfArray;
            format2 = RGBFormat;
            type = HalfFloatType;
            break;
          default:
            console.error("THREE.RGBELoader: unsupported type: ", this.type);
            break;
        }
        return {
          width: w2,
          height: h2,
          data,
          header: rgbe_header_info.string,
          gamma: rgbe_header_info.gamma,
          exposure: rgbe_header_info.exposure,
          format: format2,
          type
        };
      }
    }
    return null;
  }
  setDataType(value) {
    this.type = value;
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    function onLoadCallback(texture, texData) {
      switch (texture.type) {
        case UnsignedByteType:
          texture.encoding = RGBEEncoding;
          texture.minFilter = NearestFilter;
          texture.magFilter = NearestFilter;
          texture.generateMipmaps = false;
          texture.flipY = true;
          break;
        case FloatType:
          texture.encoding = LinearEncoding;
          texture.minFilter = LinearFilter;
          texture.magFilter = LinearFilter;
          texture.generateMipmaps = false;
          texture.flipY = true;
          break;
        case HalfFloatType:
          texture.encoding = LinearEncoding;
          texture.minFilter = LinearFilter;
          texture.magFilter = LinearFilter;
          texture.generateMipmaps = false;
          texture.flipY = true;
          break;
      }
      if (onLoad)
        onLoad(texture, texData);
    }
    return super.load(url, onLoadCallback, onProgress, onError);
  }
}
const _object_pattern = /^[og]\s*(.+)?/;
const _material_library_pattern = /^mtllib /;
const _material_use_pattern = /^usemtl /;
const _map_use_pattern = /^usemap /;
const _vA = new Vector3();
const _vB = new Vector3();
const _vC = new Vector3();
const _ab = new Vector3();
const _cb = new Vector3();
function ParserState() {
  const state = {
    objects: [],
    object: {},
    vertices: [],
    normals: [],
    colors: [],
    uvs: [],
    materials: {},
    materialLibraries: [],
    startObject: function(name2, fromDeclaration) {
      if (this.object && this.object.fromDeclaration === false) {
        this.object.name = name2;
        this.object.fromDeclaration = fromDeclaration !== false;
        return;
      }
      const previousMaterial = this.object && typeof this.object.currentMaterial === "function" ? this.object.currentMaterial() : void 0;
      if (this.object && typeof this.object._finalize === "function") {
        this.object._finalize(true);
      }
      this.object = {
        name: name2 || "",
        fromDeclaration: fromDeclaration !== false,
        geometry: {
          vertices: [],
          normals: [],
          colors: [],
          uvs: [],
          hasUVIndices: false
        },
        materials: [],
        smooth: true,
        startMaterial: function(name3, libraries) {
          const previous = this._finalize(false);
          if (previous && (previous.inherited || previous.groupCount <= 0)) {
            this.materials.splice(previous.index, 1);
          }
          const material = {
            index: this.materials.length,
            name: name3 || "",
            mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : "",
            smooth: previous !== void 0 ? previous.smooth : this.smooth,
            groupStart: previous !== void 0 ? previous.groupEnd : 0,
            groupEnd: -1,
            groupCount: -1,
            inherited: false,
            clone: function(index) {
              const cloned = {
                index: typeof index === "number" ? index : this.index,
                name: this.name,
                mtllib: this.mtllib,
                smooth: this.smooth,
                groupStart: 0,
                groupEnd: -1,
                groupCount: -1,
                inherited: false
              };
              cloned.clone = this.clone.bind(cloned);
              return cloned;
            }
          };
          this.materials.push(material);
          return material;
        },
        currentMaterial: function() {
          if (this.materials.length > 0) {
            return this.materials[this.materials.length - 1];
          }
          return void 0;
        },
        _finalize: function(end) {
          const lastMultiMaterial = this.currentMaterial();
          if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {
            lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
            lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
            lastMultiMaterial.inherited = false;
          }
          if (end && this.materials.length > 1) {
            for (let mi2 = this.materials.length - 1; mi2 >= 0; mi2--) {
              if (this.materials[mi2].groupCount <= 0) {
                this.materials.splice(mi2, 1);
              }
            }
          }
          if (end && this.materials.length === 0) {
            this.materials.push({
              name: "",
              smooth: this.smooth
            });
          }
          return lastMultiMaterial;
        }
      };
      if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === "function") {
        const declared = previousMaterial.clone(0);
        declared.inherited = true;
        this.object.materials.push(declared);
      }
      this.objects.push(this.object);
    },
    finalize: function() {
      if (this.object && typeof this.object._finalize === "function") {
        this.object._finalize(true);
      }
    },
    parseVertexIndex: function(value, len) {
      const index = parseInt(value, 10);
      return (index >= 0 ? index - 1 : index + len / 3) * 3;
    },
    parseNormalIndex: function(value, len) {
      const index = parseInt(value, 10);
      return (index >= 0 ? index - 1 : index + len / 3) * 3;
    },
    parseUVIndex: function(value, len) {
      const index = parseInt(value, 10);
      return (index >= 0 ? index - 1 : index + len / 2) * 2;
    },
    addVertex: function(a2, b2, c2) {
      const src = this.vertices;
      const dst = this.object.geometry.vertices;
      dst.push(src[a2 + 0], src[a2 + 1], src[a2 + 2]);
      dst.push(src[b2 + 0], src[b2 + 1], src[b2 + 2]);
      dst.push(src[c2 + 0], src[c2 + 1], src[c2 + 2]);
    },
    addVertexPoint: function(a2) {
      const src = this.vertices;
      const dst = this.object.geometry.vertices;
      dst.push(src[a2 + 0], src[a2 + 1], src[a2 + 2]);
    },
    addVertexLine: function(a2) {
      const src = this.vertices;
      const dst = this.object.geometry.vertices;
      dst.push(src[a2 + 0], src[a2 + 1], src[a2 + 2]);
    },
    addNormal: function(a2, b2, c2) {
      const src = this.normals;
      const dst = this.object.geometry.normals;
      dst.push(src[a2 + 0], src[a2 + 1], src[a2 + 2]);
      dst.push(src[b2 + 0], src[b2 + 1], src[b2 + 2]);
      dst.push(src[c2 + 0], src[c2 + 1], src[c2 + 2]);
    },
    addFaceNormal: function(a2, b2, c2) {
      const src = this.vertices;
      const dst = this.object.geometry.normals;
      _vA.fromArray(src, a2);
      _vB.fromArray(src, b2);
      _vC.fromArray(src, c2);
      _cb.subVectors(_vC, _vB);
      _ab.subVectors(_vA, _vB);
      _cb.cross(_ab);
      _cb.normalize();
      dst.push(_cb.x, _cb.y, _cb.z);
      dst.push(_cb.x, _cb.y, _cb.z);
      dst.push(_cb.x, _cb.y, _cb.z);
    },
    addColor: function(a2, b2, c2) {
      const src = this.colors;
      const dst = this.object.geometry.colors;
      if (src[a2] !== void 0)
        dst.push(src[a2 + 0], src[a2 + 1], src[a2 + 2]);
      if (src[b2] !== void 0)
        dst.push(src[b2 + 0], src[b2 + 1], src[b2 + 2]);
      if (src[c2] !== void 0)
        dst.push(src[c2 + 0], src[c2 + 1], src[c2 + 2]);
    },
    addUV: function(a2, b2, c2) {
      const src = this.uvs;
      const dst = this.object.geometry.uvs;
      dst.push(src[a2 + 0], src[a2 + 1]);
      dst.push(src[b2 + 0], src[b2 + 1]);
      dst.push(src[c2 + 0], src[c2 + 1]);
    },
    addDefaultUV: function() {
      const dst = this.object.geometry.uvs;
      dst.push(0, 0);
      dst.push(0, 0);
      dst.push(0, 0);
    },
    addUVLine: function(a2) {
      const src = this.uvs;
      const dst = this.object.geometry.uvs;
      dst.push(src[a2 + 0], src[a2 + 1]);
    },
    addFace: function(a2, b2, c2, ua2, ub2, uc2, na2, nb2, nc2) {
      const vLen = this.vertices.length;
      let ia2 = this.parseVertexIndex(a2, vLen);
      let ib2 = this.parseVertexIndex(b2, vLen);
      let ic2 = this.parseVertexIndex(c2, vLen);
      this.addVertex(ia2, ib2, ic2);
      this.addColor(ia2, ib2, ic2);
      if (na2 !== void 0 && na2 !== "") {
        const nLen = this.normals.length;
        ia2 = this.parseNormalIndex(na2, nLen);
        ib2 = this.parseNormalIndex(nb2, nLen);
        ic2 = this.parseNormalIndex(nc2, nLen);
        this.addNormal(ia2, ib2, ic2);
      } else {
        this.addFaceNormal(ia2, ib2, ic2);
      }
      if (ua2 !== void 0 && ua2 !== "") {
        const uvLen = this.uvs.length;
        ia2 = this.parseUVIndex(ua2, uvLen);
        ib2 = this.parseUVIndex(ub2, uvLen);
        ic2 = this.parseUVIndex(uc2, uvLen);
        this.addUV(ia2, ib2, ic2);
        this.object.geometry.hasUVIndices = true;
      } else {
        this.addDefaultUV();
      }
    },
    addPointGeometry: function(vertices) {
      this.object.geometry.type = "Points";
      const vLen = this.vertices.length;
      for (let vi2 = 0, l2 = vertices.length; vi2 < l2; vi2++) {
        const index = this.parseVertexIndex(vertices[vi2], vLen);
        this.addVertexPoint(index);
        this.addColor(index);
      }
    },
    addLineGeometry: function(vertices, uvs) {
      this.object.geometry.type = "Line";
      const vLen = this.vertices.length;
      const uvLen = this.uvs.length;
      for (let vi2 = 0, l2 = vertices.length; vi2 < l2; vi2++) {
        this.addVertexLine(this.parseVertexIndex(vertices[vi2], vLen));
      }
      for (let uvi = 0, l2 = uvs.length; uvi < l2; uvi++) {
        this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));
      }
    }
  };
  state.startObject("", false);
  return state;
}
class OBJLoader extends Loader {
  constructor(manager) {
    super(manager);
    this.materials = null;
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope.parse(text));
      } catch (e20) {
        if (onError) {
          onError(e20);
        } else {
          console.error(e20);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  setMaterials(materials) {
    this.materials = materials;
    return this;
  }
  parse(text) {
    const state = new ParserState();
    if (text.indexOf("\r\n") !== -1) {
      text = text.replace(/\r\n/g, "\n");
    }
    if (text.indexOf("\\\n") !== -1) {
      text = text.replace(/\\\n/g, "");
    }
    const lines = text.split("\n");
    let line = "", lineFirstChar = "";
    let lineLength = 0;
    let result = [];
    const trimLeft2 = typeof "".trimLeft === "function";
    for (let i2 = 0, l2 = lines.length; i2 < l2; i2++) {
      line = lines[i2];
      line = trimLeft2 ? line.trimLeft() : line.trim();
      lineLength = line.length;
      if (lineLength === 0)
        continue;
      lineFirstChar = line.charAt(0);
      if (lineFirstChar === "#")
        continue;
      if (lineFirstChar === "v") {
        const data = line.split(/\s+/);
        switch (data[0]) {
          case "v":
            state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
            if (data.length >= 7) {
              state.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]));
            } else {
              state.colors.push(void 0, void 0, void 0);
            }
            break;
          case "vn":
            state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
            break;
          case "vt":
            state.uvs.push(parseFloat(data[1]), parseFloat(data[2]));
            break;
        }
      } else if (lineFirstChar === "f") {
        const lineData = line.substr(1).trim();
        const vertexData = lineData.split(/\s+/);
        const faceVertices = [];
        for (let j2 = 0, jl2 = vertexData.length; j2 < jl2; j2++) {
          const vertex2 = vertexData[j2];
          if (vertex2.length > 0) {
            const vertexParts = vertex2.split("/");
            faceVertices.push(vertexParts);
          }
        }
        const v1 = faceVertices[0];
        for (let j2 = 1, jl2 = faceVertices.length - 1; j2 < jl2; j2++) {
          const v2 = faceVertices[j2];
          const v3 = faceVertices[j2 + 1];
          state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);
        }
      } else if (lineFirstChar === "l") {
        const lineParts = line.substring(1).trim().split(" ");
        let lineVertices = [];
        const lineUVs = [];
        if (line.indexOf("/") === -1) {
          lineVertices = lineParts;
        } else {
          for (let li2 = 0, llen = lineParts.length; li2 < llen; li2++) {
            const parts = lineParts[li2].split("/");
            if (parts[0] !== "")
              lineVertices.push(parts[0]);
            if (parts[1] !== "")
              lineUVs.push(parts[1]);
          }
        }
        state.addLineGeometry(lineVertices, lineUVs);
      } else if (lineFirstChar === "p") {
        const lineData = line.substr(1).trim();
        const pointData = lineData.split(" ");
        state.addPointGeometry(pointData);
      } else if ((result = _object_pattern.exec(line)) !== null) {
        const name2 = (" " + result[0].substr(1).trim()).substr(1);
        state.startObject(name2);
      } else if (_material_use_pattern.test(line)) {
        state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);
      } else if (_material_library_pattern.test(line)) {
        state.materialLibraries.push(line.substring(7).trim());
      } else if (_map_use_pattern.test(line)) {
        console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
      } else if (lineFirstChar === "s") {
        result = line.split(" ");
        if (result.length > 1) {
          const value = result[1].trim().toLowerCase();
          state.object.smooth = value !== "0" && value !== "off";
        } else {
          state.object.smooth = true;
        }
        const material = state.object.currentMaterial();
        if (material)
          material.smooth = state.object.smooth;
      } else {
        if (line === "\0")
          continue;
        console.warn('THREE.OBJLoader: Unexpected line: "' + line + '"');
      }
    }
    state.finalize();
    const container = new Group();
    container.materialLibraries = [].concat(state.materialLibraries);
    const hasPrimitives = !(state.objects.length === 1 && state.objects[0].geometry.vertices.length === 0);
    if (hasPrimitives === true) {
      for (let i2 = 0, l2 = state.objects.length; i2 < l2; i2++) {
        const object = state.objects[i2];
        const geometry2 = object.geometry;
        const materials = object.materials;
        const isLine = geometry2.type === "Line";
        const isPoints = geometry2.type === "Points";
        let hasVertexColors = false;
        if (geometry2.vertices.length === 0)
          continue;
        const buffergeometry = new BufferGeometry();
        buffergeometry.setAttribute("position", new Float32BufferAttribute(geometry2.vertices, 3));
        if (geometry2.normals.length > 0) {
          buffergeometry.setAttribute("normal", new Float32BufferAttribute(geometry2.normals, 3));
        }
        if (geometry2.colors.length > 0) {
          hasVertexColors = true;
          buffergeometry.setAttribute("color", new Float32BufferAttribute(geometry2.colors, 3));
        }
        if (geometry2.hasUVIndices === true) {
          buffergeometry.setAttribute("uv", new Float32BufferAttribute(geometry2.uvs, 2));
        }
        const createdMaterials = [];
        for (let mi2 = 0, miLen = materials.length; mi2 < miLen; mi2++) {
          const sourceMaterial = materials[mi2];
          const materialHash = sourceMaterial.name + "_" + sourceMaterial.smooth + "_" + hasVertexColors;
          let material = state.materials[materialHash];
          if (this.materials !== null) {
            material = this.materials.create(sourceMaterial.name);
            if (isLine && material && !(material instanceof LineBasicMaterial)) {
              const materialLine = new LineBasicMaterial();
              Material.prototype.copy.call(materialLine, material);
              materialLine.color.copy(material.color);
              material = materialLine;
            } else if (isPoints && material && !(material instanceof PointsMaterial)) {
              const materialPoints = new PointsMaterial({ size: 10, sizeAttenuation: false });
              Material.prototype.copy.call(materialPoints, material);
              materialPoints.color.copy(material.color);
              materialPoints.map = material.map;
              material = materialPoints;
            }
          }
          if (material === void 0) {
            if (isLine) {
              material = new LineBasicMaterial();
            } else if (isPoints) {
              material = new PointsMaterial({ size: 1, sizeAttenuation: false });
            } else {
              material = new MeshPhongMaterial();
            }
            material.name = sourceMaterial.name;
            material.flatShading = sourceMaterial.smooth ? false : true;
            material.vertexColors = hasVertexColors;
            state.materials[materialHash] = material;
          }
          createdMaterials.push(material);
        }
        let mesh;
        if (createdMaterials.length > 1) {
          for (let mi2 = 0, miLen = materials.length; mi2 < miLen; mi2++) {
            const sourceMaterial = materials[mi2];
            buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi2);
          }
          if (isLine) {
            mesh = new LineSegments(buffergeometry, createdMaterials);
          } else if (isPoints) {
            mesh = new Points(buffergeometry, createdMaterials);
          } else {
            mesh = new Mesh(buffergeometry, createdMaterials);
          }
        } else {
          if (isLine) {
            mesh = new LineSegments(buffergeometry, createdMaterials[0]);
          } else if (isPoints) {
            mesh = new Points(buffergeometry, createdMaterials[0]);
          } else {
            mesh = new Mesh(buffergeometry, createdMaterials[0]);
          }
        }
        mesh.name = object.name;
        container.add(mesh);
      }
    } else {
      if (state.vertices.length > 0) {
        const material = new PointsMaterial({ size: 1, sizeAttenuation: false });
        const buffergeometry = new BufferGeometry();
        buffergeometry.setAttribute("position", new Float32BufferAttribute(state.vertices, 3));
        if (state.colors.length > 0 && state.colors[0] !== void 0) {
          buffergeometry.setAttribute("color", new Float32BufferAttribute(state.colors, 3));
          material.vertexColors = true;
        }
        const points = new Points(buffergeometry, material);
        container.add(points);
      }
    }
    return container;
  }
}
var __awaiter$2 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e20) {
        reject(e20);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e20) {
        reject(e20);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class CKBlob extends SLitComponent {
  constructor() {
    var _a2;
    super({
      litComponent: {
        shadowDom: false
      }
    });
    this._grains = [];
    this._grainsGroups = [];
    this._icons = [];
    this._iconsGroups = [];
    this._start = Date.now();
    this._perlin = __perlin();
    this._isDark = (_a2 = document.body.getAttribute("class")) === null || _a2 === void 0 ? void 0 : _a2.toString().includes("-dark");
    this._postprocessing = {};
  }
  firstUpdated() {
    return __awaiter$2(this, void 0, void 0, function* () {
      this._scene = new Scene();
      this._camera = new PerspectiveCamera(30, this.offsetWidth / this.offsetHeight, 1, 1e4);
      this._camera.position.z = 50;
      this._renderer = new WebGLRenderer({
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        format: RGBAFormat,
        alpha: true,
        antialias: true
      });
      this._renderer.autoClear = false;
      this._renderer.setSize(this.offsetWidth, this.offsetHeight);
      this._renderer.setPixelRatio(window.devicePixelRatio);
      this._renderer.shadowMap.enabled = true;
      this._renderer.shadowMap.type = PCFSoftShadowMap;
      this.querySelector(".ck-blob").appendChild(this._renderer.domElement);
      this._envMap = yield this.loadEnvMap();
      let backLight;
      if (this._isDark) {
        backLight = new PointLight(16777215, 0.5);
        backLight.position.set(8, 8, -10);
      } else {
        backLight = new PointLight(16777215, 2);
        backLight.position.set(8, 8, -10);
      }
      const light = new DirectionalLight(16763927, 0.1, 100);
      light.position.set(0, 40, 0);
      light.castShadow = false;
      light.shadow.mapSize.width = 1024;
      light.shadow.mapSize.height = 1024;
      light.shadow.camera.near = 0.5;
      light.shadow.camera.far = 500;
      light.shadow.camera.left = -50;
      light.shadow.camera.right = 50;
      light.shadow.camera.top = 50;
      light.shadow.camera.bottom = -50;
      const sphere = yield this.createSphere();
      yield this.addGrains();
      const planeGeometry = new PlaneGeometry(20, 20, 32, 32);
      const planeMaterial = new ShadowMaterial({
        opacity: 0.1
      });
      const plane = new Mesh(planeGeometry, planeMaterial);
      plane.receiveShadow = true;
      plane.position.set(0, -12, 0);
      plane.rotation.x = Math.PI / 2 * -1;
      var ambientLight;
      if (this._isDark) {
        ambientLight = new AmbientLight(16777215, 0.3);
      } else {
        ambientLight = new AmbientLight(16777215, 0.3);
      }
      new CameraHelper(light.shadow.camera);
      const pointsSphere1 = this.createPointsSphere(this._isDark ? 16777215 : 0, 0, 0.1);
      pointsSphere1.scale.set(9, 9, 9);
      this._pointSpheres = [pointsSphere1];
      if (this._isDark) {
        this._scene.add(backLight);
      }
      this._scene.add(light);
      this._scene.add(ambientLight);
      this._scene.add(sphere);
      this._pointSpheres.forEach((s2) => this._scene.add(s2));
      this.initPostprocessing();
      this.animate();
    });
  }
  initPostprocessing() {
    const renderPass = new RenderPass(this._scene, this._camera);
    const composer = new EffectComposer(this._renderer);
    composer.addPass(renderPass);
    composer.addPass(new EffectPass(this._camera, new OutlineEffect(this._scene, this._camera)));
    composer.addPass(new EffectPass(this._camera, new GlitchEffect({
      delay: new Vector2(5, 15),
      duration: new Vector2(0.05, 0.2),
      ratio: 0.1,
      strengh: new Vector2(0.01, 0.02)
    })));
    this._composer = composer;
  }
  addControls() {
    this._controls = new OrbitControls(this._camera, this._renderer.domElement);
    this._controls.update();
  }
  addGrains() {
    return __awaiter$2(this, void 0, void 0, function* () {
      const grain = yield this.loadCoffeeGrain();
      grain.castShadow = true;
      grain.receiveShadow = true;
      this._grains = [];
      this._grainsGroups = [];
      this._grainsGroup = new Group();
      const yellowMaterial = yield this.createGrainMaterial("/src/3d/coffeeGrain/grain-yellow.jpg");
      const purpleMaterial = yield this.createGrainMaterial("/src/3d/coffeeGrain/grain-purple.jpg");
      const materials = [yellowMaterial, purpleMaterial];
      const count = 12;
      for (let i2 = 0; i2 < count; i2++) {
        const newGrain = grain.clone();
        newGrain.position.set(0, 0, -0.3);
        newGrain.traverse(function(child) {
          if (child instanceof Mesh) {
            child.material = materials[i2 <= count / 2 ? 0 : 1];
          }
        });
        const group = new Group();
        group.add(newGrain);
        group.rotation.set(Math.random() * 360, Math.random() * 360, Math.random() * 360);
        newGrain.position.x = 7 + Math.random() * 4;
        const scale = 5e-3 + Math.random() / 100 * 2;
        newGrain.scale.set(scale, scale, scale);
        newGrain.castShadow = true;
        this._grains.push(newGrain);
        this._grainsGroups.push(group);
        this._scene.add(group);
      }
      return this._grainsGroup;
    });
  }
  createSphere() {
    return __awaiter$2(this, void 0, void 0, function* () {
      let texture;
      let matSettings;
      if (this._isDark) {
        texture = yield this.loadTexture("/src/3d/ck-texture.jpg");
        matSettings = {
          clearcoat: 0,
          clearcoatRoughness: 0,
          metalness: 0,
          roughness: 0.6,
          color: 16777215
        };
      } else {
        texture = yield this.loadTexture("/src/3d/ck-texture-light.jpg");
        matSettings = {
          clearcoat: 0,
          clearcoatRoughness: 0,
          metalness: 0,
          roughness: 0.6,
          color: 16777215
        };
      }
      yield this.loadTexture("/src/3d/ck-roughness.jpg");
      const ballMaterial = Object.assign(Object.assign({}, matSettings), { map: texture, envMap: this._envMap.texture });
      const ballMat = new MeshStandardMaterial(ballMaterial);
      const geom = new SphereGeometry(1, 64, 64);
      this._sphere = new Mesh(geom, ballMat);
      this._sphere.scale.set(4, 4, 4);
      this._sphere.receiveShadow = true;
      this._sphere.castShadow = true;
      return this._sphere;
    });
  }
  createIconSphere(texturePath) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const texture = yield this.loadTexture(texturePath);
      const ballMaterial = {
        clearcoat: 0.1,
        clearcoatRoughness: 0,
        metalness: 0,
        roughness: 0.5,
        color: 16777215,
        map: texture,
        envMap: this._envMap.texture
      };
      const ballMat = new MeshPhysicalMaterial(ballMaterial);
      const geom = new SphereGeometry(1, 32, 32);
      const sphere = new Mesh(geom, ballMat);
      const scale = 0.3 + Math.random() * 0.5;
      sphere.scale.set(scale, scale, scale);
      sphere.position.x = 6;
      sphere.receiveShadow = true;
      sphere.castShadow = true;
      const group = new Group();
      group.add(sphere);
      this._icons.push(sphere);
      this._iconsGroups.push(group);
      return group;
    });
  }
  createPointsSphere(color2, minAlpha = 0, maxAlpha = 1) {
    const numVertices = this._sphere.geometry.attributes.position.count;
    var alphas = new Float32Array(numVertices * 1);
    for (var i2 = 0; i2 < numVertices; i2++) {
      alphas[i2] = minAlpha / (this._isDark ? 2 : 5) + Math.random() * maxAlpha / (this._isDark ? 2 : 5);
    }
    const vertexShader = `attribute float alpha;
    varying float vAlpha;

    void main() {
      vAlpha = alpha;
      vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
      gl_PointSize = 2.0;
      gl_Position = projectionMatrix * mvPosition;
    }`, fragmentShader = `uniform vec3 color;
    varying float vAlpha;

    void main() {
      gl_FragColor = vec4( color, vAlpha );
    }`;
    const ballMat = new MeshBasicMaterial({
      color: this._isDark ? 16777215 : 0
    });
    const geom = new SphereGeometry(1, 32, 32);
    const sphere = new Mesh(geom, ballMat);
    sphere.geometry.setAttribute("alpha", new BufferAttribute(alphas, 1));
    var shaderMaterial = new ShaderMaterial({
      uniforms: {
        color: { value: new Color(color2) }
      },
      vertexShader,
      fragmentShader,
      transparent: true
    });
    const cloud = new Points(sphere.geometry, shaderMaterial);
    cloud._object = sphere;
    return cloud;
  }
  loadTexture(path2) {
    return new Promise((resolve2) => {
      new TextureLoader().load(path2, (texture) => {
        resolve2(texture);
      });
    });
  }
  createGrainMaterial(texturePath) {
    return new Promise((resolve2) => __awaiter$2(this, void 0, void 0, function* () {
      const texture = yield this.loadTexture(texturePath);
      yield this.loadTexture("/src/3d/coffeeGrain/coffeeGrainBumpMap.jpg");
      let grainMat = new MeshStandardMaterial({
        clearcoat: 1,
        clearcoatRoughness: 1,
        metalness: 0,
        roughness: 1,
        color: 16777215,
        map: texture,
        envMap: this._envMap.texture
      });
      resolve2(grainMat);
    }));
  }
  loadCoffeeGrain() {
    return new Promise((resolve2) => {
      new OBJLoader().load("/src/3d/coffeeGrain/coffeeGrain.obj", (object) => {
        object.castShadow = true;
        object.scale.set(0.01, 0.01, 0.01);
        object.position.set(0, 0, 0);
        resolve2(object);
      });
    });
  }
  updateGeometryOf(object, k2 = 0.6, amount = 5e-4) {
    if (object._object)
      object = object._object;
    var time = performance.now() * amount;
    var positions = object.geometry.attributes.position.array;
    for (var i2 = 0; i2 < positions.length; i2 += 3) {
      const v2 = new Vector3(positions[i2], positions[i2 + 1], positions[i2 + 2]);
      v2.normalize().multiplyScalar(1 + 0.3 * this._perlin.perlin3(v2.x * k2 + time, v2.y * k2, v2.z * k2));
      positions[i2] = v2.x;
      positions[i2 + 1] = v2.y;
      positions[i2 + 2] = v2.z;
    }
    object.geometry.computeVertexNormals();
    object.geometry.normalsNeedUpdate = true;
    object.geometry.verticesNeedUpdate = true;
  }
  loadEnvMap() {
    return new Promise((resolve2) => {
      let envmaploader = new PMREMGenerator(this._renderer);
      new RGBELoader().setPath("/src/3d/").load("HDRI_STUDIO_vol2_030.hdr", function(hdrmap) {
        let envmap = envmaploader.fromCubemap(hdrmap);
        resolve2(envmap);
      });
    });
  }
  animate() {
    var _a2, _b2;
    if (!this.componentUtils.isInViewport) {
      setTimeout(() => {
        this.animate();
      }, 100);
      return;
    }
    this.updateGeometryOf(this._sphere, 1.4);
    this._pointSpheres.forEach((p2) => {
      this.updateGeometryOf(p2, 8, 1e-4);
      p2.geometry.attributes.alpha.needsUpdate = true;
      p2.geometry.attributes.position.needsUpdate = true;
      if (!p2._speed)
        p2._speed = Math.random() / 1e3 / 8;
      p2.rotation.x -= p2._speed;
      p2.rotation.y -= p2._speed;
      p2.rotation.z -= p2._speed;
    });
    this._sphere.rotation.y += 3e-3;
    this._grains.forEach((grain) => {
      if (!grain._speed)
        grain._speed = 3e-3 + Math.random() / 100;
      grain.rotation.x += grain._speed;
      grain.rotation.y += grain._speed;
      grain.rotation.z += grain._speed;
    });
    this._grainsGroups.forEach((group) => {
      if (!group._speed)
        group._speed = 1e-3 + Math.random() / 100 / 2;
      group.rotation.x += group._speed;
      group.rotation.y += group._speed;
      group.rotation.z += group._speed;
    });
    requestAnimationFrame(this.animate.bind(this));
    (_b2 = (_a2 = this._controls) === null || _a2 === void 0 ? void 0 : _a2.update) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
    this._composer.render();
  }
  render() {
    return html$2`
            <div class="ck-blob">
                <canvas class="blob-perlin"></canvas>
            </div>
        `;
  }
}
function define$3(props = {}, tagName = "ck-blob") {
  SLitComponent.setDefaultProps(tagName, props);
  customElements.define(tagName, CKBlob);
}
var requiresPort = function required2(port, protocol) {
  protocol = protocol.split(":")[0];
  port = +port;
  if (!port)
    return false;
  switch (protocol) {
    case "http":
    case "ws":
      return port !== 80;
    case "https":
    case "wss":
      return port !== 443;
    case "ftp":
      return port !== 21;
    case "gopher":
      return port !== 70;
    case "file":
      return false;
  }
  return port !== 0;
};
var querystringify$1 = {};
var has = Object.prototype.hasOwnProperty, undef;
function decode(input) {
  try {
    return decodeURIComponent(input.replace(/\+/g, " "));
  } catch (e20) {
    return null;
  }
}
function encode(input) {
  try {
    return encodeURIComponent(input);
  } catch (e20) {
    return null;
  }
}
function querystring(query2) {
  var parser = /([^=?#&]+)=?([^&]*)/g, result = {}, part;
  while (part = parser.exec(query2)) {
    var key = decode(part[1]), value = decode(part[2]);
    if (key === null || value === null || key in result)
      continue;
    result[key] = value;
  }
  return result;
}
function querystringify(obj2, prefix) {
  prefix = prefix || "";
  var pairs = [], value, key;
  if (typeof prefix !== "string")
    prefix = "?";
  for (key in obj2) {
    if (has.call(obj2, key)) {
      value = obj2[key];
      if (!value && (value === null || value === undef || isNaN(value))) {
        value = "";
      }
      key = encode(key);
      value = encode(value);
      if (key === null || value === null)
        continue;
      pairs.push(key + "=" + value);
    }
  }
  return pairs.length ? prefix + pairs.join("&") : "";
}
querystringify$1.stringify = querystringify;
querystringify$1.parse = querystring;
var required = requiresPort, qs = querystringify$1, slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//, protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i, windowsDriveLetter = /^[a-zA-Z]:/, whitespace = "[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]", left = new RegExp("^" + whitespace + "+");
function trimLeft(str) {
  return (str ? str : "").toString().replace(left, "");
}
var rules = [
  ["#", "hash"],
  ["?", "query"],
  function sanitize(address, url) {
    return isSpecial(url.protocol) ? address.replace(/\\/g, "/") : address;
  },
  ["/", "pathname"],
  ["@", "auth", 1],
  [NaN, "host", void 0, 1, 1],
  [/:(\d+)$/, "port", void 0, 1],
  [NaN, "hostname", void 0, 1, 1]
];
var ignore = { hash: 1, query: 1 };
function lolcation(loc) {
  var globalVar;
  if (typeof window !== "undefined")
    globalVar = window;
  else if (typeof commonjsGlobal !== "undefined")
    globalVar = commonjsGlobal;
  else if (typeof self !== "undefined")
    globalVar = self;
  else
    globalVar = {};
  var location = globalVar.location || {};
  loc = loc || location;
  var finaldestination = {}, type = typeof loc, key;
  if (loc.protocol === "blob:") {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if (type === "string") {
    finaldestination = new Url(loc, {});
    for (key in ignore)
      delete finaldestination[key];
  } else if (type === "object") {
    for (key in loc) {
      if (key in ignore)
        continue;
      finaldestination[key] = loc[key];
    }
    if (finaldestination.slashes === void 0) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }
  return finaldestination;
}
function isSpecial(scheme) {
  return scheme === "file:" || scheme === "ftp:" || scheme === "http:" || scheme === "https:" || scheme === "ws:" || scheme === "wss:";
}
function extractProtocol(address, location) {
  address = trimLeft(address);
  location = location || {};
  var match5 = protocolre.exec(address);
  var protocol = match5[1] ? match5[1].toLowerCase() : "";
  var forwardSlashes = !!match5[2];
  var otherSlashes = !!match5[3];
  var slashesCount = 0;
  var rest;
  if (forwardSlashes) {
    if (otherSlashes) {
      rest = match5[2] + match5[3] + match5[4];
      slashesCount = match5[2].length + match5[3].length;
    } else {
      rest = match5[2] + match5[4];
      slashesCount = match5[2].length;
    }
  } else {
    if (otherSlashes) {
      rest = match5[3] + match5[4];
      slashesCount = match5[3].length;
    } else {
      rest = match5[4];
    }
  }
  if (protocol === "file:") {
    if (slashesCount >= 2) {
      rest = rest.slice(2);
    }
  } else if (isSpecial(protocol)) {
    rest = match5[4];
  } else if (protocol) {
    if (forwardSlashes) {
      rest = rest.slice(2);
    }
  } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
    rest = match5[4];
  }
  return {
    protocol,
    slashes: forwardSlashes || isSpecial(protocol),
    slashesCount,
    rest
  };
}
function resolve(relative, base) {
  if (relative === "")
    return base;
  var path2 = (base || "/").split("/").slice(0, -1).concat(relative.split("/")), i2 = path2.length, last = path2[i2 - 1], unshift = false, up2 = 0;
  while (i2--) {
    if (path2[i2] === ".") {
      path2.splice(i2, 1);
    } else if (path2[i2] === "..") {
      path2.splice(i2, 1);
      up2++;
    } else if (up2) {
      if (i2 === 0)
        unshift = true;
      path2.splice(i2, 1);
      up2--;
    }
  }
  if (unshift)
    path2.unshift("");
  if (last === "." || last === "..")
    path2.push("");
  return path2.join("/");
}
function Url(address, location, parser) {
  address = trimLeft(address);
  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }
  var relative, extracted, parse2, instruction, index, key, instructions = rules.slice(), type = typeof location, url = this, i2 = 0;
  if (type !== "object" && type !== "string") {
    parser = location;
    location = null;
  }
  if (parser && typeof parser !== "function")
    parser = qs.parse;
  location = lolcation(location);
  extracted = extractProtocol(address || "", location);
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || "";
  address = extracted.rest;
  if (extracted.protocol === "file:" && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url.protocol))) {
    instructions[3] = [/(.*)/, "pathname"];
  }
  for (; i2 < instructions.length; i2++) {
    instruction = instructions[i2];
    if (typeof instruction === "function") {
      address = instruction(address, url);
      continue;
    }
    parse2 = instruction[0];
    key = instruction[1];
    if (parse2 !== parse2) {
      url[key] = address;
    } else if (typeof parse2 === "string") {
      if (~(index = address.indexOf(parse2))) {
        if (typeof instruction[2] === "number") {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if (index = parse2.exec(address)) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }
    url[key] = url[key] || (relative && instruction[3] ? location[key] || "" : "");
    if (instruction[4])
      url[key] = url[key].toLowerCase();
  }
  if (parser)
    url.query = parser(url.query);
  if (relative && location.slashes && url.pathname.charAt(0) !== "/" && (url.pathname !== "" || location.pathname !== "")) {
    url.pathname = resolve(url.pathname, location.pathname);
  }
  if (url.pathname.charAt(0) !== "/" && isSpecial(url.protocol)) {
    url.pathname = "/" + url.pathname;
  }
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = "";
  }
  url.username = url.password = "";
  if (url.auth) {
    instruction = url.auth.split(":");
    url.username = instruction[0] || "";
    url.password = instruction[1] || "";
  }
  url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
  url.href = url.toString();
}
function set(part, value, fn2) {
  var url = this;
  switch (part) {
    case "query":
      if (typeof value === "string" && value.length) {
        value = (fn2 || qs.parse)(value);
      }
      url[part] = value;
      break;
    case "port":
      url[part] = value;
      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = "";
      } else if (value) {
        url.host = url.hostname + ":" + value;
      }
      break;
    case "hostname":
      url[part] = value;
      if (url.port)
        value += ":" + url.port;
      url.host = value;
      break;
    case "host":
      url[part] = value;
      if (/:\d+$/.test(value)) {
        value = value.split(":");
        url.port = value.pop();
        url.hostname = value.join(":");
      } else {
        url.hostname = value;
        url.port = "";
      }
      break;
    case "protocol":
      url.protocol = value.toLowerCase();
      url.slashes = !fn2;
      break;
    case "pathname":
    case "hash":
      if (value) {
        var char = part === "pathname" ? "/" : "#";
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;
    default:
      url[part] = value;
  }
  for (var i2 = 0; i2 < rules.length; i2++) {
    var ins = rules[i2];
    if (ins[4])
      url[ins[1]] = url[ins[1]].toLowerCase();
  }
  url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
  url.href = url.toString();
  return url;
}
function toString$1(stringify2) {
  if (!stringify2 || typeof stringify2 !== "function")
    stringify2 = qs.stringify;
  var query2, url = this, protocol = url.protocol;
  if (protocol && protocol.charAt(protocol.length - 1) !== ":")
    protocol += ":";
  var result = protocol + (url.slashes || isSpecial(url.protocol) ? "//" : "");
  if (url.username) {
    result += url.username;
    if (url.password)
      result += ":" + url.password;
    result += "@";
  }
  result += url.host + url.pathname;
  query2 = typeof url.query === "object" ? stringify2(url.query) : url.query;
  if (query2)
    result += query2.charAt(0) !== "?" ? "?" + query2 : query2;
  if (url.hash)
    result += url.hash;
  return result;
}
Url.prototype = { set, toString: toString$1 };
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.trimLeft = trimLeft;
Url.qs = qs;
var urlParse = Url;
function ease(t2) {
  return t2 < 0.5 ? 2 * t2 * t2 : -1 + (4 - 2 * t2) * t2;
}
var requestAnimationFrame$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
let isUserScrolling = false;
let userScrollingTimeout;
let isScrollingHappening = false;
document.addEventListener("mousewheel", (e20) => {
  if (!isScrollingHappening)
    return;
  isUserScrolling = true;
  clearTimeout(userScrollingTimeout);
  userScrollingTimeout = setTimeout(() => {
    isUserScrolling = false;
  }, 200);
});
function scrollTo(target, settings = {}) {
  return new Promise((resolve2, reject) => {
    settings = Object.assign({ duration: 500, easing: ease, offset: 0, align: "top", onFinish: null }, settings);
    const docElem = document.documentElement;
    const windowHeight = window.innerHeight;
    const maxScroll = docElem.scrollHeight - windowHeight;
    const currentY = window.pageYOffset;
    isScrollingHappening = true;
    let targetY = currentY;
    const elementBounds = isNaN(target) ? target.getBoundingClientRect() : 0;
    if (settings.align === "center") {
      targetY += elementBounds.top + elementBounds.height / 2;
      targetY -= windowHeight / 2;
      targetY -= settings.offset;
    } else if (settings.align === "bottom") {
      targetY += elementBounds.bottom;
      targetY -= windowHeight;
      targetY += settings.offset;
    } else {
      targetY += elementBounds.top;
      targetY -= settings.offset;
    }
    targetY = Math.max(Math.min(maxScroll, targetY), 0);
    const deltaY = targetY - currentY;
    const obj2 = {
      targetY,
      deltaY,
      duration: settings.duration,
      easing: settings.easing,
      onFinish() {
        settings.onFinish && settings.onFinish();
        resolve2();
      },
      startTime: Date.now(),
      lastY: currentY,
      step: scrollTo.step
    };
    requestAnimationFrame$1(obj2.step.bind(obj2));
  });
}
scrollTo.step = function() {
  if (this.lastY !== window.pageYOffset && this.onFinish) {
    isScrollingHappening = false;
    this.onFinish();
    return;
  }
  const t2 = Math.min((Date.now() - this.startTime) / this.duration, 1);
  const y2 = this.targetY - (1 - this.easing(t2)) * this.deltaY;
  window.scrollTo(window.scrollX, y2);
  if (t2 !== 1 && !isUserScrolling) {
    this.lastY = window.pageYOffset;
    requestAnimationFrame$1(this.step.bind(this));
  } else {
    isScrollingHappening = false;
    if (this.onFinish)
      this.onFinish();
  }
};
function smoothScrollOnAnchorLinks(settings = {}) {
  settings = __deepMerge$7({
    scroll: {},
    checkPathNames: true
  }, settings);
  querySelectorLive('a:not([is])[href*="#"]', ($link) => {
    $link.addEventListener("click", (e20) => {
      const linkUrl = urlParse($link.getAttribute("href"));
      const currentUrl = urlParse();
      if (!linkUrl.hash || linkUrl.hash === "#")
        return;
      if (settings.checkPathNames && currentUrl.pathname !== linkUrl.pathname)
        return;
      const $target = document.querySelector(linkUrl.hash);
      if (!$target)
        return;
      e20.preventDefault();
      history.pushState({}, null, linkUrl.hash);
      scrollTo($target, settings.scroll);
    });
  });
}
function scrollToLocationHash(settings = {}) {
  settings = __deepMerge$7({
    scroll: {}
  }, settings);
  const hash = document.location.hash;
  if (!hash)
    return;
  const targetElm = document.querySelector(hash);
  if (!targetElm)
    return;
  if ("scrollRestoration" in history) {
    history.scrollRestoration = "manual";
  }
  return scrollTo(targetElm, settings.scroll);
}
function smoothScrollOnPageLoad(settings = {}) {
  settings = __deepMerge$7({
    scroll: {}
  }, settings);
  scrollToLocationHash(settings);
}
function smoothScrollOnHashChange(settings = {}) {
  settings = __deepMerge$7({
    scroll: {}
  }, settings);
  window.addEventListener("hashchange", (e20) => {
    scrollToLocationHash(settings);
  });
}
function smoothScroll(settings = {}) {
  settings = __deepMerge$7({
    scroll: {}
  }, settings);
  smoothScrollOnPageLoad(settings);
  smoothScrollOnAnchorLinks(settings);
  smoothScrollOnHashChange(settings);
}
function linksStateAttributes(settings = {}) {
  settings = __deepMerge$7({}, settings);
  function handleLink($linkElm) {
    if ($linkElm.getAttribute("href") === document.location.pathname) {
      $linkElm.setAttribute("actual", true);
    } else if ($linkElm.getAttribute("href").startsWith(document.location.pathname)) {
      $linkElm.removeAttribute("actual");
      $linkElm.setAttribute("actual-child", true);
    } else {
      $linkElm.removeAttribute("actual");
      $linkElm.removeAttribute("actual-child");
    }
  }
  querySelectorLive(`[href]`, ($linkElm) => {
    handleLink($linkElm);
  });
  window.addEventListener("locationchange", () => {
    Array.from(document.querySelectorAll("[href]")).forEach(($linkElm) => {
      handleLink($linkElm);
    });
  });
}
var __awaiter$1 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e20) {
        reject(e20);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e20) {
        reject(e20);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SFeature extends SClass {
  constructor(name2, node, settings = {}) {
    var _a2;
    super(__deepMerge$7({
      componentUtils: {},
      feature: {}
    }, settings));
    this.componentUtils = new SComponent(node, node.attributes, {
      componentUtils: Object.assign(Object.assign({}, (_a2 = this._settings.componentUtils) !== null && _a2 !== void 0 ? _a2 : {}), { name: name2 })
    });
    this.props = this.componentUtils.props;
    this.name = name2;
    this.node = node;
    (() => __awaiter$1(this, void 0, void 0, function* () {
      var _b2;
      yield this.componentUtils.waitOnMountState();
      yield (_b2 = this.mount) === null || _b2 === void 0 ? void 0 : _b2.call(this);
    }))();
  }
  static setDefaultProps(selector, props) {
    SComponent.setDefaultProps(selector, props);
  }
  static defineFeature(name2, feature, defaultProps = {}) {
    this.setDefaultProps(name2, defaultProps);
    querySelectorLive(`[${name2}]`, ($elm) => {
      new feature(name2, $elm, SComponent.getDefaultProps(name2));
    });
  }
  get featureSettings() {
    return this._settings.feature;
  }
}
class SActivateFeatureInterface extends SInterface {
  static get _definition() {
    return {
      href: {
        description: "Specify the target element(s) to activate/unactivate",
        type: "String",
        default: ""
      },
      group: {
        description: "Specify a group id for your element. This is used for things like tabs, etc...",
        type: "String"
      },
      toggle: {
        description: "Specify if you want to be able to click on the same element to activate/unactivate it.",
        type: {
          type: "Boolean",
          nullishAsTrue: true
        },
        default: false
      },
      history: {
        description: "Specify if you want to store and react to history hash changes",
        type: {
          type: "Boolean",
          nullishAsTrue: true
        },
        default: false
      },
      active: {
        description: "Specify the initial state of your element",
        type: {
          type: "Boolean",
          nullishAsTrue: true
        },
        default: false,
        physical: true
      },
      activeClass: {
        description: 'Specify the class applied on target(s) when active. Default is "active"',
        type: "String",
        default: "active"
      },
      activeAttribute: {
        description: "Specify the attribute name applied on target(s) when active.",
        type: "String",
        default: "active"
      },
      saveState: {
        description: "Specify if you want to save state in localStorage to restore it on page reload, etc...",
        type: "Boolean",
        default: false
      },
      activateTimeout: {
        description: "Specify a timeout before actiavting the target(s)",
        type: "Number",
        default: 0
      },
      unactivateTimeout: {
        description: "Specify a timeout before unactivate the target(s)",
        type: "Number",
        default: 0
      },
      trigger: {
        description: 'Specify what trigger an activate/unactivate action. Can be "click", "mouseover", "mouseout" and/or "anchor"',
        type: {
          type: "Array<String>",
          splitChars: [","]
        },
        values: [
          "click",
          "mouseover",
          "mouseenter",
          "mouseout",
          "mouseleave",
          "anchor"
        ],
        default: ["click"]
      }
    };
  }
}
var __awaiter = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e20) {
        reject(e20);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e20) {
        reject(e20);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SActivateFeature extends SFeature {
  constructor(name2, node, settings) {
    super(name2, node, __deepMerge$7({
      componentUtils: {
        interface: SActivateFeatureInterface
      },
      feature: {}
    }, settings !== null && settings !== void 0 ? settings : {}));
    this.componentUtils.exposeApi({
      activate: this.activate,
      unactivate: this.unactivate,
      isActive: this.isActive
    }, this);
  }
  mount() {
    if (this.props.saveState) {
      if (!this.props.id)
        throw new Error(`<red>[s-activate]</red> In order to use the "<yellow>saveState</yellow>" property, you MUST specify an "<cyan>id</cyan>" on your s-activate component`);
      if (localStorage.getItem(`s-activate-state-${this.saveStateId}`) === this.props.id) {
        this.props.active = true;
      } else {
        this.props.active = false;
      }
    }
    if (this.props.href) {
      this._hrefSelector = this.props.href;
    }
    let targets;
    if (this._hrefSelector)
      targets = Array.from(document.querySelectorAll(this._hrefSelector));
    if (targets === null || targets === void 0 ? void 0 : targets.length)
      this._$targets = targets;
    if (this.props.group) {
      this._$groupElements = Array.from(document.querySelectorAll(`[${this.name}][group="${this.props.group}"]`));
    }
    this.props.trigger.forEach((trigger) => {
      switch (trigger) {
        case "click":
          this.node.addEventListener("click", (e20) => {
            if (this.isActive() && this.props.toggle) {
              this.unactivate();
            } else {
              this.activate();
            }
          });
          break;
        case "mousenter":
        case "mouseover":
          this.node.addEventListener("mouseover", (e20) => {
            this.activate();
          });
          break;
        case "mouseout":
        case "mouseleave":
          this.node.addEventListener("mouseleave", (e20) => {
            this.unactivate();
          });
          break;
        case "anchor":
          if (document.location.hash === this._hrefSelector) {
            this.activate();
          }
          window.addEventListener("hashchange", (e20) => {
            if (document.location.hash === this._hrefSelector) {
              this.activate();
            }
          });
          break;
      }
    });
    if (this.props.active) {
      this.activate(true);
    }
  }
  get saveStateId() {
    return this.props.group ? `group-${this.props.group}` : this.props.id;
  }
  isActive() {
    return this.node.hasAttribute("active");
  }
  activate(force = false) {
    return __awaiter(this, void 0, void 0, function* () {
      clearTimeout(this._unactivateTimeout);
      if (!force && this.isActive())
        return;
      setTimeout(() => {
        if (this.props.saveState) {
          if (!this.props.id)
            throw new Error(`<red>[s-activate]</red> In order to use the "<yellow>saveState</yellow>" property, you MUST specify an "<cyan>id</cyan>" on your s-activate component`);
          localStorage.setItem(`s-activate-state-${this.saveStateId}`, this.props.id);
        }
        if (this.props.history && this._hrefSelector) {
          document.location.hash = this._hrefSelector;
        }
        if (this._$groupElements) {
          this._$groupElements.forEach(($element) => {
            var _a2;
            if ($element === this.node)
              return;
            try {
              (_a2 = $element.unactivate) === null || _a2 === void 0 ? void 0 : _a2.call($element);
            } catch (e20) {
            }
          });
        }
        this.props.active = true;
        if (this._$targets) {
          this._$targets.forEach(($target) => {
            if (this.props.activeClass) {
              $target.classList.add(this.props.activeClass);
            }
            if (this.props.activeAttribute) {
              $target.setAttribute(this.props.activeAttribute, "true");
            }
          });
        }
      }, this.props.activateTimeout);
    });
  }
  unactivate() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.isActive())
        return;
      this._unactivateTimeout = setTimeout(() => {
        if (this.props.saveState) {
          if (!this.props.id)
            throw new Error(`<red>[s-activate]</red> In order to use the "<yellow>saveState</yellow>" property, you MUST specify an "<cyan>id</cyan>" on your s-activate component`);
          localStorage.removeItem(`s-activate-state-${this.props.id}`);
        }
        this.node.removeAttribute("active");
        if (this._$targets) {
          this._$targets.forEach(($target) => {
            if (this.props.activeClass) {
              $target.classList.remove(this.props.activeClass);
            }
            if (this.props.activeAttribute) {
              $target.removeAttribute(this.props.activeAttribute);
            }
          });
        }
      }, this.props.unactivateTimeout);
    });
  }
}
function define$2(props = {}, name2 = "s-activate") {
  SFeature.defineFeature(name2, SActivateFeature, props);
}
class SFormValidateFeatureInterface extends SInterface {
  static get _definition() {
    return {
      type: {
        description: "Specify the validation type. Usually automatically detected depending on the field type",
        type: "String",
        default: "text"
      },
      on: {
        description: 'Specify when to trigger a validation. Can be "change","submit","enter" and/or "reset"',
        type: "Array<String>",
        values: ["change", "submit", "enter", "reset"],
        default: ["change", "submit", "enter", "reset"]
      },
      wrap: {
        description: "Specify if you want to wrap your s-form-validate element when theres an error",
        type: "Boolean",
        default: true
      },
      errorClass: {
        description: "Specify the class to apply when theres an error",
        type: "String",
        default: "s-form-validate s-form-validate--error s-color--error"
      },
      errorMessageClass: {
        description: "Specify the class to apply on the injected error message container",
        type: "String",
        default: "s-form-validate__error-message"
      },
      validClass: {
        description: "Specify the class to apply on your s-form-validate element when validation is passed successfully",
        type: "String",
        default: "s-form-validate s-form-validate--valid s-color--success"
      },
      customValidations: {
        description: "Specify some custom validations [key]: function(value, helpers). For mor info check out the [Joi](https://joi.dev/api/?v=17.4.2#anycustommethod-description) custom validation doc",
        type: "Object",
        default: {}
      },
      joiOptions: {
        description: "Specify some [Joi](https://joi.dev/) options to use for your validation",
        type: "Object",
        default: {}
      },
      language: {
        description: "Specify the language you want to use for messages",
        type: "String",
        default: "fr"
      },
      displayError: {
        description: "Specify if you want to display the error messages or not",
        type: "Boolean",
        default: true
      },
      alphanum: {
        type: "Boolean",
        description: "String: Requires the string value to only contain a-z, A-Z, and 0-9."
      },
      base64: {
        type: "Boolean",
        description: "String: Requires the string value to be a valid base64 string; does not check the decoded value."
      },
      case: {
        type: "String",
        values: ["upper", "lower"],
        description: "String: Sets the required string case"
      },
      creditCard: {
        type: "Boolean",
        description: "String: Requires the number to be a credit card number (Using Luhn Algorithm)."
      },
      dataUri: {
        type: "Boolean",
        description: "String: Requires the string value to be a valid data URI string."
      },
      domain: {
        type: "Boolean|String",
        description: "String: Requires the string value to be a valid domain name."
      },
      email: {
        type: "Boolean|String",
        description: "String: Requires the string value to be a valid email address."
      },
      guid: {
        type: "Boolean|String",
        description: "String: Requires the string value to be a valid GUID."
      },
      hex: {
        type: "Boolean|String",
        description: "String: Requires the string value to be a valid hexadecimal string."
      },
      hostname: {
        type: "Boolean|String",
        description: "String: Requires the string value to be a valid hostname as per RFC1123."
      },
      insensitive: {
        type: "Boolean|String",
        description: "String: Allows the value to match any value in the allowed list or disallowed list in a case insensitive comparison."
      },
      ip: {
        type: "Boolean|String",
        description: "String: Requires the string value to be a valid ip address."
      },
      isoDate: {
        type: "Boolean|String",
        description: "String: Requires the string value to be in valid ISO 8601 date format."
      },
      isoDuration: {
        type: "Boolean|String",
        description: "String: Requires the string value to be in valid ISO 8601 duration format."
      },
      length: {
        type: "Number",
        description: "String: Specifies the exact string length required"
      },
      lowercase: {
        type: "Boolean|String",
        description: "String: Requires the string value to be all lowercase. If the validation convert option is on (enabled by default), the string will be forced to lowercase."
      },
      max: {
        type: "Number",
        description: "String: String: Specifies the maximum number of string characters\nDate: Specifies the latest date allowed\nNumber: Specifies the minimum value"
      },
      min: {
        type: "Number",
        description: "String: String: Specifies the minimum number string characters\nDate: Specifies the oldest date allowed\nNumber: Specifies the minimum value"
      },
      normalize: {
        type: "String",
        description: "String: Requires the string value to be in a Unicode normalized form. If the validation convert option is on (enabled by default), the string will be normalized."
      },
      pattern: {
        type: "String",
        description: "String: a regular expression object the string value must match against. Note that if the pattern is a regular expression, for it to match the entire key name, it must begin with ^ and end with $."
      },
      token: {
        type: "Boolean",
        description: "String: Requires the string value to only contain a-z, A-Z, 0-9, and underscore _."
      },
      trim: {
        type: "Boolean",
        description: "String: Requires the string value to contain no whitespace before or after. If the validation convert option is on (enabled by default), the string will be trimmed."
      },
      truncate: {
        type: "Boolean",
        description: "String: Specifies whether the string.max() limit should be used as a truncation."
      },
      uppercase: {
        type: "Boolean",
        description: "String: Requires the string value to be all uppercase. If the validation convert option is on (enabled by default), the string will be forced to uppercase."
      },
      uri: {
        type: "Boolean|String",
        description: "String: Requires the string value to be a valid RFC 3986 URI."
      },
      greater: {
        type: "String",
        description: "String: Date: Specifies that the value must be greater than date (or a reference)\nNumber: Specifies that the value must be greater than limit or a reference."
      },
      less: {
        type: "String",
        description: "String: Date: Specifies that the value must be less than date (or a reference)\nNumber: Specifies that the value must be less than limit or a reference."
      },
      iso: {
        type: "Boolean",
        description: "Date: Requires the string value to be in valid ISO 8601 date format."
      },
      timestamp: {
        type: "Boolean|String",
        description: "Date: Requires the value to be a timestamp interval from Unix Time"
      },
      integer: {
        type: "Boolean",
        description: "Number: Requires the number to be an integer (no floating point)."
      },
      multiple: {
        type: "Number",
        description: "Number: Specifies that the value must be a multiple of base (or a reference):"
      },
      negative: {
        type: "Boolean",
        description: "Number: Requires the number to be negative"
      },
      port: {
        type: "Boolean",
        description: "Number: Requires the number to be a TCP port, so between 0 and 65535."
      },
      positive: {
        type: "Boolean",
        description: "Number: Requires the number to be positive"
      },
      precision: {
        type: "Number",
        description: "Number: Specifies the maximum number of decimal places"
      },
      unsafe: {
        type: "Boolean",
        description: "Number: By default, numbers must be within JavaScript's safety range (Number.MIN_SAFE_INTEGER & Number.MAX_SAFE_INTEGER), and when given a string, should be converted without loss of information. You can allow unsafe numbers at your own risks by calling number.unsafe()."
      }
    };
  }
}
var joiBrowser_min = { exports: {} };
(function(module2, exports) {
  !function(e20, t2) {
    module2.exports = t2();
  }(self, function() {
    return e20 = { 1238: (e21) => {
      e21.exports = { version: "17.4.2" };
    }, 7629: (e21, t3, r2) => {
      const s2 = r2(375), n2 = r2(8571), a2 = r2(9474), o2 = r2(1687), i2 = r2(8652), l2 = r2(8160), c2 = r2(3292), u2 = r2(6354), f2 = r2(8901), m2 = r2(9708), h2 = r2(6914), d2 = r2(2294), p2 = r2(6133), g2 = r2(1152), y2 = r2(8863), b2 = r2(2036), v2 = { Base: class {
        constructor(e22) {
          this.type = e22, this.$_root = null, this._definition = {}, this._reset();
        }
        _reset() {
          this._ids = new d2.Ids(), this._preferences = null, this._refs = new p2.Manager(), this._cache = null, this._valids = null, this._invalids = null, this._flags = {}, this._rules = [], this._singleRules = new Map(), this.$_terms = {}, this.$_temp = { ruleset: null, whens: {} };
        }
        describe() {
          return s2(typeof m2.describe == "function", "Manifest functionality disabled"), m2.describe(this);
        }
        allow(...e22) {
          return l2.verifyFlat(e22, "allow"), this._values(e22, "_valids");
        }
        alter(e22) {
          s2(e22 && typeof e22 == "object" && !Array.isArray(e22), "Invalid targets argument"), s2(!this._inRuleset(), "Cannot set alterations inside a ruleset");
          const t4 = this.clone();
          t4.$_terms.alterations = t4.$_terms.alterations || [];
          for (const r3 in e22) {
            const n3 = e22[r3];
            s2(typeof n3 == "function", "Alteration adjuster for", r3, "must be a function"), t4.$_terms.alterations.push({ target: r3, adjuster: n3 });
          }
          return t4.$_temp.ruleset = false, t4;
        }
        artifact(e22) {
          return s2(e22 !== void 0, "Artifact cannot be undefined"), s2(!this._cache, "Cannot set an artifact with a rule cache"), this.$_setFlag("artifact", e22);
        }
        cast(e22) {
          return s2(e22 === false || typeof e22 == "string", "Invalid to value"), s2(e22 === false || this._definition.cast[e22], "Type", this.type, "does not support casting to", e22), this.$_setFlag("cast", e22 === false ? void 0 : e22);
        }
        default(e22, t4) {
          return this._default("default", e22, t4);
        }
        description(e22) {
          return s2(e22 && typeof e22 == "string", "Description must be a non-empty string"), this.$_setFlag("description", e22);
        }
        empty(e22) {
          const t4 = this.clone();
          return e22 !== void 0 && (e22 = t4.$_compile(e22, { override: false })), t4.$_setFlag("empty", e22, { clone: false });
        }
        error(e22) {
          return s2(e22, "Missing error"), s2(e22 instanceof Error || typeof e22 == "function", "Must provide a valid Error object or a function"), this.$_setFlag("error", e22);
        }
        example(e22, t4 = {}) {
          return s2(e22 !== void 0, "Missing example"), l2.assertOptions(t4, ["override"]), this._inner("examples", e22, { single: true, override: t4.override });
        }
        external(e22, t4) {
          return typeof e22 == "object" && (s2(!t4, "Cannot combine options with description"), t4 = e22.description, e22 = e22.method), s2(typeof e22 == "function", "Method must be a function"), s2(t4 === void 0 || t4 && typeof t4 == "string", "Description must be a non-empty string"), this._inner("externals", { method: e22, description: t4 }, { single: true });
        }
        failover(e22, t4) {
          return this._default("failover", e22, t4);
        }
        forbidden() {
          return this.presence("forbidden");
        }
        id(e22) {
          return e22 ? (s2(typeof e22 == "string", "id must be a non-empty string"), s2(/^[^\.]+$/.test(e22), "id cannot contain period character"), this.$_setFlag("id", e22)) : this.$_setFlag("id", void 0);
        }
        invalid(...e22) {
          return this._values(e22, "_invalids");
        }
        label(e22) {
          return s2(e22 && typeof e22 == "string", "Label name must be a non-empty string"), this.$_setFlag("label", e22);
        }
        meta(e22) {
          return s2(e22 !== void 0, "Meta cannot be undefined"), this._inner("metas", e22, { single: true });
        }
        note(...e22) {
          s2(e22.length, "Missing notes");
          for (const t4 of e22)
            s2(t4 && typeof t4 == "string", "Notes must be non-empty strings");
          return this._inner("notes", e22);
        }
        only(e22 = true) {
          return s2(typeof e22 == "boolean", "Invalid mode:", e22), this.$_setFlag("only", e22);
        }
        optional() {
          return this.presence("optional");
        }
        prefs(e22) {
          s2(e22, "Missing preferences"), s2(e22.context === void 0, "Cannot override context"), s2(e22.externals === void 0, "Cannot override externals"), s2(e22.warnings === void 0, "Cannot override warnings"), s2(e22.debug === void 0, "Cannot override debug"), l2.checkPreferences(e22);
          const t4 = this.clone();
          return t4._preferences = l2.preferences(t4._preferences, e22), t4;
        }
        presence(e22) {
          return s2(["optional", "required", "forbidden"].includes(e22), "Unknown presence mode", e22), this.$_setFlag("presence", e22);
        }
        raw(e22 = true) {
          return this.$_setFlag("result", e22 ? "raw" : void 0);
        }
        result(e22) {
          return s2(["raw", "strip"].includes(e22), "Unknown result mode", e22), this.$_setFlag("result", e22);
        }
        required() {
          return this.presence("required");
        }
        strict(e22) {
          const t4 = this.clone(), r3 = e22 !== void 0 && !e22;
          return t4._preferences = l2.preferences(t4._preferences, { convert: r3 }), t4;
        }
        strip(e22 = true) {
          return this.$_setFlag("result", e22 ? "strip" : void 0);
        }
        tag(...e22) {
          s2(e22.length, "Missing tags");
          for (const t4 of e22)
            s2(t4 && typeof t4 == "string", "Tags must be non-empty strings");
          return this._inner("tags", e22);
        }
        unit(e22) {
          return s2(e22 && typeof e22 == "string", "Unit name must be a non-empty string"), this.$_setFlag("unit", e22);
        }
        valid(...e22) {
          l2.verifyFlat(e22, "valid");
          const t4 = this.allow(...e22);
          return t4.$_setFlag("only", !!t4._valids, { clone: false }), t4;
        }
        when(e22, t4) {
          const r3 = this.clone();
          r3.$_terms.whens || (r3.$_terms.whens = []);
          const n3 = c2.when(r3, e22, t4);
          if (!["any", "link"].includes(r3.type)) {
            const e23 = n3.is ? [n3] : n3.switch;
            for (const t5 of e23)
              s2(!t5.then || t5.then.type === "any" || t5.then.type === r3.type, "Cannot combine", r3.type, "with", t5.then && t5.then.type), s2(!t5.otherwise || t5.otherwise.type === "any" || t5.otherwise.type === r3.type, "Cannot combine", r3.type, "with", t5.otherwise && t5.otherwise.type);
          }
          return r3.$_terms.whens.push(n3), r3.$_mutateRebuild();
        }
        cache(e22) {
          s2(!this._inRuleset(), "Cannot set caching inside a ruleset"), s2(!this._cache, "Cannot override schema cache"), s2(this._flags.artifact === void 0, "Cannot cache a rule with an artifact");
          const t4 = this.clone();
          return t4._cache = e22 || i2.provider.provision(), t4.$_temp.ruleset = false, t4;
        }
        clone() {
          const e22 = Object.create(Object.getPrototypeOf(this));
          return this._assign(e22);
        }
        concat(e22) {
          s2(l2.isSchema(e22), "Invalid schema object"), s2(this.type === "any" || e22.type === "any" || e22.type === this.type, "Cannot merge type", this.type, "with another type:", e22.type), s2(!this._inRuleset(), "Cannot concatenate onto a schema with open ruleset"), s2(!e22._inRuleset(), "Cannot concatenate a schema with open ruleset");
          let t4 = this.clone();
          if (this.type === "any" && e22.type !== "any") {
            const r3 = e22.clone();
            for (const e23 of Object.keys(t4))
              e23 !== "type" && (r3[e23] = t4[e23]);
            t4 = r3;
          }
          t4._ids.concat(e22._ids), t4._refs.register(e22, p2.toSibling), t4._preferences = t4._preferences ? l2.preferences(t4._preferences, e22._preferences) : e22._preferences, t4._valids = b2.merge(t4._valids, e22._valids, e22._invalids), t4._invalids = b2.merge(t4._invalids, e22._invalids, e22._valids);
          for (const r3 of e22._singleRules.keys())
            t4._singleRules.has(r3) && (t4._rules = t4._rules.filter((e23) => e23.keep || e23.name !== r3), t4._singleRules.delete(r3));
          for (const r3 of e22._rules)
            e22._definition.rules[r3.method].multi || t4._singleRules.set(r3.name, r3), t4._rules.push(r3);
          if (t4._flags.empty && e22._flags.empty) {
            t4._flags.empty = t4._flags.empty.concat(e22._flags.empty);
            const r3 = Object.assign({}, e22._flags);
            delete r3.empty, o2(t4._flags, r3);
          } else if (e22._flags.empty) {
            t4._flags.empty = e22._flags.empty;
            const r3 = Object.assign({}, e22._flags);
            delete r3.empty, o2(t4._flags, r3);
          } else
            o2(t4._flags, e22._flags);
          for (const r3 in e22.$_terms) {
            const s3 = e22.$_terms[r3];
            s3 ? t4.$_terms[r3] ? t4.$_terms[r3] = t4.$_terms[r3].concat(s3) : t4.$_terms[r3] = s3.slice() : t4.$_terms[r3] || (t4.$_terms[r3] = s3);
          }
          return this.$_root._tracer && this.$_root._tracer._combine(t4, [this, e22]), t4.$_mutateRebuild();
        }
        extend(e22) {
          return s2(!e22.base, "Cannot extend type with another base"), f2.type(this, e22);
        }
        extract(e22) {
          return e22 = Array.isArray(e22) ? e22 : e22.split("."), this._ids.reach(e22);
        }
        fork(e22, t4) {
          s2(!this._inRuleset(), "Cannot fork inside a ruleset");
          let r3 = this;
          for (let s3 of [].concat(e22))
            s3 = Array.isArray(s3) ? s3 : s3.split("."), r3 = r3._ids.fork(s3, t4, r3);
          return r3.$_temp.ruleset = false, r3;
        }
        rule(e22) {
          const t4 = this._definition;
          l2.assertOptions(e22, Object.keys(t4.modifiers)), s2(this.$_temp.ruleset !== false, "Cannot apply rules to empty ruleset or the last rule added does not support rule properties");
          const r3 = this.$_temp.ruleset === null ? this._rules.length - 1 : this.$_temp.ruleset;
          s2(r3 >= 0 && r3 < this._rules.length, "Cannot apply rules to empty ruleset");
          const a3 = this.clone();
          for (let o3 = r3; o3 < a3._rules.length; ++o3) {
            const r4 = a3._rules[o3], i3 = n2(r4);
            for (const n3 in e22)
              t4.modifiers[n3](i3, e22[n3]), s2(i3.name === r4.name, "Cannot change rule name");
            a3._rules[o3] = i3, a3._singleRules.get(i3.name) === r4 && a3._singleRules.set(i3.name, i3);
          }
          return a3.$_temp.ruleset = false, a3.$_mutateRebuild();
        }
        get ruleset() {
          s2(!this._inRuleset(), "Cannot start a new ruleset without closing the previous one");
          const e22 = this.clone();
          return e22.$_temp.ruleset = e22._rules.length, e22;
        }
        get $() {
          return this.ruleset;
        }
        tailor(e22) {
          e22 = [].concat(e22), s2(!this._inRuleset(), "Cannot tailor inside a ruleset");
          let t4 = this;
          if (this.$_terms.alterations)
            for (const { target: r3, adjuster: n3 } of this.$_terms.alterations)
              e22.includes(r3) && (t4 = n3(t4), s2(l2.isSchema(t4), "Alteration adjuster for", r3, "failed to return a schema object"));
          return t4 = t4.$_modify({ each: (t5) => t5.tailor(e22), ref: false }), t4.$_temp.ruleset = false, t4.$_mutateRebuild();
        }
        tracer() {
          return g2.location ? g2.location(this) : this;
        }
        validate(e22, t4) {
          return y2.entry(e22, this, t4);
        }
        validateAsync(e22, t4) {
          return y2.entryAsync(e22, this, t4);
        }
        $_addRule(e22) {
          typeof e22 == "string" && (e22 = { name: e22 }), s2(e22 && typeof e22 == "object", "Invalid options"), s2(e22.name && typeof e22.name == "string", "Invalid rule name");
          for (const t5 in e22)
            s2(t5[0] !== "_", "Cannot set private rule properties");
          const t4 = Object.assign({}, e22);
          t4._resolve = [], t4.method = t4.method || t4.name;
          const r3 = this._definition.rules[t4.method], n3 = t4.args;
          s2(r3, "Unknown rule", t4.method);
          const a3 = this.clone();
          if (n3) {
            s2(Object.keys(n3).length === 1 || Object.keys(n3).length === this._definition.rules[t4.name].args.length, "Invalid rule definition for", this.type, t4.name);
            for (const e23 in n3) {
              let o3 = n3[e23];
              if (o3 !== void 0) {
                if (r3.argsByName) {
                  const i3 = r3.argsByName.get(e23);
                  if (i3.ref && l2.isResolvable(o3))
                    t4._resolve.push(e23), a3.$_mutateRegister(o3);
                  else if (i3.normalize && (o3 = i3.normalize(o3), n3[e23] = o3), i3.assert) {
                    const t5 = l2.validateArg(o3, e23, i3);
                    s2(!t5, t5, "or reference");
                  }
                }
                n3[e23] = o3;
              } else
                delete n3[e23];
            }
          }
          return r3.multi || (a3._ruleRemove(t4.name, { clone: false }), a3._singleRules.set(t4.name, t4)), a3.$_temp.ruleset === false && (a3.$_temp.ruleset = null), r3.priority ? a3._rules.unshift(t4) : a3._rules.push(t4), a3;
        }
        $_compile(e22, t4) {
          return c2.schema(this.$_root, e22, t4);
        }
        $_createError(e22, t4, r3, s3, n3, a3 = {}) {
          const o3 = a3.flags !== false ? this._flags : {}, i3 = a3.messages ? h2.merge(this._definition.messages, a3.messages) : this._definition.messages;
          return new u2.Report(e22, t4, r3, o3, i3, s3, n3);
        }
        $_getFlag(e22) {
          return this._flags[e22];
        }
        $_getRule(e22) {
          return this._singleRules.get(e22);
        }
        $_mapLabels(e22) {
          return e22 = Array.isArray(e22) ? e22 : e22.split("."), this._ids.labels(e22);
        }
        $_match(e22, t4, r3, s3) {
          (r3 = Object.assign({}, r3)).abortEarly = true, r3._externals = false, t4.snapshot();
          const n3 = !y2.validate(e22, this, t4, r3, s3).errors;
          return t4.restore(), n3;
        }
        $_modify(e22) {
          return l2.assertOptions(e22, ["each", "once", "ref", "schema"]), d2.schema(this, e22) || this;
        }
        $_mutateRebuild() {
          return s2(!this._inRuleset(), "Cannot add this rule inside a ruleset"), this._refs.reset(), this._ids.reset(), this.$_modify({ each: (e22, { source: t4, name: r3, path: s3, key: n3 }) => {
            const a3 = this._definition[t4][r3] && this._definition[t4][r3].register;
            a3 !== false && this.$_mutateRegister(e22, { family: a3, key: n3 });
          } }), this._definition.rebuild && this._definition.rebuild(this), this.$_temp.ruleset = false, this;
        }
        $_mutateRegister(e22, { family: t4, key: r3 } = {}) {
          this._refs.register(e22, t4), this._ids.register(e22, { key: r3 });
        }
        $_property(e22) {
          return this._definition.properties[e22];
        }
        $_reach(e22) {
          return this._ids.reach(e22);
        }
        $_rootReferences() {
          return this._refs.roots();
        }
        $_setFlag(e22, t4, r3 = {}) {
          s2(e22[0] === "_" || !this._inRuleset(), "Cannot set flag inside a ruleset");
          const n3 = this._definition.flags[e22] || {};
          if (a2(t4, n3.default) && (t4 = void 0), a2(t4, this._flags[e22]))
            return this;
          const o3 = r3.clone !== false ? this.clone() : this;
          return t4 !== void 0 ? (o3._flags[e22] = t4, o3.$_mutateRegister(t4)) : delete o3._flags[e22], e22[0] !== "_" && (o3.$_temp.ruleset = false), o3;
        }
        $_parent(e22, ...t4) {
          return this[e22][l2.symbols.parent].call(this, ...t4);
        }
        $_validate(e22, t4, r3) {
          return y2.validate(e22, this, t4, r3);
        }
        _assign(e22) {
          e22.type = this.type, e22.$_root = this.$_root, e22.$_temp = Object.assign({}, this.$_temp), e22.$_temp.whens = {}, e22._ids = this._ids.clone(), e22._preferences = this._preferences, e22._valids = this._valids && this._valids.clone(), e22._invalids = this._invalids && this._invalids.clone(), e22._rules = this._rules.slice(), e22._singleRules = n2(this._singleRules, { shallow: true }), e22._refs = this._refs.clone(), e22._flags = Object.assign({}, this._flags), e22._cache = null, e22.$_terms = {};
          for (const t4 in this.$_terms)
            e22.$_terms[t4] = this.$_terms[t4] ? this.$_terms[t4].slice() : null;
          e22.$_super = {};
          for (const t4 in this.$_super)
            e22.$_super[t4] = this._super[t4].bind(e22);
          return e22;
        }
        _bare() {
          const e22 = this.clone();
          e22._reset();
          const t4 = e22._definition.terms;
          for (const r3 in t4) {
            const s3 = t4[r3];
            e22.$_terms[r3] = s3.init;
          }
          return e22.$_mutateRebuild();
        }
        _default(e22, t4, r3 = {}) {
          return l2.assertOptions(r3, "literal"), s2(t4 !== void 0, "Missing", e22, "value"), s2(typeof t4 == "function" || !r3.literal, "Only function value supports literal option"), typeof t4 == "function" && r3.literal && (t4 = { [l2.symbols.literal]: true, literal: t4 }), this.$_setFlag(e22, t4);
        }
        _generate(e22, t4, r3) {
          if (!this.$_terms.whens)
            return { schema: this };
          const s3 = [], n3 = [];
          for (let a4 = 0; a4 < this.$_terms.whens.length; ++a4) {
            const o4 = this.$_terms.whens[a4];
            if (o4.concat) {
              s3.push(o4.concat), n3.push("".concat(a4, ".concat"));
              continue;
            }
            const i3 = o4.ref ? o4.ref.resolve(e22, t4, r3) : e22, l3 = o4.is ? [o4] : o4.switch, c3 = n3.length;
            for (let c4 = 0; c4 < l3.length; ++c4) {
              const { is: u3, then: f3, otherwise: m3 } = l3[c4], h3 = "".concat(a4).concat(o4.switch ? "." + c4 : "");
              if (u3.$_match(i3, t4.nest(u3, "".concat(h3, ".is")), r3)) {
                if (f3) {
                  const a5 = t4.localize([...t4.path, "".concat(h3, ".then")], t4.ancestors, t4.schemas), { schema: o5, id: i4 } = f3._generate(e22, a5, r3);
                  s3.push(o5), n3.push("".concat(h3, ".then").concat(i4 ? "(".concat(i4, ")") : ""));
                  break;
                }
              } else if (m3) {
                const a5 = t4.localize([...t4.path, "".concat(h3, ".otherwise")], t4.ancestors, t4.schemas), { schema: o5, id: i4 } = m3._generate(e22, a5, r3);
                s3.push(o5), n3.push("".concat(h3, ".otherwise").concat(i4 ? "(".concat(i4, ")") : ""));
                break;
              }
            }
            if (o4.break && n3.length > c3)
              break;
          }
          const a3 = n3.join(", ");
          if (t4.mainstay.tracer.debug(t4, "rule", "when", a3), !a3)
            return { schema: this };
          if (!t4.mainstay.tracer.active && this.$_temp.whens[a3])
            return { schema: this.$_temp.whens[a3], id: a3 };
          let o3 = this;
          this._definition.generate && (o3 = this._definition.generate(this, e22, t4, r3));
          for (const e23 of s3)
            o3 = o3.concat(e23);
          return this.$_root._tracer && this.$_root._tracer._combine(o3, [this, ...s3]), this.$_temp.whens[a3] = o3, { schema: o3, id: a3 };
        }
        _inner(e22, t4, r3 = {}) {
          s2(!this._inRuleset(), "Cannot set ".concat(e22, " inside a ruleset"));
          const n3 = this.clone();
          return n3.$_terms[e22] && !r3.override || (n3.$_terms[e22] = []), r3.single ? n3.$_terms[e22].push(t4) : n3.$_terms[e22].push(...t4), n3.$_temp.ruleset = false, n3;
        }
        _inRuleset() {
          return this.$_temp.ruleset !== null && this.$_temp.ruleset !== false;
        }
        _ruleRemove(e22, t4 = {}) {
          if (!this._singleRules.has(e22))
            return this;
          const r3 = t4.clone !== false ? this.clone() : this;
          r3._singleRules.delete(e22);
          const s3 = [];
          for (let t5 = 0; t5 < r3._rules.length; ++t5) {
            const n3 = r3._rules[t5];
            n3.name !== e22 || n3.keep ? s3.push(n3) : r3._inRuleset() && t5 < r3.$_temp.ruleset && --r3.$_temp.ruleset;
          }
          return r3._rules = s3, r3;
        }
        _values(e22, t4) {
          l2.verifyFlat(e22, t4.slice(1, -1));
          const r3 = this.clone(), n3 = e22[0] === l2.symbols.override;
          if (n3 && (e22 = e22.slice(1)), !r3[t4] && e22.length ? r3[t4] = new b2() : n3 && (r3[t4] = e22.length ? new b2() : null, r3.$_mutateRebuild()), !r3[t4])
            return r3;
          n3 && r3[t4].override();
          for (const n4 of e22) {
            s2(n4 !== void 0, "Cannot call allow/valid/invalid with undefined"), s2(n4 !== l2.symbols.override, "Override must be the first value");
            const e23 = t4 === "_invalids" ? "_valids" : "_invalids";
            r3[e23] && (r3[e23].remove(n4), r3[e23].length || (s2(t4 === "_valids" || !r3._flags.only, "Setting invalid value", n4, "leaves schema rejecting all values due to previous valid rule"), r3[e23] = null)), r3[t4].add(n4, r3._refs);
          }
          return r3;
        }
      } };
      v2.Base.prototype[l2.symbols.any] = { version: l2.version, compile: c2.compile, root: "$_root" }, v2.Base.prototype.isImmutable = true, v2.Base.prototype.deny = v2.Base.prototype.invalid, v2.Base.prototype.disallow = v2.Base.prototype.invalid, v2.Base.prototype.equal = v2.Base.prototype.valid, v2.Base.prototype.exist = v2.Base.prototype.required, v2.Base.prototype.not = v2.Base.prototype.invalid, v2.Base.prototype.options = v2.Base.prototype.prefs, v2.Base.prototype.preferences = v2.Base.prototype.prefs, e21.exports = new v2.Base();
    }, 8652: (e21, t3, r2) => {
      const s2 = r2(375), n2 = r2(8571), a2 = r2(8160), o2 = { max: 1e3, supported: new Set(["undefined", "boolean", "number", "string"]) };
      t3.provider = { provision: (e22) => new o2.Cache(e22) }, o2.Cache = class {
        constructor(e22 = {}) {
          a2.assertOptions(e22, ["max"]), s2(e22.max === void 0 || e22.max && e22.max > 0 && isFinite(e22.max), "Invalid max cache size"), this._max = e22.max || o2.max, this._map = new Map(), this._list = new o2.List();
        }
        get length() {
          return this._map.size;
        }
        set(e22, t4) {
          if (e22 !== null && !o2.supported.has(typeof e22))
            return;
          let r3 = this._map.get(e22);
          if (r3)
            return r3.value = t4, void this._list.first(r3);
          r3 = this._list.unshift({ key: e22, value: t4 }), this._map.set(e22, r3), this._compact();
        }
        get(e22) {
          const t4 = this._map.get(e22);
          if (t4)
            return this._list.first(t4), n2(t4.value);
        }
        _compact() {
          if (this._map.size > this._max) {
            const e22 = this._list.pop();
            this._map.delete(e22.key);
          }
        }
      }, o2.List = class {
        constructor() {
          this.tail = null, this.head = null;
        }
        unshift(e22) {
          return e22.next = null, e22.prev = this.head, this.head && (this.head.next = e22), this.head = e22, this.tail || (this.tail = e22), e22;
        }
        first(e22) {
          e22 !== this.head && (this._remove(e22), this.unshift(e22));
        }
        pop() {
          return this._remove(this.tail);
        }
        _remove(e22) {
          const { next: t4, prev: r3 } = e22;
          return t4.prev = r3, r3 && (r3.next = t4), e22 === this.tail && (this.tail = t4), e22.prev = null, e22.next = null, e22;
        }
      };
    }, 8160: (e21, t3, r2) => {
      const s2 = r2(375), n2 = r2(7916), a2 = r2(1238);
      let o2, i2;
      const l2 = { isoDate: /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/ };
      t3.version = a2.version, t3.defaults = { abortEarly: true, allowUnknown: false, artifacts: false, cache: true, context: null, convert: true, dateFormat: "iso", errors: { escapeHtml: false, label: "path", language: null, render: true, stack: false, wrap: { label: '"', array: "[]" } }, externals: true, messages: {}, nonEnumerables: false, noDefaults: false, presence: "optional", skipFunctions: false, stripUnknown: false, warnings: false }, t3.symbols = { any: Symbol.for("@hapi/joi/schema"), arraySingle: Symbol("arraySingle"), deepDefault: Symbol("deepDefault"), errors: Symbol("errors"), literal: Symbol("literal"), override: Symbol("override"), parent: Symbol("parent"), prefs: Symbol("prefs"), ref: Symbol("ref"), template: Symbol("template"), values: Symbol("values") }, t3.assertOptions = function(e22, t4, r3 = "Options") {
        s2(e22 && typeof e22 == "object" && !Array.isArray(e22), "Options must be of type object");
        const n3 = Object.keys(e22).filter((e23) => !t4.includes(e23));
        s2(n3.length === 0, "".concat(r3, " contain unknown keys: ").concat(n3));
      }, t3.checkPreferences = function(e22) {
        i2 = i2 || r2(3378);
        const t4 = i2.preferences.validate(e22);
        if (t4.error)
          throw new n2([t4.error.details[0].message]);
      }, t3.compare = function(e22, t4, r3) {
        switch (r3) {
          case "=":
            return e22 === t4;
          case ">":
            return e22 > t4;
          case "<":
            return e22 < t4;
          case ">=":
            return e22 >= t4;
          case "<=":
            return e22 <= t4;
        }
      }, t3.default = function(e22, t4) {
        return e22 === void 0 ? t4 : e22;
      }, t3.isIsoDate = function(e22) {
        return l2.isoDate.test(e22);
      }, t3.isNumber = function(e22) {
        return typeof e22 == "number" && !isNaN(e22);
      }, t3.isResolvable = function(e22) {
        return !!e22 && (e22[t3.symbols.ref] || e22[t3.symbols.template]);
      }, t3.isSchema = function(e22, r3 = {}) {
        const n3 = e22 && e22[t3.symbols.any];
        return !!n3 && (s2(r3.legacy || n3.version === t3.version, "Cannot mix different versions of joi schemas"), true);
      }, t3.isValues = function(e22) {
        return e22[t3.symbols.values];
      }, t3.limit = function(e22) {
        return Number.isSafeInteger(e22) && e22 >= 0;
      }, t3.preferences = function(e22, s3) {
        o2 = o2 || r2(6914), e22 = e22 || {}, s3 = s3 || {};
        const n3 = Object.assign({}, e22, s3);
        return s3.errors && e22.errors && (n3.errors = Object.assign({}, e22.errors, s3.errors), n3.errors.wrap = Object.assign({}, e22.errors.wrap, s3.errors.wrap)), s3.messages && (n3.messages = o2.compile(s3.messages, e22.messages)), delete n3[t3.symbols.prefs], n3;
      }, t3.tryWithPath = function(e22, t4, r3 = {}) {
        try {
          return e22();
        } catch (e23) {
          throw e23.path !== void 0 ? e23.path = t4 + "." + e23.path : e23.path = t4, r3.append && (e23.message = "".concat(e23.message, " (").concat(e23.path, ")")), e23;
        }
      }, t3.validateArg = function(e22, r3, { assert: s3, message: n3 }) {
        if (t3.isSchema(s3)) {
          const t4 = s3.validate(e22);
          if (!t4.error)
            return;
          return t4.error.message;
        }
        if (!s3(e22))
          return r3 ? "".concat(r3, " ").concat(n3) : n3;
      }, t3.verifyFlat = function(e22, t4) {
        for (const r3 of e22)
          s2(!Array.isArray(r3), "Method no longer accepts array arguments:", t4);
      };
    }, 3292: (e21, t3, r2) => {
      const s2 = r2(375), n2 = r2(8160), a2 = r2(6133), o2 = {};
      t3.schema = function(e22, t4, r3 = {}) {
        n2.assertOptions(r3, ["appendPath", "override"]);
        try {
          return o2.schema(e22, t4, r3);
        } catch (e23) {
          throw r3.appendPath && e23.path !== void 0 && (e23.message = "".concat(e23.message, " (").concat(e23.path, ")")), e23;
        }
      }, o2.schema = function(e22, t4, r3) {
        s2(t4 !== void 0, "Invalid undefined schema"), Array.isArray(t4) && (s2(t4.length, "Invalid empty array schema"), t4.length === 1 && (t4 = t4[0]));
        const a3 = (t5, ...s3) => r3.override !== false ? t5.valid(e22.override, ...s3) : t5.valid(...s3);
        if (o2.simple(t4))
          return a3(e22, t4);
        if (typeof t4 == "function")
          return e22.custom(t4);
        if (s2(typeof t4 == "object", "Invalid schema content:", typeof t4), n2.isResolvable(t4))
          return a3(e22, t4);
        if (n2.isSchema(t4))
          return t4;
        if (Array.isArray(t4)) {
          for (const r4 of t4)
            if (!o2.simple(r4))
              return e22.alternatives().try(...t4);
          return a3(e22, ...t4);
        }
        return t4 instanceof RegExp ? e22.string().regex(t4) : t4 instanceof Date ? a3(e22.date(), t4) : (s2(Object.getPrototypeOf(t4) === Object.getPrototypeOf({}), "Schema can only contain plain objects"), e22.object().keys(t4));
      }, t3.ref = function(e22, t4) {
        return a2.isRef(e22) ? e22 : a2.create(e22, t4);
      }, t3.compile = function(e22, r3, a3 = {}) {
        n2.assertOptions(a3, ["legacy"]);
        const i2 = r3 && r3[n2.symbols.any];
        if (i2)
          return s2(a3.legacy || i2.version === n2.version, "Cannot mix different versions of joi schemas:", i2.version, n2.version), r3;
        if (typeof r3 != "object" || !a3.legacy)
          return t3.schema(e22, r3, { appendPath: true });
        const l2 = o2.walk(r3);
        return l2 ? l2.compile(l2.root, r3) : t3.schema(e22, r3, { appendPath: true });
      }, o2.walk = function(e22) {
        if (typeof e22 != "object")
          return null;
        if (Array.isArray(e22)) {
          for (const t5 of e22) {
            const e23 = o2.walk(t5);
            if (e23)
              return e23;
          }
          return null;
        }
        const t4 = e22[n2.symbols.any];
        if (t4)
          return { root: e22[t4.root], compile: t4.compile };
        s2(Object.getPrototypeOf(e22) === Object.getPrototypeOf({}), "Schema can only contain plain objects");
        for (const t5 in e22) {
          const r3 = o2.walk(e22[t5]);
          if (r3)
            return r3;
        }
        return null;
      }, o2.simple = function(e22) {
        return e22 === null || ["boolean", "string", "number"].includes(typeof e22);
      }, t3.when = function(e22, r3, i2) {
        if (i2 === void 0 && (s2(r3 && typeof r3 == "object", "Missing options"), i2 = r3, r3 = a2.create(".")), Array.isArray(i2) && (i2 = { switch: i2 }), n2.assertOptions(i2, ["is", "not", "then", "otherwise", "switch", "break"]), n2.isSchema(r3))
          return s2(i2.is === void 0, '"is" can not be used with a schema condition'), s2(i2.not === void 0, '"not" can not be used with a schema condition'), s2(i2.switch === void 0, '"switch" can not be used with a schema condition'), o2.condition(e22, { is: r3, then: i2.then, otherwise: i2.otherwise, break: i2.break });
        if (s2(a2.isRef(r3) || typeof r3 == "string", "Invalid condition:", r3), s2(i2.not === void 0 || i2.is === void 0, 'Cannot combine "is" with "not"'), i2.switch === void 0) {
          let l3 = i2;
          i2.not !== void 0 && (l3 = { is: i2.not, then: i2.otherwise, otherwise: i2.then, break: i2.break });
          let c2 = l3.is !== void 0 ? e22.$_compile(l3.is) : e22.$_root.invalid(null, false, 0, "").required();
          return s2(l3.then !== void 0 || l3.otherwise !== void 0, 'options must have at least one of "then", "otherwise", or "switch"'), s2(l3.break === void 0 || l3.then === void 0 || l3.otherwise === void 0, "Cannot specify then, otherwise, and break all together"), i2.is === void 0 || a2.isRef(i2.is) || n2.isSchema(i2.is) || (c2 = c2.required()), o2.condition(e22, { ref: t3.ref(r3), is: c2, then: l3.then, otherwise: l3.otherwise, break: l3.break });
        }
        s2(Array.isArray(i2.switch), '"switch" must be an array'), s2(i2.is === void 0, 'Cannot combine "switch" with "is"'), s2(i2.not === void 0, 'Cannot combine "switch" with "not"'), s2(i2.then === void 0, 'Cannot combine "switch" with "then"');
        const l2 = { ref: t3.ref(r3), switch: [], break: i2.break };
        for (let t4 = 0; t4 < i2.switch.length; ++t4) {
          const r4 = i2.switch[t4], o3 = t4 === i2.switch.length - 1;
          n2.assertOptions(r4, o3 ? ["is", "then", "otherwise"] : ["is", "then"]), s2(r4.is !== void 0, 'Switch statement missing "is"'), s2(r4.then !== void 0, 'Switch statement missing "then"');
          const c2 = { is: e22.$_compile(r4.is), then: e22.$_compile(r4.then) };
          if (a2.isRef(r4.is) || n2.isSchema(r4.is) || (c2.is = c2.is.required()), o3) {
            s2(i2.otherwise === void 0 || r4.otherwise === void 0, 'Cannot specify "otherwise" inside and outside a "switch"');
            const t5 = i2.otherwise !== void 0 ? i2.otherwise : r4.otherwise;
            t5 !== void 0 && (s2(l2.break === void 0, "Cannot specify both otherwise and break"), c2.otherwise = e22.$_compile(t5));
          }
          l2.switch.push(c2);
        }
        return l2;
      }, o2.condition = function(e22, t4) {
        for (const r3 of ["then", "otherwise"])
          t4[r3] === void 0 ? delete t4[r3] : t4[r3] = e22.$_compile(t4[r3]);
        return t4;
      };
    }, 6354: (e21, t3, r2) => {
      const s2 = r2(5688), n2 = r2(8160), a2 = r2(3328);
      t3.Report = class {
        constructor(e22, r3, s3, n3, a3, o2, i2) {
          if (this.code = e22, this.flags = n3, this.messages = a3, this.path = o2.path, this.prefs = i2, this.state = o2, this.value = r3, this.message = null, this.template = null, this.local = s3 || {}, this.local.label = t3.label(this.flags, this.state, this.prefs, this.messages), this.value === void 0 || this.local.hasOwnProperty("value") || (this.local.value = this.value), this.path.length) {
            const e23 = this.path[this.path.length - 1];
            typeof e23 != "object" && (this.local.key = e23);
          }
        }
        _setTemplate(e22) {
          if (this.template = e22, !this.flags.label && this.path.length === 0) {
            const e23 = this._template(this.template, "root");
            e23 && (this.local.label = e23);
          }
        }
        toString() {
          if (this.message)
            return this.message;
          const e22 = this.code;
          if (!this.prefs.errors.render)
            return this.code;
          const t4 = this._template(this.template) || this._template(this.prefs.messages) || this._template(this.messages);
          return t4 === void 0 ? 'Error code "'.concat(e22, '" is not defined, your custom type is missing the correct messages definition') : (this.message = t4.render(this.value, this.state, this.prefs, this.local, { errors: this.prefs.errors, messages: [this.prefs.messages, this.messages] }), this.prefs.errors.label || (this.message = this.message.replace(/^"" /, "").trim()), this.message);
        }
        _template(e22, r3) {
          return t3.template(this.value, e22, r3 || this.code, this.state, this.prefs);
        }
      }, t3.path = function(e22) {
        let t4 = "";
        for (const r3 of e22)
          typeof r3 != "object" && (typeof r3 == "string" ? (t4 && (t4 += "."), t4 += r3) : t4 += "[".concat(r3, "]"));
        return t4;
      }, t3.template = function(e22, t4, r3, s3, o2) {
        if (!t4)
          return;
        if (a2.isTemplate(t4))
          return r3 !== "root" ? t4 : null;
        let i2 = o2.errors.language;
        return n2.isResolvable(i2) && (i2 = i2.resolve(e22, s3, o2)), i2 && t4[i2] && t4[i2][r3] !== void 0 ? t4[i2][r3] : t4[r3];
      }, t3.label = function(e22, r3, s3, n3) {
        if (e22.label)
          return e22.label;
        if (!s3.errors.label)
          return "";
        let a3 = r3.path;
        s3.errors.label === "key" && r3.path.length > 1 && (a3 = r3.path.slice(-1));
        return t3.path(a3) || t3.template(null, s3.messages, "root", r3, s3) || n3 && t3.template(null, n3, "root", r3, s3) || "value";
      }, t3.process = function(e22, r3, s3) {
        if (!e22)
          return null;
        const { override: n3, message: a3, details: o2 } = t3.details(e22);
        if (n3)
          return n3;
        if (s3.errors.stack)
          return new t3.ValidationError(a3, o2, r3);
        const i2 = Error.stackTraceLimit;
        Error.stackTraceLimit = 0;
        const l2 = new t3.ValidationError(a3, o2, r3);
        return Error.stackTraceLimit = i2, l2;
      }, t3.details = function(e22, t4 = {}) {
        let r3 = [];
        const s3 = [];
        for (const n3 of e22) {
          if (n3 instanceof Error) {
            if (t4.override !== false)
              return { override: n3 };
            const e24 = n3.toString();
            r3.push(e24), s3.push({ message: e24, type: "override", context: { error: n3 } });
            continue;
          }
          const e23 = n3.toString();
          r3.push(e23), s3.push({ message: e23, path: n3.path.filter((e24) => typeof e24 != "object"), type: n3.code, context: n3.local });
        }
        return r3.length > 1 && (r3 = [...new Set(r3)]), { message: r3.join(". "), details: s3 };
      }, t3.ValidationError = class extends Error {
        constructor(e22, t4, r3) {
          super(e22), this._original = r3, this.details = t4;
        }
        static isError(e22) {
          return e22 instanceof t3.ValidationError;
        }
      }, t3.ValidationError.prototype.isJoi = true, t3.ValidationError.prototype.name = "ValidationError", t3.ValidationError.prototype.annotate = s2.error;
    }, 8901: (e21, t3, r2) => {
      const s2 = r2(375), n2 = r2(8571), a2 = r2(8160), o2 = r2(6914), i2 = {};
      t3.type = function(e22, t4) {
        const r3 = Object.getPrototypeOf(e22), l2 = n2(r3), c2 = e22._assign(Object.create(l2)), u2 = Object.assign({}, t4);
        delete u2.base, l2._definition = u2;
        const f2 = r3._definition || {};
        u2.messages = o2.merge(f2.messages, u2.messages), u2.properties = Object.assign({}, f2.properties, u2.properties), c2.type = u2.type, u2.flags = Object.assign({}, f2.flags, u2.flags);
        const m2 = Object.assign({}, f2.terms);
        if (u2.terms)
          for (const e23 in u2.terms) {
            const t5 = u2.terms[e23];
            s2(c2.$_terms[e23] === void 0, "Invalid term override for", u2.type, e23), c2.$_terms[e23] = t5.init, m2[e23] = t5;
          }
        u2.terms = m2, u2.args || (u2.args = f2.args), u2.prepare = i2.prepare(u2.prepare, f2.prepare), u2.coerce && (typeof u2.coerce == "function" && (u2.coerce = { method: u2.coerce }), u2.coerce.from && !Array.isArray(u2.coerce.from) && (u2.coerce = { method: u2.coerce.method, from: [].concat(u2.coerce.from) })), u2.coerce = i2.coerce(u2.coerce, f2.coerce), u2.validate = i2.validate(u2.validate, f2.validate);
        const h2 = Object.assign({}, f2.rules);
        if (u2.rules)
          for (const e23 in u2.rules) {
            const t5 = u2.rules[e23];
            s2(typeof t5 == "object", "Invalid rule definition for", u2.type, e23);
            let r4 = t5.method;
            if (r4 === void 0 && (r4 = function() {
              return this.$_addRule(e23);
            }), r4 && (s2(!l2[e23], "Rule conflict in", u2.type, e23), l2[e23] = r4), s2(!h2[e23], "Rule conflict in", u2.type, e23), h2[e23] = t5, t5.alias) {
              const e24 = [].concat(t5.alias);
              for (const r5 of e24)
                l2[r5] = t5.method;
            }
            t5.args && (t5.argsByName = new Map(), t5.args = t5.args.map((e24) => (typeof e24 == "string" && (e24 = { name: e24 }), s2(!t5.argsByName.has(e24.name), "Duplicated argument name", e24.name), a2.isSchema(e24.assert) && (e24.assert = e24.assert.strict().label(e24.name)), t5.argsByName.set(e24.name, e24), e24)));
          }
        u2.rules = h2;
        const d2 = Object.assign({}, f2.modifiers);
        if (u2.modifiers)
          for (const e23 in u2.modifiers) {
            s2(!l2[e23], "Rule conflict in", u2.type, e23);
            const t5 = u2.modifiers[e23];
            s2(typeof t5 == "function", "Invalid modifier definition for", u2.type, e23);
            const r4 = function(t6) {
              return this.rule({ [e23]: t6 });
            };
            l2[e23] = r4, d2[e23] = t5;
          }
        if (u2.modifiers = d2, u2.overrides) {
          l2._super = r3, c2.$_super = {};
          for (const e23 in u2.overrides)
            s2(r3[e23], "Cannot override missing", e23), u2.overrides[e23][a2.symbols.parent] = r3[e23], c2.$_super[e23] = r3[e23].bind(c2);
          Object.assign(l2, u2.overrides);
        }
        u2.cast = Object.assign({}, f2.cast, u2.cast);
        const p2 = Object.assign({}, f2.manifest, u2.manifest);
        return p2.build = i2.build(u2.manifest && u2.manifest.build, f2.manifest && f2.manifest.build), u2.manifest = p2, u2.rebuild = i2.rebuild(u2.rebuild, f2.rebuild), c2;
      }, i2.build = function(e22, t4) {
        return e22 && t4 ? function(r3, s3) {
          return t4(e22(r3, s3), s3);
        } : e22 || t4;
      }, i2.coerce = function(e22, t4) {
        return e22 && t4 ? { from: e22.from && t4.from ? [...new Set([...e22.from, ...t4.from])] : null, method(r3, s3) {
          let n3;
          if ((!t4.from || t4.from.includes(typeof r3)) && (n3 = t4.method(r3, s3), n3)) {
            if (n3.errors || n3.value === void 0)
              return n3;
            r3 = n3.value;
          }
          if (!e22.from || e22.from.includes(typeof r3)) {
            const t5 = e22.method(r3, s3);
            if (t5)
              return t5;
          }
          return n3;
        } } : e22 || t4;
      }, i2.prepare = function(e22, t4) {
        return e22 && t4 ? function(r3, s3) {
          const n3 = e22(r3, s3);
          if (n3) {
            if (n3.errors || n3.value === void 0)
              return n3;
            r3 = n3.value;
          }
          return t4(r3, s3) || n3;
        } : e22 || t4;
      }, i2.rebuild = function(e22, t4) {
        return e22 && t4 ? function(r3) {
          t4(r3), e22(r3);
        } : e22 || t4;
      }, i2.validate = function(e22, t4) {
        return e22 && t4 ? function(r3, s3) {
          const n3 = t4(r3, s3);
          if (n3) {
            if (n3.errors && (!Array.isArray(n3.errors) || n3.errors.length))
              return n3;
            r3 = n3.value;
          }
          return e22(r3, s3) || n3;
        } : e22 || t4;
      };
    }, 5107: (e21, t3, r2) => {
      const s2 = r2(375), n2 = r2(8571), a2 = r2(8652), o2 = r2(8160), i2 = r2(3292), l2 = r2(6354), c2 = r2(8901), u2 = r2(9708), f2 = r2(6133), m2 = r2(3328), h2 = r2(1152);
      let d2;
      const p2 = { types: { alternatives: r2(4946), any: r2(8068), array: r2(546), boolean: r2(4937), date: r2(7500), function: r2(390), link: r2(8785), number: r2(3832), object: r2(8966), string: r2(7417), symbol: r2(8826) }, aliases: { alt: "alternatives", bool: "boolean", func: "function" }, root: function() {
        const e22 = { _types: new Set(Object.keys(p2.types)) };
        for (const t4 of e22._types)
          e22[t4] = function(...e23) {
            return s2(!e23.length || ["alternatives", "link", "object"].includes(t4), "The", t4, "type does not allow arguments"), p2.generate(this, p2.types[t4], e23);
          };
        for (const t4 of ["allow", "custom", "disallow", "equal", "exist", "forbidden", "invalid", "not", "only", "optional", "options", "prefs", "preferences", "required", "strip", "valid", "when"])
          e22[t4] = function(...e23) {
            return this.any()[t4](...e23);
          };
        Object.assign(e22, p2.methods);
        for (const t4 in p2.aliases) {
          const r3 = p2.aliases[t4];
          e22[t4] = e22[r3];
        }
        return e22.x = e22.expression, h2.setup && h2.setup(e22), e22;
      } };
      p2.methods = { ValidationError: l2.ValidationError, version: o2.version, cache: a2.provider, assert(e22, t4, ...r3) {
        p2.assert(e22, t4, true, r3);
      }, attempt: (e22, t4, ...r3) => p2.assert(e22, t4, false, r3), build(e22) {
        return s2(typeof u2.build == "function", "Manifest functionality disabled"), u2.build(this, e22);
      }, checkPreferences(e22) {
        o2.checkPreferences(e22);
      }, compile(e22, t4) {
        return i2.compile(this, e22, t4);
      }, defaults(e22) {
        s2(typeof e22 == "function", "modifier must be a function");
        const t4 = Object.assign({}, this);
        for (const r3 of t4._types) {
          const n3 = e22(t4[r3]());
          s2(o2.isSchema(n3), "modifier must return a valid schema object"), t4[r3] = function(...e23) {
            return p2.generate(this, n3, e23);
          };
        }
        return t4;
      }, expression: (...e22) => new m2(...e22), extend(...e22) {
        o2.verifyFlat(e22, "extend"), d2 = d2 || r2(3378), s2(e22.length, "You need to provide at least one extension"), this.assert(e22, d2.extensions);
        const t4 = Object.assign({}, this);
        t4._types = new Set(t4._types);
        for (let r3 of e22) {
          typeof r3 == "function" && (r3 = r3(t4)), this.assert(r3, d2.extension);
          const e23 = p2.expandExtension(r3, t4);
          for (const r4 of e23) {
            s2(t4[r4.type] === void 0 || t4._types.has(r4.type), "Cannot override name", r4.type);
            const e24 = r4.base || this.any(), n3 = c2.type(e24, r4);
            t4._types.add(r4.type), t4[r4.type] = function(...e25) {
              return p2.generate(this, n3, e25);
            };
          }
        }
        return t4;
      }, isError: l2.ValidationError.isError, isExpression: m2.isTemplate, isRef: f2.isRef, isSchema: o2.isSchema, in: (...e22) => f2.in(...e22), override: o2.symbols.override, ref: (...e22) => f2.create(...e22), types() {
        const e22 = {};
        for (const t4 of this._types)
          e22[t4] = this[t4]();
        for (const t4 in p2.aliases)
          e22[t4] = this[t4]();
        return e22;
      } }, p2.assert = function(e22, t4, r3, s3) {
        const a3 = s3[0] instanceof Error || typeof s3[0] == "string" ? s3[0] : null, i3 = a3 ? s3[1] : s3[0], c3 = t4.validate(e22, o2.preferences({ errors: { stack: true } }, i3 || {}));
        let u3 = c3.error;
        if (!u3)
          return c3.value;
        if (a3 instanceof Error)
          throw a3;
        const f3 = r3 && typeof u3.annotate == "function" ? u3.annotate() : u3.message;
        throw u3 instanceof l2.ValidationError == 0 && (u3 = n2(u3)), u3.message = a3 ? "".concat(a3, " ").concat(f3) : f3, u3;
      }, p2.generate = function(e22, t4, r3) {
        return s2(e22, "Must be invoked on a Joi instance."), t4.$_root = e22, t4._definition.args && r3.length ? t4._definition.args(t4, ...r3) : t4;
      }, p2.expandExtension = function(e22, t4) {
        if (typeof e22.type == "string")
          return [e22];
        const r3 = [];
        for (const s3 of t4._types)
          if (e22.type.test(s3)) {
            const n3 = Object.assign({}, e22);
            n3.type = s3, n3.base = t4[s3](), r3.push(n3);
          }
        return r3;
      }, e21.exports = p2.root();
    }, 6914: (e21, t3, r2) => {
      const s2 = r2(375), n2 = r2(8571), a2 = r2(3328);
      t3.compile = function(e22, t4) {
        if (typeof e22 == "string")
          return s2(!t4, "Cannot set single message string"), new a2(e22);
        if (a2.isTemplate(e22))
          return s2(!t4, "Cannot set single message template"), e22;
        s2(typeof e22 == "object" && !Array.isArray(e22), "Invalid message options"), t4 = t4 ? n2(t4) : {};
        for (let r3 in e22) {
          const n3 = e22[r3];
          if (r3 === "root" || a2.isTemplate(n3)) {
            t4[r3] = n3;
            continue;
          }
          if (typeof n3 == "string") {
            t4[r3] = new a2(n3);
            continue;
          }
          s2(typeof n3 == "object" && !Array.isArray(n3), "Invalid message for", r3);
          const o2 = r3;
          for (r3 in t4[o2] = t4[o2] || {}, n3) {
            const e23 = n3[r3];
            r3 === "root" || a2.isTemplate(e23) ? t4[o2][r3] = e23 : (s2(typeof e23 == "string", "Invalid message for", r3, "in", o2), t4[o2][r3] = new a2(e23));
          }
        }
        return t4;
      }, t3.decompile = function(e22) {
        const t4 = {};
        for (let r3 in e22) {
          const s3 = e22[r3];
          if (r3 === "root") {
            t4[r3] = s3;
            continue;
          }
          if (a2.isTemplate(s3)) {
            t4[r3] = s3.describe({ compact: true });
            continue;
          }
          const n3 = r3;
          for (r3 in t4[n3] = {}, s3) {
            const e23 = s3[r3];
            t4[n3][r3] = r3 !== "root" ? e23.describe({ compact: true }) : e23;
          }
        }
        return t4;
      }, t3.merge = function(e22, r3) {
        if (!e22)
          return t3.compile(r3);
        if (!r3)
          return e22;
        if (typeof r3 == "string")
          return new a2(r3);
        if (a2.isTemplate(r3))
          return r3;
        const o2 = n2(e22);
        for (let e23 in r3) {
          const t4 = r3[e23];
          if (e23 === "root" || a2.isTemplate(t4)) {
            o2[e23] = t4;
            continue;
          }
          if (typeof t4 == "string") {
            o2[e23] = new a2(t4);
            continue;
          }
          s2(typeof t4 == "object" && !Array.isArray(t4), "Invalid message for", e23);
          const n3 = e23;
          for (e23 in o2[n3] = o2[n3] || {}, t4) {
            const r4 = t4[e23];
            e23 === "root" || a2.isTemplate(r4) ? o2[n3][e23] = r4 : (s2(typeof r4 == "string", "Invalid message for", e23, "in", n3), o2[n3][e23] = new a2(r4));
          }
        }
        return o2;
      };
    }, 2294: (e21, t3, r2) => {
      function s2(e22, t4) {
        var r3 = Object.keys(e22);
        if (Object.getOwnPropertySymbols) {
          var s3 = Object.getOwnPropertySymbols(e22);
          t4 && (s3 = s3.filter(function(t5) {
            return Object.getOwnPropertyDescriptor(e22, t5).enumerable;
          })), r3.push.apply(r3, s3);
        }
        return r3;
      }
      function n2(e22) {
        for (var t4 = 1; t4 < arguments.length; t4++) {
          var r3 = arguments[t4] != null ? arguments[t4] : {};
          t4 % 2 ? s2(Object(r3), true).forEach(function(t5) {
            a2(e22, t5, r3[t5]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e22, Object.getOwnPropertyDescriptors(r3)) : s2(Object(r3)).forEach(function(t5) {
            Object.defineProperty(e22, t5, Object.getOwnPropertyDescriptor(r3, t5));
          });
        }
        return e22;
      }
      function a2(e22, t4, r3) {
        return t4 in e22 ? Object.defineProperty(e22, t4, { value: r3, enumerable: true, configurable: true, writable: true }) : e22[t4] = r3, e22;
      }
      const o2 = r2(375), i2 = r2(8160), l2 = r2(6133), c2 = {};
      t3.Ids = c2.Ids = class {
        constructor() {
          this._byId = new Map(), this._byKey = new Map(), this._schemaChain = false;
        }
        clone() {
          const e22 = new c2.Ids();
          return e22._byId = new Map(this._byId), e22._byKey = new Map(this._byKey), e22._schemaChain = this._schemaChain, e22;
        }
        concat(e22) {
          e22._schemaChain && (this._schemaChain = true);
          for (const [t4, r3] of e22._byId.entries())
            o2(!this._byKey.has(t4), "Schema id conflicts with existing key:", t4), this._byId.set(t4, r3);
          for (const [t4, r3] of e22._byKey.entries())
            o2(!this._byId.has(t4), "Schema key conflicts with existing id:", t4), this._byKey.set(t4, r3);
        }
        fork(e22, t4, r3) {
          const s3 = this._collect(e22);
          s3.push({ schema: r3 });
          const n3 = s3.shift();
          let a3 = { id: n3.id, schema: t4(n3.schema) };
          o2(i2.isSchema(a3.schema), "adjuster function failed to return a joi schema type");
          for (const e23 of s3)
            a3 = { id: e23.id, schema: c2.fork(e23.schema, a3.id, a3.schema) };
          return a3.schema;
        }
        labels(e22, t4 = []) {
          const r3 = e22[0], s3 = this._get(r3);
          if (!s3)
            return [...t4, ...e22].join(".");
          const n3 = e22.slice(1);
          return t4 = [...t4, s3.schema._flags.label || r3], n3.length ? s3.schema._ids.labels(n3, t4) : t4.join(".");
        }
        reach(e22, t4 = []) {
          const r3 = e22[0], s3 = this._get(r3);
          o2(s3, "Schema does not contain path", [...t4, ...e22].join("."));
          const n3 = e22.slice(1);
          return n3.length ? s3.schema._ids.reach(n3, [...t4, r3]) : s3.schema;
        }
        register(e22, { key: t4 } = {}) {
          if (!e22 || !i2.isSchema(e22))
            return;
          (e22.$_property("schemaChain") || e22._ids._schemaChain) && (this._schemaChain = true);
          const r3 = e22._flags.id;
          if (r3) {
            const t5 = this._byId.get(r3);
            o2(!t5 || t5.schema === e22, "Cannot add different schemas with the same id:", r3), o2(!this._byKey.has(r3), "Schema id conflicts with existing key:", r3), this._byId.set(r3, { schema: e22, id: r3 });
          }
          t4 && (o2(!this._byKey.has(t4), "Schema already contains key:", t4), o2(!this._byId.has(t4), "Schema key conflicts with existing id:", t4), this._byKey.set(t4, { schema: e22, id: t4 }));
        }
        reset() {
          this._byId = new Map(), this._byKey = new Map(), this._schemaChain = false;
        }
        _collect(e22, t4 = [], r3 = []) {
          const s3 = e22[0], n3 = this._get(s3);
          o2(n3, "Schema does not contain path", [...t4, ...e22].join(".")), r3 = [n3, ...r3];
          const a3 = e22.slice(1);
          return a3.length ? n3.schema._ids._collect(a3, [...t4, s3], r3) : r3;
        }
        _get(e22) {
          return this._byId.get(e22) || this._byKey.get(e22);
        }
      }, c2.fork = function(e22, r3, s3) {
        const n3 = t3.schema(e22, { each: (e23, { key: t4 }) => {
          if (r3 === (e23._flags.id || t4))
            return s3;
        }, ref: false });
        return n3 ? n3.$_mutateRebuild() : e22;
      }, t3.schema = function(e22, t4) {
        let r3;
        for (const s3 in e22._flags) {
          if (s3[0] === "_")
            continue;
          const n3 = c2.scan(e22._flags[s3], { source: "flags", name: s3 }, t4);
          n3 !== void 0 && (r3 = r3 || e22.clone(), r3._flags[s3] = n3);
        }
        for (let s3 = 0; s3 < e22._rules.length; ++s3) {
          const n3 = e22._rules[s3], a3 = c2.scan(n3.args, { source: "rules", name: n3.name }, t4);
          if (a3 !== void 0) {
            r3 = r3 || e22.clone();
            const t5 = Object.assign({}, n3);
            t5.args = a3, r3._rules[s3] = t5, r3._singleRules.get(n3.name) === n3 && r3._singleRules.set(n3.name, t5);
          }
        }
        for (const s3 in e22.$_terms) {
          if (s3[0] === "_")
            continue;
          const n3 = c2.scan(e22.$_terms[s3], { source: "terms", name: s3 }, t4);
          n3 !== void 0 && (r3 = r3 || e22.clone(), r3.$_terms[s3] = n3);
        }
        return r3;
      }, c2.scan = function(e22, t4, r3, s3, a3) {
        const o3 = s3 || [];
        if (e22 === null || typeof e22 != "object")
          return;
        let u2;
        if (Array.isArray(e22)) {
          for (let s4 = 0; s4 < e22.length; ++s4) {
            const n3 = t4.source === "terms" && t4.name === "keys" && e22[s4].key, a4 = c2.scan(e22[s4], t4, r3, [s4, ...o3], n3);
            a4 !== void 0 && (u2 = u2 || e22.slice(), u2[s4] = a4);
          }
          return u2;
        }
        if (r3.schema !== false && i2.isSchema(e22) || r3.ref !== false && l2.isRef(e22)) {
          const s4 = r3.each(e22, n2(n2({}, t4), {}, { path: o3, key: a3 }));
          if (s4 === e22)
            return;
          return s4;
        }
        for (const s4 in e22) {
          if (s4[0] === "_")
            continue;
          const n3 = c2.scan(e22[s4], t4, r3, [s4, ...o3], a3);
          n3 !== void 0 && (u2 = u2 || Object.assign({}, e22), u2[s4] = n3);
        }
        return u2;
      };
    }, 6133: (e21, t3, r2) => {
      function s2(e22, t4) {
        var r3 = Object.keys(e22);
        if (Object.getOwnPropertySymbols) {
          var s3 = Object.getOwnPropertySymbols(e22);
          t4 && (s3 = s3.filter(function(t5) {
            return Object.getOwnPropertyDescriptor(e22, t5).enumerable;
          })), r3.push.apply(r3, s3);
        }
        return r3;
      }
      function n2(e22) {
        for (var t4 = 1; t4 < arguments.length; t4++) {
          var r3 = arguments[t4] != null ? arguments[t4] : {};
          t4 % 2 ? s2(Object(r3), true).forEach(function(t5) {
            a2(e22, t5, r3[t5]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e22, Object.getOwnPropertyDescriptors(r3)) : s2(Object(r3)).forEach(function(t5) {
            Object.defineProperty(e22, t5, Object.getOwnPropertyDescriptor(r3, t5));
          });
        }
        return e22;
      }
      function a2(e22, t4, r3) {
        return t4 in e22 ? Object.defineProperty(e22, t4, { value: r3, enumerable: true, configurable: true, writable: true }) : e22[t4] = r3, e22;
      }
      const o2 = r2(375), i2 = r2(8571), l2 = r2(9621), c2 = r2(8160);
      let u2;
      const f2 = { symbol: Symbol("ref"), defaults: { adjust: null, in: false, iterables: null, map: null, separator: ".", type: "value" } };
      t3.create = function(e22, t4 = {}) {
        o2(typeof e22 == "string", "Invalid reference key:", e22), c2.assertOptions(t4, ["adjust", "ancestor", "in", "iterables", "map", "prefix", "render", "separator"]), o2(!t4.prefix || typeof t4.prefix == "object", "options.prefix must be of type object");
        const r3 = Object.assign({}, f2.defaults, t4);
        delete r3.prefix;
        const s3 = r3.separator, n3 = f2.context(e22, s3, t4.prefix);
        if (r3.type = n3.type, e22 = n3.key, r3.type === "value")
          if (n3.root && (o2(!s3 || e22[0] !== s3, "Cannot specify relative path with root prefix"), r3.ancestor = "root", e22 || (e22 = null)), s3 && s3 === e22)
            e22 = null, r3.ancestor = 0;
          else if (r3.ancestor !== void 0)
            o2(!s3 || !e22 || e22[0] !== s3, "Cannot combine prefix with ancestor option");
          else {
            const [t5, n4] = f2.ancestor(e22, s3);
            n4 && (e22 = e22.slice(n4)) === "" && (e22 = null), r3.ancestor = t5;
          }
        return r3.path = s3 ? e22 === null ? [] : e22.split(s3) : [e22], new f2.Ref(r3);
      }, t3.in = function(e22, r3 = {}) {
        return t3.create(e22, n2(n2({}, r3), {}, { in: true }));
      }, t3.isRef = function(e22) {
        return !!e22 && !!e22[c2.symbols.ref];
      }, f2.Ref = class {
        constructor(e22) {
          o2(typeof e22 == "object", "Invalid reference construction"), c2.assertOptions(e22, ["adjust", "ancestor", "in", "iterables", "map", "path", "render", "separator", "type", "depth", "key", "root", "display"]), o2([false, void 0].includes(e22.separator) || typeof e22.separator == "string" && e22.separator.length === 1, "Invalid separator"), o2(!e22.adjust || typeof e22.adjust == "function", "options.adjust must be a function"), o2(!e22.map || Array.isArray(e22.map), "options.map must be an array"), o2(!e22.map || !e22.adjust, "Cannot set both map and adjust options"), Object.assign(this, f2.defaults, e22), o2(this.type === "value" || this.ancestor === void 0, "Non-value references cannot reference ancestors"), Array.isArray(this.map) && (this.map = new Map(this.map)), this.depth = this.path.length, this.key = this.path.length ? this.path.join(this.separator) : null, this.root = this.path[0], this.updateDisplay();
        }
        resolve(e22, t4, r3, s3, n3 = {}) {
          return o2(!this.in || n3.in, "Invalid in() reference usage"), this.type === "global" ? this._resolve(r3.context, t4, n3) : this.type === "local" ? this._resolve(s3, t4, n3) : this.ancestor ? this.ancestor === "root" ? this._resolve(t4.ancestors[t4.ancestors.length - 1], t4, n3) : (o2(this.ancestor <= t4.ancestors.length, "Invalid reference exceeds the schema root:", this.display), this._resolve(t4.ancestors[this.ancestor - 1], t4, n3)) : this._resolve(e22, t4, n3);
        }
        _resolve(e22, t4, r3) {
          let s3;
          if (this.type === "value" && t4.mainstay.shadow && r3.shadow !== false && (s3 = t4.mainstay.shadow.get(this.absolute(t4))), s3 === void 0 && (s3 = l2(e22, this.path, { iterables: this.iterables, functions: true })), this.adjust && (s3 = this.adjust(s3)), this.map) {
            const e23 = this.map.get(s3);
            e23 !== void 0 && (s3 = e23);
          }
          return t4.mainstay && t4.mainstay.tracer.resolve(t4, this, s3), s3;
        }
        toString() {
          return this.display;
        }
        absolute(e22) {
          return [...e22.path.slice(0, -this.ancestor), ...this.path];
        }
        clone() {
          return new f2.Ref(this);
        }
        describe() {
          const e22 = { path: this.path };
          this.type !== "value" && (e22.type = this.type), this.separator !== "." && (e22.separator = this.separator), this.type === "value" && this.ancestor !== 1 && (e22.ancestor = this.ancestor), this.map && (e22.map = [...this.map]);
          for (const t4 of ["adjust", "iterables", "render"])
            this[t4] !== null && this[t4] !== void 0 && (e22[t4] = this[t4]);
          return this.in !== false && (e22.in = true), { ref: e22 };
        }
        updateDisplay() {
          const e22 = this.key !== null ? this.key : "";
          if (this.type !== "value")
            return void (this.display = "ref:".concat(this.type, ":").concat(e22));
          if (!this.separator)
            return void (this.display = "ref:".concat(e22));
          if (!this.ancestor)
            return void (this.display = "ref:".concat(this.separator).concat(e22));
          if (this.ancestor === "root")
            return void (this.display = "ref:root:".concat(e22));
          if (this.ancestor === 1)
            return void (this.display = "ref:".concat(e22 || ".."));
          const t4 = new Array(this.ancestor + 1).fill(this.separator).join("");
          this.display = "ref:".concat(t4).concat(e22 || "");
        }
      }, f2.Ref.prototype[c2.symbols.ref] = true, t3.build = function(e22) {
        return (e22 = Object.assign({}, f2.defaults, e22)).type === "value" && e22.ancestor === void 0 && (e22.ancestor = 1), new f2.Ref(e22);
      }, f2.context = function(e22, t4, r3 = {}) {
        if (e22 = e22.trim(), r3) {
          const s3 = r3.global === void 0 ? "$" : r3.global;
          if (s3 !== t4 && e22.startsWith(s3))
            return { key: e22.slice(s3.length), type: "global" };
          const n3 = r3.local === void 0 ? "#" : r3.local;
          if (n3 !== t4 && e22.startsWith(n3))
            return { key: e22.slice(n3.length), type: "local" };
          const a3 = r3.root === void 0 ? "/" : r3.root;
          if (a3 !== t4 && e22.startsWith(a3))
            return { key: e22.slice(a3.length), type: "value", root: true };
        }
        return { key: e22, type: "value" };
      }, f2.ancestor = function(e22, t4) {
        if (!t4)
          return [1, 0];
        if (e22[0] !== t4)
          return [1, 0];
        if (e22[1] !== t4)
          return [0, 1];
        let r3 = 2;
        for (; e22[r3] === t4; )
          ++r3;
        return [r3 - 1, r3];
      }, t3.toSibling = 0, t3.toParent = 1, t3.Manager = class {
        constructor() {
          this.refs = [];
        }
        register(e22, s3) {
          if (e22)
            if (s3 = s3 === void 0 ? t3.toParent : s3, Array.isArray(e22))
              for (const t4 of e22)
                this.register(t4, s3);
            else if (c2.isSchema(e22))
              for (const t4 of e22._refs.refs)
                t4.ancestor - s3 >= 0 && this.refs.push({ ancestor: t4.ancestor - s3, root: t4.root });
            else
              t3.isRef(e22) && e22.type === "value" && e22.ancestor - s3 >= 0 && this.refs.push({ ancestor: e22.ancestor - s3, root: e22.root }), u2 = u2 || r2(3328), u2.isTemplate(e22) && this.register(e22.refs(), s3);
        }
        get length() {
          return this.refs.length;
        }
        clone() {
          const e22 = new t3.Manager();
          return e22.refs = i2(this.refs), e22;
        }
        reset() {
          this.refs = [];
        }
        roots() {
          return this.refs.filter((e22) => !e22.ancestor).map((e22) => e22.root);
        }
      };
    }, 3378: (e21, t3, r2) => {
      const s2 = r2(5107), n2 = {};
      n2.wrap = s2.string().min(1).max(2).allow(false), t3.preferences = s2.object({ allowUnknown: s2.boolean(), abortEarly: s2.boolean(), artifacts: s2.boolean(), cache: s2.boolean(), context: s2.object(), convert: s2.boolean(), dateFormat: s2.valid("date", "iso", "string", "time", "utc"), debug: s2.boolean(), errors: { escapeHtml: s2.boolean(), label: s2.valid("path", "key", false), language: [s2.string(), s2.object().ref()], render: s2.boolean(), stack: s2.boolean(), wrap: { label: n2.wrap, array: n2.wrap } }, externals: s2.boolean(), messages: s2.object(), noDefaults: s2.boolean(), nonEnumerables: s2.boolean(), presence: s2.valid("required", "optional", "forbidden"), skipFunctions: s2.boolean(), stripUnknown: s2.object({ arrays: s2.boolean(), objects: s2.boolean() }).or("arrays", "objects").allow(true, false), warnings: s2.boolean() }).strict(), n2.nameRx = /^[a-zA-Z0-9]\w*$/, n2.rule = s2.object({ alias: s2.array().items(s2.string().pattern(n2.nameRx)).single(), args: s2.array().items(s2.string(), s2.object({ name: s2.string().pattern(n2.nameRx).required(), ref: s2.boolean(), assert: s2.alternatives([s2.function(), s2.object().schema()]).conditional("ref", { is: true, then: s2.required() }), normalize: s2.function(), message: s2.string().when("assert", { is: s2.function(), then: s2.required() }) })), convert: s2.boolean(), manifest: s2.boolean(), method: s2.function().allow(false), multi: s2.boolean(), validate: s2.function() }), t3.extension = s2.object({ type: s2.alternatives([s2.string(), s2.object().regex()]).required(), args: s2.function(), cast: s2.object().pattern(n2.nameRx, s2.object({ from: s2.function().maxArity(1).required(), to: s2.function().minArity(1).maxArity(2).required() })), base: s2.object().schema().when("type", { is: s2.object().regex(), then: s2.forbidden() }), coerce: [s2.function().maxArity(3), s2.object({ method: s2.function().maxArity(3).required(), from: s2.array().items(s2.string()).single() })], flags: s2.object().pattern(n2.nameRx, s2.object({ setter: s2.string(), default: s2.any() })), manifest: { build: s2.function().arity(2) }, messages: [s2.object(), s2.string()], modifiers: s2.object().pattern(n2.nameRx, s2.function().minArity(1).maxArity(2)), overrides: s2.object().pattern(n2.nameRx, s2.function()), prepare: s2.function().maxArity(3), rebuild: s2.function().arity(1), rules: s2.object().pattern(n2.nameRx, n2.rule), terms: s2.object().pattern(n2.nameRx, s2.object({ init: s2.array().allow(null).required(), manifest: s2.object().pattern(/.+/, [s2.valid("schema", "single"), s2.object({ mapped: s2.object({ from: s2.string().required(), to: s2.string().required() }).required() })]) })), validate: s2.function().maxArity(3) }).strict(), t3.extensions = s2.array().items(s2.object(), s2.function().arity(1)).strict(), n2.desc = { buffer: s2.object({ buffer: s2.string() }), func: s2.object({ function: s2.function().required(), options: { literal: true } }), override: s2.object({ override: true }), ref: s2.object({ ref: s2.object({ type: s2.valid("value", "global", "local"), path: s2.array().required(), separator: s2.string().length(1).allow(false), ancestor: s2.number().min(0).integer().allow("root"), map: s2.array().items(s2.array().length(2)).min(1), adjust: s2.function(), iterables: s2.boolean(), in: s2.boolean(), render: s2.boolean() }).required() }), regex: s2.object({ regex: s2.string().min(3) }), special: s2.object({ special: s2.valid("deep").required() }), template: s2.object({ template: s2.string().required(), options: s2.object() }), value: s2.object({ value: s2.alternatives([s2.object(), s2.array()]).required() }) }, n2.desc.entity = s2.alternatives([s2.array().items(s2.link("...")), s2.boolean(), s2.function(), s2.number(), s2.string(), n2.desc.buffer, n2.desc.func, n2.desc.ref, n2.desc.regex, n2.desc.special, n2.desc.template, n2.desc.value, s2.link("/")]), n2.desc.values = s2.array().items(null, s2.boolean(), s2.function(), s2.number().allow(1 / 0, -1 / 0), s2.string().allow(""), s2.symbol(), n2.desc.buffer, n2.desc.func, n2.desc.override, n2.desc.ref, n2.desc.regex, n2.desc.template, n2.desc.value), n2.desc.messages = s2.object().pattern(/.+/, [s2.string(), n2.desc.template, s2.object().pattern(/.+/, [s2.string(), n2.desc.template])]), t3.description = s2.object({ type: s2.string().required(), flags: s2.object({ cast: s2.string(), default: s2.any(), description: s2.string(), empty: s2.link("/"), failover: n2.desc.entity, id: s2.string(), label: s2.string(), only: true, presence: ["optional", "required", "forbidden"], result: ["raw", "strip"], strip: s2.boolean(), unit: s2.string() }).unknown(), preferences: { allowUnknown: s2.boolean(), abortEarly: s2.boolean(), artifacts: s2.boolean(), cache: s2.boolean(), convert: s2.boolean(), dateFormat: ["date", "iso", "string", "time", "utc"], errors: { escapeHtml: s2.boolean(), label: ["path", "key"], language: [s2.string(), n2.desc.ref], wrap: { label: n2.wrap, array: n2.wrap } }, externals: s2.boolean(), messages: n2.desc.messages, noDefaults: s2.boolean(), nonEnumerables: s2.boolean(), presence: ["required", "optional", "forbidden"], skipFunctions: s2.boolean(), stripUnknown: s2.object({ arrays: s2.boolean(), objects: s2.boolean() }).or("arrays", "objects").allow(true, false), warnings: s2.boolean() }, allow: n2.desc.values, invalid: n2.desc.values, rules: s2.array().min(1).items({ name: s2.string().required(), args: s2.object().min(1), keep: s2.boolean(), message: [s2.string(), n2.desc.messages], warn: s2.boolean() }), keys: s2.object().pattern(/.*/, s2.link("/")), link: n2.desc.ref }).pattern(/^[a-z]\w*$/, s2.any());
    }, 493: (e21, t3, r2) => {
      const s2 = r2(8571), n2 = r2(9621), a2 = r2(8160), o2 = { value: Symbol("value") };
      e21.exports = o2.State = class {
        constructor(e22, t4, r3) {
          this.path = e22, this.ancestors = t4, this.mainstay = r3.mainstay, this.schemas = r3.schemas, this.debug = null;
        }
        localize(e22, t4 = null, r3 = null) {
          const s3 = new o2.State(e22, t4, this);
          return r3 && s3.schemas && (s3.schemas = [o2.schemas(r3), ...s3.schemas]), s3;
        }
        nest(e22, t4) {
          const r3 = new o2.State(this.path, this.ancestors, this);
          return r3.schemas = r3.schemas && [o2.schemas(e22), ...r3.schemas], r3.debug = t4, r3;
        }
        shadow(e22, t4) {
          this.mainstay.shadow = this.mainstay.shadow || new o2.Shadow(), this.mainstay.shadow.set(this.path, e22, t4);
        }
        snapshot() {
          this.mainstay.shadow && (this._snapshot = s2(this.mainstay.shadow.node(this.path)));
        }
        restore() {
          this.mainstay.shadow && (this.mainstay.shadow.override(this.path, this._snapshot), this._snapshot = void 0);
        }
      }, o2.schemas = function(e22) {
        return a2.isSchema(e22) ? { schema: e22 } : e22;
      }, o2.Shadow = class {
        constructor() {
          this._values = null;
        }
        set(e22, t4, r3) {
          if (!e22.length)
            return;
          if (r3 === "strip" && typeof e22[e22.length - 1] == "number")
            return;
          this._values = this._values || new Map();
          let s3 = this._values;
          for (let t5 = 0; t5 < e22.length; ++t5) {
            const r4 = e22[t5];
            let n3 = s3.get(r4);
            n3 || (n3 = new Map(), s3.set(r4, n3)), s3 = n3;
          }
          s3[o2.value] = t4;
        }
        get(e22) {
          const t4 = this.node(e22);
          if (t4)
            return t4[o2.value];
        }
        node(e22) {
          if (this._values)
            return n2(this._values, e22, { iterables: true });
        }
        override(e22, t4) {
          if (!this._values)
            return;
          const r3 = e22.slice(0, -1), s3 = e22[e22.length - 1], a3 = n2(this._values, r3, { iterables: true });
          t4 ? a3.set(s3, t4) : a3 && a3.delete(s3);
        }
      };
    }, 3328: (e21, t3, r2) => {
      function s2(e22, t4) {
        var r3 = Object.keys(e22);
        if (Object.getOwnPropertySymbols) {
          var s3 = Object.getOwnPropertySymbols(e22);
          t4 && (s3 = s3.filter(function(t5) {
            return Object.getOwnPropertyDescriptor(e22, t5).enumerable;
          })), r3.push.apply(r3, s3);
        }
        return r3;
      }
      function n2(e22, t4, r3) {
        return t4 in e22 ? Object.defineProperty(e22, t4, { value: r3, enumerable: true, configurable: true, writable: true }) : e22[t4] = r3, e22;
      }
      const a2 = r2(375), o2 = r2(8571), i2 = r2(5277), l2 = r2(1447), c2 = r2(8160), u2 = r2(6354), f2 = r2(6133), m2 = { symbol: Symbol("template"), opens: new Array(1e3).join("\0"), closes: new Array(1e3).join(""), dateFormat: { date: Date.prototype.toDateString, iso: Date.prototype.toISOString, string: Date.prototype.toString, time: Date.prototype.toTimeString, utc: Date.prototype.toUTCString } };
      e21.exports = m2.Template = class {
        constructor(e22, t4) {
          a2(typeof e22 == "string", "Template source must be a string"), a2(!e22.includes("\0") && !e22.includes(""), "Template source cannot contain reserved control characters"), this.source = e22, this.rendered = e22, this._template = null, this._settings = o2(t4), this._parse();
        }
        _parse() {
          if (!this.source.includes("{"))
            return;
          const e22 = m2.encode(this.source), t4 = m2.split(e22);
          let r3 = false;
          const s3 = [], n3 = t4.shift();
          n3 && s3.push(n3);
          for (const e23 of t4) {
            const t5 = e23[0] !== "{", n4 = t5 ? "}" : "}}", a3 = e23.indexOf(n4);
            if (a3 === -1 || e23[1] === "{") {
              s3.push("{".concat(m2.decode(e23)));
              continue;
            }
            let o3 = e23.slice(t5 ? 0 : 1, a3);
            const i3 = o3[0] === ":";
            i3 && (o3 = o3.slice(1));
            const l3 = this._ref(m2.decode(o3), { raw: t5, wrapped: i3 });
            s3.push(l3), typeof l3 != "string" && (r3 = true);
            const c3 = e23.slice(a3 + n4.length);
            c3 && s3.push(m2.decode(c3));
          }
          r3 ? this._template = s3 : this.rendered = s3.join("");
        }
        static date(e22, t4) {
          return m2.dateFormat[t4.dateFormat].call(e22);
        }
        describe(e22 = {}) {
          if (!this._settings && e22.compact)
            return this.source;
          const t4 = { template: this.source };
          return this._settings && (t4.options = this._settings), t4;
        }
        static build(e22) {
          return new m2.Template(e22.template, e22.options);
        }
        isDynamic() {
          return !!this._template;
        }
        static isTemplate(e22) {
          return !!e22 && !!e22[c2.symbols.template];
        }
        refs() {
          if (!this._template)
            return;
          const e22 = [];
          for (const t4 of this._template)
            typeof t4 != "string" && e22.push(...t4.refs);
          return e22;
        }
        resolve(e22, t4, r3, s3) {
          return this._template && this._template.length === 1 ? this._part(this._template[0], e22, t4, r3, s3, {}) : this.render(e22, t4, r3, s3);
        }
        _part(e22, ...t4) {
          return e22.ref ? e22.ref.resolve(...t4) : e22.formula.evaluate(t4);
        }
        render(e22, t4, r3, s3, n3 = {}) {
          if (!this.isDynamic())
            return this.rendered;
          const a3 = [];
          for (const o3 of this._template)
            if (typeof o3 == "string")
              a3.push(o3);
            else {
              const l3 = this._part(o3, e22, t4, r3, s3, n3), c3 = m2.stringify(l3, e22, t4, r3, s3, n3);
              if (c3 !== void 0) {
                const e23 = o3.raw || (n3.errors && n3.errors.escapeHtml) === false ? c3 : i2(c3);
                a3.push(m2.wrap(e23, o3.wrapped && r3.errors.wrap.label));
              }
            }
          return a3.join("");
        }
        _ref(e22, { raw: t4, wrapped: r3 }) {
          const s3 = [], n3 = (e23) => {
            const t5 = f2.create(e23, this._settings);
            return s3.push(t5), (e24) => t5.resolve(...e24);
          };
          try {
            var a3 = new l2.Parser(e22, { reference: n3, functions: m2.functions, constants: m2.constants });
          } catch (t5) {
            throw t5.message = 'Invalid template variable "'.concat(e22, '" fails due to: ').concat(t5.message), t5;
          }
          if (a3.single) {
            if (a3.single.type === "reference") {
              const e23 = s3[0];
              return { ref: e23, raw: t4, refs: s3, wrapped: r3 || e23.type === "local" && e23.key === "label" };
            }
            return m2.stringify(a3.single.value);
          }
          return { formula: a3, raw: t4, refs: s3 };
        }
        toString() {
          return this.source;
        }
      }, m2.Template.prototype[c2.symbols.template] = true, m2.Template.prototype.isImmutable = true, m2.encode = function(e22) {
        return e22.replace(/\\(\{+)/g, (e23, t4) => m2.opens.slice(0, t4.length)).replace(/\\(\}+)/g, (e23, t4) => m2.closes.slice(0, t4.length));
      }, m2.decode = function(e22) {
        return e22.replace(/\u0000/g, "{").replace(/\u0001/g, "}");
      }, m2.split = function(e22) {
        const t4 = [];
        let r3 = "";
        for (let s3 = 0; s3 < e22.length; ++s3) {
          const n3 = e22[s3];
          if (n3 === "{") {
            let n4 = "";
            for (; s3 + 1 < e22.length && e22[s3 + 1] === "{"; )
              n4 += "{", ++s3;
            t4.push(r3), r3 = n4;
          } else
            r3 += n3;
        }
        return t4.push(r3), t4;
      }, m2.wrap = function(e22, t4) {
        return t4 ? t4.length === 1 ? "".concat(t4).concat(e22).concat(t4) : "".concat(t4[0]).concat(e22).concat(t4[1]) : e22;
      }, m2.stringify = function(e22, t4, r3, a3, o3, i3) {
        const l3 = typeof e22;
        let c3 = false;
        if (f2.isRef(e22) && e22.render && (c3 = e22.in, e22 = e22.resolve(t4, r3, a3, o3, function(e23) {
          for (var t5 = 1; t5 < arguments.length; t5++) {
            var r4 = arguments[t5] != null ? arguments[t5] : {};
            t5 % 2 ? s2(Object(r4), true).forEach(function(t6) {
              n2(e23, t6, r4[t6]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e23, Object.getOwnPropertyDescriptors(r4)) : s2(Object(r4)).forEach(function(t6) {
              Object.defineProperty(e23, t6, Object.getOwnPropertyDescriptor(r4, t6));
            });
          }
          return e23;
        }({ in: e22.in }, i3))), e22 === null)
          return "null";
        if (l3 === "string")
          return e22;
        if (l3 === "number" || l3 === "function" || l3 === "symbol")
          return e22.toString();
        if (l3 !== "object")
          return JSON.stringify(e22);
        if (e22 instanceof Date)
          return m2.Template.date(e22, a3);
        if (e22 instanceof Map) {
          const t5 = [];
          for (const [r4, s3] of e22.entries())
            t5.push("".concat(r4.toString(), " -> ").concat(s3.toString()));
          e22 = t5;
        }
        if (!Array.isArray(e22))
          return e22.toString();
        let u3 = "";
        for (const s3 of e22)
          u3 = u3 + (u3.length ? ", " : "") + m2.stringify(s3, t4, r3, a3, o3, i3);
        return c3 ? u3 : m2.wrap(u3, a3.errors.wrap.array);
      }, m2.constants = { true: true, false: false, null: null, second: 1e3, minute: 6e4, hour: 36e5, day: 864e5 }, m2.functions = { if: (e22, t4, r3) => e22 ? t4 : r3, msg(e22) {
        const [t4, r3, s3, n3, a3] = this, o3 = a3.messages;
        if (!o3)
          return "";
        const i3 = u2.template(t4, o3[0], e22, r3, s3) || u2.template(t4, o3[1], e22, r3, s3);
        return i3 ? i3.render(t4, r3, s3, n3, a3) : "";
      }, number: (e22) => typeof e22 == "number" ? e22 : typeof e22 == "string" ? parseFloat(e22) : typeof e22 == "boolean" ? e22 ? 1 : 0 : e22 instanceof Date ? e22.getTime() : null };
    }, 4946: (e21, t3, r2) => {
      const s2 = r2(375), n2 = r2(1687), a2 = r2(8068), o2 = r2(8160), i2 = r2(3292), l2 = r2(6354), c2 = r2(6133), u2 = {};
      e21.exports = a2.extend({ type: "alternatives", flags: { match: { default: "any" } }, terms: { matches: { init: [], register: c2.toSibling } }, args: (e22, ...t4) => t4.length === 1 && Array.isArray(t4[0]) ? e22.try(...t4[0]) : e22.try(...t4), validate(e22, t4) {
        const { schema: r3, error: s3, state: a3, prefs: o3 } = t4;
        if (r3._flags.match) {
          const t5 = [];
          for (let s4 = 0; s4 < r3.$_terms.matches.length; ++s4) {
            const n3 = r3.$_terms.matches[s4], i4 = a3.nest(n3.schema, "match.".concat(s4));
            i4.snapshot();
            const l3 = n3.schema.$_validate(e22, i4, o3);
            l3.errors ? i4.restore() : t5.push(l3.value);
          }
          return t5.length === 0 ? { errors: s3("alternatives.any") } : r3._flags.match === "one" ? t5.length === 1 ? { value: t5[0] } : { errors: s3("alternatives.one") } : t5.length !== r3.$_terms.matches.length ? { errors: s3("alternatives.all") } : r3.$_terms.matches.reduce((e23, t6) => e23 && t6.schema.type === "object", true) ? { value: t5.reduce((e23, t6) => n2(e23, t6, { mergeArrays: false })) } : { value: t5[t5.length - 1] };
        }
        const i3 = [];
        for (let t5 = 0; t5 < r3.$_terms.matches.length; ++t5) {
          const s4 = r3.$_terms.matches[t5];
          if (s4.schema) {
            const r4 = a3.nest(s4.schema, "match.".concat(t5));
            r4.snapshot();
            const n4 = s4.schema.$_validate(e22, r4, o3);
            if (!n4.errors)
              return n4;
            r4.restore(), i3.push({ schema: s4.schema, reports: n4.errors });
            continue;
          }
          const n3 = s4.ref ? s4.ref.resolve(e22, a3, o3) : e22, l3 = s4.is ? [s4] : s4.switch;
          for (let r4 = 0; r4 < l3.length; ++r4) {
            const i4 = l3[r4], { is: c3, then: u3, otherwise: f2 } = i4, m2 = "match.".concat(t5).concat(s4.switch ? "." + r4 : "");
            if (c3.$_match(n3, a3.nest(c3, "".concat(m2, ".is")), o3)) {
              if (u3)
                return u3.$_validate(e22, a3.nest(u3, "".concat(m2, ".then")), o3);
            } else if (f2)
              return f2.$_validate(e22, a3.nest(f2, "".concat(m2, ".otherwise")), o3);
          }
        }
        return u2.errors(i3, t4);
      }, rules: { conditional: { method(e22, t4) {
        s2(!this._flags._endedSwitch, "Unreachable condition"), s2(!this._flags.match, "Cannot combine match mode", this._flags.match, "with conditional rule"), s2(t4.break === void 0, "Cannot use break option with alternatives conditional");
        const r3 = this.clone(), n3 = i2.when(r3, e22, t4), a3 = n3.is ? [n3] : n3.switch;
        for (const e23 of a3)
          if (e23.then && e23.otherwise) {
            r3.$_setFlag("_endedSwitch", true, { clone: false });
            break;
          }
        return r3.$_terms.matches.push(n3), r3.$_mutateRebuild();
      } }, match: { method(e22) {
        if (s2(["any", "one", "all"].includes(e22), "Invalid alternatives match mode", e22), e22 !== "any")
          for (const t4 of this.$_terms.matches)
            s2(t4.schema, "Cannot combine match mode", e22, "with conditional rules");
        return this.$_setFlag("match", e22);
      } }, try: { method(...e22) {
        s2(e22.length, "Missing alternative schemas"), o2.verifyFlat(e22, "try"), s2(!this._flags._endedSwitch, "Unreachable condition");
        const t4 = this.clone();
        for (const r3 of e22)
          t4.$_terms.matches.push({ schema: t4.$_compile(r3) });
        return t4.$_mutateRebuild();
      } } }, overrides: { label(e22) {
        return this.$_parent("label", e22).$_modify({ each: (t4, r3) => r3.path[0] !== "is" ? t4.label(e22) : void 0, ref: false });
      } }, rebuild(e22) {
        e22.$_modify({ each: (t4) => {
          o2.isSchema(t4) && t4.type === "array" && e22.$_setFlag("_arrayItems", true, { clone: false });
        } });
      }, manifest: { build(e22, t4) {
        if (t4.matches)
          for (const r3 of t4.matches) {
            const { schema: t5, ref: s3, is: n3, not: a3, then: o3, otherwise: i3 } = r3;
            e22 = t5 ? e22.try(t5) : s3 ? e22.conditional(s3, { is: n3, then: o3, not: a3, otherwise: i3, switch: r3.switch }) : e22.conditional(n3, { then: o3, otherwise: i3 });
          }
        return e22;
      } }, messages: { "alternatives.all": "{{#label}} does not match all of the required types", "alternatives.any": "{{#label}} does not match any of the allowed types", "alternatives.match": "{{#label}} does not match any of the allowed types", "alternatives.one": "{{#label}} matches more than one allowed type", "alternatives.types": "{{#label}} must be one of {{#types}}" } }), u2.errors = function(e22, { error: t4, state: r3 }) {
        if (!e22.length)
          return { errors: t4("alternatives.any") };
        if (e22.length === 1)
          return { errors: e22[0].reports };
        const s3 = new Set(), n3 = [];
        for (const { reports: a3, schema: o3 } of e22) {
          if (a3.length > 1)
            return u2.unmatched(e22, t4);
          const i3 = a3[0];
          if (i3 instanceof l2.Report == 0)
            return u2.unmatched(e22, t4);
          if (i3.state.path.length !== r3.path.length) {
            n3.push({ type: o3.type, report: i3 });
            continue;
          }
          if (i3.code === "any.only") {
            for (const e23 of i3.local.valids)
              s3.add(e23);
            continue;
          }
          const [c3, f2] = i3.code.split(".");
          f2 === "base" ? s3.add(c3) : n3.push({ type: o3.type, report: i3 });
        }
        return n3.length ? n3.length === 1 ? { errors: n3[0].report } : u2.unmatched(e22, t4) : { errors: t4("alternatives.types", { types: [...s3] }) };
      }, u2.unmatched = function(e22, t4) {
        const r3 = [];
        for (const t5 of e22)
          r3.push(...t5.reports);
        return { errors: t4("alternatives.match", l2.details(r3, { override: false })) };
      };
    }, 8068: (e21, t3, r2) => {
      const s2 = r2(375), n2 = r2(7629), a2 = r2(8160), o2 = r2(6914);
      e21.exports = n2.extend({ type: "any", flags: { only: { default: false } }, terms: { alterations: { init: null }, examples: { init: null }, externals: { init: null }, metas: { init: [] }, notes: { init: [] }, shared: { init: null }, tags: { init: [] }, whens: { init: null } }, rules: { custom: { method(e22, t4) {
        return s2(typeof e22 == "function", "Method must be a function"), s2(t4 === void 0 || t4 && typeof t4 == "string", "Description must be a non-empty string"), this.$_addRule({ name: "custom", args: { method: e22, description: t4 } });
      }, validate(e22, t4, { method: r3 }) {
        try {
          return r3(e22, t4);
        } catch (e23) {
          return t4.error("any.custom", { error: e23 });
        }
      }, args: ["method", "description"], multi: true }, messages: { method(e22) {
        return this.prefs({ messages: e22 });
      } }, shared: { method(e22) {
        s2(a2.isSchema(e22) && e22._flags.id, "Schema must be a schema with an id");
        const t4 = this.clone();
        return t4.$_terms.shared = t4.$_terms.shared || [], t4.$_terms.shared.push(e22), t4.$_mutateRegister(e22), t4;
      } }, warning: { method(e22, t4) {
        return s2(e22 && typeof e22 == "string", "Invalid warning code"), this.$_addRule({ name: "warning", args: { code: e22, local: t4 }, warn: true });
      }, validate: (e22, t4, { code: r3, local: s3 }) => t4.error(r3, s3), args: ["code", "local"], multi: true } }, modifiers: { keep(e22, t4 = true) {
        e22.keep = t4;
      }, message(e22, t4) {
        e22.message = o2.compile(t4);
      }, warn(e22, t4 = true) {
        e22.warn = t4;
      } }, manifest: { build(e22, t4) {
        for (const r3 in t4) {
          const s3 = t4[r3];
          if (["examples", "externals", "metas", "notes", "tags"].includes(r3))
            for (const t5 of s3)
              e22 = e22[r3.slice(0, -1)](t5);
          else if (r3 !== "alterations")
            if (r3 !== "whens") {
              if (r3 === "shared")
                for (const t5 of s3)
                  e22 = e22.shared(t5);
            } else
              for (const t5 of s3) {
                const { ref: r4, is: s4, not: n3, then: a3, otherwise: o3, concat: i2 } = t5;
                e22 = i2 ? e22.concat(i2) : r4 ? e22.when(r4, { is: s4, not: n3, then: a3, otherwise: o3, switch: t5.switch, break: t5.break }) : e22.when(s4, { then: a3, otherwise: o3, break: t5.break });
              }
          else {
            const t5 = {};
            for (const { target: e23, adjuster: r4 } of s3)
              t5[e23] = r4;
            e22 = e22.alter(t5);
          }
        }
        return e22;
      } }, messages: { "any.custom": "{{#label}} failed custom validation because {{#error.message}}", "any.default": "{{#label}} threw an error when running default method", "any.failover": "{{#label}} threw an error when running failover method", "any.invalid": "{{#label}} contains an invalid value", "any.only": '{{#label}} must be {if(#valids.length == 1, "", "one of ")}{{#valids}}', "any.ref": "{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}", "any.required": "{{#label}} is required", "any.unknown": "{{#label}} is not allowed" } });
    }, 546: (e21, t3, r2) => {
      const s2 = r2(375), n2 = r2(9474), a2 = r2(9621), o2 = r2(8068), i2 = r2(8160), l2 = r2(3292), c2 = {};
      e21.exports = o2.extend({ type: "array", flags: { single: { default: false }, sparse: { default: false } }, terms: { items: { init: [], manifest: "schema" }, ordered: { init: [], manifest: "schema" }, _exclusions: { init: [] }, _inclusions: { init: [] }, _requireds: { init: [] } }, coerce: { from: "object", method(e22, { schema: t4, state: r3, prefs: s3 }) {
        if (!Array.isArray(e22))
          return;
        const n3 = t4.$_getRule("sort");
        return n3 ? c2.sort(t4, e22, n3.args.options, r3, s3) : void 0;
      } }, validate(e22, { schema: t4, error: r3 }) {
        if (!Array.isArray(e22)) {
          if (t4._flags.single) {
            const t5 = [e22];
            return t5[i2.symbols.arraySingle] = true, { value: t5 };
          }
          return { errors: r3("array.base") };
        }
        if (t4.$_getRule("items") || t4.$_terms.externals)
          return { value: e22.slice() };
      }, rules: { has: { method(e22) {
        e22 = this.$_compile(e22, { appendPath: true });
        const t4 = this.$_addRule({ name: "has", args: { schema: e22 } });
        return t4.$_mutateRegister(e22), t4;
      }, validate(e22, { state: t4, prefs: r3, error: s3 }, { schema: n3 }) {
        const a3 = [e22, ...t4.ancestors];
        for (let s4 = 0; s4 < e22.length; ++s4) {
          const o4 = t4.localize([...t4.path, s4], a3, n3);
          if (n3.$_match(e22[s4], o4, r3))
            return e22;
        }
        const o3 = n3._flags.label;
        return o3 ? s3("array.hasKnown", { patternLabel: o3 }) : s3("array.hasUnknown", null);
      }, multi: true }, items: { method(...e22) {
        i2.verifyFlat(e22, "items");
        const t4 = this.$_addRule("items");
        for (let r3 = 0; r3 < e22.length; ++r3) {
          const s3 = i2.tryWithPath(() => this.$_compile(e22[r3]), r3, { append: true });
          t4.$_terms.items.push(s3);
        }
        return t4.$_mutateRebuild();
      }, validate(e22, { schema: t4, error: r3, state: s3, prefs: n3, errorsArray: a3 }) {
        const o3 = t4.$_terms._requireds.slice(), l3 = t4.$_terms.ordered.slice(), u2 = [...t4.$_terms._inclusions, ...o3], f2 = !e22[i2.symbols.arraySingle];
        delete e22[i2.symbols.arraySingle];
        const m2 = a3();
        let h2 = e22.length;
        for (let a4 = 0; a4 < h2; ++a4) {
          const i3 = e22[a4];
          let d2 = false, p2 = false;
          const g2 = f2 ? a4 : new Number(a4), y2 = [...s3.path, g2];
          if (!t4._flags.sparse && i3 === void 0) {
            if (m2.push(r3("array.sparse", { key: g2, path: y2, pos: a4, value: void 0 }, s3.localize(y2))), n3.abortEarly)
              return m2;
            l3.shift();
            continue;
          }
          const b2 = [e22, ...s3.ancestors];
          for (const e23 of t4.$_terms._exclusions)
            if (e23.$_match(i3, s3.localize(y2, b2, e23), n3, { presence: "ignore" })) {
              if (m2.push(r3("array.excludes", { pos: a4, value: i3 }, s3.localize(y2))), n3.abortEarly)
                return m2;
              d2 = true, l3.shift();
              break;
            }
          if (d2)
            continue;
          if (t4.$_terms.ordered.length) {
            if (l3.length) {
              const o4 = l3.shift(), u3 = o4.$_validate(i3, s3.localize(y2, b2, o4), n3);
              if (u3.errors) {
                if (m2.push(...u3.errors), n3.abortEarly)
                  return m2;
              } else if (o4._flags.result === "strip")
                c2.fastSplice(e22, a4), --a4, --h2;
              else {
                if (!t4._flags.sparse && u3.value === void 0) {
                  if (m2.push(r3("array.sparse", { key: g2, path: y2, pos: a4, value: void 0 }, s3.localize(y2))), n3.abortEarly)
                    return m2;
                  continue;
                }
                e22[a4] = u3.value;
              }
              continue;
            }
            if (!t4.$_terms.items.length) {
              if (m2.push(r3("array.orderedLength", { pos: a4, limit: t4.$_terms.ordered.length })), n3.abortEarly)
                return m2;
              break;
            }
          }
          const v2 = [];
          let _2 = o3.length;
          for (let l4 = 0; l4 < _2; ++l4) {
            const u3 = s3.localize(y2, b2, o3[l4]);
            u3.snapshot();
            const f3 = o3[l4].$_validate(i3, u3, n3);
            if (v2[l4] = f3, !f3.errors) {
              if (e22[a4] = f3.value, p2 = true, c2.fastSplice(o3, l4), --l4, --_2, !t4._flags.sparse && f3.value === void 0 && (m2.push(r3("array.sparse", { key: g2, path: y2, pos: a4, value: void 0 }, s3.localize(y2))), n3.abortEarly))
                return m2;
              break;
            }
            u3.restore();
          }
          if (p2)
            continue;
          const w2 = n3.stripUnknown && !!n3.stripUnknown.arrays || false;
          _2 = u2.length;
          for (const l4 of u2) {
            let u3;
            const f3 = o3.indexOf(l4);
            if (f3 !== -1)
              u3 = v2[f3];
            else {
              const o4 = s3.localize(y2, b2, l4);
              if (o4.snapshot(), u3 = l4.$_validate(i3, o4, n3), !u3.errors) {
                l4._flags.result === "strip" ? (c2.fastSplice(e22, a4), --a4, --h2) : t4._flags.sparse || u3.value !== void 0 ? e22[a4] = u3.value : (m2.push(r3("array.sparse", { key: g2, path: y2, pos: a4, value: void 0 }, s3.localize(y2))), d2 = true), p2 = true;
                break;
              }
              o4.restore();
            }
            if (_2 === 1) {
              if (w2) {
                c2.fastSplice(e22, a4), --a4, --h2, p2 = true;
                break;
              }
              if (m2.push(...u3.errors), n3.abortEarly)
                return m2;
              d2 = true;
              break;
            }
          }
          if (!d2 && (t4.$_terms._inclusions.length || t4.$_terms._requireds.length) && !p2) {
            if (w2) {
              c2.fastSplice(e22, a4), --a4, --h2;
              continue;
            }
            if (m2.push(r3("array.includes", { pos: a4, value: i3 }, s3.localize(y2))), n3.abortEarly)
              return m2;
          }
        }
        return o3.length && c2.fillMissedErrors(t4, m2, o3, e22, s3, n3), l3.length && (c2.fillOrderedErrors(t4, m2, l3, e22, s3, n3), m2.length || c2.fillDefault(l3, e22, s3, n3)), m2.length ? m2 : e22;
      }, priority: true, manifest: false }, length: { method(e22) {
        return this.$_addRule({ name: "length", args: { limit: e22 }, operator: "=" });
      }, validate: (e22, t4, { limit: r3 }, { name: s3, operator: n3, args: a3 }) => i2.compare(e22.length, r3, n3) ? e22 : t4.error("array." + s3, { limit: a3.limit, value: e22 }), args: [{ name: "limit", ref: true, assert: i2.limit, message: "must be a positive integer" }] }, max: { method(e22) {
        return this.$_addRule({ name: "max", method: "length", args: { limit: e22 }, operator: "<=" });
      } }, min: { method(e22) {
        return this.$_addRule({ name: "min", method: "length", args: { limit: e22 }, operator: ">=" });
      } }, ordered: { method(...e22) {
        i2.verifyFlat(e22, "ordered");
        const t4 = this.$_addRule("items");
        for (let r3 = 0; r3 < e22.length; ++r3) {
          const s3 = i2.tryWithPath(() => this.$_compile(e22[r3]), r3, { append: true });
          c2.validateSingle(s3, t4), t4.$_mutateRegister(s3), t4.$_terms.ordered.push(s3);
        }
        return t4.$_mutateRebuild();
      } }, single: { method(e22) {
        const t4 = e22 === void 0 || !!e22;
        return s2(!t4 || !this._flags._arrayItems, "Cannot specify single rule when array has array items"), this.$_setFlag("single", t4);
      } }, sort: { method(e22 = {}) {
        i2.assertOptions(e22, ["by", "order"]);
        const t4 = { order: e22.order || "ascending" };
        return e22.by && (t4.by = l2.ref(e22.by, { ancestor: 0 }), s2(!t4.by.ancestor, "Cannot sort by ancestor")), this.$_addRule({ name: "sort", args: { options: t4 } });
      }, validate(e22, { error: t4, state: r3, prefs: s3, schema: n3 }, { options: a3 }) {
        const { value: o3, errors: i3 } = c2.sort(n3, e22, a3, r3, s3);
        if (i3)
          return i3;
        for (let r4 = 0; r4 < e22.length; ++r4)
          if (e22[r4] !== o3[r4])
            return t4("array.sort", { order: a3.order, by: a3.by ? a3.by.key : "value" });
        return e22;
      }, convert: true }, sparse: { method(e22) {
        const t4 = e22 === void 0 || !!e22;
        return this._flags.sparse === t4 ? this : (t4 ? this.clone() : this.$_addRule("items")).$_setFlag("sparse", t4, { clone: false });
      } }, unique: { method(e22, t4 = {}) {
        s2(!e22 || typeof e22 == "function" || typeof e22 == "string", "comparator must be a function or a string"), i2.assertOptions(t4, ["ignoreUndefined", "separator"]);
        const r3 = { name: "unique", args: { options: t4, comparator: e22 } };
        if (e22)
          if (typeof e22 == "string") {
            const s3 = i2.default(t4.separator, ".");
            r3.path = s3 ? e22.split(s3) : [e22];
          } else
            r3.comparator = e22;
        return this.$_addRule(r3);
      }, validate(e22, { state: t4, error: r3, schema: o3 }, { comparator: i3, options: l3 }, { comparator: c3, path: u2 }) {
        const f2 = { string: Object.create(null), number: Object.create(null), undefined: Object.create(null), boolean: Object.create(null), object: new Map(), function: new Map(), custom: new Map() }, m2 = c3 || n2, h2 = l3.ignoreUndefined;
        for (let n3 = 0; n3 < e22.length; ++n3) {
          const o4 = u2 ? a2(e22[n3], u2) : e22[n3], l4 = c3 ? f2.custom : f2[typeof o4];
          if (s2(l4, "Failed to find unique map container for type", typeof o4), l4 instanceof Map) {
            const s3 = l4.entries();
            let a3;
            for (; !(a3 = s3.next()).done; )
              if (m2(a3.value[0], o4)) {
                const s4 = t4.localize([...t4.path, n3], [e22, ...t4.ancestors]), o5 = { pos: n3, value: e22[n3], dupePos: a3.value[1], dupeValue: e22[a3.value[1]] };
                return u2 && (o5.path = i3), r3("array.unique", o5, s4);
              }
            l4.set(o4, n3);
          } else {
            if ((!h2 || o4 !== void 0) && l4[o4] !== void 0) {
              const s3 = { pos: n3, value: e22[n3], dupePos: l4[o4], dupeValue: e22[l4[o4]] };
              return u2 && (s3.path = i3), r3("array.unique", s3, t4.localize([...t4.path, n3], [e22, ...t4.ancestors]));
            }
            l4[o4] = n3;
          }
        }
        return e22;
      }, args: ["comparator", "options"], multi: true } }, cast: { set: { from: Array.isArray, to: (e22, t4) => new Set(e22) } }, rebuild(e22) {
        e22.$_terms._inclusions = [], e22.$_terms._exclusions = [], e22.$_terms._requireds = [];
        for (const t4 of e22.$_terms.items)
          c2.validateSingle(t4, e22), t4._flags.presence === "required" ? e22.$_terms._requireds.push(t4) : t4._flags.presence === "forbidden" ? e22.$_terms._exclusions.push(t4) : e22.$_terms._inclusions.push(t4);
        for (const t4 of e22.$_terms.ordered)
          c2.validateSingle(t4, e22);
      }, manifest: { build: (e22, t4) => (t4.items && (e22 = e22.items(...t4.items)), t4.ordered && (e22 = e22.ordered(...t4.ordered)), e22) }, messages: { "array.base": "{{#label}} must be an array", "array.excludes": "{{#label}} contains an excluded value", "array.hasKnown": "{{#label}} does not contain at least one required match for type {:#patternLabel}", "array.hasUnknown": "{{#label}} does not contain at least one required match", "array.includes": "{{#label}} does not match any of the allowed types", "array.includesRequiredBoth": "{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)", "array.includesRequiredKnowns": "{{#label}} does not contain {{#knownMisses}}", "array.includesRequiredUnknowns": "{{#label}} does not contain {{#unknownMisses}} required value(s)", "array.length": "{{#label}} must contain {{#limit}} items", "array.max": "{{#label}} must contain less than or equal to {{#limit}} items", "array.min": "{{#label}} must contain at least {{#limit}} items", "array.orderedLength": "{{#label}} must contain at most {{#limit}} items", "array.sort": "{{#label}} must be sorted in {#order} order by {{#by}}", "array.sort.mismatching": "{{#label}} cannot be sorted due to mismatching types", "array.sort.unsupported": "{{#label}} cannot be sorted due to unsupported type {#type}", "array.sparse": "{{#label}} must not be a sparse array item", "array.unique": "{{#label}} contains a duplicate value" } }), c2.fillMissedErrors = function(e22, t4, r3, s3, n3, a3) {
        const o3 = [];
        let i3 = 0;
        for (const e23 of r3) {
          const t5 = e23._flags.label;
          t5 ? o3.push(t5) : ++i3;
        }
        o3.length ? i3 ? t4.push(e22.$_createError("array.includesRequiredBoth", s3, { knownMisses: o3, unknownMisses: i3 }, n3, a3)) : t4.push(e22.$_createError("array.includesRequiredKnowns", s3, { knownMisses: o3 }, n3, a3)) : t4.push(e22.$_createError("array.includesRequiredUnknowns", s3, { unknownMisses: i3 }, n3, a3));
      }, c2.fillOrderedErrors = function(e22, t4, r3, s3, n3, a3) {
        const o3 = [];
        for (const e23 of r3)
          e23._flags.presence === "required" && o3.push(e23);
        o3.length && c2.fillMissedErrors(e22, t4, o3, s3, n3, a3);
      }, c2.fillDefault = function(e22, t4, r3, s3) {
        const n3 = [];
        let a3 = true;
        for (let o3 = e22.length - 1; o3 >= 0; --o3) {
          const i3 = e22[o3], l3 = [t4, ...r3.ancestors], c3 = i3.$_validate(void 0, r3.localize(r3.path, l3, i3), s3).value;
          if (a3) {
            if (c3 === void 0)
              continue;
            a3 = false;
          }
          n3.unshift(c3);
        }
        n3.length && t4.push(...n3);
      }, c2.fastSplice = function(e22, t4) {
        let r3 = t4;
        for (; r3 < e22.length; )
          e22[r3++] = e22[r3];
        --e22.length;
      }, c2.validateSingle = function(e22, t4) {
        (e22.type === "array" || e22._flags._arrayItems) && (s2(!t4._flags.single, "Cannot specify array item with single rule enabled"), t4.$_setFlag("_arrayItems", true, { clone: false }));
      }, c2.sort = function(e22, t4, r3, s3, n3) {
        const a3 = r3.order === "ascending" ? 1 : -1, o3 = -1 * a3, i3 = a3, l3 = (l4, u2) => {
          let f2 = c2.compare(l4, u2, o3, i3);
          if (f2 !== null)
            return f2;
          if (r3.by && (l4 = r3.by.resolve(l4, s3, n3), u2 = r3.by.resolve(u2, s3, n3)), f2 = c2.compare(l4, u2, o3, i3), f2 !== null)
            return f2;
          const m2 = typeof l4;
          if (m2 !== typeof u2)
            throw e22.$_createError("array.sort.mismatching", t4, null, s3, n3);
          if (m2 !== "number" && m2 !== "string")
            throw e22.$_createError("array.sort.unsupported", t4, { type: m2 }, s3, n3);
          return m2 === "number" ? (l4 - u2) * a3 : l4 < u2 ? o3 : i3;
        };
        try {
          return { value: t4.slice().sort(l3) };
        } catch (e23) {
          return { errors: e23 };
        }
      }, c2.compare = function(e22, t4, r3, s3) {
        return e22 === t4 ? 0 : e22 === void 0 ? 1 : t4 === void 0 ? -1 : e22 === null ? s3 : t4 === null ? r3 : null;
      };
    }, 4937: (e21, t3, r2) => {
      const s2 = r2(375), n2 = r2(8068), a2 = r2(8160), o2 = r2(2036), i2 = { isBool: function(e22) {
        return typeof e22 == "boolean";
      } };
      e21.exports = n2.extend({ type: "boolean", flags: { sensitive: { default: false } }, terms: { falsy: { init: null, manifest: "values" }, truthy: { init: null, manifest: "values" } }, coerce(e22, { schema: t4 }) {
        if (typeof e22 != "boolean") {
          if (typeof e22 == "string") {
            const r3 = t4._flags.sensitive ? e22 : e22.toLowerCase();
            e22 = r3 === "true" || r3 !== "false" && e22;
          }
          return typeof e22 != "boolean" && (e22 = t4.$_terms.truthy && t4.$_terms.truthy.has(e22, null, null, !t4._flags.sensitive) || (!t4.$_terms.falsy || !t4.$_terms.falsy.has(e22, null, null, !t4._flags.sensitive)) && e22), { value: e22 };
        }
      }, validate(e22, { error: t4 }) {
        if (typeof e22 != "boolean")
          return { value: e22, errors: t4("boolean.base") };
      }, rules: { truthy: { method(...e22) {
        a2.verifyFlat(e22, "truthy");
        const t4 = this.clone();
        t4.$_terms.truthy = t4.$_terms.truthy || new o2();
        for (let r3 = 0; r3 < e22.length; ++r3) {
          const n3 = e22[r3];
          s2(n3 !== void 0, "Cannot call truthy with undefined"), t4.$_terms.truthy.add(n3);
        }
        return t4;
      } }, falsy: { method(...e22) {
        a2.verifyFlat(e22, "falsy");
        const t4 = this.clone();
        t4.$_terms.falsy = t4.$_terms.falsy || new o2();
        for (let r3 = 0; r3 < e22.length; ++r3) {
          const n3 = e22[r3];
          s2(n3 !== void 0, "Cannot call falsy with undefined"), t4.$_terms.falsy.add(n3);
        }
        return t4;
      } }, sensitive: { method(e22 = true) {
        return this.$_setFlag("sensitive", e22);
      } } }, cast: { number: { from: i2.isBool, to: (e22, t4) => e22 ? 1 : 0 }, string: { from: i2.isBool, to: (e22, t4) => e22 ? "true" : "false" } }, manifest: { build: (e22, t4) => (t4.truthy && (e22 = e22.truthy(...t4.truthy)), t4.falsy && (e22 = e22.falsy(...t4.falsy)), e22) }, messages: { "boolean.base": "{{#label}} must be a boolean" } });
    }, 7500: (e21, t3, r2) => {
      const s2 = r2(375), n2 = r2(8068), a2 = r2(8160), o2 = r2(3328), i2 = { isDate: function(e22) {
        return e22 instanceof Date;
      } };
      e21.exports = n2.extend({ type: "date", coerce: { from: ["number", "string"], method: (e22, { schema: t4 }) => ({ value: i2.parse(e22, t4._flags.format) || e22 }) }, validate(e22, { schema: t4, error: r3, prefs: s3 }) {
        if (e22 instanceof Date && !isNaN(e22.getTime()))
          return;
        const n3 = t4._flags.format;
        return s3.convert && n3 && typeof e22 == "string" ? { value: e22, errors: r3("date.format", { format: n3 }) } : { value: e22, errors: r3("date.base") };
      }, rules: { compare: { method: false, validate(e22, t4, { date: r3 }, { name: s3, operator: n3, args: o3 }) {
        const i3 = r3 === "now" ? Date.now() : r3.getTime();
        return a2.compare(e22.getTime(), i3, n3) ? e22 : t4.error("date." + s3, { limit: o3.date, value: e22 });
      }, args: [{ name: "date", ref: true, normalize: (e22) => e22 === "now" ? e22 : i2.parse(e22), assert: (e22) => e22 !== null, message: "must have a valid date format" }] }, format: { method(e22) {
        return s2(["iso", "javascript", "unix"].includes(e22), "Unknown date format", e22), this.$_setFlag("format", e22);
      } }, greater: { method(e22) {
        return this.$_addRule({ name: "greater", method: "compare", args: { date: e22 }, operator: ">" });
      } }, iso: { method() {
        return this.format("iso");
      } }, less: { method(e22) {
        return this.$_addRule({ name: "less", method: "compare", args: { date: e22 }, operator: "<" });
      } }, max: { method(e22) {
        return this.$_addRule({ name: "max", method: "compare", args: { date: e22 }, operator: "<=" });
      } }, min: { method(e22) {
        return this.$_addRule({ name: "min", method: "compare", args: { date: e22 }, operator: ">=" });
      } }, timestamp: { method(e22 = "javascript") {
        return s2(["javascript", "unix"].includes(e22), '"type" must be one of "javascript, unix"'), this.format(e22);
      } } }, cast: { number: { from: i2.isDate, to: (e22, t4) => e22.getTime() }, string: { from: i2.isDate, to: (e22, { prefs: t4 }) => o2.date(e22, t4) } }, messages: { "date.base": "{{#label}} must be a valid date", "date.format": '{{#label}} must be in {msg("date.format." + #format) || #format} format', "date.greater": "{{#label}} must be greater than {{:#limit}}", "date.less": "{{#label}} must be less than {{:#limit}}", "date.max": "{{#label}} must be less than or equal to {{:#limit}}", "date.min": "{{#label}} must be greater than or equal to {{:#limit}}", "date.format.iso": "ISO 8601 date", "date.format.javascript": "timestamp or number of milliseconds", "date.format.unix": "timestamp or number of seconds" } }), i2.parse = function(e22, t4) {
        if (e22 instanceof Date)
          return e22;
        if (typeof e22 != "string" && (isNaN(e22) || !isFinite(e22)))
          return null;
        if (/^\s*$/.test(e22))
          return null;
        if (t4 === "iso")
          return a2.isIsoDate(e22) ? i2.date(e22.toString()) : null;
        const r3 = e22;
        if (typeof e22 == "string" && /^[+-]?\d+(\.\d+)?$/.test(e22) && (e22 = parseFloat(e22)), t4) {
          if (t4 === "javascript")
            return i2.date(1 * e22);
          if (t4 === "unix")
            return i2.date(1e3 * e22);
          if (typeof r3 == "string")
            return null;
        }
        return i2.date(e22);
      }, i2.date = function(e22) {
        const t4 = new Date(e22);
        return isNaN(t4.getTime()) ? null : t4;
      };
    }, 390: (e21, t3, r2) => {
      const s2 = r2(375), n2 = r2(7824);
      e21.exports = n2.extend({ type: "function", properties: { typeof: "function" }, rules: { arity: { method(e22) {
        return s2(Number.isSafeInteger(e22) && e22 >= 0, "n must be a positive integer"), this.$_addRule({ name: "arity", args: { n: e22 } });
      }, validate: (e22, t4, { n: r3 }) => e22.length === r3 ? e22 : t4.error("function.arity", { n: r3 }) }, class: { method() {
        return this.$_addRule("class");
      }, validate: (e22, t4) => /^\s*class\s/.test(e22.toString()) ? e22 : t4.error("function.class", { value: e22 }) }, minArity: { method(e22) {
        return s2(Number.isSafeInteger(e22) && e22 > 0, "n must be a strict positive integer"), this.$_addRule({ name: "minArity", args: { n: e22 } });
      }, validate: (e22, t4, { n: r3 }) => e22.length >= r3 ? e22 : t4.error("function.minArity", { n: r3 }) }, maxArity: { method(e22) {
        return s2(Number.isSafeInteger(e22) && e22 >= 0, "n must be a positive integer"), this.$_addRule({ name: "maxArity", args: { n: e22 } });
      }, validate: (e22, t4, { n: r3 }) => e22.length <= r3 ? e22 : t4.error("function.maxArity", { n: r3 }) } }, messages: { "function.arity": "{{#label}} must have an arity of {{#n}}", "function.class": "{{#label}} must be a class", "function.maxArity": "{{#label}} must have an arity lesser or equal to {{#n}}", "function.minArity": "{{#label}} must have an arity greater or equal to {{#n}}" } });
    }, 7824: (e21, t3, r2) => {
      const s2 = r2(978), n2 = r2(375), a2 = r2(8571), o2 = r2(3652), i2 = r2(8068), l2 = r2(8160), c2 = r2(3292), u2 = r2(6354), f2 = r2(6133), m2 = r2(3328), h2 = { renameDefaults: { alias: false, multiple: false, override: false } };
      e21.exports = i2.extend({ type: "_keys", properties: { typeof: "object" }, flags: { unknown: { default: false } }, terms: { dependencies: { init: null }, keys: { init: null, manifest: { mapped: { from: "schema", to: "key" } } }, patterns: { init: null }, renames: { init: null } }, args: (e22, t4) => e22.keys(t4), validate(e22, { schema: t4, error: r3, state: s3, prefs: n3 }) {
        if (!e22 || typeof e22 !== t4.$_property("typeof") || Array.isArray(e22))
          return { value: e22, errors: r3("object.base", { type: t4.$_property("typeof") }) };
        if (!(t4.$_terms.renames || t4.$_terms.dependencies || t4.$_terms.keys || t4.$_terms.patterns || t4.$_terms.externals))
          return;
        e22 = h2.clone(e22, n3);
        const a3 = [];
        if (t4.$_terms.renames && !h2.rename(t4, e22, s3, n3, a3))
          return { value: e22, errors: a3 };
        if (!t4.$_terms.keys && !t4.$_terms.patterns && !t4.$_terms.dependencies)
          return { value: e22, errors: a3 };
        const o3 = new Set(Object.keys(e22));
        if (t4.$_terms.keys) {
          const r4 = [e22, ...s3.ancestors];
          for (const i3 of t4.$_terms.keys) {
            const t5 = i3.key, l3 = e22[t5];
            o3.delete(t5);
            const c3 = s3.localize([...s3.path, t5], r4, i3), u3 = i3.schema.$_validate(l3, c3, n3);
            if (u3.errors) {
              if (n3.abortEarly)
                return { value: e22, errors: u3.errors };
              u3.value !== void 0 && (e22[t5] = u3.value), a3.push(...u3.errors);
            } else
              i3.schema._flags.result === "strip" || u3.value === void 0 && l3 !== void 0 ? delete e22[t5] : u3.value !== void 0 && (e22[t5] = u3.value);
          }
        }
        if (o3.size || t4._flags._hasPatternMatch) {
          const r4 = h2.unknown(t4, e22, o3, a3, s3, n3);
          if (r4)
            return r4;
        }
        if (t4.$_terms.dependencies)
          for (const r4 of t4.$_terms.dependencies) {
            if (r4.key && r4.key.resolve(e22, s3, n3, null, { shadow: false }) === void 0)
              continue;
            const o4 = h2.dependencies[r4.rel](t4, r4, e22, s3, n3);
            if (o4) {
              const r5 = t4.$_createError(o4.code, e22, o4.context, s3, n3);
              if (n3.abortEarly)
                return { value: e22, errors: r5 };
              a3.push(r5);
            }
          }
        return { value: e22, errors: a3 };
      }, rules: { and: { method(...e22) {
        return l2.verifyFlat(e22, "and"), h2.dependency(this, "and", null, e22);
      } }, append: { method(e22) {
        return e22 == null || Object.keys(e22).length === 0 ? this : this.keys(e22);
      } }, assert: { method(e22, t4, r3) {
        m2.isTemplate(e22) || (e22 = c2.ref(e22)), n2(r3 === void 0 || typeof r3 == "string", "Message must be a string"), t4 = this.$_compile(t4, { appendPath: true });
        const s3 = this.$_addRule({ name: "assert", args: { subject: e22, schema: t4, message: r3 } });
        return s3.$_mutateRegister(e22), s3.$_mutateRegister(t4), s3;
      }, validate(e22, { error: t4, prefs: r3, state: s3 }, { subject: n3, schema: a3, message: o3 }) {
        const i3 = n3.resolve(e22, s3, r3), l3 = f2.isRef(n3) ? n3.absolute(s3) : [];
        return a3.$_match(i3, s3.localize(l3, [e22, ...s3.ancestors], a3), r3) ? e22 : t4("object.assert", { subject: n3, message: o3 });
      }, args: ["subject", "schema", "message"], multi: true }, instance: { method(e22, t4) {
        return n2(typeof e22 == "function", "constructor must be a function"), t4 = t4 || e22.name, this.$_addRule({ name: "instance", args: { constructor: e22, name: t4 } });
      }, validate: (e22, t4, { constructor: r3, name: s3 }) => e22 instanceof r3 ? e22 : t4.error("object.instance", { type: s3, value: e22 }), args: ["constructor", "name"] }, keys: { method(e22) {
        n2(e22 === void 0 || typeof e22 == "object", "Object schema must be a valid object"), n2(!l2.isSchema(e22), "Object schema cannot be a joi schema");
        const t4 = this.clone();
        if (e22)
          if (Object.keys(e22).length) {
            t4.$_terms.keys = t4.$_terms.keys ? t4.$_terms.keys.filter((t5) => !e22.hasOwnProperty(t5.key)) : new h2.Keys();
            for (const r3 in e22)
              l2.tryWithPath(() => t4.$_terms.keys.push({ key: r3, schema: this.$_compile(e22[r3]) }), r3);
          } else
            t4.$_terms.keys = new h2.Keys();
        else
          t4.$_terms.keys = null;
        return t4.$_mutateRebuild();
      } }, length: { method(e22) {
        return this.$_addRule({ name: "length", args: { limit: e22 }, operator: "=" });
      }, validate: (e22, t4, { limit: r3 }, { name: s3, operator: n3, args: a3 }) => l2.compare(Object.keys(e22).length, r3, n3) ? e22 : t4.error("object." + s3, { limit: a3.limit, value: e22 }), args: [{ name: "limit", ref: true, assert: l2.limit, message: "must be a positive integer" }] }, max: { method(e22) {
        return this.$_addRule({ name: "max", method: "length", args: { limit: e22 }, operator: "<=" });
      } }, min: { method(e22) {
        return this.$_addRule({ name: "min", method: "length", args: { limit: e22 }, operator: ">=" });
      } }, nand: { method(...e22) {
        return l2.verifyFlat(e22, "nand"), h2.dependency(this, "nand", null, e22);
      } }, or: { method(...e22) {
        return l2.verifyFlat(e22, "or"), h2.dependency(this, "or", null, e22);
      } }, oxor: { method(...e22) {
        return h2.dependency(this, "oxor", null, e22);
      } }, pattern: { method(e22, t4, r3 = {}) {
        const s3 = e22 instanceof RegExp;
        s3 || (e22 = this.$_compile(e22, { appendPath: true })), n2(t4 !== void 0, "Invalid rule"), l2.assertOptions(r3, ["fallthrough", "matches"]), s3 && n2(!e22.flags.includes("g") && !e22.flags.includes("y"), "pattern should not use global or sticky mode"), t4 = this.$_compile(t4, { appendPath: true });
        const a3 = this.clone();
        a3.$_terms.patterns = a3.$_terms.patterns || [];
        const o3 = { [s3 ? "regex" : "schema"]: e22, rule: t4 };
        return r3.matches && (o3.matches = this.$_compile(r3.matches), o3.matches.type !== "array" && (o3.matches = o3.matches.$_root.array().items(o3.matches)), a3.$_mutateRegister(o3.matches), a3.$_setFlag("_hasPatternMatch", true, { clone: false })), r3.fallthrough && (o3.fallthrough = true), a3.$_terms.patterns.push(o3), a3.$_mutateRegister(t4), a3;
      } }, ref: { method() {
        return this.$_addRule("ref");
      }, validate: (e22, t4) => f2.isRef(e22) ? e22 : t4.error("object.refType", { value: e22 }) }, regex: { method() {
        return this.$_addRule("regex");
      }, validate: (e22, t4) => e22 instanceof RegExp ? e22 : t4.error("object.regex", { value: e22 }) }, rename: { method(e22, t4, r3 = {}) {
        n2(typeof e22 == "string" || e22 instanceof RegExp, "Rename missing the from argument"), n2(typeof t4 == "string" || t4 instanceof m2, "Invalid rename to argument"), n2(t4 !== e22, "Cannot rename key to same name:", e22), l2.assertOptions(r3, ["alias", "ignoreUndefined", "override", "multiple"]);
        const a3 = this.clone();
        a3.$_terms.renames = a3.$_terms.renames || [];
        for (const t5 of a3.$_terms.renames)
          n2(t5.from !== e22, "Cannot rename the same key multiple times");
        return t4 instanceof m2 && a3.$_mutateRegister(t4), a3.$_terms.renames.push({ from: e22, to: t4, options: s2(h2.renameDefaults, r3) }), a3;
      } }, schema: { method(e22 = "any") {
        return this.$_addRule({ name: "schema", args: { type: e22 } });
      }, validate: (e22, t4, { type: r3 }) => !l2.isSchema(e22) || r3 !== "any" && e22.type !== r3 ? t4.error("object.schema", { type: r3 }) : e22 }, unknown: { method(e22) {
        return this.$_setFlag("unknown", e22 !== false);
      } }, with: { method(e22, t4, r3 = {}) {
        return h2.dependency(this, "with", e22, t4, r3);
      } }, without: { method(e22, t4, r3 = {}) {
        return h2.dependency(this, "without", e22, t4, r3);
      } }, xor: { method(...e22) {
        return l2.verifyFlat(e22, "xor"), h2.dependency(this, "xor", null, e22);
      } } }, overrides: { default(e22, t4) {
        return e22 === void 0 && (e22 = l2.symbols.deepDefault), this.$_parent("default", e22, t4);
      } }, rebuild(e22) {
        if (e22.$_terms.keys) {
          const t4 = new o2.Sorter();
          for (const r3 of e22.$_terms.keys)
            l2.tryWithPath(() => t4.add(r3, { after: r3.schema.$_rootReferences(), group: r3.key }), r3.key);
          e22.$_terms.keys = new h2.Keys(...t4.nodes);
        }
      }, manifest: { build(e22, t4) {
        if (t4.keys && (e22 = e22.keys(t4.keys)), t4.dependencies)
          for (const { rel: r3, key: s3 = null, peers: n3, options: a3 } of t4.dependencies)
            e22 = h2.dependency(e22, r3, s3, n3, a3);
        if (t4.patterns)
          for (const { regex: r3, schema: s3, rule: n3, fallthrough: a3, matches: o3 } of t4.patterns)
            e22 = e22.pattern(r3 || s3, n3, { fallthrough: a3, matches: o3 });
        if (t4.renames)
          for (const { from: r3, to: s3, options: n3 } of t4.renames)
            e22 = e22.rename(r3, s3, n3);
        return e22;
      } }, messages: { "object.and": "{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}", "object.assert": '{{#label}} is invalid because {if(#subject.key, `"` + #subject.key + `" failed to ` + (#message || "pass the assertion test"), #message || "the assertion failed")}', "object.base": "{{#label}} must be of type {{#type}}", "object.instance": "{{#label}} must be an instance of {{:#type}}", "object.length": '{{#label}} must have {{#limit}} key{if(#limit == 1, "", "s")}', "object.max": '{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, "", "s")}', "object.min": '{{#label}} must have at least {{#limit}} key{if(#limit == 1, "", "s")}', "object.missing": "{{#label}} must contain at least one of {{#peersWithLabels}}", "object.nand": "{{:#mainWithLabel}} must not exist simultaneously with {{#peersWithLabels}}", "object.oxor": "{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}", "object.pattern.match": "{{#label}} keys failed to match pattern requirements", "object.refType": "{{#label}} must be a Joi reference", "object.regex": "{{#label}} must be a RegExp object", "object.rename.multiple": "{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}", "object.rename.override": "{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists", "object.schema": "{{#label}} must be a Joi schema of {{#type}} type", "object.unknown": "{{#label}} is not allowed", "object.with": "{{:#mainWithLabel}} missing required peer {{:#peerWithLabel}}", "object.without": "{{:#mainWithLabel}} conflict with forbidden peer {{:#peerWithLabel}}", "object.xor": "{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}" } }), h2.clone = function(e22, t4) {
        if (typeof e22 == "object") {
          if (t4.nonEnumerables)
            return a2(e22, { shallow: true });
          const r4 = Object.create(Object.getPrototypeOf(e22));
          return Object.assign(r4, e22), r4;
        }
        const r3 = function(...t5) {
          return e22.apply(this, t5);
        };
        return r3.prototype = a2(e22.prototype), Object.defineProperty(r3, "name", { value: e22.name, writable: false }), Object.defineProperty(r3, "length", { value: e22.length, writable: false }), Object.assign(r3, e22), r3;
      }, h2.dependency = function(e22, t4, r3, s3, a3) {
        n2(r3 === null || typeof r3 == "string", t4, "key must be a strings"), a3 || (a3 = s3.length > 1 && typeof s3[s3.length - 1] == "object" ? s3.pop() : {}), l2.assertOptions(a3, ["separator"]), s3 = [].concat(s3);
        const o3 = l2.default(a3.separator, "."), i3 = [];
        for (const e23 of s3)
          n2(typeof e23 == "string", t4, "peers must be strings"), i3.push(c2.ref(e23, { separator: o3, ancestor: 0, prefix: false }));
        r3 !== null && (r3 = c2.ref(r3, { separator: o3, ancestor: 0, prefix: false }));
        const u3 = e22.clone();
        return u3.$_terms.dependencies = u3.$_terms.dependencies || [], u3.$_terms.dependencies.push(new h2.Dependency(t4, r3, i3, s3)), u3;
      }, h2.dependencies = { and(e22, t4, r3, s3, n3) {
        const a3 = [], o3 = [], i3 = t4.peers.length;
        for (const e23 of t4.peers)
          e23.resolve(r3, s3, n3, null, { shadow: false }) === void 0 ? a3.push(e23.key) : o3.push(e23.key);
        if (a3.length !== i3 && o3.length !== i3)
          return { code: "object.and", context: { present: o3, presentWithLabels: h2.keysToLabels(e22, o3), missing: a3, missingWithLabels: h2.keysToLabels(e22, a3) } };
      }, nand(e22, t4, r3, s3, n3) {
        const a3 = [];
        for (const e23 of t4.peers)
          e23.resolve(r3, s3, n3, null, { shadow: false }) !== void 0 && a3.push(e23.key);
        if (a3.length !== t4.peers.length)
          return;
        const o3 = t4.paths[0], i3 = t4.paths.slice(1);
        return { code: "object.nand", context: { main: o3, mainWithLabel: h2.keysToLabels(e22, o3), peers: i3, peersWithLabels: h2.keysToLabels(e22, i3) } };
      }, or(e22, t4, r3, s3, n3) {
        for (const e23 of t4.peers)
          if (e23.resolve(r3, s3, n3, null, { shadow: false }) !== void 0)
            return;
        return { code: "object.missing", context: { peers: t4.paths, peersWithLabels: h2.keysToLabels(e22, t4.paths) } };
      }, oxor(e22, t4, r3, s3, n3) {
        const a3 = [];
        for (const e23 of t4.peers)
          e23.resolve(r3, s3, n3, null, { shadow: false }) !== void 0 && a3.push(e23.key);
        if (!a3.length || a3.length === 1)
          return;
        const o3 = { peers: t4.paths, peersWithLabels: h2.keysToLabels(e22, t4.paths) };
        return o3.present = a3, o3.presentWithLabels = h2.keysToLabels(e22, a3), { code: "object.oxor", context: o3 };
      }, with(e22, t4, r3, s3, n3) {
        for (const a3 of t4.peers)
          if (a3.resolve(r3, s3, n3, null, { shadow: false }) === void 0)
            return { code: "object.with", context: { main: t4.key.key, mainWithLabel: h2.keysToLabels(e22, t4.key.key), peer: a3.key, peerWithLabel: h2.keysToLabels(e22, a3.key) } };
      }, without(e22, t4, r3, s3, n3) {
        for (const a3 of t4.peers)
          if (a3.resolve(r3, s3, n3, null, { shadow: false }) !== void 0)
            return { code: "object.without", context: { main: t4.key.key, mainWithLabel: h2.keysToLabels(e22, t4.key.key), peer: a3.key, peerWithLabel: h2.keysToLabels(e22, a3.key) } };
      }, xor(e22, t4, r3, s3, n3) {
        const a3 = [];
        for (const e23 of t4.peers)
          e23.resolve(r3, s3, n3, null, { shadow: false }) !== void 0 && a3.push(e23.key);
        if (a3.length === 1)
          return;
        const o3 = { peers: t4.paths, peersWithLabels: h2.keysToLabels(e22, t4.paths) };
        return a3.length === 0 ? { code: "object.missing", context: o3 } : (o3.present = a3, o3.presentWithLabels = h2.keysToLabels(e22, a3), { code: "object.xor", context: o3 });
      } }, h2.keysToLabels = function(e22, t4) {
        return Array.isArray(t4) ? t4.map((t5) => e22.$_mapLabels(t5)) : e22.$_mapLabels(t4);
      }, h2.rename = function(e22, t4, r3, s3, n3) {
        const a3 = {};
        for (const o3 of e22.$_terms.renames) {
          const i3 = [], l3 = typeof o3.from != "string";
          if (l3)
            for (const e23 in t4) {
              if (t4[e23] === void 0 && o3.options.ignoreUndefined)
                continue;
              if (e23 === o3.to)
                continue;
              const r4 = o3.from.exec(e23);
              r4 && i3.push({ from: e23, to: o3.to, match: r4 });
            }
          else
            !Object.prototype.hasOwnProperty.call(t4, o3.from) || t4[o3.from] === void 0 && o3.options.ignoreUndefined || i3.push(o3);
          for (const c3 of i3) {
            const i4 = c3.from;
            let u3 = c3.to;
            if (u3 instanceof m2 && (u3 = u3.render(t4, r3, s3, c3.match)), i4 !== u3) {
              if (!o3.options.multiple && a3[u3] && (n3.push(e22.$_createError("object.rename.multiple", t4, { from: i4, to: u3, pattern: l3 }, r3, s3)), s3.abortEarly))
                return false;
              if (Object.prototype.hasOwnProperty.call(t4, u3) && !o3.options.override && !a3[u3] && (n3.push(e22.$_createError("object.rename.override", t4, { from: i4, to: u3, pattern: l3 }, r3, s3)), s3.abortEarly))
                return false;
              t4[i4] === void 0 ? delete t4[u3] : t4[u3] = t4[i4], a3[u3] = true, o3.options.alias || delete t4[i4];
            }
          }
        }
        return true;
      }, h2.unknown = function(e22, t4, r3, s3, n3, a3) {
        if (e22.$_terms.patterns) {
          let o3 = false;
          const i3 = e22.$_terms.patterns.map((e23) => {
            if (e23.matches)
              return o3 = true, [];
          }), l3 = [t4, ...n3.ancestors];
          for (const o4 of r3) {
            const c3 = t4[o4], u3 = [...n3.path, o4];
            for (let f3 = 0; f3 < e22.$_terms.patterns.length; ++f3) {
              const m3 = e22.$_terms.patterns[f3];
              if (m3.regex) {
                const e23 = m3.regex.test(o4);
                if (n3.mainstay.tracer.debug(n3, "rule", "pattern.".concat(f3), e23 ? "pass" : "error"), !e23)
                  continue;
              } else if (!m3.schema.$_match(o4, n3.nest(m3.schema, "pattern.".concat(f3)), a3))
                continue;
              r3.delete(o4);
              const h3 = n3.localize(u3, l3, { schema: m3.rule, key: o4 }), d2 = m3.rule.$_validate(c3, h3, a3);
              if (d2.errors) {
                if (a3.abortEarly)
                  return { value: t4, errors: d2.errors };
                s3.push(...d2.errors);
              }
              if (m3.matches && i3[f3].push(o4), t4[o4] = d2.value, !m3.fallthrough)
                break;
            }
          }
          if (o3)
            for (let r4 = 0; r4 < i3.length; ++r4) {
              const o4 = i3[r4];
              if (!o4)
                continue;
              const c3 = e22.$_terms.patterns[r4].matches, f3 = n3.localize(n3.path, l3, c3), m3 = c3.$_validate(o4, f3, a3);
              if (m3.errors) {
                const r5 = u2.details(m3.errors, { override: false });
                r5.matches = o4;
                const i4 = e22.$_createError("object.pattern.match", t4, r5, n3, a3);
                if (a3.abortEarly)
                  return { value: t4, errors: i4 };
                s3.push(i4);
              }
            }
        }
        if (r3.size && (e22.$_terms.keys || e22.$_terms.patterns)) {
          if (a3.stripUnknown && !e22._flags.unknown || a3.skipFunctions) {
            const e23 = !(!a3.stripUnknown || a3.stripUnknown !== true && !a3.stripUnknown.objects);
            for (const s4 of r3)
              e23 ? (delete t4[s4], r3.delete(s4)) : typeof t4[s4] == "function" && r3.delete(s4);
          }
          if (!l2.default(e22._flags.unknown, a3.allowUnknown))
            for (const o3 of r3) {
              const r4 = n3.localize([...n3.path, o3], []), i3 = e22.$_createError("object.unknown", t4[o3], { child: o3 }, r4, a3, { flags: false });
              if (a3.abortEarly)
                return { value: t4, errors: i3 };
              s3.push(i3);
            }
        }
      }, h2.Dependency = class {
        constructor(e22, t4, r3, s3) {
          this.rel = e22, this.key = t4, this.peers = r3, this.paths = s3;
        }
        describe() {
          const e22 = { rel: this.rel, peers: this.paths };
          return this.key !== null && (e22.key = this.key.key), this.peers[0].separator !== "." && (e22.options = { separator: this.peers[0].separator }), e22;
        }
      }, h2.Keys = class extends Array {
        concat(e22) {
          const t4 = this.slice(), r3 = new Map();
          for (let e23 = 0; e23 < t4.length; ++e23)
            r3.set(t4[e23].key, e23);
          for (const s3 of e22) {
            const e23 = s3.key, n3 = r3.get(e23);
            n3 !== void 0 ? t4[n3] = { key: e23, schema: t4[n3].schema.concat(s3.schema) } : t4.push(s3);
          }
          return t4;
        }
      };
    }, 8785: (e21, t3, r2) => {
      const s2 = r2(375), n2 = r2(8068), a2 = r2(8160), o2 = r2(3292), i2 = r2(6354), l2 = {};
      e21.exports = n2.extend({ type: "link", properties: { schemaChain: true }, terms: { link: { init: null, manifest: "single", register: false } }, args: (e22, t4) => e22.ref(t4), validate(e22, { schema: t4, state: r3, prefs: n3 }) {
        s2(t4.$_terms.link, "Uninitialized link schema");
        const a3 = l2.generate(t4, e22, r3, n3), o3 = t4.$_terms.link[0].ref;
        return a3.$_validate(e22, r3.nest(a3, "link:".concat(o3.display, ":").concat(a3.type)), n3);
      }, generate: (e22, t4, r3, s3) => l2.generate(e22, t4, r3, s3), rules: { ref: { method(e22) {
        s2(!this.$_terms.link, "Cannot reinitialize schema"), e22 = o2.ref(e22), s2(e22.type === "value" || e22.type === "local", "Invalid reference type:", e22.type), s2(e22.type === "local" || e22.ancestor === "root" || e22.ancestor > 0, "Link cannot reference itself");
        const t4 = this.clone();
        return t4.$_terms.link = [{ ref: e22 }], t4;
      } }, relative: { method(e22 = true) {
        return this.$_setFlag("relative", e22);
      } } }, overrides: { concat(e22) {
        s2(this.$_terms.link, "Uninitialized link schema"), s2(a2.isSchema(e22), "Invalid schema object"), s2(e22.type !== "link", "Cannot merge type link with another link");
        const t4 = this.clone();
        return t4.$_terms.whens || (t4.$_terms.whens = []), t4.$_terms.whens.push({ concat: e22 }), t4.$_mutateRebuild();
      } }, manifest: { build: (e22, t4) => (s2(t4.link, "Invalid link description missing link"), e22.ref(t4.link)) } }), l2.generate = function(e22, t4, r3, s3) {
        let n3 = r3.mainstay.links.get(e22);
        if (n3)
          return n3._generate(t4, r3, s3).schema;
        const a3 = e22.$_terms.link[0].ref, { perspective: o3, path: i3 } = l2.perspective(a3, r3);
        l2.assert(o3, "which is outside of schema boundaries", a3, e22, r3, s3);
        try {
          n3 = i3.length ? o3.$_reach(i3) : o3;
        } catch (t5) {
          l2.assert(false, "to non-existing schema", a3, e22, r3, s3);
        }
        return l2.assert(n3.type !== "link", "which is another link", a3, e22, r3, s3), e22._flags.relative || r3.mainstay.links.set(e22, n3), n3._generate(t4, r3, s3).schema;
      }, l2.perspective = function(e22, t4) {
        if (e22.type === "local") {
          for (const { schema: r3, key: s3 } of t4.schemas) {
            if ((r3._flags.id || s3) === e22.path[0])
              return { perspective: r3, path: e22.path.slice(1) };
            if (r3.$_terms.shared) {
              for (const t5 of r3.$_terms.shared)
                if (t5._flags.id === e22.path[0])
                  return { perspective: t5, path: e22.path.slice(1) };
            }
          }
          return { perspective: null, path: null };
        }
        return e22.ancestor === "root" ? { perspective: t4.schemas[t4.schemas.length - 1].schema, path: e22.path } : { perspective: t4.schemas[e22.ancestor] && t4.schemas[e22.ancestor].schema, path: e22.path };
      }, l2.assert = function(e22, t4, r3, n3, a3, o3) {
        e22 || s2(false, '"'.concat(i2.label(n3._flags, a3, o3), '" contains link reference "').concat(r3.display, '" ').concat(t4));
      };
    }, 3832: (e21, t3, r2) => {
      const s2 = r2(375), n2 = r2(8068), a2 = r2(8160), o2 = { numberRx: /^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i, precisionRx: /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/ };
      e21.exports = n2.extend({ type: "number", flags: { unsafe: { default: false } }, coerce: { from: "string", method(e22, { schema: t4, error: r3 }) {
        const s3 = e22.match(o2.numberRx);
        if (!s3)
          return;
        e22 = e22.trim();
        const n3 = { value: parseFloat(e22) };
        if (n3.value === 0 && (n3.value = 0), !t4._flags.unsafe)
          if (e22.match(/e/i)) {
            if (o2.normalizeExponent("".concat(n3.value / Math.pow(10, s3[1]), "e").concat(s3[1])) !== o2.normalizeExponent(e22))
              return n3.errors = r3("number.unsafe"), n3;
          } else {
            const t5 = n3.value.toString();
            if (t5.match(/e/i))
              return n3;
            if (t5 !== o2.normalizeDecimal(e22))
              return n3.errors = r3("number.unsafe"), n3;
          }
        return n3;
      } }, validate(e22, { schema: t4, error: r3, prefs: s3 }) {
        if (e22 === 1 / 0 || e22 === -1 / 0)
          return { value: e22, errors: r3("number.infinity") };
        if (!a2.isNumber(e22))
          return { value: e22, errors: r3("number.base") };
        const n3 = { value: e22 };
        if (s3.convert) {
          const e23 = t4.$_getRule("precision");
          if (e23) {
            const t5 = Math.pow(10, e23.args.limit);
            n3.value = Math.round(n3.value * t5) / t5;
          }
        }
        return n3.value === 0 && (n3.value = 0), !t4._flags.unsafe && (e22 > Number.MAX_SAFE_INTEGER || e22 < Number.MIN_SAFE_INTEGER) && (n3.errors = r3("number.unsafe")), n3;
      }, rules: { compare: { method: false, validate: (e22, t4, { limit: r3 }, { name: s3, operator: n3, args: o3 }) => a2.compare(e22, r3, n3) ? e22 : t4.error("number." + s3, { limit: o3.limit, value: e22 }), args: [{ name: "limit", ref: true, assert: a2.isNumber, message: "must be a number" }] }, greater: { method(e22) {
        return this.$_addRule({ name: "greater", method: "compare", args: { limit: e22 }, operator: ">" });
      } }, integer: { method() {
        return this.$_addRule("integer");
      }, validate: (e22, t4) => Math.trunc(e22) - e22 == 0 ? e22 : t4.error("number.integer") }, less: { method(e22) {
        return this.$_addRule({ name: "less", method: "compare", args: { limit: e22 }, operator: "<" });
      } }, max: { method(e22) {
        return this.$_addRule({ name: "max", method: "compare", args: { limit: e22 }, operator: "<=" });
      } }, min: { method(e22) {
        return this.$_addRule({ name: "min", method: "compare", args: { limit: e22 }, operator: ">=" });
      } }, multiple: { method(e22) {
        return this.$_addRule({ name: "multiple", args: { base: e22 } });
      }, validate: (e22, t4, { base: r3 }, s3) => e22 % r3 == 0 ? e22 : t4.error("number.multiple", { multiple: s3.args.base, value: e22 }), args: [{ name: "base", ref: true, assert: (e22) => typeof e22 == "number" && isFinite(e22) && e22 > 0, message: "must be a positive number" }], multi: true }, negative: { method() {
        return this.sign("negative");
      } }, port: { method() {
        return this.$_addRule("port");
      }, validate: (e22, t4) => Number.isSafeInteger(e22) && e22 >= 0 && e22 <= 65535 ? e22 : t4.error("number.port") }, positive: { method() {
        return this.sign("positive");
      } }, precision: { method(e22) {
        return s2(Number.isSafeInteger(e22), "limit must be an integer"), this.$_addRule({ name: "precision", args: { limit: e22 } });
      }, validate(e22, t4, { limit: r3 }) {
        const s3 = e22.toString().match(o2.precisionRx);
        return Math.max((s3[1] ? s3[1].length : 0) - (s3[2] ? parseInt(s3[2], 10) : 0), 0) <= r3 ? e22 : t4.error("number.precision", { limit: r3, value: e22 });
      }, convert: true }, sign: { method(e22) {
        return s2(["negative", "positive"].includes(e22), "Invalid sign", e22), this.$_addRule({ name: "sign", args: { sign: e22 } });
      }, validate: (e22, t4, { sign: r3 }) => r3 === "negative" && e22 < 0 || r3 === "positive" && e22 > 0 ? e22 : t4.error("number.".concat(r3)) }, unsafe: { method(e22 = true) {
        return s2(typeof e22 == "boolean", "enabled must be a boolean"), this.$_setFlag("unsafe", e22);
      } } }, cast: { string: { from: (e22) => typeof e22 == "number", to: (e22, t4) => e22.toString() } }, messages: { "number.base": "{{#label}} must be a number", "number.greater": "{{#label}} must be greater than {{#limit}}", "number.infinity": "{{#label}} cannot be infinity", "number.integer": "{{#label}} must be an integer", "number.less": "{{#label}} must be less than {{#limit}}", "number.max": "{{#label}} must be less than or equal to {{#limit}}", "number.min": "{{#label}} must be greater than or equal to {{#limit}}", "number.multiple": "{{#label}} must be a multiple of {{#multiple}}", "number.negative": "{{#label}} must be a negative number", "number.port": "{{#label}} must be a valid port", "number.positive": "{{#label}} must be a positive number", "number.precision": "{{#label}} must have no more than {{#limit}} decimal places", "number.unsafe": "{{#label}} must be a safe number" } }), o2.normalizeExponent = function(e22) {
        return e22.replace(/E/, "e").replace(/\.(\d*[1-9])?0+e/, ".$1e").replace(/\.e/, "e").replace(/e\+/, "e").replace(/^\+/, "").replace(/^(-?)0+([1-9])/, "$1$2");
      }, o2.normalizeDecimal = function(e22) {
        return (e22 = e22.replace(/^\+/, "").replace(/\.0*$/, "").replace(/^(-?)\.([^\.]*)$/, "$10.$2").replace(/^(-?)0+([0-9])/, "$1$2")).includes(".") && e22.endsWith("0") && (e22 = e22.replace(/0+$/, "")), e22 === "-0" ? "0" : e22;
      };
    }, 8966: (e21, t3, r2) => {
      const s2 = r2(7824);
      e21.exports = s2.extend({ type: "object", cast: { map: { from: (e22) => e22 && typeof e22 == "object", to: (e22, t4) => new Map(Object.entries(e22)) } } });
    }, 7417: (e21, t3, r2) => {
      function s2(e22, t4) {
        var r3 = Object.keys(e22);
        if (Object.getOwnPropertySymbols) {
          var s3 = Object.getOwnPropertySymbols(e22);
          t4 && (s3 = s3.filter(function(t5) {
            return Object.getOwnPropertyDescriptor(e22, t5).enumerable;
          })), r3.push.apply(r3, s3);
        }
        return r3;
      }
      function n2(e22) {
        for (var t4 = 1; t4 < arguments.length; t4++) {
          var r3 = arguments[t4] != null ? arguments[t4] : {};
          t4 % 2 ? s2(Object(r3), true).forEach(function(t5) {
            a2(e22, t5, r3[t5]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e22, Object.getOwnPropertyDescriptors(r3)) : s2(Object(r3)).forEach(function(t5) {
            Object.defineProperty(e22, t5, Object.getOwnPropertyDescriptor(r3, t5));
          });
        }
        return e22;
      }
      function a2(e22, t4, r3) {
        return t4 in e22 ? Object.defineProperty(e22, t4, { value: r3, enumerable: true, configurable: true, writable: true }) : e22[t4] = r3, e22;
      }
      const o2 = r2(375), i2 = r2(5380), l2 = r2(1745), c2 = r2(9959), u2 = r2(6064), f2 = r2(9926), m2 = r2(5752), h2 = r2(8068), d2 = r2(8160), p2 = { tlds: f2 instanceof Set && { tlds: { allow: f2, deny: null } }, base64Regex: { true: { true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}==|[\w\-]{3}=)?$/, false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/ }, false: { true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}(==)?|[\w\-]{3}=?)?$/, false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/ } }, dataUriRegex: /^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/, hexRegex: /^[a-f0-9]+$/i, ipRegex: c2.regex().regex, isoDurationRegex: /^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/, guidBrackets: { "{": "}", "[": "]", "(": ")", "": "" }, guidVersions: { uuidv1: "1", uuidv2: "2", uuidv3: "3", uuidv4: "4", uuidv5: "5" }, guidSeparators: new Set([void 0, true, false, "-", ":"]), normalizationForms: ["NFC", "NFD", "NFKC", "NFKD"] };
      e21.exports = h2.extend({ type: "string", flags: { insensitive: { default: false }, truncate: { default: false } }, terms: { replacements: { init: null } }, coerce: { from: "string", method(e22, { schema: t4, state: r3, prefs: s3 }) {
        const n3 = t4.$_getRule("normalize");
        n3 && (e22 = e22.normalize(n3.args.form));
        const a3 = t4.$_getRule("case");
        a3 && (e22 = a3.args.direction === "upper" ? e22.toLocaleUpperCase() : e22.toLocaleLowerCase());
        const o3 = t4.$_getRule("trim");
        if (o3 && o3.args.enabled && (e22 = e22.trim()), t4.$_terms.replacements)
          for (const r4 of t4.$_terms.replacements)
            e22 = e22.replace(r4.pattern, r4.replacement);
        const i3 = t4.$_getRule("hex");
        if (i3 && i3.args.options.byteAligned && e22.length % 2 != 0 && (e22 = "0".concat(e22)), t4.$_getRule("isoDate")) {
          const t5 = p2.isoDate(e22);
          t5 && (e22 = t5);
        }
        if (t4._flags.truncate) {
          const n4 = t4.$_getRule("max");
          if (n4) {
            let a4 = n4.args.limit;
            if (d2.isResolvable(a4) && (a4 = a4.resolve(e22, r3, s3), !d2.limit(a4)))
              return { value: e22, errors: t4.$_createError("any.ref", a4, { ref: n4.args.limit, arg: "limit", reason: "must be a positive integer" }, r3, s3) };
            e22 = e22.slice(0, a4);
          }
        }
        return { value: e22 };
      } }, validate: (e22, { error: t4 }) => typeof e22 != "string" ? { value: e22, errors: t4("string.base") } : e22 === "" ? { value: e22, errors: t4("string.empty") } : void 0, rules: { alphanum: { method() {
        return this.$_addRule("alphanum");
      }, validate: (e22, t4) => /^[a-zA-Z0-9]+$/.test(e22) ? e22 : t4.error("string.alphanum") }, base64: { method(e22 = {}) {
        return d2.assertOptions(e22, ["paddingRequired", "urlSafe"]), e22 = n2({ urlSafe: false, paddingRequired: true }, e22), o2(typeof e22.paddingRequired == "boolean", "paddingRequired must be boolean"), o2(typeof e22.urlSafe == "boolean", "urlSafe must be boolean"), this.$_addRule({ name: "base64", args: { options: e22 } });
      }, validate: (e22, t4, { options: r3 }) => p2.base64Regex[r3.paddingRequired][r3.urlSafe].test(e22) ? e22 : t4.error("string.base64") }, case: { method(e22) {
        return o2(["lower", "upper"].includes(e22), "Invalid case:", e22), this.$_addRule({ name: "case", args: { direction: e22 } });
      }, validate: (e22, t4, { direction: r3 }) => r3 === "lower" && e22 === e22.toLocaleLowerCase() || r3 === "upper" && e22 === e22.toLocaleUpperCase() ? e22 : t4.error("string.".concat(r3, "case")), convert: true }, creditCard: { method() {
        return this.$_addRule("creditCard");
      }, validate(e22, t4) {
        let r3 = e22.length, s3 = 0, n3 = 1;
        for (; r3--; ) {
          const t5 = e22.charAt(r3) * n3;
          s3 += t5 - 9 * (t5 > 9), n3 ^= 3;
        }
        return s3 > 0 && s3 % 10 == 0 ? e22 : t4.error("string.creditCard");
      } }, dataUri: { method(e22 = {}) {
        return d2.assertOptions(e22, ["paddingRequired"]), e22 = n2({ paddingRequired: true }, e22), o2(typeof e22.paddingRequired == "boolean", "paddingRequired must be boolean"), this.$_addRule({ name: "dataUri", args: { options: e22 } });
      }, validate(e22, t4, { options: r3 }) {
        const s3 = e22.match(p2.dataUriRegex);
        if (s3) {
          if (!s3[2])
            return e22;
          if (s3[2] !== "base64")
            return e22;
          if (p2.base64Regex[r3.paddingRequired].false.test(s3[3]))
            return e22;
        }
        return t4.error("string.dataUri");
      } }, domain: { method(e22) {
        e22 && d2.assertOptions(e22, ["allowUnicode", "maxDomainSegments", "minDomainSegments", "tlds"]);
        const t4 = p2.addressOptions(e22);
        return this.$_addRule({ name: "domain", args: { options: e22 }, address: t4 });
      }, validate: (e22, t4, r3, { address: s3 }) => i2.isValid(e22, s3) ? e22 : t4.error("string.domain") }, email: { method(e22 = {}) {
        d2.assertOptions(e22, ["allowUnicode", "ignoreLength", "maxDomainSegments", "minDomainSegments", "multiple", "separator", "tlds"]), o2(e22.multiple === void 0 || typeof e22.multiple == "boolean", "multiple option must be an boolean");
        const t4 = p2.addressOptions(e22), r3 = new RegExp("\\s*[".concat(e22.separator ? u2(e22.separator) : ",", "]\\s*"));
        return this.$_addRule({ name: "email", args: { options: e22 }, regex: r3, address: t4 });
      }, validate(e22, t4, { options: r3 }, { regex: s3, address: n3 }) {
        const a3 = r3.multiple ? e22.split(s3) : [e22], o3 = [];
        for (const e23 of a3)
          l2.isValid(e23, n3) || o3.push(e23);
        return o3.length ? t4.error("string.email", { value: e22, invalids: o3 }) : e22;
      } }, guid: { alias: "uuid", method(e22 = {}) {
        d2.assertOptions(e22, ["version", "separator"]);
        let t4 = "";
        if (e22.version) {
          const r4 = [].concat(e22.version);
          o2(r4.length >= 1, "version must have at least 1 valid version specified");
          const s4 = new Set();
          for (let e23 = 0; e23 < r4.length; ++e23) {
            const n3 = r4[e23];
            o2(typeof n3 == "string", "version at position " + e23 + " must be a string");
            const a3 = p2.guidVersions[n3.toLowerCase()];
            o2(a3, "version at position " + e23 + " must be one of " + Object.keys(p2.guidVersions).join(", ")), o2(!s4.has(a3), "version at position " + e23 + " must not be a duplicate"), t4 += a3, s4.add(a3);
          }
        }
        o2(p2.guidSeparators.has(e22.separator), 'separator must be one of true, false, "-", or ":"');
        const r3 = e22.separator === void 0 ? "[:-]?" : e22.separator === true ? "[:-]" : e22.separator === false ? "[]?" : "\\".concat(e22.separator), s3 = new RegExp("^([\\[{\\(]?)[0-9A-F]{8}(".concat(r3, ")[0-9A-F]{4}\\2?[").concat(t4 || "0-9A-F", "][0-9A-F]{3}\\2?[").concat(t4 ? "89AB" : "0-9A-F", "][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$"), "i");
        return this.$_addRule({ name: "guid", args: { options: e22 }, regex: s3 });
      }, validate(e22, t4, r3, { regex: s3 }) {
        const n3 = s3.exec(e22);
        return n3 ? p2.guidBrackets[n3[1]] !== n3[n3.length - 1] ? t4.error("string.guid") : e22 : t4.error("string.guid");
      } }, hex: { method(e22 = {}) {
        return d2.assertOptions(e22, ["byteAligned"]), e22 = n2({ byteAligned: false }, e22), o2(typeof e22.byteAligned == "boolean", "byteAligned must be boolean"), this.$_addRule({ name: "hex", args: { options: e22 } });
      }, validate: (e22, t4, { options: r3 }) => p2.hexRegex.test(e22) ? r3.byteAligned && e22.length % 2 != 0 ? t4.error("string.hexAlign") : e22 : t4.error("string.hex") }, hostname: { method() {
        return this.$_addRule("hostname");
      }, validate: (e22, t4) => i2.isValid(e22, { minDomainSegments: 1 }) || p2.ipRegex.test(e22) ? e22 : t4.error("string.hostname") }, insensitive: { method() {
        return this.$_setFlag("insensitive", true);
      } }, ip: { method(e22 = {}) {
        d2.assertOptions(e22, ["cidr", "version"]);
        const { cidr: t4, versions: r3, regex: s3 } = c2.regex(e22), n3 = e22.version ? r3 : void 0;
        return this.$_addRule({ name: "ip", args: { options: { cidr: t4, version: n3 } }, regex: s3 });
      }, validate: (e22, t4, { options: r3 }, { regex: s3 }) => s3.test(e22) ? e22 : r3.version ? t4.error("string.ipVersion", { value: e22, cidr: r3.cidr, version: r3.version }) : t4.error("string.ip", { value: e22, cidr: r3.cidr }) }, isoDate: { method() {
        return this.$_addRule("isoDate");
      }, validate: (e22, { error: t4 }) => p2.isoDate(e22) ? e22 : t4("string.isoDate") }, isoDuration: { method() {
        return this.$_addRule("isoDuration");
      }, validate: (e22, t4) => p2.isoDurationRegex.test(e22) ? e22 : t4.error("string.isoDuration") }, length: { method(e22, t4) {
        return p2.length(this, "length", e22, "=", t4);
      }, validate(e22, t4, { limit: r3, encoding: s3 }, { name: n3, operator: a3, args: o3 }) {
        const i3 = !s3 && e22.length;
        return d2.compare(i3, r3, a3) ? e22 : t4.error("string." + n3, { limit: o3.limit, value: e22, encoding: s3 });
      }, args: [{ name: "limit", ref: true, assert: d2.limit, message: "must be a positive integer" }, "encoding"] }, lowercase: { method() {
        return this.case("lower");
      } }, max: { method(e22, t4) {
        return p2.length(this, "max", e22, "<=", t4);
      }, args: ["limit", "encoding"] }, min: { method(e22, t4) {
        return p2.length(this, "min", e22, ">=", t4);
      }, args: ["limit", "encoding"] }, normalize: { method(e22 = "NFC") {
        return o2(p2.normalizationForms.includes(e22), "normalization form must be one of " + p2.normalizationForms.join(", ")), this.$_addRule({ name: "normalize", args: { form: e22 } });
      }, validate: (e22, { error: t4 }, { form: r3 }) => e22 === e22.normalize(r3) ? e22 : t4("string.normalize", { value: e22, form: r3 }), convert: true }, pattern: { alias: "regex", method(e22, t4 = {}) {
        o2(e22 instanceof RegExp, "regex must be a RegExp"), o2(!e22.flags.includes("g") && !e22.flags.includes("y"), "regex should not use global or sticky mode"), typeof t4 == "string" && (t4 = { name: t4 }), d2.assertOptions(t4, ["invert", "name"]);
        const r3 = ["string.pattern", t4.invert ? ".invert" : "", t4.name ? ".name" : ".base"].join("");
        return this.$_addRule({ name: "pattern", args: { regex: e22, options: t4 }, errorCode: r3 });
      }, validate: (e22, t4, { regex: r3, options: s3 }, { errorCode: n3 }) => r3.test(e22) ^ s3.invert ? e22 : t4.error(n3, { name: s3.name, regex: r3, value: e22 }), args: ["regex", "options"], multi: true }, replace: { method(e22, t4) {
        typeof e22 == "string" && (e22 = new RegExp(u2(e22), "g")), o2(e22 instanceof RegExp, "pattern must be a RegExp"), o2(typeof t4 == "string", "replacement must be a String");
        const r3 = this.clone();
        return r3.$_terms.replacements || (r3.$_terms.replacements = []), r3.$_terms.replacements.push({ pattern: e22, replacement: t4 }), r3;
      } }, token: { method() {
        return this.$_addRule("token");
      }, validate: (e22, t4) => /^\w+$/.test(e22) ? e22 : t4.error("string.token") }, trim: { method(e22 = true) {
        return o2(typeof e22 == "boolean", "enabled must be a boolean"), this.$_addRule({ name: "trim", args: { enabled: e22 } });
      }, validate: (e22, t4, { enabled: r3 }) => r3 && e22 !== e22.trim() ? t4.error("string.trim") : e22, convert: true }, truncate: { method(e22 = true) {
        return o2(typeof e22 == "boolean", "enabled must be a boolean"), this.$_setFlag("truncate", e22);
      } }, uppercase: { method() {
        return this.case("upper");
      } }, uri: { method(e22 = {}) {
        d2.assertOptions(e22, ["allowRelative", "allowQuerySquareBrackets", "domain", "relativeOnly", "scheme"]), e22.domain && d2.assertOptions(e22.domain, ["allowUnicode", "maxDomainSegments", "minDomainSegments", "tlds"]);
        const { regex: t4, scheme: r3 } = m2.regex(e22), s3 = e22.domain ? p2.addressOptions(e22.domain) : null;
        return this.$_addRule({ name: "uri", args: { options: e22 }, regex: t4, domain: s3, scheme: r3 });
      }, validate(e22, t4, { options: r3 }, { regex: s3, domain: n3, scheme: a3 }) {
        if (["http:/", "https:/"].includes(e22))
          return t4.error("string.uri");
        const o3 = s3.exec(e22);
        if (o3) {
          const s4 = o3[1] || o3[2];
          return !n3 || r3.allowRelative && !s4 || i2.isValid(s4, n3) ? e22 : t4.error("string.domain", { value: s4 });
        }
        return r3.relativeOnly ? t4.error("string.uriRelativeOnly") : r3.scheme ? t4.error("string.uriCustomScheme", { scheme: a3, value: e22 }) : t4.error("string.uri");
      } } }, manifest: { build(e22, t4) {
        if (t4.replacements)
          for (const { pattern: r3, replacement: s3 } of t4.replacements)
            e22 = e22.replace(r3, s3);
        return e22;
      } }, messages: { "string.alphanum": "{{#label}} must only contain alpha-numeric characters", "string.base": "{{#label}} must be a string", "string.base64": "{{#label}} must be a valid base64 string", "string.creditCard": "{{#label}} must be a credit card", "string.dataUri": "{{#label}} must be a valid dataUri string", "string.domain": "{{#label}} must contain a valid domain name", "string.email": "{{#label}} must be a valid email", "string.empty": "{{#label}} is not allowed to be empty", "string.guid": "{{#label}} must be a valid GUID", "string.hex": "{{#label}} must only contain hexadecimal characters", "string.hexAlign": "{{#label}} hex decoded representation must be byte aligned", "string.hostname": "{{#label}} must be a valid hostname", "string.ip": "{{#label}} must be a valid ip address with a {{#cidr}} CIDR", "string.ipVersion": "{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR", "string.isoDate": "{{#label}} must be in iso format", "string.isoDuration": "{{#label}} must be a valid ISO 8601 duration", "string.length": "{{#label}} length must be {{#limit}} characters long", "string.lowercase": "{{#label}} must only contain lowercase characters", "string.max": "{{#label}} length must be less than or equal to {{#limit}} characters long", "string.min": "{{#label}} length must be at least {{#limit}} characters long", "string.normalize": "{{#label}} must be unicode normalized in the {{#form}} form", "string.token": "{{#label}} must only contain alpha-numeric and underscore characters", "string.pattern.base": "{{#label}} with value {:[.]} fails to match the required pattern: {{#regex}}", "string.pattern.name": "{{#label}} with value {:[.]} fails to match the {{#name}} pattern", "string.pattern.invert.base": "{{#label}} with value {:[.]} matches the inverted pattern: {{#regex}}", "string.pattern.invert.name": "{{#label}} with value {:[.]} matches the inverted {{#name}} pattern", "string.trim": "{{#label}} must not have leading or trailing whitespace", "string.uri": "{{#label}} must be a valid uri", "string.uriCustomScheme": "{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern", "string.uriRelativeOnly": "{{#label}} must be a valid relative uri", "string.uppercase": "{{#label}} must only contain uppercase characters" } }), p2.addressOptions = function(e22) {
        if (!e22)
          return e22;
        if (o2(e22.minDomainSegments === void 0 || Number.isSafeInteger(e22.minDomainSegments) && e22.minDomainSegments > 0, "minDomainSegments must be a positive integer"), o2(e22.maxDomainSegments === void 0 || Number.isSafeInteger(e22.maxDomainSegments) && e22.maxDomainSegments > 0, "maxDomainSegments must be a positive integer"), e22.tlds === false)
          return e22;
        if (e22.tlds === true || e22.tlds === void 0)
          return o2(p2.tlds, "Built-in TLD list disabled"), Object.assign({}, e22, p2.tlds);
        o2(typeof e22.tlds == "object", "tlds must be true, false, or an object");
        const t4 = e22.tlds.deny;
        if (t4)
          return Array.isArray(t4) && (e22 = Object.assign({}, e22, { tlds: { deny: new Set(t4) } })), o2(e22.tlds.deny instanceof Set, "tlds.deny must be an array, Set, or boolean"), o2(!e22.tlds.allow, "Cannot specify both tlds.allow and tlds.deny lists"), p2.validateTlds(e22.tlds.deny, "tlds.deny"), e22;
        const r3 = e22.tlds.allow;
        return r3 ? r3 === true ? (o2(p2.tlds, "Built-in TLD list disabled"), Object.assign({}, e22, p2.tlds)) : (Array.isArray(r3) && (e22 = Object.assign({}, e22, { tlds: { allow: new Set(r3) } })), o2(e22.tlds.allow instanceof Set, "tlds.allow must be an array, Set, or boolean"), p2.validateTlds(e22.tlds.allow, "tlds.allow"), e22) : e22;
      }, p2.validateTlds = function(e22, t4) {
        for (const r3 of e22)
          o2(i2.isValid(r3, { minDomainSegments: 1, maxDomainSegments: 1 }), "".concat(t4, " must contain valid top level domain names"));
      }, p2.isoDate = function(e22) {
        if (!d2.isIsoDate(e22))
          return null;
        /.*T.*[+-]\d\d$/.test(e22) && (e22 += "00");
        const t4 = new Date(e22);
        return isNaN(t4.getTime()) ? null : t4.toISOString();
      }, p2.length = function(e22, t4, r3, s3, n3) {
        return o2(!n3 || false, "Invalid encoding:", n3), e22.$_addRule({ name: t4, method: "length", args: { limit: r3, encoding: n3 }, operator: s3 });
      };
    }, 8826: (e21, t3, r2) => {
      const s2 = r2(375), n2 = r2(8068), a2 = {};
      a2.Map = class extends Map {
        slice() {
          return new a2.Map(this);
        }
      }, e21.exports = n2.extend({ type: "symbol", terms: { map: { init: new a2.Map() } }, coerce: { method(e22, { schema: t4, error: r3 }) {
        const s3 = t4.$_terms.map.get(e22);
        return s3 && (e22 = s3), t4._flags.only && typeof e22 != "symbol" ? { value: e22, errors: r3("symbol.map", { map: t4.$_terms.map }) } : { value: e22 };
      } }, validate(e22, { error: t4 }) {
        if (typeof e22 != "symbol")
          return { value: e22, errors: t4("symbol.base") };
      }, rules: { map: { method(e22) {
        e22 && !e22[Symbol.iterator] && typeof e22 == "object" && (e22 = Object.entries(e22)), s2(e22 && e22[Symbol.iterator], "Iterable must be an iterable or object");
        const t4 = this.clone(), r3 = [];
        for (const n3 of e22) {
          s2(n3 && n3[Symbol.iterator], "Entry must be an iterable");
          const [e23, a3] = n3;
          s2(typeof e23 != "object" && typeof e23 != "function" && typeof e23 != "symbol", "Key must not be of type object, function, or Symbol"), s2(typeof a3 == "symbol", "Value must be a Symbol"), t4.$_terms.map.set(e23, a3), r3.push(a3);
        }
        return t4.valid(...r3);
      } } }, manifest: { build: (e22, t4) => (t4.map && (e22 = e22.map(t4.map)), e22) }, messages: { "symbol.base": "{{#label}} must be a symbol", "symbol.map": "{{#label}} must be one of {{#map}}" } });
    }, 8863: (e21, t3, r2) => {
      const s2 = r2(375), n2 = r2(8571), a2 = r2(738), o2 = r2(9621), i2 = r2(8160), l2 = r2(6354), c2 = r2(493), u2 = { result: Symbol("result") };
      t3.entry = function(e22, t4, r3) {
        let n3 = i2.defaults;
        r3 && (s2(r3.warnings === void 0, "Cannot override warnings preference in synchronous validation"), s2(r3.artifacts === void 0, "Cannot override artifacts preference in synchronous validation"), n3 = i2.preferences(i2.defaults, r3));
        const a3 = u2.entry(e22, t4, n3);
        s2(!a3.mainstay.externals.length, "Schema with external rules must use validateAsync()");
        const o3 = { value: a3.value };
        return a3.error && (o3.error = a3.error), a3.mainstay.warnings.length && (o3.warning = l2.details(a3.mainstay.warnings)), a3.mainstay.debug && (o3.debug = a3.mainstay.debug), a3.mainstay.artifacts && (o3.artifacts = a3.mainstay.artifacts), o3;
      }, t3.entryAsync = async function(e22, t4, r3) {
        let s3 = i2.defaults;
        r3 && (s3 = i2.preferences(i2.defaults, r3));
        const n3 = u2.entry(e22, t4, s3), a3 = n3.mainstay;
        if (n3.error)
          throw a3.debug && (n3.error.debug = a3.debug), n3.error;
        if (a3.externals.length) {
          let e23 = n3.value;
          for (const { method: t5, path: s4, label: n4 } of a3.externals) {
            let a4, i3, l3 = e23;
            s4.length && (a4 = s4[s4.length - 1], i3 = o2(e23, s4.slice(0, -1)), l3 = i3[a4]);
            try {
              const s5 = await t5(l3, { prefs: r3 });
              if (s5 === void 0 || s5 === l3)
                continue;
              i3 ? i3[a4] = s5 : e23 = s5;
            } catch (e24) {
              throw e24.message += " (".concat(n4, ")"), e24;
            }
          }
          n3.value = e23;
        }
        if (!s3.warnings && !s3.debug && !s3.artifacts)
          return n3.value;
        const c3 = { value: n3.value };
        return a3.warnings.length && (c3.warning = l2.details(a3.warnings)), a3.debug && (c3.debug = a3.debug), a3.artifacts && (c3.artifacts = a3.artifacts), c3;
      }, u2.entry = function(e22, r3, s3) {
        const { tracer: n3, cleanup: a3 } = u2.tracer(r3, s3), o3 = { externals: [], warnings: [], tracer: n3, debug: s3.debug ? [] : null, links: r3._ids._schemaChain ? new Map() : null }, i3 = r3._ids._schemaChain ? [{ schema: r3 }] : null, f2 = new c2([], [], { mainstay: o3, schemas: i3 }), m2 = t3.validate(e22, r3, f2, s3);
        a3 && r3.$_root.untrace();
        const h2 = l2.process(m2.errors, e22, s3);
        return { value: m2.value, error: h2, mainstay: o3 };
      }, u2.tracer = function(e22, t4) {
        return e22.$_root._tracer ? { tracer: e22.$_root._tracer._register(e22) } : t4.debug ? (s2(e22.$_root.trace, "Debug mode not supported"), { tracer: e22.$_root.trace()._register(e22), cleanup: true }) : { tracer: u2.ignore };
      }, t3.validate = function(e22, t4, r3, s3, n3 = {}) {
        if (t4.$_terms.whens && (t4 = t4._generate(e22, r3, s3).schema), t4._preferences && (s3 = u2.prefs(t4, s3)), t4._cache && s3.cache) {
          const s4 = t4._cache.get(e22);
          if (r3.mainstay.tracer.debug(r3, "validate", "cached", !!s4), s4)
            return s4;
        }
        const a3 = (n4, a4, o4) => t4.$_createError(n4, e22, a4, o4 || r3, s3), o3 = { original: e22, prefs: s3, schema: t4, state: r3, error: a3, errorsArray: u2.errorsArray, warn: (e23, t5, s4) => r3.mainstay.warnings.push(a3(e23, t5, s4)), message: (n4, a4) => t4.$_createError("custom", e22, a4, r3, s3, { messages: n4 }) };
        r3.mainstay.tracer.entry(t4, r3);
        const l3 = t4._definition;
        if (l3.prepare && e22 !== void 0 && s3.convert) {
          const t5 = l3.prepare(e22, o3);
          if (t5) {
            if (r3.mainstay.tracer.value(r3, "prepare", e22, t5.value), t5.errors)
              return u2.finalize(t5.value, [].concat(t5.errors), o3);
            e22 = t5.value;
          }
        }
        if (l3.coerce && e22 !== void 0 && s3.convert && (!l3.coerce.from || l3.coerce.from.includes(typeof e22))) {
          const t5 = l3.coerce.method(e22, o3);
          if (t5) {
            if (r3.mainstay.tracer.value(r3, "coerced", e22, t5.value), t5.errors)
              return u2.finalize(t5.value, [].concat(t5.errors), o3);
            e22 = t5.value;
          }
        }
        const c3 = t4._flags.empty;
        c3 && c3.$_match(u2.trim(e22, t4), r3.nest(c3), i2.defaults) && (r3.mainstay.tracer.value(r3, "empty", e22, void 0), e22 = void 0);
        const f2 = n3.presence || t4._flags.presence || (t4._flags._endedSwitch ? null : s3.presence);
        if (e22 === void 0) {
          if (f2 === "forbidden")
            return u2.finalize(e22, null, o3);
          if (f2 === "required")
            return u2.finalize(e22, [t4.$_createError("any.required", e22, null, r3, s3)], o3);
          if (f2 === "optional") {
            if (t4._flags.default !== i2.symbols.deepDefault)
              return u2.finalize(e22, null, o3);
            r3.mainstay.tracer.value(r3, "default", e22, {}), e22 = {};
          }
        } else if (f2 === "forbidden")
          return u2.finalize(e22, [t4.$_createError("any.unknown", e22, null, r3, s3)], o3);
        const m2 = [];
        if (t4._valids) {
          const n4 = t4._valids.get(e22, r3, s3, t4._flags.insensitive);
          if (n4)
            return s3.convert && (r3.mainstay.tracer.value(r3, "valids", e22, n4.value), e22 = n4.value), r3.mainstay.tracer.filter(t4, r3, "valid", n4), u2.finalize(e22, null, o3);
          if (t4._flags.only) {
            const n5 = t4.$_createError("any.only", e22, { valids: t4._valids.values({ display: true }) }, r3, s3);
            if (s3.abortEarly)
              return u2.finalize(e22, [n5], o3);
            m2.push(n5);
          }
        }
        if (t4._invalids) {
          const n4 = t4._invalids.get(e22, r3, s3, t4._flags.insensitive);
          if (n4) {
            r3.mainstay.tracer.filter(t4, r3, "invalid", n4);
            const a4 = t4.$_createError("any.invalid", e22, { invalids: t4._invalids.values({ display: true }) }, r3, s3);
            if (s3.abortEarly)
              return u2.finalize(e22, [a4], o3);
            m2.push(a4);
          }
        }
        if (l3.validate) {
          const t5 = l3.validate(e22, o3);
          if (t5 && (r3.mainstay.tracer.value(r3, "base", e22, t5.value), e22 = t5.value, t5.errors)) {
            if (!Array.isArray(t5.errors))
              return m2.push(t5.errors), u2.finalize(e22, m2, o3);
            if (t5.errors.length)
              return m2.push(...t5.errors), u2.finalize(e22, m2, o3);
          }
        }
        return t4._rules.length ? u2.rules(e22, m2, o3) : u2.finalize(e22, m2, o3);
      }, u2.rules = function(e22, t4, r3) {
        const { schema: s3, state: n3, prefs: a3 } = r3;
        for (const o3 of s3._rules) {
          const l3 = s3._definition.rules[o3.method];
          if (l3.convert && a3.convert) {
            n3.mainstay.tracer.log(s3, n3, "rule", o3.name, "full");
            continue;
          }
          let c3, f2 = o3.args;
          if (o3._resolve.length) {
            f2 = Object.assign({}, f2);
            for (const t5 of o3._resolve) {
              const r4 = l3.argsByName.get(t5), o4 = f2[t5].resolve(e22, n3, a3), u3 = r4.normalize ? r4.normalize(o4) : o4, m3 = i2.validateArg(u3, null, r4);
              if (m3) {
                c3 = s3.$_createError("any.ref", o4, { arg: t5, ref: f2[t5], reason: m3 }, n3, a3);
                break;
              }
              f2[t5] = u3;
            }
          }
          c3 = c3 || l3.validate(e22, r3, f2, o3);
          const m2 = u2.rule(c3, o3);
          if (m2.errors) {
            if (n3.mainstay.tracer.log(s3, n3, "rule", o3.name, "error"), o3.warn) {
              n3.mainstay.warnings.push(...m2.errors);
              continue;
            }
            if (a3.abortEarly)
              return u2.finalize(e22, m2.errors, r3);
            t4.push(...m2.errors);
          } else
            n3.mainstay.tracer.log(s3, n3, "rule", o3.name, "pass"), n3.mainstay.tracer.value(n3, "rule", e22, m2.value, o3.name), e22 = m2.value;
        }
        return u2.finalize(e22, t4, r3);
      }, u2.rule = function(e22, t4) {
        return e22 instanceof l2.Report ? (u2.error(e22, t4), { errors: [e22], value: null }) : Array.isArray(e22) && e22[i2.symbols.errors] ? (e22.forEach((e23) => u2.error(e23, t4)), { errors: e22, value: null }) : { errors: null, value: e22 };
      }, u2.error = function(e22, t4) {
        return t4.message && e22._setTemplate(t4.message), e22;
      }, u2.finalize = function(e22, t4, r3) {
        t4 = t4 || [];
        const { schema: n3, state: a3, prefs: o3 } = r3;
        if (t4.length) {
          const s3 = u2.default("failover", void 0, t4, r3);
          s3 !== void 0 && (a3.mainstay.tracer.value(a3, "failover", e22, s3), e22 = s3, t4 = []);
        }
        if (t4.length && n3._flags.error)
          if (typeof n3._flags.error == "function") {
            t4 = n3._flags.error(t4), Array.isArray(t4) || (t4 = [t4]);
            for (const e23 of t4)
              s2(e23 instanceof Error || e23 instanceof l2.Report, "error() must return an Error object");
          } else
            t4 = [n3._flags.error];
        if (e22 === void 0) {
          const s3 = u2.default("default", e22, t4, r3);
          a3.mainstay.tracer.value(a3, "default", e22, s3), e22 = s3;
        }
        if (n3._flags.cast && e22 !== void 0) {
          const t5 = n3._definition.cast[n3._flags.cast];
          if (t5.from(e22)) {
            const s3 = t5.to(e22, r3);
            a3.mainstay.tracer.value(a3, "cast", e22, s3, n3._flags.cast), e22 = s3;
          }
        }
        if (n3.$_terms.externals && o3.externals && o3._externals !== false)
          for (const { method: e23 } of n3.$_terms.externals)
            a3.mainstay.externals.push({ method: e23, path: a3.path, label: l2.label(n3._flags, a3, o3) });
        const i3 = { value: e22, errors: t4.length ? t4 : null };
        return n3._flags.result && (i3.value = n3._flags.result === "strip" ? void 0 : r3.original, a3.mainstay.tracer.value(a3, n3._flags.result, e22, i3.value), a3.shadow(e22, n3._flags.result)), n3._cache && o3.cache !== false && !n3._refs.length && n3._cache.set(r3.original, i3), e22 === void 0 || i3.errors || n3._flags.artifact === void 0 || (a3.mainstay.artifacts = a3.mainstay.artifacts || new Map(), a3.mainstay.artifacts.has(n3._flags.artifact) || a3.mainstay.artifacts.set(n3._flags.artifact, []), a3.mainstay.artifacts.get(n3._flags.artifact).push(a3.path)), i3;
      }, u2.prefs = function(e22, t4) {
        const r3 = t4 === i2.defaults;
        return r3 && e22._preferences[i2.symbols.prefs] ? e22._preferences[i2.symbols.prefs] : (t4 = i2.preferences(t4, e22._preferences), r3 && (e22._preferences[i2.symbols.prefs] = t4), t4);
      }, u2.default = function(e22, t4, r3, s3) {
        const { schema: a3, state: o3, prefs: l3 } = s3, c3 = a3._flags[e22];
        if (l3.noDefaults || c3 === void 0)
          return t4;
        if (o3.mainstay.tracer.log(a3, o3, "rule", e22, "full"), !c3)
          return c3;
        if (typeof c3 == "function") {
          const t5 = c3.length ? [n2(o3.ancestors[0]), s3] : [];
          try {
            return c3(...t5);
          } catch (t6) {
            return void r3.push(a3.$_createError("any.".concat(e22), null, { error: t6 }, o3, l3));
          }
        }
        return typeof c3 != "object" ? c3 : c3[i2.symbols.literal] ? c3.literal : i2.isResolvable(c3) ? c3.resolve(t4, o3, l3) : n2(c3);
      }, u2.trim = function(e22, t4) {
        if (typeof e22 != "string")
          return e22;
        const r3 = t4.$_getRule("trim");
        return r3 && r3.args.enabled ? e22.trim() : e22;
      }, u2.ignore = { active: false, debug: a2, entry: a2, filter: a2, log: a2, resolve: a2, value: a2 }, u2.errorsArray = function() {
        const e22 = [];
        return e22[i2.symbols.errors] = true, e22;
      };
    }, 2036: (e21, t3, r2) => {
      const s2 = r2(375), n2 = r2(9474), a2 = r2(8160), o2 = {};
      e21.exports = o2.Values = class {
        constructor(e22, t4) {
          this._values = new Set(e22), this._refs = new Set(t4), this._lowercase = o2.lowercases(e22), this._override = false;
        }
        get length() {
          return this._values.size + this._refs.size;
        }
        add(e22, t4) {
          a2.isResolvable(e22) ? this._refs.has(e22) || (this._refs.add(e22), t4 && t4.register(e22)) : this.has(e22, null, null, false) || (this._values.add(e22), typeof e22 == "string" && this._lowercase.set(e22.toLowerCase(), e22));
        }
        static merge(e22, t4, r3) {
          if (e22 = e22 || new o2.Values(), t4) {
            if (t4._override)
              return t4.clone();
            for (const r4 of [...t4._values, ...t4._refs])
              e22.add(r4);
          }
          if (r3)
            for (const t5 of [...r3._values, ...r3._refs])
              e22.remove(t5);
          return e22.length ? e22 : null;
        }
        remove(e22) {
          a2.isResolvable(e22) ? this._refs.delete(e22) : (this._values.delete(e22), typeof e22 == "string" && this._lowercase.delete(e22.toLowerCase()));
        }
        has(e22, t4, r3, s3) {
          return !!this.get(e22, t4, r3, s3);
        }
        get(e22, t4, r3, s3) {
          if (!this.length)
            return false;
          if (this._values.has(e22))
            return { value: e22 };
          if (typeof e22 == "string" && e22 && s3) {
            const t5 = this._lowercase.get(e22.toLowerCase());
            if (t5)
              return { value: t5 };
          }
          if (!this._refs.size && typeof e22 != "object")
            return false;
          if (typeof e22 == "object") {
            for (const t5 of this._values)
              if (n2(t5, e22))
                return { value: t5 };
          }
          if (t4)
            for (const a3 of this._refs) {
              const o3 = a3.resolve(e22, t4, r3, null, { in: true });
              if (o3 === void 0)
                continue;
              const i2 = a3.in && typeof o3 == "object" ? Array.isArray(o3) ? o3 : Object.keys(o3) : [o3];
              for (const t5 of i2)
                if (typeof t5 == typeof e22) {
                  if (s3 && e22 && typeof e22 == "string") {
                    if (t5.toLowerCase() === e22.toLowerCase())
                      return { value: t5, ref: a3 };
                  } else if (n2(t5, e22))
                    return { value: t5, ref: a3 };
                }
            }
          return false;
        }
        override() {
          this._override = true;
        }
        values(e22) {
          if (e22 && e22.display) {
            const e23 = [];
            for (const t4 of [...this._values, ...this._refs])
              t4 !== void 0 && e23.push(t4);
            return e23;
          }
          return Array.from([...this._values, ...this._refs]);
        }
        clone() {
          const e22 = new o2.Values(this._values, this._refs);
          return e22._override = this._override, e22;
        }
        concat(e22) {
          s2(!e22._override, "Cannot concat override set of values");
          const t4 = new o2.Values([...this._values, ...e22._values], [...this._refs, ...e22._refs]);
          return t4._override = this._override, t4;
        }
        describe() {
          const e22 = [];
          this._override && e22.push({ override: true });
          for (const t4 of this._values.values())
            e22.push(t4 && typeof t4 == "object" ? { value: t4 } : t4);
          for (const t4 of this._refs.values())
            e22.push(t4.describe());
          return e22;
        }
      }, o2.Values.prototype[a2.symbols.values] = true, o2.Values.prototype.slice = o2.Values.prototype.clone, o2.lowercases = function(e22) {
        const t4 = new Map();
        if (e22)
          for (const r3 of e22)
            typeof r3 == "string" && t4.set(r3.toLowerCase(), r3);
        return t4;
      };
    }, 978: (e21, t3, r2) => {
      const s2 = r2(375), n2 = r2(8571), a2 = r2(1687), o2 = r2(9621), i2 = {};
      e21.exports = function(e22, t4, r3 = {}) {
        if (s2(e22 && typeof e22 == "object", "Invalid defaults value: must be an object"), s2(!t4 || t4 === true || typeof t4 == "object", "Invalid source value: must be true, falsy or an object"), s2(typeof r3 == "object", "Invalid options: must be an object"), !t4)
          return null;
        if (r3.shallow)
          return i2.applyToDefaultsWithShallow(e22, t4, r3);
        const o3 = n2(e22);
        if (t4 === true)
          return o3;
        const l2 = r3.nullOverride !== void 0 && r3.nullOverride;
        return a2(o3, t4, { nullOverride: l2, mergeArrays: false });
      }, i2.applyToDefaultsWithShallow = function(e22, t4, r3) {
        const l2 = r3.shallow;
        s2(Array.isArray(l2), "Invalid keys");
        const c2 = new Map(), u2 = t4 === true ? null : new Set();
        for (let r4 of l2) {
          r4 = Array.isArray(r4) ? r4 : r4.split(".");
          const s3 = o2(e22, r4);
          s3 && typeof s3 == "object" ? c2.set(s3, u2 && o2(t4, r4) || s3) : u2 && u2.add(r4);
        }
        const f2 = n2(e22, {}, c2);
        if (!u2)
          return f2;
        for (const e23 of u2)
          i2.reachCopy(f2, t4, e23);
        const m2 = r3.nullOverride !== void 0 && r3.nullOverride;
        return a2(f2, t4, { nullOverride: m2, mergeArrays: false });
      }, i2.reachCopy = function(e22, t4, r3) {
        for (const e23 of r3) {
          if (!(e23 in t4))
            return;
          const r4 = t4[e23];
          if (typeof r4 != "object" || r4 === null)
            return;
          t4 = r4;
        }
        const s3 = t4;
        let n3 = e22;
        for (let e23 = 0; e23 < r3.length - 1; ++e23) {
          const t5 = r3[e23];
          typeof n3[t5] != "object" && (n3[t5] = {}), n3 = n3[t5];
        }
        n3[r3[r3.length - 1]] = s3;
      };
    }, 375: (e21, t3, r2) => {
      const s2 = r2(7916);
      e21.exports = function(e22, ...t4) {
        if (!e22) {
          if (t4.length === 1 && t4[0] instanceof Error)
            throw t4[0];
          throw new s2(t4);
        }
      };
    }, 8571: (e21, t3, r2) => {
      const s2 = r2(9621), n2 = r2(4277), a2 = r2(7043), o2 = { needsProtoHack: new Set([n2.set, n2.map, n2.weakSet, n2.weakMap]) };
      e21.exports = o2.clone = function(e22, t4 = {}, r3 = null) {
        if (typeof e22 != "object" || e22 === null)
          return e22;
        let s3 = o2.clone, i2 = r3;
        if (t4.shallow) {
          if (t4.shallow !== true)
            return o2.cloneWithShallow(e22, t4);
          s3 = (e23) => e23;
        } else if (i2) {
          const t5 = i2.get(e22);
          if (t5)
            return t5;
        } else
          i2 = new Map();
        const l2 = n2.getInternalProto(e22);
        if (l2 === n2.buffer)
          return false;
        if (l2 === n2.date)
          return new Date(e22.getTime());
        if (l2 === n2.regex)
          return new RegExp(e22);
        const c2 = o2.base(e22, l2, t4);
        if (c2 === e22)
          return e22;
        if (i2 && i2.set(e22, c2), l2 === n2.set)
          for (const r4 of e22)
            c2.add(s3(r4, t4, i2));
        else if (l2 === n2.map)
          for (const [r4, n3] of e22)
            c2.set(r4, s3(n3, t4, i2));
        const u2 = a2.keys(e22, t4);
        for (const r4 of u2) {
          if (r4 === "__proto__")
            continue;
          if (l2 === n2.array && r4 === "length") {
            c2.length = e22.length;
            continue;
          }
          const a3 = Object.getOwnPropertyDescriptor(e22, r4);
          a3 ? a3.get || a3.set ? Object.defineProperty(c2, r4, a3) : a3.enumerable ? c2[r4] = s3(e22[r4], t4, i2) : Object.defineProperty(c2, r4, { enumerable: false, writable: true, configurable: true, value: s3(e22[r4], t4, i2) }) : Object.defineProperty(c2, r4, { enumerable: true, writable: true, configurable: true, value: s3(e22[r4], t4, i2) });
        }
        return c2;
      }, o2.cloneWithShallow = function(e22, t4) {
        const r3 = t4.shallow;
        (t4 = Object.assign({}, t4)).shallow = false;
        const n3 = new Map();
        for (const t5 of r3) {
          const r4 = s2(e22, t5);
          typeof r4 != "object" && typeof r4 != "function" || n3.set(r4, r4);
        }
        return o2.clone(e22, t4, n3);
      }, o2.base = function(e22, t4, r3) {
        if (r3.prototype === false)
          return o2.needsProtoHack.has(t4) ? new t4.constructor() : t4 === n2.array ? [] : {};
        const s3 = Object.getPrototypeOf(e22);
        if (s3 && s3.isImmutable)
          return e22;
        if (t4 === n2.array) {
          const e23 = [];
          return s3 !== t4 && Object.setPrototypeOf(e23, s3), e23;
        }
        if (o2.needsProtoHack.has(t4)) {
          const e23 = new s3.constructor();
          return s3 !== t4 && Object.setPrototypeOf(e23, s3), e23;
        }
        return Object.create(s3);
      };
    }, 9474: (e21, t3, r2) => {
      const s2 = r2(4277), n2 = { mismatched: null };
      e21.exports = function(e22, t4, r3) {
        return r3 = Object.assign({ prototype: true }, r3), !!n2.isDeepEqual(e22, t4, r3, []);
      }, n2.isDeepEqual = function(e22, t4, r3, a2) {
        if (e22 === t4)
          return e22 !== 0 || 1 / e22 == 1 / t4;
        const o2 = typeof e22;
        if (o2 !== typeof t4)
          return false;
        if (e22 === null || t4 === null)
          return false;
        if (o2 === "function") {
          if (!r3.deepFunction || e22.toString() !== t4.toString())
            return false;
        } else if (o2 !== "object")
          return e22 != e22 && t4 != t4;
        const i2 = n2.getSharedType(e22, t4, !!r3.prototype);
        switch (i2) {
          case s2.buffer:
            return false;
          case s2.promise:
            return e22 === t4;
          case s2.regex:
            return e22.toString() === t4.toString();
          case n2.mismatched:
            return false;
        }
        for (let r4 = a2.length - 1; r4 >= 0; --r4)
          if (a2[r4].isSame(e22, t4))
            return true;
        a2.push(new n2.SeenEntry(e22, t4));
        try {
          return !!n2.isDeepEqualObj(i2, e22, t4, r3, a2);
        } finally {
          a2.pop();
        }
      }, n2.getSharedType = function(e22, t4, r3) {
        if (r3)
          return Object.getPrototypeOf(e22) !== Object.getPrototypeOf(t4) ? n2.mismatched : s2.getInternalProto(e22);
        const a2 = s2.getInternalProto(e22);
        return a2 !== s2.getInternalProto(t4) ? n2.mismatched : a2;
      }, n2.valueOf = function(e22) {
        const t4 = e22.valueOf;
        if (t4 === void 0)
          return e22;
        try {
          return t4.call(e22);
        } catch (e23) {
          return e23;
        }
      }, n2.hasOwnEnumerableProperty = function(e22, t4) {
        return Object.prototype.propertyIsEnumerable.call(e22, t4);
      }, n2.isSetSimpleEqual = function(e22, t4) {
        for (const r3 of Set.prototype.values.call(e22))
          if (!Set.prototype.has.call(t4, r3))
            return false;
        return true;
      }, n2.isDeepEqualObj = function(e22, t4, r3, a2, o2) {
        const { isDeepEqual: i2, valueOf: l2, hasOwnEnumerableProperty: c2 } = n2, { keys: u2, getOwnPropertySymbols: f2 } = Object;
        if (e22 === s2.array) {
          if (!a2.part) {
            if (t4.length !== r3.length)
              return false;
            for (let e23 = 0; e23 < t4.length; ++e23)
              if (!i2(t4[e23], r3[e23], a2, o2))
                return false;
            return true;
          }
          for (const e23 of t4)
            for (const t5 of r3)
              if (i2(e23, t5, a2, o2))
                return true;
        } else if (e22 === s2.set) {
          if (t4.size !== r3.size)
            return false;
          if (!n2.isSetSimpleEqual(t4, r3)) {
            const e23 = new Set(Set.prototype.values.call(r3));
            for (const r4 of Set.prototype.values.call(t4)) {
              if (e23.delete(r4))
                continue;
              let t5 = false;
              for (const s3 of e23)
                if (i2(r4, s3, a2, o2)) {
                  e23.delete(s3), t5 = true;
                  break;
                }
              if (!t5)
                return false;
            }
          }
        } else if (e22 === s2.map) {
          if (t4.size !== r3.size)
            return false;
          for (const [e23, s3] of Map.prototype.entries.call(t4)) {
            if (s3 === void 0 && !Map.prototype.has.call(r3, e23))
              return false;
            if (!i2(s3, Map.prototype.get.call(r3, e23), a2, o2))
              return false;
          }
        } else if (e22 === s2.error && (t4.name !== r3.name || t4.message !== r3.message))
          return false;
        const m2 = l2(t4), h2 = l2(r3);
        if ((t4 !== m2 || r3 !== h2) && !i2(m2, h2, a2, o2))
          return false;
        const d2 = u2(t4);
        if (!a2.part && d2.length !== u2(r3).length && !a2.skip)
          return false;
        let p2 = 0;
        for (const e23 of d2)
          if (a2.skip && a2.skip.includes(e23))
            r3[e23] === void 0 && ++p2;
          else {
            if (!c2(r3, e23))
              return false;
            if (!i2(t4[e23], r3[e23], a2, o2))
              return false;
          }
        if (!a2.part && d2.length - p2 !== u2(r3).length)
          return false;
        if (a2.symbols !== false) {
          const e23 = f2(t4), s3 = new Set(f2(r3));
          for (const n3 of e23) {
            if (!a2.skip || !a2.skip.includes(n3)) {
              if (c2(t4, n3)) {
                if (!c2(r3, n3))
                  return false;
                if (!i2(t4[n3], r3[n3], a2, o2))
                  return false;
              } else if (c2(r3, n3))
                return false;
            }
            s3.delete(n3);
          }
          for (const e24 of s3)
            if (c2(r3, e24))
              return false;
        }
        return true;
      }, n2.SeenEntry = class {
        constructor(e22, t4) {
          this.obj = e22, this.ref = t4;
        }
        isSame(e22, t4) {
          return this.obj === e22 && this.ref === t4;
        }
      };
    }, 7916: (e21, t3, r2) => {
      const s2 = r2(8761);
      e21.exports = class extends Error {
        constructor(e22) {
          super(e22.filter((e23) => e23 !== "").map((e23) => typeof e23 == "string" ? e23 : e23 instanceof Error ? e23.message : s2(e23)).join(" ") || "Unknown error"), typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, t3.assert);
        }
      };
    }, 5277: (e21) => {
      const t3 = {};
      e21.exports = function(e22) {
        if (!e22)
          return "";
        let r2 = "";
        for (let s2 = 0; s2 < e22.length; ++s2) {
          const n2 = e22.charCodeAt(s2);
          t3.isSafe(n2) ? r2 += e22[s2] : r2 += t3.escapeHtmlChar(n2);
        }
        return r2;
      }, t3.escapeHtmlChar = function(e22) {
        const r2 = t3.namedHtml[e22];
        if (r2 !== void 0)
          return r2;
        if (e22 >= 256)
          return "&#" + e22 + ";";
        const s2 = e22.toString(16).padStart(2, "0");
        return "&#x".concat(s2, ";");
      }, t3.isSafe = function(e22) {
        return t3.safeCharCodes[e22] !== void 0;
      }, t3.namedHtml = { 38: "&amp;", 60: "&lt;", 62: "&gt;", 34: "&quot;", 160: "&nbsp;", 162: "&cent;", 163: "&pound;", 164: "&curren;", 169: "&copy;", 174: "&reg;" }, t3.safeCharCodes = function() {
        const e22 = {};
        for (let t4 = 32; t4 < 123; ++t4)
          (t4 >= 97 || t4 >= 65 && t4 <= 90 || t4 >= 48 && t4 <= 57 || t4 === 32 || t4 === 46 || t4 === 44 || t4 === 45 || t4 === 58 || t4 === 95) && (e22[t4] = null);
        return e22;
      }();
    }, 6064: (e21) => {
      e21.exports = function(e22) {
        return e22.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, "\\$&");
      };
    }, 738: (e21) => {
      e21.exports = function() {
      };
    }, 1687: (e21, t3, r2) => {
      const s2 = r2(375), n2 = r2(8571), a2 = r2(7043), o2 = {};
      e21.exports = o2.merge = function(e22, t4, r3) {
        if (s2(e22 && typeof e22 == "object", "Invalid target value: must be an object"), s2(t4 == null || typeof t4 == "object", "Invalid source value: must be null, undefined, or an object"), !t4)
          return e22;
        if (r3 = Object.assign({ nullOverride: true, mergeArrays: true }, r3), Array.isArray(t4)) {
          s2(Array.isArray(e22), "Cannot merge array onto an object"), r3.mergeArrays || (e22.length = 0);
          for (let s3 = 0; s3 < t4.length; ++s3)
            e22.push(n2(t4[s3], { symbols: r3.symbols }));
          return e22;
        }
        const i2 = a2.keys(t4, r3);
        for (let s3 = 0; s3 < i2.length; ++s3) {
          const a3 = i2[s3];
          if (a3 === "__proto__" || !Object.prototype.propertyIsEnumerable.call(t4, a3))
            continue;
          const l2 = t4[a3];
          if (l2 && typeof l2 == "object") {
            if (e22[a3] === l2)
              continue;
            !e22[a3] || typeof e22[a3] != "object" || Array.isArray(e22[a3]) !== Array.isArray(l2) || l2 instanceof Date || l2 instanceof RegExp ? e22[a3] = n2(l2, { symbols: r3.symbols }) : o2.merge(e22[a3], l2, r3);
          } else
            (l2 != null || r3.nullOverride) && (e22[a3] = l2);
        }
        return e22;
      };
    }, 9621: (e21, t3, r2) => {
      const s2 = r2(375), n2 = {};
      e21.exports = function(e22, t4, r3) {
        if (t4 === false || t4 == null)
          return e22;
        typeof (r3 = r3 || {}) == "string" && (r3 = { separator: r3 });
        const a2 = Array.isArray(t4);
        s2(!a2 || !r3.separator, "Separator option no valid for array-based chain");
        const o2 = a2 ? t4 : t4.split(r3.separator || ".");
        let i2 = e22;
        for (let e23 = 0; e23 < o2.length; ++e23) {
          let a3 = o2[e23];
          const l2 = r3.iterables && n2.iterables(i2);
          if (Array.isArray(i2) || l2 === "set") {
            const e24 = Number(a3);
            Number.isInteger(e24) && (a3 = e24 < 0 ? i2.length + e24 : e24);
          }
          if (!i2 || typeof i2 == "function" && r3.functions === false || !l2 && i2[a3] === void 0) {
            s2(!r3.strict || e23 + 1 === o2.length, "Missing segment", a3, "in reach path ", t4), s2(typeof i2 == "object" || r3.functions === true || typeof i2 != "function", "Invalid segment", a3, "in reach path ", t4), i2 = r3.default;
            break;
          }
          i2 = l2 ? l2 === "set" ? [...i2][a3] : i2.get(a3) : i2[a3];
        }
        return i2;
      }, n2.iterables = function(e22) {
        return e22 instanceof Set ? "set" : e22 instanceof Map ? "map" : void 0;
      };
    }, 8761: (e21) => {
      e21.exports = function(...e22) {
        try {
          return JSON.stringify.apply(null, e22);
        } catch (e23) {
          return "[Cannot display object: " + e23.message + "]";
        }
      };
    }, 4277: (e21, t3) => {
      const r2 = {};
      t3 = e21.exports = { array: Array.prototype, buffer: false, date: Date.prototype, error: Error.prototype, generic: Object.prototype, map: Map.prototype, promise: Promise.prototype, regex: RegExp.prototype, set: Set.prototype, weakMap: WeakMap.prototype, weakSet: WeakSet.prototype }, r2.typeMap = new Map([["[object Error]", t3.error], ["[object Map]", t3.map], ["[object Promise]", t3.promise], ["[object Set]", t3.set], ["[object WeakMap]", t3.weakMap], ["[object WeakSet]", t3.weakSet]]), t3.getInternalProto = function(e22) {
        if (Array.isArray(e22))
          return t3.array;
        if (e22 instanceof Date)
          return t3.date;
        if (e22 instanceof RegExp)
          return t3.regex;
        if (e22 instanceof Error)
          return t3.error;
        const s2 = Object.prototype.toString.call(e22);
        return r2.typeMap.get(s2) || t3.generic;
      };
    }, 7043: (e21, t3) => {
      t3.keys = function(e22, t4 = {}) {
        return t4.symbols !== false ? Reflect.ownKeys(e22) : Object.getOwnPropertyNames(e22);
      };
    }, 3652: (e21, t3, r2) => {
      const s2 = r2(375), n2 = {};
      t3.Sorter = class {
        constructor() {
          this._items = [], this.nodes = [];
        }
        add(e22, t4) {
          const r3 = [].concat((t4 = t4 || {}).before || []), n3 = [].concat(t4.after || []), a2 = t4.group || "?", o2 = t4.sort || 0;
          s2(!r3.includes(a2), "Item cannot come before itself: ".concat(a2)), s2(!r3.includes("?"), "Item cannot come before unassociated items"), s2(!n3.includes(a2), "Item cannot come after itself: ".concat(a2)), s2(!n3.includes("?"), "Item cannot come after unassociated items"), Array.isArray(e22) || (e22 = [e22]);
          for (const t5 of e22) {
            const e23 = { seq: this._items.length, sort: o2, before: r3, after: n3, group: a2, node: t5 };
            this._items.push(e23);
          }
          if (!t4.manual) {
            const e23 = this._sort();
            s2(e23, "item", a2 !== "?" ? "added into group ".concat(a2) : "", "created a dependencies error");
          }
          return this.nodes;
        }
        merge(e22) {
          Array.isArray(e22) || (e22 = [e22]);
          for (const t5 of e22)
            if (t5)
              for (const e23 of t5._items)
                this._items.push(Object.assign({}, e23));
          this._items.sort(n2.mergeSort);
          for (let e23 = 0; e23 < this._items.length; ++e23)
            this._items[e23].seq = e23;
          const t4 = this._sort();
          return s2(t4, "merge created a dependencies error"), this.nodes;
        }
        sort() {
          const e22 = this._sort();
          return s2(e22, "sort created a dependencies error"), this.nodes;
        }
        _sort() {
          const e22 = {}, t4 = Object.create(null), r3 = Object.create(null);
          for (const s4 of this._items) {
            const n4 = s4.seq, a3 = s4.group;
            r3[a3] = r3[a3] || [], r3[a3].push(n4), e22[n4] = s4.before;
            for (const e23 of s4.after)
              t4[e23] = t4[e23] || [], t4[e23].push(n4);
          }
          for (const t5 in e22) {
            const s4 = [];
            for (const n4 in e22[t5]) {
              const a3 = e22[t5][n4];
              r3[a3] = r3[a3] || [], s4.push(...r3[a3]);
            }
            e22[t5] = s4;
          }
          for (const s4 in t4)
            if (r3[s4])
              for (const n4 of r3[s4])
                e22[n4].push(...t4[s4]);
          const s3 = {};
          for (const t5 in e22) {
            const r4 = e22[t5];
            for (const e23 of r4)
              s3[e23] = s3[e23] || [], s3[e23].push(t5);
          }
          const n3 = {}, a2 = [];
          for (let e23 = 0; e23 < this._items.length; ++e23) {
            let t5 = e23;
            if (s3[e23]) {
              t5 = null;
              for (let e24 = 0; e24 < this._items.length; ++e24) {
                if (n3[e24] === true)
                  continue;
                s3[e24] || (s3[e24] = []);
                const r4 = s3[e24].length;
                let a3 = 0;
                for (let t6 = 0; t6 < r4; ++t6)
                  n3[s3[e24][t6]] && ++a3;
                if (a3 === r4) {
                  t5 = e24;
                  break;
                }
              }
            }
            t5 !== null && (n3[t5] = true, a2.push(t5));
          }
          if (a2.length !== this._items.length)
            return false;
          const o2 = {};
          for (const e23 of this._items)
            o2[e23.seq] = e23;
          this._items = [], this.nodes = [];
          for (const e23 of a2) {
            const t5 = o2[e23];
            this.nodes.push(t5.node), this._items.push(t5);
          }
          return true;
        }
      }, n2.mergeSort = (e22, t4) => e22.sort === t4.sort ? 0 : e22.sort < t4.sort ? -1 : 1;
    }, 5380: (e21, t3, r2) => {
      const s2 = r2(443), n2 = r2(2178), a2 = { minDomainSegments: 2, nonAsciiRx: /[^\x00-\x7f]/, domainControlRx: /[\x00-\x20@\:\/\\#!\$&\'\(\)\*\+,;=\?]/, tldSegmentRx: /^[a-zA-Z](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/, domainSegmentRx: /^[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/, URL: s2.URL || URL };
      t3.analyze = function(e22, t4 = {}) {
        if (typeof e22 != "string")
          throw new Error("Invalid input: domain must be a string");
        if (!e22)
          return n2.code("DOMAIN_NON_EMPTY_STRING");
        if (e22.length > 256)
          return n2.code("DOMAIN_TOO_LONG");
        if (a2.nonAsciiRx.test(e22)) {
          if (t4.allowUnicode === false)
            return n2.code("DOMAIN_INVALID_UNICODE_CHARS");
          e22 = e22.normalize("NFC");
        }
        if (a2.domainControlRx.test(e22))
          return n2.code("DOMAIN_INVALID_CHARS");
        e22 = a2.punycode(e22);
        const r3 = t4.minDomainSegments || a2.minDomainSegments, s3 = e22.split(".");
        if (s3.length < r3)
          return n2.code("DOMAIN_SEGMENTS_COUNT");
        if (t4.maxDomainSegments && s3.length > t4.maxDomainSegments)
          return n2.code("DOMAIN_SEGMENTS_COUNT_MAX");
        const o2 = t4.tlds;
        if (o2) {
          const e23 = s3[s3.length - 1].toLowerCase();
          if (o2.deny && o2.deny.has(e23) || o2.allow && !o2.allow.has(e23))
            return n2.code("DOMAIN_FORBIDDEN_TLDS");
        }
        for (let e23 = 0; e23 < s3.length; ++e23) {
          const t5 = s3[e23];
          if (!t5.length)
            return n2.code("DOMAIN_EMPTY_SEGMENT");
          if (t5.length > 63)
            return n2.code("DOMAIN_LONG_SEGMENT");
          if (e23 < s3.length - 1) {
            if (!a2.domainSegmentRx.test(t5))
              return n2.code("DOMAIN_INVALID_CHARS");
          } else if (!a2.tldSegmentRx.test(t5))
            return n2.code("DOMAIN_INVALID_TLDS_CHARS");
        }
        return null;
      }, t3.isValid = function(e22, r3) {
        return !t3.analyze(e22, r3);
      }, a2.punycode = function(e22) {
        try {
          return new a2.URL("http://".concat(e22)).host;
        } catch (t4) {
          return e22;
        }
      };
    }, 1745: (e21, t3, r2) => {
      const s2 = r2(9848), n2 = r2(5380), a2 = r2(2178), o2 = { nonAsciiRx: /[^\x00-\x7f]/, encoder: new (s2.TextEncoder || TextEncoder)() };
      t3.analyze = function(e22, t4) {
        return o2.email(e22, t4);
      }, t3.isValid = function(e22, t4) {
        return !o2.email(e22, t4);
      }, o2.email = function(e22, t4 = {}) {
        if (typeof e22 != "string")
          throw new Error("Invalid input: email must be a string");
        if (!e22)
          return a2.code("EMPTY_STRING");
        const r3 = !o2.nonAsciiRx.test(e22);
        if (!r3) {
          if (t4.allowUnicode === false)
            return a2.code("FORBIDDEN_UNICODE");
          e22 = e22.normalize("NFC");
        }
        const s3 = e22.split("@");
        if (s3.length !== 2)
          return s3.length > 2 ? a2.code("MULTIPLE_AT_CHAR") : a2.code("MISSING_AT_CHAR");
        const [i2, l2] = s3;
        if (!i2)
          return a2.code("EMPTY_LOCAL");
        if (!t4.ignoreLength) {
          if (e22.length > 254)
            return a2.code("ADDRESS_TOO_LONG");
          if (o2.encoder.encode(i2).length > 64)
            return a2.code("LOCAL_TOO_LONG");
        }
        return o2.local(i2, r3) || n2.analyze(l2, t4);
      }, o2.local = function(e22, t4) {
        const r3 = e22.split(".");
        for (const e23 of r3) {
          if (!e23.length)
            return a2.code("EMPTY_LOCAL_SEGMENT");
          if (t4) {
            if (!o2.atextRx.test(e23))
              return a2.code("INVALID_LOCAL_CHARS");
          } else
            for (const t5 of e23) {
              if (o2.atextRx.test(t5))
                continue;
              const e24 = o2.binary(t5);
              if (!o2.atomRx.test(e24))
                return a2.code("INVALID_LOCAL_CHARS");
            }
        }
      }, o2.binary = function(e22) {
        return Array.from(o2.encoder.encode(e22)).map((e23) => String.fromCharCode(e23)).join("");
      }, o2.atextRx = /^[\w!#\$%&'\*\+\-/=\?\^`\{\|\}~]+$/, o2.atomRx = new RegExp(["(?:[\\xc2-\\xdf][\\x80-\\xbf])", "(?:\\xe0[\\xa0-\\xbf][\\x80-\\xbf])|(?:[\\xe1-\\xec][\\x80-\\xbf]{2})|(?:\\xed[\\x80-\\x9f][\\x80-\\xbf])|(?:[\\xee-\\xef][\\x80-\\xbf]{2})", "(?:\\xf0[\\x90-\\xbf][\\x80-\\xbf]{2})|(?:[\\xf1-\\xf3][\\x80-\\xbf]{3})|(?:\\xf4[\\x80-\\x8f][\\x80-\\xbf]{2})"].join("|"));
    }, 2178: (e21, t3) => {
      t3.codes = { EMPTY_STRING: "Address must be a non-empty string", FORBIDDEN_UNICODE: "Address contains forbidden Unicode characters", MULTIPLE_AT_CHAR: "Address cannot contain more than one @ character", MISSING_AT_CHAR: "Address must contain one @ character", EMPTY_LOCAL: "Address local part cannot be empty", ADDRESS_TOO_LONG: "Address too long", LOCAL_TOO_LONG: "Address local part too long", EMPTY_LOCAL_SEGMENT: "Address local part contains empty dot-separated segment", INVALID_LOCAL_CHARS: "Address local part contains invalid character", DOMAIN_NON_EMPTY_STRING: "Domain must be a non-empty string", DOMAIN_TOO_LONG: "Domain too long", DOMAIN_INVALID_UNICODE_CHARS: "Domain contains forbidden Unicode characters", DOMAIN_INVALID_CHARS: "Domain contains invalid character", DOMAIN_INVALID_TLDS_CHARS: "Domain contains invalid tld character", DOMAIN_SEGMENTS_COUNT: "Domain lacks the minimum required number of segments", DOMAIN_SEGMENTS_COUNT_MAX: "Domain contains too many segments", DOMAIN_FORBIDDEN_TLDS: "Domain uses forbidden TLD", DOMAIN_EMPTY_SEGMENT: "Domain contains empty dot-separated segment", DOMAIN_LONG_SEGMENT: "Domain contains dot-separated segment that is too long" }, t3.code = function(e22) {
        return { code: e22, error: t3.codes[e22] };
      };
    }, 9959: (e21, t3, r2) => {
      const s2 = r2(375), n2 = r2(5752);
      t3.regex = function(e22 = {}) {
        s2(e22.cidr === void 0 || typeof e22.cidr == "string", "options.cidr must be a string");
        const t4 = e22.cidr ? e22.cidr.toLowerCase() : "optional";
        s2(["required", "optional", "forbidden"].includes(t4), "options.cidr must be one of required, optional, forbidden"), s2(e22.version === void 0 || typeof e22.version == "string" || Array.isArray(e22.version), "options.version must be a string or an array of string");
        let r3 = e22.version || ["ipv4", "ipv6", "ipvfuture"];
        Array.isArray(r3) || (r3 = [r3]), s2(r3.length >= 1, "options.version must have at least 1 version specified");
        for (let e23 = 0; e23 < r3.length; ++e23)
          s2(typeof r3[e23] == "string", "options.version must only contain strings"), r3[e23] = r3[e23].toLowerCase(), s2(["ipv4", "ipv6", "ipvfuture"].includes(r3[e23]), "options.version contains unknown version " + r3[e23] + " - must be one of ipv4, ipv6, ipvfuture");
        r3 = Array.from(new Set(r3));
        const a2 = r3.map((e23) => {
          if (t4 === "forbidden")
            return n2.ip[e23];
          const r4 = "\\/".concat(e23 === "ipv4" ? n2.ip.v4Cidr : n2.ip.v6Cidr);
          return t4 === "required" ? "".concat(n2.ip[e23]).concat(r4) : "".concat(n2.ip[e23], "(?:").concat(r4, ")?");
        }), o2 = "(?:".concat(a2.join("|"), ")"), i2 = new RegExp("^".concat(o2, "$"));
        return { cidr: t4, versions: r3, regex: i2, raw: o2 };
      };
    }, 5752: (e21, t3, r2) => {
      const s2 = r2(375), n2 = r2(6064), a2 = { generate: function() {
        const e22 = {}, t4 = "!\\$&'\\(\\)\\*\\+,;=", r3 = "\\w-\\.~%\\dA-Fa-f" + t4 + ":@", s3 = "[" + r3 + "]", n3 = "(?:0{0,2}\\d|0?[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";
        e22.ipv4address = "(?:" + n3 + "\\.){3}" + n3;
        const a3 = "[\\dA-Fa-f]{1,4}", o2 = "(?:" + a3 + ":" + a3 + "|" + e22.ipv4address + ")", i2 = "(?:" + a3 + ":){6}" + o2, l2 = "::(?:" + a3 + ":){5}" + o2, c2 = "(?:" + a3 + ")?::(?:" + a3 + ":){4}" + o2, u2 = "(?:(?:" + a3 + ":){0,1}" + a3 + ")?::(?:" + a3 + ":){3}" + o2, f2 = "(?:(?:" + a3 + ":){0,2}" + a3 + ")?::(?:" + a3 + ":){2}" + o2, m2 = "(?:(?:" + a3 + ":){0,3}" + a3 + ")?::" + a3 + ":" + o2, h2 = "(?:(?:" + a3 + ":){0,4}" + a3 + ")?::" + o2;
        e22.ipv4Cidr = "(?:\\d|[1-2]\\d|3[0-2])", e22.ipv6Cidr = "(?:0{0,2}\\d|0?[1-9]\\d|1[01]\\d|12[0-8])", e22.ipv6address = "(?:" + i2 + "|" + l2 + "|" + c2 + "|" + u2 + "|" + f2 + "|" + m2 + "|" + h2 + "|(?:(?:[\\dA-Fa-f]{1,4}:){0,5}[\\dA-Fa-f]{1,4})?::[\\dA-Fa-f]{1,4}|(?:(?:[\\dA-Fa-f]{1,4}:){0,6}[\\dA-Fa-f]{1,4})?::)", e22.ipvFuture = "v[\\dA-Fa-f]+\\.[\\w-\\.~" + t4 + ":]+", e22.scheme = "[a-zA-Z][a-zA-Z\\d+-\\.]*", e22.schemeRegex = new RegExp(e22.scheme);
        const d2 = "[\\w-\\.~%\\dA-Fa-f" + t4 + ":]*", p2 = "(?:\\[(?:" + e22.ipv6address + "|" + e22.ipvFuture + ")\\]|" + e22.ipv4address + "|[\\w-\\.~%\\dA-Fa-f!\\$&'\\(\\)\\*\\+,;=]{1,255})", g2 = "(?:" + d2 + "@)?" + p2 + "(?::\\d*)?", y2 = "(?:" + d2 + "@)?(" + p2 + ")(?::\\d*)?", b2 = s3 + "+", v2 = "(?:\\/[\\w-\\.~%\\dA-Fa-f!\\$&'\\(\\)\\*\\+,;=:@]*)*", _2 = "\\/(?:" + b2 + v2 + ")?", w2 = b2 + v2, $2 = "[\\w-\\.~%\\dA-Fa-f!\\$&'\\(\\)\\*\\+,;=@]+" + v2;
        return e22.hierPart = "(?:(?:\\/\\/" + g2 + v2 + ")|" + _2 + "|" + w2 + "|(?:\\/\\/\\/[\\w-\\.~%\\dA-Fa-f!\\$&'\\(\\)\\*\\+,;=:@]*(?:\\/[\\w-\\.~%\\dA-Fa-f!\\$&'\\(\\)\\*\\+,;=:@]*)*))", e22.hierPartCapture = "(?:(?:\\/\\/" + y2 + v2 + ")|" + _2 + "|" + w2 + ")", e22.relativeRef = "(?:(?:\\/\\/" + g2 + v2 + ")|" + _2 + "|" + $2 + "|)", e22.relativeRefCapture = "(?:(?:\\/\\/" + y2 + v2 + ")|" + _2 + "|" + $2 + "|)", e22.query = "[" + r3 + "\\/\\?]*(?=#|$)", e22.queryWithSquareBrackets = "[" + r3 + "\\[\\]\\/\\?]*(?=#|$)", e22.fragment = "[" + r3 + "\\/\\?]*", e22;
      } };
      a2.rfc3986 = a2.generate(), t3.ip = { v4Cidr: a2.rfc3986.ipv4Cidr, v6Cidr: a2.rfc3986.ipv6Cidr, ipv4: a2.rfc3986.ipv4address, ipv6: a2.rfc3986.ipv6address, ipvfuture: a2.rfc3986.ipvFuture }, a2.createRegex = function(e22) {
        const t4 = a2.rfc3986, r3 = "(?:\\?" + (e22.allowQuerySquareBrackets ? t4.queryWithSquareBrackets : t4.query) + ")?(?:#" + t4.fragment + ")?", o2 = e22.domain ? t4.relativeRefCapture : t4.relativeRef;
        if (e22.relativeOnly)
          return a2.wrap(o2 + r3);
        let i2 = "";
        if (e22.scheme) {
          s2(e22.scheme instanceof RegExp || typeof e22.scheme == "string" || Array.isArray(e22.scheme), "scheme must be a RegExp, String, or Array");
          const r4 = [].concat(e22.scheme);
          s2(r4.length >= 1, "scheme must have at least 1 scheme specified");
          const a3 = [];
          for (let e23 = 0; e23 < r4.length; ++e23) {
            const o3 = r4[e23];
            s2(o3 instanceof RegExp || typeof o3 == "string", "scheme at position " + e23 + " must be a RegExp or String"), o3 instanceof RegExp ? a3.push(o3.source.toString()) : (s2(t4.schemeRegex.test(o3), "scheme at position " + e23 + " must be a valid scheme"), a3.push(n2(o3)));
          }
          i2 = a3.join("|");
        }
        const l2 = "(?:" + (i2 ? "(?:" + i2 + ")" : t4.scheme) + ":" + (e22.domain ? t4.hierPartCapture : t4.hierPart) + ")", c2 = e22.allowRelative ? "(?:" + l2 + "|" + o2 + ")" : l2;
        return a2.wrap(c2 + r3, i2);
      }, a2.wrap = function(e22, t4) {
        return { raw: e22 = "(?=.)(?!https?:/$)".concat(e22), regex: new RegExp("^".concat(e22, "$")), scheme: t4 };
      }, a2.uriRegex = a2.createRegex({}), t3.regex = function(e22 = {}) {
        return e22.scheme || e22.allowRelative || e22.relativeOnly || e22.allowQuerySquareBrackets || e22.domain ? a2.createRegex(e22) : a2.uriRegex;
      };
    }, 1447: (e21, t3) => {
      const r2 = { operators: ["!", "^", "*", "/", "%", "+", "-", "<", "<=", ">", ">=", "==", "!=", "&&", "||", "??"], operatorCharacters: ["!", "^", "*", "/", "%", "+", "-", "<", "=", ">", "&", "|", "?"], operatorsOrder: [["^"], ["*", "/", "%"], ["+", "-"], ["<", "<=", ">", ">="], ["==", "!="], ["&&"], ["||", "??"]], operatorsPrefix: ["!", "n"], literals: { '"': '"', "`": "`", "'": "'", "[": "]" }, numberRx: /^(?:[0-9]*\.?[0-9]*){1}$/, tokenRx: /^[\w\$\#\.\@\:\{\}]+$/, symbol: Symbol("formula"), settings: Symbol("settings") };
      t3.Parser = class {
        constructor(e22, t4 = {}) {
          if (!t4[r2.settings] && t4.constants)
            for (const e23 in t4.constants) {
              const r3 = t4.constants[e23];
              if (r3 !== null && !["boolean", "number", "string"].includes(typeof r3))
                throw new Error("Formula constant ".concat(e23, " contains invalid ").concat(typeof r3, " value type"));
            }
          this.settings = t4[r2.settings] ? t4 : Object.assign({ [r2.settings]: true, constants: {}, functions: {} }, t4), this.single = null, this._parts = null, this._parse(e22);
        }
        _parse(e22) {
          let s2 = [], n2 = "", a2 = 0, o2 = false;
          const i2 = (e23) => {
            if (a2)
              throw new Error("Formula missing closing parenthesis");
            const i3 = s2.length ? s2[s2.length - 1] : null;
            if (o2 || n2 || e23) {
              if (i3 && i3.type === "reference" && e23 === ")")
                return i3.type = "function", i3.value = this._subFormula(n2, i3.value), void (n2 = "");
              if (e23 === ")") {
                const e24 = new t3.Parser(n2, this.settings);
                s2.push({ type: "segment", value: e24 });
              } else if (o2) {
                if (o2 === "]")
                  return s2.push({ type: "reference", value: n2 }), void (n2 = "");
                s2.push({ type: "literal", value: n2 });
              } else if (r2.operatorCharacters.includes(n2))
                i3 && i3.type === "operator" && r2.operators.includes(i3.value + n2) ? i3.value += n2 : s2.push({ type: "operator", value: n2 });
              else if (n2.match(r2.numberRx))
                s2.push({ type: "constant", value: parseFloat(n2) });
              else if (this.settings.constants[n2] !== void 0)
                s2.push({ type: "constant", value: this.settings.constants[n2] });
              else {
                if (!n2.match(r2.tokenRx))
                  throw new Error("Formula contains invalid token: ".concat(n2));
                s2.push({ type: "reference", value: n2 });
              }
              n2 = "";
            }
          };
          for (const t4 of e22)
            o2 ? t4 === o2 ? (i2(), o2 = false) : n2 += t4 : a2 ? t4 === "(" ? (n2 += t4, ++a2) : t4 === ")" ? (--a2, a2 ? n2 += t4 : i2(t4)) : n2 += t4 : t4 in r2.literals ? o2 = r2.literals[t4] : t4 === "(" ? (i2(), ++a2) : r2.operatorCharacters.includes(t4) ? (i2(), n2 = t4, i2()) : t4 !== " " ? n2 += t4 : i2();
          i2(), s2 = s2.map((e23, t4) => e23.type !== "operator" || e23.value !== "-" || t4 && s2[t4 - 1].type !== "operator" ? e23 : { type: "operator", value: "n" });
          let l2 = false;
          for (const e23 of s2) {
            if (e23.type === "operator") {
              if (r2.operatorsPrefix.includes(e23.value))
                continue;
              if (!l2)
                throw new Error("Formula contains an operator in invalid position");
              if (!r2.operators.includes(e23.value))
                throw new Error("Formula contains an unknown operator ".concat(e23.value));
            } else if (l2)
              throw new Error("Formula missing expected operator");
            l2 = !l2;
          }
          if (!l2)
            throw new Error("Formula contains invalid trailing operator");
          s2.length === 1 && ["reference", "literal", "constant"].includes(s2[0].type) && (this.single = { type: s2[0].type === "reference" ? "reference" : "value", value: s2[0].value }), this._parts = s2.map((e23) => {
            if (e23.type === "operator")
              return r2.operatorsPrefix.includes(e23.value) ? e23 : e23.value;
            if (e23.type !== "reference")
              return e23.value;
            if (this.settings.tokenRx && !this.settings.tokenRx.test(e23.value))
              throw new Error("Formula contains invalid reference ".concat(e23.value));
            return this.settings.reference ? this.settings.reference(e23.value) : r2.reference(e23.value);
          });
        }
        _subFormula(e22, s2) {
          const n2 = this.settings.functions[s2];
          if (typeof n2 != "function")
            throw new Error("Formula contains unknown function ".concat(s2));
          let a2 = [];
          if (e22) {
            let t4 = "", n3 = 0, o2 = false;
            const i2 = () => {
              if (!t4)
                throw new Error("Formula contains function ".concat(s2, " with invalid arguments ").concat(e22));
              a2.push(t4), t4 = "";
            };
            for (let s3 = 0; s3 < e22.length; ++s3) {
              const a3 = e22[s3];
              o2 ? (t4 += a3, a3 === o2 && (o2 = false)) : a3 in r2.literals && !n3 ? (t4 += a3, o2 = r2.literals[a3]) : a3 !== "," || n3 ? (t4 += a3, a3 === "(" ? ++n3 : a3 === ")" && --n3) : i2();
            }
            i2();
          }
          return a2 = a2.map((e23) => new t3.Parser(e23, this.settings)), function(e23) {
            const t4 = [];
            for (const r3 of a2)
              t4.push(r3.evaluate(e23));
            return n2.call(e23, ...t4);
          };
        }
        evaluate(e22) {
          const t4 = this._parts.slice();
          for (let s2 = t4.length - 2; s2 >= 0; --s2) {
            const n2 = t4[s2];
            if (n2 && n2.type === "operator") {
              const a2 = t4[s2 + 1];
              t4.splice(s2 + 1, 1);
              const o2 = r2.evaluate(a2, e22);
              t4[s2] = r2.single(n2.value, o2);
            }
          }
          return r2.operatorsOrder.forEach((s2) => {
            for (let n2 = 1; n2 < t4.length - 1; )
              if (s2.includes(t4[n2])) {
                const s3 = t4[n2], a2 = r2.evaluate(t4[n2 - 1], e22), o2 = r2.evaluate(t4[n2 + 1], e22);
                t4.splice(n2, 2);
                const i2 = r2.calculate(s3, a2, o2);
                t4[n2 - 1] = i2 === 0 ? 0 : i2;
              } else
                n2 += 2;
          }), r2.evaluate(t4[0], e22);
        }
      }, t3.Parser.prototype[r2.symbol] = true, r2.reference = function(e22) {
        return function(t4) {
          return t4 && t4[e22] !== void 0 ? t4[e22] : null;
        };
      }, r2.evaluate = function(e22, t4) {
        return e22 === null ? null : typeof e22 == "function" ? e22(t4) : e22[r2.symbol] ? e22.evaluate(t4) : e22;
      }, r2.single = function(e22, t4) {
        if (e22 === "!")
          return !t4;
        const r3 = -t4;
        return r3 === 0 ? 0 : r3;
      }, r2.calculate = function(e22, t4, s2) {
        if (e22 === "??")
          return r2.exists(t4) ? t4 : s2;
        if (typeof t4 == "string" || typeof s2 == "string") {
          if (e22 === "+")
            return (t4 = r2.exists(t4) ? t4 : "") + (r2.exists(s2) ? s2 : "");
        } else
          switch (e22) {
            case "^":
              return Math.pow(t4, s2);
            case "*":
              return t4 * s2;
            case "/":
              return t4 / s2;
            case "%":
              return t4 % s2;
            case "+":
              return t4 + s2;
            case "-":
              return t4 - s2;
          }
        switch (e22) {
          case "<":
            return t4 < s2;
          case "<=":
            return t4 <= s2;
          case ">":
            return t4 > s2;
          case ">=":
            return t4 >= s2;
          case "==":
            return t4 === s2;
          case "!=":
            return t4 !== s2;
          case "&&":
            return t4 && s2;
          case "||":
            return t4 || s2;
        }
        return null;
      }, r2.exists = function(e22) {
        return e22 != null;
      };
    }, 9926: () => {
    }, 5688: () => {
    }, 9708: () => {
    }, 1152: () => {
    }, 443: () => {
    }, 9848: () => {
    } }, t2 = {}, function r2(s2) {
      var n2 = t2[s2];
      if (n2 !== void 0)
        return n2.exports;
      var a2 = t2[s2] = { exports: {} };
      return e20[s2](a2, a2.exports, r2), a2.exports;
    }(5107);
    var e20, t2;
  });
})(joiBrowser_min);
var __joi = joiBrowser_min.exports;
function wrap($elm, $wrapper) {
  if (typeof $wrapper === "string") {
    $wrapper = document.createElement($wrapper);
  }
  const $parent = $elm.parentNode;
  const $sibling = $elm.nextSibling;
  if ($sibling) {
    $parent.insertBefore($wrapper, $sibling);
  } else {
    $parent.appendChild($wrapper);
  }
  return $wrapper.appendChild($elm);
}
function insertAfter(elm, refElm) {
  const nextSibling = refElm.nextSibling;
  if (!nextSibling) {
    refElm.parentNode.appendChild(elm);
  } else {
    refElm.parentNode.insertBefore(elm, nextSibling);
  }
  return elm;
}
var __css = ".s-form-validate.s-form-validate--error[s-form-validate-error-container] > *:first-child {\n            margin-bottom: 0 !important;\n        }\n    .s-form-validate .s-form-validate__error-message {\n        text-align: end;\n        color: hsla(calc(var(--s-theme-color-error-h, 0) + var(--s-theme-color-error-spin ,0)),calc((var(--s-theme-color-error-s, 0)) * 1%),calc((var(--s-theme-color-error-l, 0)) * 1%),var(--s-theme-color-error-a, 1));\n        overflow: hidden;\n        max-height: 0;\n        line-height: 1;\n        margin: 0;\n        -webkit-animation: 0.2s error-message-appear var(--s-theme-easing-default, 0) forwards;\n                animation: 0.2s error-message-appear var(--s-theme-easing-default, 0) forwards;\n    }\n    @-webkit-keyframes error-message-appear {\n        from {\n            line-height: 1;\n            max-height: 0;\n        }\n        to {\n            max-height: 2em;\n            line-height: 2;\n        }\n    }\n    @keyframes error-message-appear {\n        from {\n            line-height: 1;\n            max-height: 0;\n        }\n        to {\n            max-height: 2em;\n            line-height: 2;\n        }\n    }\n";
class SFormValidateFeature extends SFeature {
  constructor(name2, node, settings) {
    var _a2;
    Object.keys((_a2 = SComponent.getDefaultProps(name2)) === null || _a2 === void 0 ? void 0 : _a2.customValidations).forEach((validationName) => {
      if (SFormValidateFeatureInterface.definition[validationName])
        return;
      SFormValidateFeatureInterface.definition[validationName] = {
        type: "String|Boolean"
      };
    });
    super(name2, node, __deepMerge$7({
      componentUtils: {
        interface: SFormValidateFeatureInterface,
        style: __css
      }
    }, settings !== null && settings !== void 0 ? settings : {}));
    this._validationType = "string";
    this._isValidating = false;
    this.componentUtils.exposeApi({
      validate: this.validate
    }, this);
  }
  mount() {
    this._$field = this.node;
    const $insideField = this.node.querySelector("input,textarea,select");
    if ($insideField)
      this._$field = $insideField;
    if (this.props.type) {
      if (this.props.type === "text")
        this._validationType = "string";
      else
        this._validationType = this.props.type;
    }
    this.props.on.forEach((on2) => {
      var _a2, _b2;
      if (on2 === "enter") {
        this._$field.addEventListener("keyup", (e20) => {
          if (e20.keyCode !== 13)
            return;
          this.validate(e20);
        });
      } else if (on2 === "reset") {
        (_a2 = this._$field.form) === null || _a2 === void 0 ? void 0 : _a2.addEventListener(on2, (e20) => {
          setTimeout(() => {
            this.validate(e20);
          });
        });
      } else if (on2 === "submit") {
        (_b2 = this._$field.form) === null || _b2 === void 0 ? void 0 : _b2.addEventListener(on2, (e20) => {
          this.validate(e20);
        });
      } else {
        this.node.addEventListener(on2, (e20) => {
          this.validate(e20);
        });
      }
    });
    let schema = __joi[this._validationType]();
    let isCustom = false;
    Object.keys(this.props).forEach((prop) => {
      if (isCustom)
        return;
      if (this.props.customValidations[prop]) {
        isCustom = true;
        schema = schema.custom(this.props.customValidations[prop], prop);
      } else {
        const propValue = this.props[prop];
        if (propValue === true && typeof schema[prop] === "function") {
          let options = {};
          if (prop === "email" || prop === "domain") {
            options = {
              tlds: false
            };
          }
          schema = schema[prop](options);
        } else if (typeof schema[prop] === "function") {
          schema = schema[prop](autoCast$1(propValue));
        }
      }
    });
    this._schema = schema;
  }
  validate(event) {
    var _a2;
    if (((_a2 = event === null || event === void 0 ? void 0 : event.currentTarget) === null || _a2 === void 0 ? void 0 : _a2.tagName.toLowerCase()) === "form" && event.type !== "reset") {
      event.preventDefault();
    }
    if (this._isValidating)
      return;
    this._isValidating = true;
    setTimeout(() => {
      this._isValidating = false;
    });
    let resultObj;
    if (this._$field.type === "checkbox") {
      resultObj = this._validateCheckbox();
    } else if (this._$field.type === "range") {
      resultObj = this._validateRange();
    } else if (this._$field.tagName.toLowerCase() === "select") {
      resultObj = this._validateSelect();
    } else {
      resultObj = this._schema.validate(this._$field.value, __deepMerge$7({
        errors: {
          label: false,
          language: this.props.language
        }
      }, this.props.joiOptions));
    }
    if (event.type === "reset") {
      resultObj = {};
    }
    this._applyResult(resultObj, event);
  }
  _validateCheckbox() {
    const checkboxesValues = Array.from(this.node.querySelectorAll('input[type="checkbox"]:checked')).map(($item) => $item.value);
    let schema = __joi.array();
    if (this.props.min) {
      schema = schema.min(this.props.min);
    }
    if (this.props.max) {
      schema = schema.max(this.props.max);
    }
    return schema.validate(checkboxesValues, __deepMerge$7({
      errors: {
        label: false,
        language: this.props.language
      }
    }, this.props.joiOptions));
  }
  _validateRange() {
    const value = parseFloat(this._$field.value);
    let schema = __joi.number();
    if (this.props.min) {
      schema = schema.min(this.props.min);
    }
    if (this.props.max) {
      schema = schema.max(this.props.max);
    }
    return schema.validate(value, __deepMerge$7({
      errors: {
        label: false,
        language: this.props.language
      }
    }, this.props.joiOptions));
  }
  _validateSelect() {
    const selectedItems = Array.from(this._$field.querySelectorAll("option")).filter(($item) => $item.selected).map(($item) => $item.value);
    let schema = __joi.array();
    if (this.props.min) {
      schema = schema.min(this.props.min);
    }
    if (this.props.max) {
      schema = schema.max(this.props.max);
    }
    return schema.validate(selectedItems, __deepMerge$7({
      errors: {
        label: false,
        language: this.props.language
      }
    }, this.props.joiOptions));
  }
  _applyResult(res, event) {
    var _a2, _b2;
    if (res.error) {
      const marginBottom = getComputedStyle(this.node).marginBottom;
      let $container = ((_b2 = (_a2 = this.node.parentNode) === null || _a2 === void 0 ? void 0 : _a2.hasAttribute) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, "s-form-validate-error-container")) ? this.node.parentNode : void 0;
      if (!$container && this.props.wrap) {
        $container = document.createElement("div");
        $container.setAttribute("s-form-validate-error-container", "true");
        $container.classList.remove(...this.props.validClass.split(" "));
        $container.classList.add(...this.props.errorClass.split(" "));
        wrap(this.node, $container);
      }
      if (!this.props.wrap) {
        this.node.classList.add(...this.props.errorClass.split(" "));
      }
      this.node.classList.remove(...this.props.validClass.split(" "));
      if (this.props.displayError) {
        const alreadyExists = !!($container === null || $container === void 0 ? void 0 : $container.querySelector("p[s-form-validate-error-message]"));
        const $error = alreadyExists ? $container === null || $container === void 0 ? void 0 : $container.querySelector("p[s-form-validate-error-message]") : document.createElement("p");
        if (!alreadyExists) {
          $error.setAttribute("s-form-validate-error-message", "true");
          $error.setAttribute("class", this.props.errorMessageClass);
          $error.innerHTML = res.error.message;
          $error.style.marginBottom = marginBottom;
          if ($container) {
            $container.appendChild($error);
          } else {
            insertAfter($error, this.node);
          }
        } else {
          $error.innerHTML = res.error.message;
        }
      }
    } else if (!res.error) {
      if (event.type !== "reset") {
        this.node.classList.add(...this.props.validClass.split(" "));
      } else {
        this.node.classList.remove(...this.props.validClass.split(" "));
      }
      if (this.props.wrap) {
        const $container = this.node.parentNode;
        if (!$container.hasAttribute("s-form-validate-error-container"))
          return;
        insertAfter(this.node, $container);
        $container === null || $container === void 0 ? void 0 : $container.remove();
      } else {
        const $errorMessage = this.node.nextSibling;
        if ($errorMessage === null || $errorMessage === void 0 ? void 0 : $errorMessage.hasAttribute("s-form-validate-error-message")) {
          $errorMessage === null || $errorMessage === void 0 ? void 0 : $errorMessage.remove();
        }
      }
    }
  }
}
function define$1(props = {}, name2 = "s-form-validate") {
  SFeature.defineFeature(name2, SFormValidateFeature, props);
}
class SParallaxFeatureInterface extends SInterface {
  static get _definition() {
    return {
      amount: {
        description: "Specify the amount of parallax you want to apply",
        type: "Number",
        default: 1
      },
      amountX: {
        description: "Specify the amount of parallax you want for the x axis. This will be applied on top of the global amount",
        type: "Number",
        default: 1
      },
      amountY: {
        description: "Specify the amount of parallax you want for the y axis. This will be applied on top of the global amount",
        type: "Number",
        default: 1
      },
      amountTranslateX: {
        description: "Specify the amount of parallax you want for the translate x axis. This will be applied on top of the global amount",
        type: "Number",
        default: 1
      },
      amountTranslateY: {
        description: "Specify the amount of parallax you want for the translate y axis. This will be applied on top of the global amount",
        type: "Number",
        default: 1
      },
      amountRotateX: {
        description: "Specify the amount of parallax you want for the rotate x axis. This will be applied on top of the global amount",
        type: "Number",
        default: 1
      },
      amountRotateY: {
        description: "Specify the amount of parallax you want for the rotate y axis. This will be applied on top of the global amount",
        type: "Number",
        default: 1
      }
    };
  }
}
/*! @license Rematrix v0.7.2

	Copyright 2021 Julian Lloyd.

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
*/
function format(source3) {
  if (source3 && source3.constructor === Array) {
    var values = source3.filter(function(value) {
      return typeof value === "number";
    }).filter(function(value) {
      return !isNaN(value);
    });
    if (source3.length === 6 && values.length === 6) {
      var matrix = identity();
      matrix[0] = values[0];
      matrix[1] = values[1];
      matrix[4] = values[2];
      matrix[5] = values[3];
      matrix[12] = values[4];
      matrix[13] = values[5];
      return matrix;
    } else if (source3.length === 16 && values.length === 16) {
      return source3;
    }
  }
  throw new TypeError("Expected a `number[]` with length 6 or 16.");
}
function fromString(source3) {
  if (typeof source3 === "string") {
    var match5 = source3.match(/matrix(3d)?\(([^)]+)\)/);
    if (match5) {
      var raw = match5[2].split(",").map(parseFloat);
      return format(raw);
    }
    if (source3 === "none" || source3 === "") {
      return identity();
    }
  }
  throw new TypeError("Expected a string containing `matrix()` or `matrix3d()");
}
function identity() {
  var matrix = [];
  for (var i2 = 0; i2 < 16; i2++) {
    i2 % 5 == 0 ? matrix.push(1) : matrix.push(0);
  }
  return matrix;
}
function multiply(matrixA, matrixB) {
  var fma = format(matrixA);
  var fmb = format(matrixB);
  var product = [];
  for (var i2 = 0; i2 < 4; i2++) {
    var row = [fma[i2], fma[i2 + 4], fma[i2 + 8], fma[i2 + 12]];
    for (var j2 = 0; j2 < 4; j2++) {
      var k2 = j2 * 4;
      var col = [fmb[k2], fmb[k2 + 1], fmb[k2 + 2], fmb[k2 + 3]];
      var result = row[0] * col[0] + row[1] * col[1] + row[2] * col[2] + row[3] * col[3];
      product[i2 + k2] = result;
    }
  }
  return product;
}
function rotateX(angle) {
  var theta = Math.PI / 180 * angle;
  var matrix = identity();
  matrix[5] = matrix[10] = Math.cos(theta);
  matrix[6] = matrix[9] = Math.sin(theta);
  matrix[9] *= -1;
  return matrix;
}
function rotateY(angle) {
  var theta = Math.PI / 180 * angle;
  var matrix = identity();
  matrix[0] = matrix[10] = Math.cos(theta);
  matrix[2] = matrix[8] = Math.sin(theta);
  matrix[2] *= -1;
  return matrix;
}
function toString(source3) {
  return "matrix3d(" + format(source3).join(", ") + ")";
}
function translateX(distance) {
  var matrix = identity();
  matrix[12] = distance;
  return matrix;
}
function translateY(distance) {
  var matrix = identity();
  matrix[13] = distance;
  return matrix;
}
class SParallaxFeature extends SFeature {
  constructor(name2, node, settings) {
    super(name2, node, __deepMerge$7({
      componentUtils: {
        interface: SParallaxFeatureInterface
      },
      feature: {}
    }, settings !== null && settings !== void 0 ? settings : {}));
    const style = window.getComputedStyle(this.node);
    const transformStr = style.transform;
    this._originalTransform = transformStr;
  }
  mount() {
    document.addEventListener("mousemove", (e20) => {
      if (!this.componentUtils.isInViewport)
        return;
      const percentage = this._getPositionPercentages(e20);
      this._setLayerTransform(percentage);
    });
  }
  _setLayerTransform(percentage) {
    var _a2;
    const rotateY$1 = 90 / 100 * percentage.x;
    const rotateX$1 = 90 / 100 * percentage.y;
    const offsetX = 200 / 100 * percentage.x;
    const offsetY = 200 / 100 * percentage.y;
    const amount = (_a2 = this.props.amount) !== null && _a2 !== void 0 ? _a2 : "1";
    const matrix = fromString(this._originalTransform);
    const finalRotateY = rotateY$1 * parseFloat(amount) * parseFloat(this.props.amountY) * parseFloat(this.props.amountRotateY);
    const finalRotateX = rotateX$1 * parseFloat(amount) * parseFloat(this.props.amountX) * parseFloat(this.props.amountRotateX);
    const finalOffsetX = offsetX * parseFloat(amount) * parseFloat(this.props.amountX) * parseFloat(this.props.amountTranslateX);
    const finalOffsetY = offsetY * parseFloat(amount) * parseFloat(this.props.amountY) * parseFloat(this.props.amountTranslateY);
    const tx2 = translateX(finalOffsetX), ty2 = translateY(finalOffsetY), rx2 = rotateX(finalRotateX), ry2 = rotateY(finalRotateY);
    let newMatrix = [matrix, tx2, ty2, rx2, ry2].reduce(multiply);
    this.node.style.transform = toString(newMatrix);
  }
  _getPositionPercentages(e20) {
    var _a2, _b2, _c2, _d2;
    const viewportWidth = document.documentElement.clientWidth, viewportHeight = document.documentElement.clientHeight, halfViewportWidth = viewportWidth * 0.5, halfViewportHeight = viewportHeight * 0.5, positionX = (_b2 = (_a2 = e20.touches) === null || _a2 === void 0 ? void 0 : _a2[0].clientX) !== null && _b2 !== void 0 ? _b2 : e20.pageX, positionY = ((_d2 = (_c2 = e20.touches) === null || _c2 === void 0 ? void 0 : _c2[0].clientY) !== null && _d2 !== void 0 ? _d2 : e20.pageY) - document.documentElement.scrollTop, percentageX = 100 / halfViewportWidth * (positionX - halfViewportWidth), percentageY = 100 / halfViewportHeight * (positionY - halfViewportHeight);
    return {
      x: percentageX,
      y: percentageY
    };
  }
}
function define(props = {}, name2 = "s-parallax") {
  SFeature.defineFeature(name2, SParallaxFeature, props);
}
new SDuration();
(async () => {
  SLitComponent.setDefaultProps("*", {
    mountWhen: "inViewport"
  });
  SLitComponent.setDefaultProps(["s-side-panel", "ck-settings"], {
    mountWhen: "direct"
  });
  expandPleasantCssClassnamesLive();
  define$2();
  define$8();
  define$6();
  define$3();
  smoothScroll({
    scroll: {
      offset: 188
    }
  });
  linksStateAttributes();
  document.addEventListener("scroll", (e20) => {
    if (window.scrollY >= 10) {
      document.body.classList.add("scrolled");
    } else {
      document.body.classList.remove("scrolled");
    }
  });
  await wait$1(1500);
  console.log("LOADED", 2);
  define$5();
  define$4();
  define$d();
  define$c();
  define$a();
  define$b();
  define$9();
  await wait$1(1e3);
  console.log("LOADED", 3);
  define();
  define$1({
    customValidations: {
      coffeekraken: (value, helpers) => {
        if (value === "coffeekraken") {
          return helpers.message("Are you sure? Krakens are dangerous...");
        }
        return value;
      }
    }
  });
})();

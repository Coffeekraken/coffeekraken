{"version":3,"sources":["webpack:///../src/js/dom/closestNotVisible.js","webpack:///../src/js/dom/isVisible.js","webpack:///../src/js/dom/whenVisible.js"],"names":["closestNotVisible","elm","originalElm","parentNode","ownerDocument","isVisible","nodeName","toLowerCase","style","window","getComputedStyle","opacity","visibility","display","__isVisible","whenVisible","cb","Promise","resolve","reject","isSelfVisible","areParentsVisible","selfObserver","parentObserver","_cb","removeEventListener","_eventCb","e","setTimeout","target","disconnect","MutationObserver","mutations","forEach","mutation","attributeName","observe","attributes","addEventListener"],"mappings":"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","file":"whenVisible.index.js","sourcesContent":["import __isVisible from './isVisible';\n\n/**\n * @name        closestNotVisible\n * @namespace           js.dom\n * @type      Function\n *\n * Go up the dom three to find the first element that is not visible.\n * Not visible mean that has either an opacity to 0, a visibility to hidden or a display to none\n *\n * @param \t\t{HTMLElement} \t\t\t\t\telm  \t\tThe element to start on\n * @return \t\t{HTMLElement} \t\t\t\t\t\t\t\tThe element found or null\n *\n * @example  \tjs\n * import closestNotVisible from 'sugarcss/js/dom/closestNotVisible'\n * const closestElm = closestNotVisible(myCoolElement);\n * if (closestElm) {\n * \t\t// we have found en element that is not visible\n * }\n *\n * @author \t\tOlivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)\n */\nexport default function closestNotVisible(elm) {\n  const originalElm = elm;\n  elm = elm.parentNode;\n  while (elm && elm != originalElm.ownerDocument) {\n    if (!__isVisible(elm)) {\n      return elm;\n    }\n    elm = elm.parentNode;\n  }\n  return null;\n}\n","/**\n * @name      isVisible\n * @namespace           js.dom\n * @type      Function\n *\n * Check if the passed HTMLElement is visible or not.\n * Visible mean that it has not an opacity of 0, not a visibility of hidden and not a display of none\n *\n * @param \t\t{HTMLElement} \t\t\t\telm  \t\tThe element to check\n * @return \t\t{Boolean}\t\t\t\t\t\t\t\tIf the element is visible or not\n *\n * @example  \tjs\n * import isVisible from '@coffeekraken/sugar/js/dom/isVisible'\n * if (isVisible(myCoolHTMLElement) {\n * \t\t// i'm visible\n * }\n *\n * @author \t\tOlivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)\n */\nexport default function isVisible(elm) {\n  // assume that the script tag is always visible\n  if (elm.nodeName.toLowerCase() === 'script') return true;\n\n  // get style\n  const style = window.getComputedStyle(elm, null),\n    opacity = style['opacity'],\n    visibility = style['visibility'],\n    display = style['display'];\n  return '0' !== opacity && 'none' !== display && 'hidden' !== visibility;\n}\nwindow.__isVisible = isVisible;\n","import __isVisible from './isVisible';\nimport __closestNotVisible from './closestNotVisible';\n\n/**\n * @name      whenVisible\n * @namespace           js.dom\n * @type      Function\n *\n * Monitor an HTMLElement to be notified when it is visible\n *\n * @param \t\t{HTMLElement} \t\t\t\telm \t\tThe element to monitor\n * @param \t\t{Function} \t\t\t\t\t[cb=null] \tAn optional callback to call when the element is visible\n * @return \t\t(Promise) \t\t\t\t\t\t\t\tThe promise that will be resolved when the element is visible\n *\n * @example \tjs\n * import whenVisible from '@coffeekraken/sugar/js/dom/whenVisible'\n * whenVisible(myCoolHTMLElement).then((elm) => {\n * \t\t// do something with your element that is now visible\n * });\n *\n * @author \t\tOlivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)\n */\nexport default function whenVisible(elm, cb = null) {\n  return new Promise((resolve, reject) => {\n    // variables\n    let isSelfVisible = false,\n      areParentsVisible = false,\n      closestNotVisible = null,\n      selfObserver = null,\n      parentObserver = null;\n\n    const _cb = () => {\n      if (isSelfVisible && areParentsVisible) {\n        // process callbacks\n        if (cb) cb(elm);\n        resolve(elm);\n        // remove the event listeners\n        elm.removeEventListener('transitionend', _eventCb);\n        elm.removeEventListener('animationstart', _eventCb);\n        elm.removeEventListener('animationend', _eventCb);\n        // remove the event listeners\n        if (closestNotVisible) {\n          closestNotVisible.removeEventListener('transitionend', _eventCb);\n          closestNotVisible.removeEventListener('animationstart', _eventCb);\n          closestNotVisible.removeEventListener('animationend', _eventCb);\n        }\n      }\n    };\n\n    // function called on each transitionend, start, etc...\n    const _eventCb = (e) => {\n      // wait just a little time to check again\n      setTimeout(() => {\n        if (e.target === elm) {\n          if (__isVisible(elm)) {\n            isSelfVisible = true;\n            if (selfObserver && selfObserver.disconnect) {\n              selfObserver.disconnect();\n            }\n            // remove the event listeners\n            elm.removeEventListener('transitionend', _eventCb);\n            elm.removeEventListener('animationstart', _eventCb);\n            elm.removeEventListener('animationend', _eventCb);\n          }\n        } else if (e.target === closestNotVisible) {\n          if (__isVisible(closestNotVisible)) {\n            areParentsVisible = true;\n            if (parentObserver && parentObserver.disconnect) {\n              parentObserver.disconnect();\n            }\n            // remove the event listeners\n            closestNotVisible.removeEventListener('transitionend', _eventCb);\n            closestNotVisible.removeEventListener('animationstart', _eventCb);\n            closestNotVisible.removeEventListener('animationend', _eventCb);\n          }\n        }\n        // callback\n        _cb();\n      });\n    };\n\n    // check if element itself is not visible\n    if (!__isVisible(elm)) {\n      selfObserver = new MutationObserver((mutations) => {\n        mutations.forEach((mutation) => {\n          // check that is the style whos changed\n          if (\n            mutation.attributeName === 'style' ||\n            mutation.attributeName === 'class'\n          ) {\n            // check if is visible\n            if (__isVisible(mutation.target)) {\n              // update\n              isSelfVisible = true;\n              // callback\n              _cb();\n              // stop observe\n              selfObserver.disconnect();\n            }\n          }\n        });\n      });\n      selfObserver.observe(elm, { attributes: true });\n\n      // listen for animationstart to check if the element is visible\n      elm.addEventListener('animationstart', _eventCb);\n      elm.addEventListener('animationend', _eventCb);\n      elm.addEventListener('transitionend', _eventCb);\n    } else {\n      isSelfVisible = true;\n    }\n\n    // get the closest not visible element\n    // if found, we monitor it to check when it is visible\n    closestNotVisible = __closestNotVisible(elm);\n    if (closestNotVisible) {\n      parentObserver = new MutationObserver((mutations) => {\n        mutations.forEach((mutation) => {\n          // check that is the style whos changed\n          if (\n            mutation.attributeName === 'style' ||\n            mutation.attributeName === 'class'\n          ) {\n            // check if is visible\n            if (__isVisible(mutation.target)) {\n              // update\n              areParentsVisible = true;\n              // callback\n              _cb();\n              // stop observe\n              parentObserver.disconnect();\n            }\n          }\n        });\n      });\n      parentObserver.observe(closestNotVisible, { attributes: true });\n\n      // listen for animationstart to check if the element is visible\n      closestNotVisible.addEventListener('animationstart', _eventCb);\n      closestNotVisible.addEventListener('animationend', _eventCb);\n      closestNotVisible.addEventListener('transitionend', _eventCb);\n    } else {\n      areParentsVisible = true;\n    }\n\n    // callback\n    _cb();\n  });\n}\n"],"sourceRoot":""}
{"version":3,"sources":["exitCleanup.js"],"names":["__deepMerge","require","__getRegisteredProcessed","__clear","__fkill","__hotkey","__spawn","__parseHtml","__keypress","_exitCleanupRegistered","module","exports","exitCleanup","handler","settings","once","on","processes","processesCount","Object","keys","length","remainingProcessesCount","disableMouse","process","stdout","console","log","processKilled","pro","id","value","exit","forEach","key","processObj","hasAfterCommand","waitForClose","p","Promise","resolve","exitCode","pid"],"mappings":"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","sourcesContent":["const __deepMerge = require('../object/deepMerge');\nconst __getRegisteredProcessed = require('./getRegisteredProcesses');\nconst __clear = require('clear');\nconst __fkill = require('fkill');\nconst __hotkey = require('../keyboard/hotkey');\nconst __spawn = require('../process/spawn');\nconst __parseHtml = require('../terminal/parseHtml');\nconst __keypress = require('keypress');\n\n/**\n * @name              exitCleanup\n * @namespace           node.process\n * @type              Function\n *\n * This function register a handler on process exit and try to clean all the child process, etc...\n *\n * @param       {Function}       [handler=null]       A custom function to handle custom cleanup if you need. MUST return a promise that you have to resolve once the cleanup has been done\n * @param       {Object}        [settings={}]         An object of settings to configure your cleanup:\n * - childProcess (true) {Boolean}: Specify if you want to clean the child processes or not\n *\n * @example         js\n * const exitCleanup = require('@coffeekraken/sugar/node/process/exitCleanup');\n * exitCleanup();\n *\n * @since       2.0.0\n * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)\n */\nlet _exitCleanupRegistered = false;\nmodule.exports = function exitCleanup(handler = null, settings = {}) {\n  if (_exitCleanupRegistered) return;\n  _exitCleanupRegistered = true;\n  __hotkey('ctrl+c', {\n    once: true\n  }).on('press', async () => {\n    // check if all processes are closed\n    const processes = __getRegisteredProcessed();\n    const processesCount = Object.keys(processes).length;\n\n    let remainingProcessesCount = Object.keys(processes).length;\n\n    __keypress.disableMouse(process.stdout);\n\n    console.log(\n      __parseHtml(\n        '  Cleaning your system after <primary>Sugar</primary> execution...'\n      )\n    );\n\n    async function processKilled() {\n      remainingProcessesCount--;\n      if (remainingProcessesCount <= 0) {\n        console.log(__parseHtml('  Cleaning the forgotten process(es)...'));\n        const pro = __spawn('sugar util.kill all', {\n          id: 'cleanup'\n        })\n          .on('log,error', (value) => {\n            console.log(__parseHtml(`    - ${value.value}`));\n          })\n          .on('cancel,finally', () => {\n            console.log(\n              __parseHtml(\n                `  All of the <cyan>${processesCount}</cyan> process(es) have been <green>successfully</green> closed`\n              )\n            );\n            process.exit();\n          });\n      }\n    }\n\n    if (remainingProcessesCount > 0) {\n      Object.keys(processes).forEach(async (key) => {\n        const processObj = processes[key];\n        if (processObj.hasAfterCommand && processObj.hasAfterCommand()) {\n          function waitForClose() {\n            const p = new Promise((resolve) => {\n              processObj\n                .on('close', () => {\n                  resolve();\n                })\n                .on('log,error', (value) => {\n                  console.log(__parseHtml(`  ${value.value}`));\n                });\n            });\n            return p;\n          }\n          await waitForClose();\n          processKilled();\n        } else if (!processObj.exitCode && process.pid !== processObj.pid) {\n          console.log(\n            __parseHtml(\n              `  Killing the process with the PID <cyan>${processObj.pid}</cyan>`\n            )\n          );\n          await __fkill(processObj.pid);\n          processKilled();\n        } else {\n          processKilled();\n        }\n      });\n    } else {\n      console.log(__parseHtml('  Cleaning the forgotten process(es)...'));\n      await __spawn('sugar util.kill all')\n        .on('log,error', (value) => {\n          console.log(__parseHtml(`    - ${value.value}`));\n        })\n        .on('cancel,finally', () => {\n          console.log(\n            __parseHtml(\n              `  All of the <cyan>${processesCount}</cyan> process(es) have been <green>successfully</green> closed`\n            )\n          );\n          process.exit();\n        });\n    }\n  });\n};\n"]}
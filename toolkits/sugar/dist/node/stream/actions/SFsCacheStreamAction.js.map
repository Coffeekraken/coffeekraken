{"version":3,"sources":["SFsCacheStreamAction.js"],"names":["__SActionsStreamAction","require","__packageRoot","__fs","__ensureDirSync","__deepMerge","__md5","__writeJsonSync","module","exports","settings","id","idProperty","streamObj","_settings","resolve","reject","trigger","cancel","cacheDir","encrypt","outputFilesExists","outputStack","Object","keys","forEach","key","path","existsSync","cacheFilePath","generateCache","Promise","_sugarVersion","__dirname","version","registerCallback","inputStats","statSync","input","cacheStats","mtimeMs","cacheJson","value","skipNextActions","type","required","default"],"mappings":"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","sourcesContent":["const __SActionsStreamAction = require('../SActionsStreamAction');\nconst __packageRoot = require('../../path/packageRoot');\nconst __fs = require('fs');\nconst __ensureDirSync = require('../../fs/ensureDirSync');\nconst __deepMerge = require('../../object/deepMerge');\nconst __md5 = require('../../crypt/md5');\nconst __writeJsonSync = require('../../fs/writeJsonSync');\n\n/**\n * @name            SFsCacheStreamAction\n * @namespace           node.stream.actions\n * @type            Class\n * @extends         SActionsStreamAction\n *\n * This action allows you to make profit of the filesystem cache.\n * You can specify which streamObj property will be the cache id as well as\n * in which condition you want to bypass the cached value.\n * By default the cached value will be regenerated if the \"input\" property is a file and that this file has been saved after the cached value.\n *\n * @param       {Object}Â        streamObj          The streamObj object with the properties described bellow:\n * @return      {Promise}                         A simple promise that will be resolved when the process is finished\n *\n * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)\n */\nmodule.exports = class SFsCacheStreamAction extends __SActionsStreamAction {\n  /**\n   * @name            definitionObj\n   * @type             Object\n   * @static\n   *\n   * Store the definition object that specify the streamObj required properties, types, etc...\n   *\n   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)\n   */\n  static definitionObj = {\n    input: {\n      type: 'String',\n      required: true\n    },\n    cacheDir: {\n      type: 'String',\n      required: true,\n      default: `${__packageRoot()}/.cache/SFsCacheStreamAction`\n    }\n  };\n\n  /**\n   * @name            constructor\n   * @type            Function\n   * @constructor\n   *\n   * Constructor\n   *\n   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)\n   */\n  constructor(settings = {}) {\n    super(\n      __deepMerge(\n        {\n          id: 'actionStream.action.fs.cache',\n          idProperty: 'input'\n        },\n        settings\n      )\n    );\n  }\n\n  /**\n   * @name          run\n   * @type          Function\n   * @async\n   *\n   * Override the base class run method\n   *\n   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)\n   */\n  run(streamObj, settings = this._settings) {\n    return super.run(streamObj, async (resolve, reject, trigger, cancel) => {\n      // make sure we have the cache directory\n      __ensureDirSync(streamObj.cacheDir);\n\n      // generate the id\n      const id = `${this._settings.id}-${__md5.encrypt(\n        streamObj[settings.idProperty]\n      )}`;\n\n      // check if the output files exists or not\n      let outputFilesExists = true;\n      if (streamObj.outputStack) {\n        Object.keys(streamObj.outputStack).forEach((key) => {\n          const path = streamObj.outputStack[key];\n          if (!__fs.existsSync(path)) {\n            outputFilesExists = false;\n          }\n        });\n      }\n\n      // cache file path\n      const cacheFilePath = `${streamObj.cacheDir}/${id}.json`;\n\n      // generate cache function\n      function generateCache(streamObj) {\n        return new Promise((resolve, reject) => {\n          __writeJsonSync(cacheFilePath, {\n            streamObj,\n            _sugarVersion: require(`${__packageRoot(__dirname)}/package.json`)\n              .version\n          });\n          resolve(streamObj);\n        });\n      }\n\n      // check if the cache file exists\n      // or if the output files does not exists\n      if (!__fs.existsSync(cacheFilePath) || !outputFilesExists) {\n        this.registerCallback(generateCache, 'after');\n        return resolve(streamObj);\n      }\n\n      // get the timestamp of each files\n      const inputStats = __fs.statSync(streamObj.input);\n      const cacheStats = __fs.statSync(cacheFilePath);\n\n      // check if the input file is newer that the cache one\n      if (inputStats.mtimeMs > cacheStats.mtimeMs) {\n        this.registerCallback(generateCache, 'after');\n      } else {\n        // load the cache file\n        const cacheJson = require(cacheFilePath);\n        // restore the streamObject\n        streamObj = cacheJson.streamObj;\n        // specify to the ActionStream that we need to skip all the next actions\n        trigger('log', {\n          value: `Skipping the next actions cause the data have been <primary>laoded from the cache</primary>...`\n        });\n        this.skipNextActions();\n      }\n\n      resolve(streamObj);\n    });\n  }\n};\n"]}
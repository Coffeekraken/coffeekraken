{"version":3,"sources":["SFsCacheStreamAction.js"],"names":["__SActionsStreamAction","require","__packageRoot","__fs","__ensureDirSync","__deepMerge","__md5","__writeJsonSync","module","exports","settings","id","idProperty","streamObj","_settings","resolve","reject","trigger","cancel","cacheDir","encrypt","outputFilesExists","outputStack","Object","keys","forEach","key","path","existsSync","cacheFilePath","generateCache","Promise","_sugarVersion","__dirname","version","registerCallback","inputStats","statSync","input","cacheStats","mtimeMs","cacheJson","value","skipNextActions","type","required","default"],"mappings":"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","sourcesContent":["const __SActionsStreamAction = require('../SActionsStreamAction');\nconst __packageRoot = require('../../path/packageRoot');\nconst __fs = require('fs');\nconst __ensureDirSync = require('../../fs/ensureDirSync');\nconst __deepMerge = require('../../object/deepMerge');\nconst __md5 = require('../../crypt/md5');\nconst __writeJsonSync = require('../../fs/writeJsonSync');\n\n/**\n * @name            SFsCacheStreamAction\n * @namespace           node.stream.actions\n * @type            Class\n * @extends         SActionsStreamAction\n *\n * This action allows you to make profit of the filesystem cache.\n * You can specify which streamObj property will be the cache id as well as\n * in which condition you want to bypass the cached value.\n * By default the cached value will be regenerated if the \"input\" property is a file and that this file has been saved after the cached value.\n *\n * @param       {Object}Â        streamObj          The streamObj object with the properties described bellow:\n * @return      {Promise}                         A simple promise that will be resolved when the process is finished\n *\n * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)\n */\nmodule.exports = class SFsCacheStreamAction extends __SActionsStreamAction {\n  /**\n   * @name            definitionObj\n   * @type             Object\n   * @static\n   *\n   * Store the definition object that specify the streamObj required properties, types, etc...\n   *\n   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)\n   */\n  static definitionObj = {\n    input: {\n      type: 'String',\n      required: true\n    },\n    cacheDir: {\n      type: 'String',\n      required: true,\n      default: `${__packageRoot()}/.cache/SFsCacheStreamAction`\n    }\n  };\n\n  /**\n   * @name            constructor\n   * @type            Function\n   * @constructor\n   *\n   * Constructor\n   *\n   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)\n   */\n  constructor(settings = {}) {\n    super(\n      __deepMerge(\n        {\n          id: 'actionStream.action.fs.cache',\n          idProperty: 'input'\n        },\n        settings\n      )\n    );\n  }\n\n  /**\n   * @name          run\n   * @type          Function\n   * @async\n   *\n   * Override the base class run method\n   *\n   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)\n   */\n  run(streamObj, settings = this._settings) {\n    return super.run(streamObj, async (resolve, reject, trigger, cancel) => {\n      // make sure we have the cache directory\n      __ensureDirSync(streamObj.cacheDir);\n\n      // generate the id\n      const id = `${this._settings.id}-${__md5.encrypt(\n        streamObj[settings.idProperty]\n      )}`;\n\n      // check if the output files exists or not\n      let outputFilesExists = true;\n      if (streamObj.outputStack) {\n        Object.keys(streamObj.outputStack).forEach((key) => {\n          const path = streamObj.outputStack[key];\n          if (!__fs.existsSync(path)) {\n            outputFilesExists = false;\n          }\n        });\n      }\n\n      // cache file path\n      const cacheFilePath = `${streamObj.cacheDir}/${id}.json`;\n\n      // generate cache function\n      function generateCache(streamObj) {\n        return new Promise((resolve, reject) => {\n          __writeJsonSync(cacheFilePath, {\n            streamObj,\n            _sugarVersion: require(`${__packageRoot(__dirname)}/package.json`)\n              .version\n          });\n          resolve(streamObj);\n        });\n      }\n\n      // check if the cache file exists\n      // or if the output files does not exists\n      if (!__fs.existsSync(cacheFilePath) || !outputFilesExists) {\n        this.registerCallback(generateCache, 'after');\n        return resolve(streamObj);\n      }\n\n      // get the timestamp of each files\n      const inputStats = __fs.statSync(streamObj.input);\n      const cacheStats = __fs.statSync(cacheFilePath);\n\n      // check if the input file is newer that the cache one\n      if (inputStats.mtimeMs > cacheStats.mtimeMs) {\n        this.registerCallback(generateCache, 'after');\n      } else {\n        // load the cache file\n        const cacheJson = require(cacheFilePath);\n        // restore the streamObject\n        streamObj = cacheJson.streamObj;\n        // specify to the ActionStream that we need to skip all the next actions\n        trigger('log', {\n          value: `Skipping the next actions cause the data have been <primary>laoded from the cache</primary>...`\n        });\n        this.skipNextActions();\n      }\n\n      resolve(streamObj);\n    });\n  }\n};\n"]}
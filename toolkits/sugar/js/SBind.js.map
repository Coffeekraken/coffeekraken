{
    "version": 3,
    "sources": [
        "SBind.js"
    ],
    "names": [
        "SBind",
        "attr2obj",
        "obj2attr",
        "Map",
        "_watcher",
        "SWatch",
        "source",
        "sourcePath",
        "target",
        "targetPath",
        "hasOwnProperty"
    ],
    "mappings": ";;;;;;;AAqBA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;;;;;;;;;;;IAEqBA,K;AACnB;;;;;;;;;;AAcA;;;;;;;;;;;AAYA;;;;;;;;;;;;AAaA;;;AAGA,mBAAc;AAAA;;AAAA,wCAjCD;AACXC,MAAAA,QAAQ,EAAE,EADC;AAEXC,MAAAA,QAAQ,EAAE;AAFC,KAiCC;;AAAA,4DAlBmB,EAkBnB;;AAAA,8CALK,IAAIC,GAAJ,EAKL;;AACZ;AACA,SAAKC,QAAL,GAAgB,IAAIC,eAAJ,EAAhB;AACD;AAED;;;;;;;;;;;;;;;;;;;yBAeKC,M,EAAQC,U,EAAYC,M,EAAQC,U,EAAY;AAC3C;AACA,UAAI,OAAOH,MAAP,KAAkB,QAAlB,IAA8B,CAACA,MAAM,CAACI,cAAP,CAAsB,WAAtB,CAAnC,EAAuE;AACrEJ,QAAAA,MAAM,GAAG,IAAID,eAAJ,CAAWC,MAAX,CAAT;AACD;AACF,K,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
    "sourcesContent": [
        "/**\n * @name \t\tSBind\n * @namespace           sugar.js.class\n * @type    Class\n *\n * This class allows to bind properties between objects, object to HTMLElement attribute and vice versa.\n *\n * @example\t\tjs\n * const binder = new SBind();\n *\n * // keep in sync the myObject2.title with the myObject1.title property\n * binder.bindObjectPath2ObjectPath(myObject1, 'title', myObject2, 'title');\n *\n * // update and HTMLElement attribute when the myObject1.title is updated\n * binder.bindObjectPath2ElementAttribute(myObject1, 'title', myHTMLElement, 'title');\n *\n * // and more...\n *\n * @author\t\tOlivier Bossel<olivier.bossel@gmail.com>\n */\n\nimport SWatch from '../object/SWatch';\nimport __camelize from '../string/camelize';\nimport __uncamelize from '../string/uncamelize';\nimport __autoCast from '../string/autoCast';\nimport __uniqid from '../util/uniqid';\nimport __set from '../object/set';\nimport __dispatchEvent from '../dom/dispatchEvent';\n\nexport default class SBind {\n  /**\n   * @name              _bindStack\n   * @type              Object\n   * @private\n   *\n   * Store all the bind objects settings\n   *\n   * @author\t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  _bindStack = {\n    attr2obj: {},\n    obj2attr: {}\n  };\n\n  /**\n   * @name                _mutationObservedElementsStack\n   * @type                Array\n   * @private\n   *\n   * Store all the mutation observers that are used to\n   * be notified when attributes are updated\n   *\n   * @author\t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  _mutationObservedElementsStack = [];\n\n  /**\n   * @name                _digestsMutation\n   * @type                Map\n   * @private\n   *\n   * Store for each binded HTMLElement if each binded attributes are\n   * in digest phase to avoid multiple assignement of the same attribute\n   * in each digest phase\n   *\n   * @author\t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  _digestsMutation = new Map();\n\n  /**\n   * @constructor\n   */\n  constructor() {\n    // init new watcher\n    this._watcher = new SWatch();\n  }\n\n  /**\n   * @name                  bind\n   * @type                  Function\n   *\n   * This method allows you to bind an Object|HTMLElement property to another Object|HTMLElement property\n   * This mean that when the property of the first passed element is updated, the same property on the second\n   * element will be updated as well\n   *\n   * @param       {Object|HTMLElement}        source            The source object\n   * @param       {String}                    sourcePath        The source path to the property that you want to bind\n   * @param       {Object|HTMLElement}        target            The target object\n   * @param       {String}                    [targetPath=sourcePath]        The target path to the property that you want to be sync with the source element\n   *\n   * @author\t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  bind(source, sourcePath, target, targetPath) {\n    // check if the source object is already a watched one\n    if (typeof source === 'object' && !source.hasOwnProperty('__$SWatch')) {\n      source = new SWatch(source);\n    }\n  }\n\n  // /**\n  //  * Bind object path 2 object path\n  //  * @param \t\t{Object} \tobject1 \tThe source object that will be watched\n  //  * @param \t\t{String} \tpath1 \t\tThe property path on the source object to watch\n  //  * @param \t\t{Object} \tobject2 \tThe destination object that will be updated\n  //  * @param \t\t{String} \tpath2 \t\tThe property path on the destination object to update\n  //  * @return \t\t{SBind} \t\t\t\tThe binder instance to allow chainability\n  //  */\n  // bindObjectPath2ObjectPath(object1, path1, object2, path2) {\n  //   // watch the path to update the attribute accordingly\n  //   this._watcher.watch(object1, path1, (newVal, oldVal) => {\n  //     // do nothing is no\n  //     if (newVal === oldVal) return;\n\n  //     // set the new value\n  //     __set(object2, path2, newVal);\n  //   });\n  //   return this;\n  // }\n\n  // /**\n  //  * Bind element attribute to object path\n  //  * @param \t\t{HTMLElement} \telm \t\tThe source html element that will be watched\n  //  * @param \t\t{String} \t\tattribute  \tThe attribute name to watch on the element\n  //  * @param \t\t{Object} \t\tobject \t\tThe destination object that will be updated\n  //  * @param \t\t{String} \t\tpath \t\tThe property path on the destination object to update\n  //  * @return \t\t{SBind} \t\t\t\t\tThe binder instance to allow chainability\n  //  */\n  // bindElementAttribute2ObjectPath(elm, attribute, object, path) {\n  //   // generate an bindId in the object if not already exist\n  //   if (!object._binderId) object._binderId = `s-binder-${__uniqid()}`;\n\n  //   // observe the element\n  //   this._observeDomElement(elm);\n\n  //   // attr2obj\n  //   if (!this._bindStack.attr2obj[attribute])\n  //     this._bindStack.attr2obj[attribute] = {};\n  //   if (!this._bindStack.attr2obj[attribute][`${object._binderId}:${path}`]) {\n  //     this._bindStack.attr2obj[attribute][`${object._binderId}:${path}`] = {\n  //       object: object,\n  //       path: path\n  //     };\n  //   }\n  //   return this;\n  // }\n\n  // /**\n  //  * Bind object path to element attribute\n  //  * @param \t\t{Object} \t\tobject \t\tThe source object that will be watched\n  //  * @param \t\t{String} \t\tpath \t\tThe property path on the source object to watch\n  //  * @param \t\t{HTMLElement}\telm \t\tThe HTMLElement that will be updated\n  //  * @param \t\t{String} \t\tattribute \tThe attribute to update on the element\n  //  * @return \t\t{SBind} \t\t\t\t\tThe binder instance to allow chainability\n  //  */\n  // bindObjectPath2ElementAttribute(object, path, elm, attribute) {\n  //   // generate an bindId in the object if not already exist\n  //   if (!object._binderId) object._binderId = `s-binder-${__uniqid()}`;\n\n  //   // obj2attr\n  //   if (!this._bindStack.obj2attr[`${object._binderId}:${path}`])\n  //     this._bindStack.obj2attr[`${object._binderId}:${path}`] = {};\n  //   if (!this._bindStack.obj2attr[`${object._binderId}:${path}`][attribute]) {\n  //     this._bindStack.obj2attr[`${object._binderId}:${path}`][attribute] = {\n  //       elm: elm,\n  //       attribute: attribute\n  //     };\n  //   }\n\n  //   // watch the path to update the attribute accordingly\n  //   this._watcher.watch(object, path, (newVal, oldVal) => {\n  //     // get the digest attribute stack from the element\n  //     let digest = this._digestsMutation.get(elm);\n\n  //     if (digest && digest[attribute]) return;\n  //     if (newVal === oldVal) return;\n\n  //     // loop on all attributes to update\n  //     for (const attribute in this._bindStack.obj2attr[\n  //       `${object._binderId}:${path}`\n  //     ]) {\n  //       const watch = this._bindStack.obj2attr[`${object._binderId}:${path}`][\n  //         attribute\n  //       ];\n\n  //       // prevent from multiple same attribute assignement in the same digest process\n  //       if (digest && digest[watch.attribute]) continue;\n  //       if (!digest) digest = {};\n  //       digest[watch.attribute] = true;\n  //       this._digestsMutation.set(elm, digest);\n\n  //       // update the attribute\n  //       watch.elm.setAttribute(__uncamelize(watch.attribute), newVal);\n\n  //       // if the attribute is the value, trigger a change event\n  //       // if (__uncamelize(watch.attribute) === 'value') {\n  //       // \telm.value = newVal;\n  //       // \t__dispatchEvent(watch.elm, 'change');\n  //       // }\n  //     }\n  //   });\n  //   return this;\n  // }\n\n  // /**\n  //  * Destroy the binder\n  //  */\n  // destroy() {\n  //   // @TODO binder destroy implementation\n  // }\n\n  // /**\n  //  * Observe DOM element\n  //  * @param \t\t{HTMLElement} \telm \tThe element to watch\n  //  */\n  // _observeDomElement(elm) {\n  //   // check if already observe the element\n  //   if (this._mutationObservedElementsStack.indexOf(elm) !== -1) return;\n  //   this._mutationObservedElementsStack.push(elm);\n\n  //   // check attributes changes to update settings\n  //   let observer = new MutationObserver(mutations => {\n  //     // loop on mutations\n  //     mutations.forEach(mutation => {\n  //       // update the attr property\n  //       let val = __autoCast(elm.getAttribute(mutation.attributeName));\n\n  //       // make a new attribute\n  //       let camelName = __camelize(mutation.attributeName);\n\n  //       // set that we are digesting this attribute on this element\n  //       let digest = this._digestsMutation.get(elm);\n  //       if (!digest) digest = {};\n  //       digest[mutation.attributeName] = true;\n  //       this._digestsMutation.set(elm, digest);\n\n  //       // set all the objects values bound to this attribute\n  //       if (this._bindStack.attr2obj[mutation.attributeName]) {\n  //         // loop on each objects to update\n  //         for (const objectPath in this._bindStack.attr2obj[\n  //           mutation.attributeName\n  //         ]) {\n  //           const watch = this._bindStack.attr2obj[mutation.attributeName][\n  //             objectPath\n  //           ];\n\n  //           // update the value\n  //           __set(watch.object, watch.path, val);\n  //         }\n  //       }\n  //     });\n  //     // restore the mutate state in the next loop\n  //     setTimeout(() => {\n  //       this._digestsMutation = new Map();\n  //     });\n  //   });\n  //   // observe the node itself\n  //   observer.observe(elm, {\n  //     childList: false,\n  //     attributes: true,\n  //     characterData: true,\n  //     subtree: false,\n  //     attributeOldValue: true,\n  //     characterDataOldValue: true\n  //   });\n  // }\n}\n"
    ]
}
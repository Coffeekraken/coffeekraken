{
    "version": 3,
    "sources": [
        "SPromise.js"
    ],
    "names": [
        "SPromise",
        "sourceSPromise",
        "destSPromise",
        "settings",
        "stacks",
        "processor",
        "filter",
        "on",
        "value",
        "metas",
        "res",
        "Array",
        "isArray",
        "length",
        "stack",
        "includes",
        "console",
        "log",
        "trigger",
        "level",
        "executorFnOrSettings",
        "_masterPromiseRejectFn",
        "_masterPromiseResolveFn",
        "_resolve",
        "args",
        "setTimeout",
        "resolve",
        "_reject",
        "reject",
        "_trigger",
        "_cancel",
        "cancel",
        "Promise",
        "rejectPromiseResolve",
        "rejectPromiseReject",
        "catch",
        "e",
        "_settings",
        "triggerOnCatch",
        "executor",
        "Object",
        "defineProperty",
        "writable",
        "configurable",
        "enumerable",
        "then",
        "finally",
        "destroyTimeout",
        "id",
        "_destroy",
        "status",
        "statusArray",
        "split",
        "map",
        "l",
        "trim",
        "indexOf",
        "_promiseState",
        "dest",
        "pipe",
        "arg",
        "stacksOrder",
        "_isDestroyed",
        "stacksResult",
        "_triggerStacks",
        "what",
        "s",
        "forEach",
        "_stacks",
        "Error",
        "_registerNewStacks",
        "callback",
        "callNumber",
        "push",
        "called",
        "initialValue",
        "currentCallbackReturnedValue",
        "keys",
        "stackArray",
        "stackName",
        "toAvoid",
        "item",
        "metasObj",
        "state",
        "time",
        "Date",
        "now",
        "i",
        "callbackResult",
        "undefined",
        "currentStackResult",
        "stackResult",
        "_triggerStack",
        "name",
        "splitedName",
        "parseInt",
        "_registerCallbackInStack"
    ],
    "mappings": "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",
    "sourcesContent": [
        "import __minimatch from 'minimatch';\nimport __deepMerge from '../object/deepMerge';\nimport __uniqid from '../string/uniqid';\nimport __wait from '../time/wait';\nimport __toString from '../string/toString';\nimport __env from '../core/env';\n\n// var originalCatch = Promise.prototype.catch;\n// Promise.prototype.catch = function () {\n//   console.log('PLOP');\n//   return originalCatch.apply(this, arguments);\n// };\n\n/**\n * @name                  SPromise\n * @namespace           sugar.js.promise\n * @type                  Class\n *\n * This class works the same as the default Promise one. The difference is that you have more control on this one like\n * the possibility to resolve it multiple times. Here's a list of the \"differences\" and the \"features\" that this class provide:\n *\n * - Pass the normal \"resolve\" and \"reject\" function to the passed executor\n * - Pass a new function to the passed executor called \"trigger\" that let you launch your registered callbacks like \"then\", \"catch\", etc... but without resolving the master promise. Here's some examples:\n *    - new SPromise((resolve, reject, trigger, cancel) => { trigger('then', 'myCoolValue'); }).then(value => { ... });\n *    - new SPromise((resolve, reject, trigger, cancel) => { trigger('then,catch', 'myCoolValue') }).then(value => { ... });\n * - Pass a new function to the passed executor called \"cancel\" that let you stop/cancel the promise execution without triggering your registered callbacks unless the \"cancel\" once...\n * - Expose the normal \"then\" and \"catch\" methods to register your callbacks\n * - Expose some new callbacks registration functions described here:\n *    - Expose a method called \"resolved\" that let you register callbacks called only when the \"resolve\" function has been called\n *    - Expose a method called \"rejected\" that let you register callbacks called only when the \"reject\" function has been called\n *    - Expose a method called \"finally\" that let you register callbacks called when the \"resolve\" or \"reject\" function has been called\n *    - Expose a method called \"canceled\" that let you register callbacks called only when the \"cancel\" function has been called\n * - Every callbacks registration methods accept as first argument the number of time that your callback will be called at max. Here's some examples:\n *    - new SPromise((...)).then(value => { // do something... }).catch(error => { // do something... });\n *    - new SPromise((...)).then(1, value => { // do something... }).catch(3, error => { // do something... });\n * - Expose a method called \"on\" that can be used to register callbacks the same as the \"then\", \"catch\", etc... methods but you can register a same callback function to multiple callbacks type at once:\n *    - new SPromise((...)).on('then', value => { ... }).on('then,catch', value => { ... });\n *    - Specify the max number of time to call your callback function like so: new SPromise((...)).on('then:2', value => { ... }).on('then:1,catch', value => { ... });\n * - A new method called \"start\" is exposed. This method is useful when you absolutely need that your executor function is launched right after the callbacks registrations.\n *    - If you don't call the \"start\" method, the executor function passed to the SPromise constructor will be called on the next javascript execution loop\n * - Support the Promises chaining through the callbacks like to:\n *    ```js\n *      const result = await new SPromise((resolve, reject, trigger, cancel) => {\n *        resolve('hello');\n *      }).then(value => {\n *        return new Promise((resolve) => {\n *          setTimeout(() => {\n *            resolve(value + 'World');\n *          }, 1000);\n *        });\n *      }).then(value => {\n *        return value + 'Promise';\n *      });\n *      console.log(result); // => helloWorldPromise\n *    ```\n *\n * @example         js\n * import SPromise from '@coffeekraken/sugar/js/promise/SPromise';\n * function myCoolFunction() {\n *    return new SPromise((resolve, reject, trigger, cancel) => {\n *        // do something...\n *        setInterval(() => {\n *            // resolve the promise\n *            resolve('something'); *\n *        }, 1000);\n *    });\n * }\n *\n * // calling the function and get back the SPromise instance\n * myCoolFunction().then(value => {\n *    // do something here...\n * }).then(1, value => {\n *    // do something just once...\n * }).catch(error => {\n *    // do something with the returned reason of failure...\n * });\n *\n * @author \t\tOlivier Bossel<olivier.bossel@gmail.com>\n */\nexport default class SPromise extends Promise {\n  /**\n   * @name                  _settings\n   * @type                  Object\n   * @private\n   *\n   * Store the settings of this SPromise instance. Here's the available settings:\n   * - stacks (null) {Array|String}: An array or comma separated string of additional stacks you want for this instance\n   *\n   * @author \t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  _settings = {};\n\n  /**\n   * @name                  _promiseState\n   * @type                  String\n   * @private\n   *\n   * Store the promise status. Can be:\n   * - pending: When the promise is waiting for resolution or rejection\n   * - resolved: When the promise has been resolved\n   * - rejected: When the promise has been rejected\n   * - canceled: When the promise has been canceled\n   * - destroyed: When the promise has been destroyed\n   *\n   * @author \t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  _promiseState = 'pending';\n\n  /**\n   * @name                  pipe\n   * @type                  Function\n   * @static\n   *\n   * This static function allows you to redirect some SPromise \"events\" to another SPromise instance\n   * with the ability to process the linked value before triggering it on the destination SPromise.\n   *\n   * @param         {SPromise}      sourceSPromise        The source SPromise instance on which to listen for \"events\"\n   * @param         {SPromise}      destSPromise          The destination SPromise instance on which to trigger the listened \"events\"\n   * @param         {Object}        [settings={}]         An object of settings to configure your pipe process\n   * - stacks (*) {String}: Specify which stacks you want to pipe. By default it's all using the \"*\" character\n   * - processor (null) {Function}: Specify a function to apply on the triggered value before triggering it on the dest SPromise. Take as arguments the value itself and the stack name. Need to return a new value\n   * - filter (null) {Function}: Specify a function to filter the \"events\". It will take as parameter the triggered value and the metas object. You must return true or false depending if you want to pipe the particular event or not\n   *\n   * @author \t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  static pipe(sourceSPromise, destSPromise, settings = {}) {\n    // settings\n    settings = __deepMerge(\n      {\n        stacks: '*',\n        processor: null,\n        filter: null\n      },\n      settings\n    );\n    if (\n      !(sourceSPromise instanceof SPromise) ||\n      !(destSPromise instanceof SPromise)\n    )\n      return;\n    // listen for all on the source promise\n    sourceSPromise.on(settings.stacks, (value, metas) => {\n      // check if we have a filter setted\n      if (settings.filter && !settings.filter(value, metas)) return;\n      // check if need to process the value\n      if (settings.processor) {\n        const res = settings.processor(value, metas);\n        if (Array.isArray(res) && res.length === 2) {\n          value = res[0];\n          metas = res[1];\n        } else {\n          value = res;\n        }\n      }\n\n      if (metas.stack.includes('catch')) {\n        console.log('tri', metas.stack);\n      }\n\n      // trigger on the destination promise\n      destSPromise.trigger(metas.stack, value, {\n        ...metas,\n        level: metas.level + 1\n      });\n    });\n  }\n\n  /**\n   * @name                  constructor\n   * @type                  Function\n   *\n   * Constructor\n   *\n   * @param         {Function}          executor          The executor function that will receive the resolve and reject ones...\n   * @param         {Object}            [settings={}]     An object of settings for this particular SPromise instance. Here's the available settings:\n   *\n   * @example       js\n   * const promise = new SPromise((resolve, reject, trigger, cancel) => {\n   *    // do something...\n   * }).then(value => {\n   *    // do something...\n   * }).finally(value => {\n   *    // do something...\n   * });\n   *\n   * @author \t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  constructor(executorFnOrSettings = {}, settings = {}) {\n    let _masterPromiseRejectFn, _masterPromiseResolveFn;\n\n    const _resolve = (...args) => {\n      setTimeout(() => {\n        this.resolve(...args);\n      });\n    };\n    const _reject = (...args) => {\n      setTimeout(() => {\n        this.reject(...args);\n      });\n    };\n    const _trigger = (...args) => {\n      setTimeout(() => {\n        this.trigger(...args);\n      });\n    };\n    const _cancel = (...args) => {\n      setTimeout(() => {\n        this.cancel(...args);\n      });\n    };\n\n    super((resolve) => {\n      _masterPromiseResolveFn = resolve;\n\n      new Promise((rejectPromiseResolve, rejectPromiseReject) => {\n        _masterPromiseRejectFn = rejectPromiseReject;\n      }).catch((e) => {\n        this.trigger(this._settings.triggerOnCatch, {\n          value: e\n        });\n      });\n\n      const executor =\n        typeof executorFnOrSettings === 'function'\n          ? executorFnOrSettings\n          : null;\n      if (executor) {\n        return executor(_resolve, _reject, _trigger, _cancel);\n      }\n    });\n\n    Object.defineProperty(this, '_masterPromiseResolveFn', {\n      writable: true,\n      configurable: true,\n      enumerable: false,\n      value: _masterPromiseResolveFn\n    });\n    Object.defineProperty(this, '_masterPromiseRejectFn', {\n      writable: true,\n      configurable: true,\n      enumerable: false,\n      value: _masterPromiseRejectFn\n    });\n    Object.defineProperty(this, '_promiseState', {\n      writable: true,\n      configurable: true,\n      enumerable: false,\n      value: 'pending'\n    });\n    Object.defineProperty(this, '_stacks', {\n      writable: true,\n      configurable: true,\n      enumerable: false,\n      value: {\n        then: [],\n        catch: [],\n        resolve: [],\n        reject: [],\n        finally: [],\n        cancel: []\n      }\n    });\n\n    // extend settings\n    this._settings = __deepMerge(\n      {\n        triggerOnCatch: 'error',\n        destroyTimeout: 5000,\n        id: __uniqid()\n      },\n      typeof executorFnOrSettings === 'object' ? executorFnOrSettings : {},\n      settings\n    );\n\n    if (this._settings.destroyTimeout !== -1) {\n      this.on('finally', () => {\n        setTimeout(() => {\n          this._destroy();\n        }, this._settings.destroyTimeout);\n      });\n    }\n  }\n\n  /**\n   * @name                    promiseState\n   * @type                    String\n   * @get\n   *\n   * Access the promise state. Can be one of these:\n   * - pending: When the promise is waiting for resolution or rejection\n   * - resolved: When the promise has been resolved\n   * - rejected: When the promise has been rejected\n   * - canceled: When the promise has been canceled\n   * - destroyed: When the promise has been destroyed\n   *\n   * @author \t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  get promiseState() {\n    return this._promiseState;\n  }\n\n  /**\n   * @name                  is\n   * @type                  Function\n   *\n   * Check is the promise is on one of the passed status\n   *\n   * @param       {String}        status        A comma separated list of status to check\n   * @return      {Boolean}                     Return true if the promise is in one of the passed status\n   *\n   * @author \t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  is(status) {\n    const statusArray = status.split(',').map((l) => l.trim());\n    if (statusArray.indexOf(this._promiseState) !== -1) return true;\n    return false;\n  }\n\n  /**\n   * @name                  isPending\n   * @type                  Function\n   *\n   * Return back true or false depending on the promise status\n   *\n   * @return    {Boolean}         true or false depending on the promise status\n   *\n   * @author \t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  isPending() {\n    return this._promiseState === 'pending';\n  }\n\n  /**\n   * @name                  isResolved\n   * @type                  Function\n   *\n   * Return back true or false depending on the promise status\n   *\n   * @return    {Boolean}         true or false depending on the promise status\n   *\n   * @author \t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  isResolved() {\n    return this._promiseState === 'resolved';\n  }\n\n  /**\n   * @name                  isRejected\n   * @type                  Function\n   *\n   * Return back true or false depending on the promise status\n   *\n   * @return    {Boolean}         true or false depending on the promise status\n   *\n   * @author \t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  isRejected() {\n    return this._promiseState === 'rejected';\n  }\n\n  /**\n   * @name                  isCanceled\n   * @type                  Function\n   *\n   * Return back true or false depending on the promise status\n   *\n   * @return    {Boolean}         true or false depending on the promise status\n   *\n   * @author \t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  isCanceled() {\n    return this._promiseState === 'canceled';\n  }\n\n  /**\n   * @name                  isDestroyed\n   * @type                  Function\n   *\n   * Return back true or false depending on the promise status\n   *\n   * @return    {Boolean}         true or false depending on the promise status\n   *\n   * @author \t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  isDestroyed() {\n    return this._promiseState === 'destroyed';\n  }\n\n  /**\n   * @name          pipe\n   * @type          Function\n   *\n   * This method take an SPromise instance as parameter on which to pipe the\n   * specified stacks using the settings.stacks property.\n   * It is exactly the same as the static ```pipe``` method but for this\n   * particular instance.\n   *\n   * @param       {SPromise}      dest      The destination promise on which to pipe the events of this one\n   * @param       {Object}      [settings={}]    An object ob settings to configure the pipe process:\n   * - stacks (*) {String}: Specify which stacks you want to pipe. By default it's all using the \"*\" character\n   * - processor (null) {Function}: Specify a function to apply on the triggered value before triggering it on the dest SPromise. Take as arguments the value itself and the stack name. Need to return a new value\n   * - filter (null) {Function}: Specify a function to filter the \"events\". It will take as parameter the triggered value and the metas object. You must return true or false depending if you want to pipe the particular event or not\n   *\n   * @since       2.0.0\n   * @author \t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  pipe(dest, settings = {}) {\n    SPromise.pipe(this, dest, settings);\n    return this;\n  }\n\n  /**\n   * @name          resolve\n   * @type          Function\n   * @async\n   *\n   * This is the \"resolve\" method exposed on the promise itself for convinience\n   *\n   * @param         {Mixed}         arg       The value that you want to return back from the promise\n   * @param       {Array|String}         [stacksOrder='then,resolve,finally']      This specify in which order have to be called the stacks\n   * @return        {Promise}                       A simple promise that will be resolved once the promise has been canceled with the cancel stack result as value\n   *\n   * @author \t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  resolve(arg, stacksOrder = 'then,resolve,finally') {\n    return this._resolve(arg, stacksOrder);\n  }\n\n  /**\n   * @name          _resolve\n   * @type          Function\n   * @private\n   * @async\n   *\n   * This is the method that will be called by the promise executor passed resolve function\n   *\n   * @param       {Mixed}         arg           The argument that the promise user is sendind through the resolve function\n   * @param       {Array|String}         [stacksOrder='then,resolve,finally']      This specify in which order have to be called the stacks\n   * @return        {Promise}                       A simple promise that will be resolved once the promise has been canceled with the cancel stack result as value\n   *\n   * @author \t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  _resolve(arg, stacksOrder = 'then,resolve,finally') {\n    if (this._isDestroyed) return;\n    return new Promise(async (resolve, reject) => {\n      // update the status\n      this._promiseState = 'resolved';\n      // exec the wanted stacks\n      const stacksResult = await this._triggerStacks(stacksOrder, arg);\n      // resolve the master promise\n      this._masterPromiseResolveFn(stacksResult);\n      // return the stack result\n      resolve(stacksResult);\n    });\n  }\n\n  /**\n   * @name          reject\n   * @type          Function\n   * @async\n   *\n   * This is the \"reject\" method exposed on the promise itself for convinience\n   *\n   * @param         {Mixed}         arg       The value that you want to return back from the promise\n   * @param       {Array|String}         [stacksOrder='catch,reject,finally']      This specify in which order have to be called the stacks\n   * @return        {Promise}      A simple promise that will be resolved once the promise has been canceled with the cancel stack result as value\n   *\n   * @author \t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  reject(arg, stacksOrder = 'catch,reject,finally') {\n    return this._reject(arg, stacksOrder);\n  }\n\n  /**\n   * @name          _reject\n   * @type          Function\n   * @private\n   * @async\n   *\n   * This is the method that will be called by the promise executor passed reject function\n   *\n   * @param         {Mixed}         arg       The value that you want to return back from the promise\n   * @param       {Array|String}         [stacksOrder='catch,reject,finally']      This specify in which order have to be called the stacks\n   * @return        {Promise}                       A simple promise that will be resolved once the promise has been canceled with the cancel stack result as value\n   *\n   * @author \t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  _reject(arg, stacksOrder = 'catch,reject,finally') {\n    if (this._isDestroyed) return;\n    return new Promise(async (resolve, reject) => {\n      // update the status\n      this._promiseState = 'rejected';\n      // exec the wanted stacks\n      const stacksResult = await this._triggerStacks(stacksOrder, arg);\n      // resolve the master promise\n      this._masterPromiseRejectFn(arg);\n      // return the stack result\n      resolve(stacksResult);\n    });\n  }\n\n  /**\n   * @name          cancel\n   * @type          Function\n   * @async\n   *\n   * This is the \"cancel\" method exposed on the promise itself for convinience\n   *\n   * @param         {Mixed}         arg       The value that you want to return back from the promise\n   * @param       {Array|String}         [stacksOrder='cancel,finally']      This specify in which order have to be called the stacks\n   * @return        {Promise}                       A simple promise that will be resolved once the promise has been canceled with the cancel stack result as value\n   *\n   * @author \t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  cancel(arg, stacksOrder = 'cancel,finally') {\n    return this._cancel(arg, stacksOrder);\n  }\n\n  /**\n   * @name            _cancel\n   * @type            Function\n   * @private\n   * @async\n   *\n   * Cancel the promise execution, destroy the Promise and resolve it with the passed value without calling any callbacks\n   *\n   * @param         {Mixed}           arg           The argument you want to pass to the cancel callbacks\n   * @param       {Array|String}         [stacksOrder='cancel,finally']      This specify in which order have to be called the stacks\n   * @return        {Promise}                       A simple promise that will be resolved once the promise has been canceled with the cancel stack result as value\n   *\n   * @author \t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  _cancel(arg, stacksOrder = 'cancel,finally') {\n    if (this._isDestroyed) return;\n    return new Promise(async (resolve, reject) => {\n      // update the status\n      this._promiseState = 'canceled';\n      // exec the wanted stacks\n      const stacksResult = await this._triggerStacks(stacksOrder, arg);\n      // resolve the master promise\n      this._masterPromiseResolveFn(stacksResult);\n      // return the stack result\n      resolve(stacksResult);\n    });\n  }\n\n  /**\n   * @name          trigger\n   * @type          Function\n   * @async\n   *\n   * This is the method that allows you to trigger the callbacks like \"then\", \"catch\", \"finally\", etc... without actually resolving the Promise itself\n   *\n   * @param         {String|Array}        what            The callbacks that you want to trigger. Can be \"then\", \"catch\", \"finally\" or \"cancel\". You can trigger multiple stacks by passing an Array like ['then','finally'], or a string like \"then,finally\"\n   * @param         {Mixed}         arg         The argument you want to pass to the callback\n   * @return        {Promise}                       A default Promise that will be resolved with the result of the stack execution\n   *\n   * @example         js\n   * new SPromise((resolve, reject, trigger, cancel) => {\n   *    trigger('then', 'hello world');\n   *    setTimeout(() => {\n   *      resolve('something');\n   *    }, 2000);\n   * }).then(value => {\n   *    // do something with one time \"hello world\", and one time \"something\"...\n   * });\n   *\n   * @author \t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  async trigger(what, arg, metas = {}) {\n    if (this._isDestroyed) return;\n\n    // triger the passed stacks\n    return this._triggerStacks(what, arg, metas);\n  }\n\n  /**\n   * @name            _registerNewStacks\n   * @type            Function\n   * @private\n   *\n   * This methods allows you to register new stacks.\n   * A new stack can be called then using the \"on('stackName', ...)\" method,\n   * or directly on the SPromise instance like so \"myPromise.stackName(...)\".\n   *\n   * @param       {String|Array}      stacks        The stack(s) name(s) you want to register. Can be an Array or a comma separated string\n   * @return      {SPromise}                        The SPromise instance\n   *\n   * @author \t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  _registerNewStacks(stacks) {\n    // split the stacks order\n    if (typeof stacks === 'string')\n      stacks = stacks.split(',').map((s) => s.trim());\n    stacks.forEach((stack) => {\n      if (!this._stacks[stack]) {\n        this._stacks[stack] = [];\n      }\n    });\n  }\n\n  /**\n   * @name            _registerCallbackInStack\n   * @type            Function\n   *\n   * This function take as argument a stack array and register into it the passed callback function\n   *\n   * @author \t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  _registerCallbackInStack(stack, ...args) {\n    if (this._isDestroyed) {\n      throw new Error(\n        `Sorry but you can't call the \"${stack}\" method on this SPromise cause it has been destroyed...`\n      );\n    }\n    // make sure the stack exist\n    if (!this._stacks[stack]) {\n      this._registerNewStacks(stack);\n    }\n\n    if (typeof stack === 'string') stack = this._stacks[stack];\n    // process the args\n    let callback = args[0];\n    let callNumber = -1;\n    if (args.length === 2 && typeof args[0] === 'number') {\n      callback = args[1];\n      callNumber = args[0];\n    }\n    // make sure this is a function and register it to the _catchStack\n    if (typeof callback === 'function' && stack.indexOf(callback) === -1)\n      stack.push({\n        callback,\n        callNumber,\n        called: 0\n      });\n    // maintain chainability\n    return this;\n  }\n\n  /**\n   * @name            _triggerStack\n   * @type            Function\n   * @private\n   * @async\n   *\n   * This function take an Array Stack as parameter and execute it to return the result\n   *\n   * @param         {Array|String}             stack             The stack to execute. Can be the stack array directly, or just the stack name like \"then\", \"catch\", etc.stack.stack.\n   * @param         {Mixed}             initialValue      The initial value to pass to the first stack callback\n   * @return        {Promise}                             A promise resolved with the stack result\n   *\n   * @author \t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  async _triggerStack(stack, initialValue, metas = {}) {\n    let currentCallbackReturnedValue = initialValue;\n\n    if (!this._stacks || Object.keys(this._stacks).length === 0)\n      return currentCallbackReturnedValue;\n\n    let stackArray = [];\n\n    if (typeof stack === 'string') {\n      if (this._stacks[stack]) {\n        stackArray = [...stackArray, ...this._stacks[stack]];\n      }\n\n      // check if the stack is a glob pattern\n      Object.keys(this._stacks).forEach((stackName) => {\n        if (stackName === stack) return;\n        const toAvoid = [\n          'then',\n          'catch',\n          'resolve',\n          'reject',\n          'finally',\n          'cancel'\n        ];\n        if (toAvoid.indexOf(stack) !== -1 || toAvoid.indexOf(stackName) !== -1)\n          return;\n\n        if (__minimatch(stack, stackName)) {\n          // the glob pattern match the triggered stack so add it to the stack array\n          stackArray = [...stackArray, ...this._stacks[stackName]];\n        }\n      });\n    }\n\n    // filter the catchStack\n    stackArray.map((item) => item.called++);\n    stackArray = stackArray.filter((item) => {\n      if (item.callNumber === -1) return true;\n      if (item.called <= item.callNumber) return true;\n      return false;\n    });\n\n    const metasObj = __deepMerge(\n      {\n        stack,\n        id: this._settings.id,\n        state: this._promiseState,\n        time: Date.now(),\n        level: 1\n      },\n      metas\n    );\n\n    for (let i = 0; i < stackArray.length; i++) {\n      // get the actual item in the array\n      const item = stackArray[i];\n      // make sure the stack exist\n      if (!item.callback) return currentCallbackReturnedValue;\n      // call the callback function\n      let callbackResult = item.callback(\n        currentCallbackReturnedValue,\n        metasObj\n      );\n      // check if the callback result is a promise\n      callbackResult = await callbackResult;\n      // if the settings tells that we have to pass each returned value to the next callback\n      if (callbackResult !== undefined) {\n        currentCallbackReturnedValue = callbackResult;\n      }\n    }\n\n    // return the result\n    return currentCallbackReturnedValue;\n  }\n\n  /**\n   * @name          _triggerStacks\n   * @type          Function\n   * @private\n   * @async\n   *\n   * This function take as parameters a list of stacks to trigger like an Array ['then','finnaly'], or a string like so \"then,finally\", and as second parameter,\n   * the initial value to pass to the first callback of the joined stacks...\n   *\n   * @param         {Array|String}            stacks          The stacks to trigger\n   * @param         {Mixed}                   initialValue    The initial value to pass to the first stack callback\n   * @return        {Promise}                                 A promise that will be resolved with the stacks resulting value\n   *\n   * @author \t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  _triggerStacks(stacks, initialValue, metas = {}) {\n    return new Promise(async (resolve, reject) => {\n      // await __wait(0);\n\n      // check if the stacks is \"*\"\n      if (typeof stacks === 'string')\n        stacks = stacks.split(',').map((s) => s.trim());\n\n      let currentStackResult = initialValue;\n\n      for (let i = 0; i < stacks.length; i++) {\n        const stackResult = await this._triggerStack(\n          stacks[i],\n          currentStackResult,\n          metas\n        );\n        if (stackResult !== undefined) {\n          currentStackResult = stackResult;\n        }\n      }\n\n      resolve(currentStackResult);\n    });\n  }\n\n  /**\n   * @name                on\n   * @type                Function\n   *\n   * This method allows the SPromise user to register a function that will be called every time the \"resolve\" one is called in the executor\n   * The context of the callback will be the SPromise instance itself so you can call all the methods available like \"resolve\", \"release\", \"on\", etc using\n   * the \"this.resolve('something')\" statusment. In an arrow function like \"(value) => { ... }\", the \"this\" keyword will be bound to the current context where you define\n   * your function. You can access to the SPromise instance through the last parameter like so \"(value, sPromiseInstance) => { ... }\".\n   *\n   * @param           {String|Array}      stacks        The stacks in which you want register your callback. Either an Array like ['then','finally'], or a String like \"then,finally\"\n   * @param           {Function}        callback        The callback function to register\n   * @return          {SPromise}                  The SPromise instance to maintain chainability\n   *\n   * @example         js\n   * new SPromise((resolve, reject, trigger, cancel) => {\n   *    // do something...\n   *    resolve('hello world');\n   * }).on('then', value => {\n   *    // do something with the value that is \"hello world\"\n   * }).on('catch:1', error => {\n   *    // do something that will be called only once\n   * });\n   *\n   * @author \t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  on(stacks, callback) {\n    if (this._isDestroyed) {\n      throw new Error(\n        `Sorry but you can't call the \"on\" method on this SPromise cause it has been destroyed...`\n      );\n    }\n\n    if (typeof stacks === 'string')\n      stacks = stacks.split(',').map((s) => s.trim());\n\n    // loop on each stacks\n    stacks.forEach((name) => {\n      // check if it has a callNumber specified using name:1\n      const splitedName = name.split(':');\n      let callNumber = -1;\n      if (splitedName.length === 2) {\n        name = splitedName[0];\n        callNumber = parseInt(splitedName[1]);\n      }\n      // calling the registration method\n      this._registerCallbackInStack(name, callNumber, callback);\n    });\n\n    // maintain chainability\n    return this;\n  }\n\n  /**\n   * @name            off\n   * @type            Function\n   *\n   * This method allows you to unsubscribe to an event by passing the event name an optionally the callback function.\n   * If you don't pass the callback function, all the subscribed events the same as the passed one will be unsubscribed.\n   *\n   * @param       {String}        name        The event name to unsubscribe to\n   * @param       {Function}    [callback=null]     The callback function you want to unsubscribe\n   * @return      {SPromise}                The SPromise instance to maintain chainability\n   *\n   * @since     2.0.0\n   * @author \t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  off(name, callback = null) {\n    if (!callback) {\n      delete this._stacks[name];\n      return this;\n    }\n\n    // get the stack\n    let stack = this._stacks[name];\n    if (!stack) return this;\n    // loop on the stack registered callback to finc the one to delete\n    stack = stack.filter((item) => {\n      if (item.callback === callback) return false;\n      return true;\n    });\n    // make sure we have saved the new stack\n    this._stacks[name] = stack;\n    // maintain chainability\n    return this;\n  }\n\n  /**\n   * @name                then\n   * @type                Function\n   *\n   * This method allows the SPromise user to register a function that will be called every time the \"resolve\" one is called in the executor\n   * The context of the callback will be the SPromise instance itself so you can call all the methods available like \"resolve\", \"then\", etc using\n   * the \"this.resolve('something')\" statusment. In an arrow function like \"(value) => { ... }\", the \"this\" keyword will be bound to the current context where you define\n   * your function. You can access to the SPromise instance through the last parameter like so \"(value, sPromiseInstance) => { ... }\".\n   *\n   * @param           {Number}          [callNumber=-1]     (Optional) How many times you want this callback to be called at max. -1 means unlimited\n   * @param           {Function}        callback        The callback function to register\n   * @return          {SPromise}                  The SPromise instance to maintain chainability\n   *\n   * @example         js\n   * new SPromise((resolve, reject, trigger, cancel) => {\n   *    // do something...\n   *    resolve('hello world');\n   * }).then(value => {\n   *    // do something with the value that is \"hello world\"\n   *    return new Promise((resolve, reject) => {\n   *       setTimeout(() => resolve('hola'), 1000);\n   *    });\n   * }).then(2, value => {\n   *    // do something that will be executed only twice\n   *    // do something with the value passed \"hola\"\n   * });\n   *\n   * @author \t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  then(...args) {\n    if (\n      args.length === 2 &&\n      typeof args[0] === 'function' &&\n      typeof args[1] === 'function'\n    ) {\n      this._masterPromiseResolveFn = args[0];\n      this._masterPromiseRejectFn = args[1];\n      return;\n    }\n    // super.then(...args);\n    return this._registerCallbackInStack('then', ...args);\n  }\n\n  /**\n   * @name                catch\n   * @type                Function\n   *\n   * This method allows the SPromise user to register a function that will be called every time the \"reject\" one is called in the executor\n   * The context of the callback will be the SPromise instance itself so you can call all the methods available like \"resolve\", \"then\", etc using\n   * the \"this.resolve('something')\" statusment. In an arrow function like \"(value) => { ... }\", the \"this\" keyword will be bound to the current context where you define\n   * your function. You can access to the SPromise instance through the last parameter like so \"(value, sPromiseInstance) => { ... }\".\n   *\n   * @param           {Number}          [callNumber=-1]     (Optional) How many times you want this callback to be called at max. -1 means unlimited\n   * @param           {Function}        callback        The callback function to register\n   * @return          {SPromise}                  The SPromise instance to maintain chainability\n   *\n   * @example         js\n   * new SPromise((resolve, reject, trigger, cancel) => {\n   *    // do something...\n   *    reject('hello world');\n   * }).catch(value => {\n   *    // do something with the value that is \"hello world\"\n   * }).catch(1, value => {\n   *    // do something that will be executed only once\n   * });\n   *\n   * @author \t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  catch(...args) {\n    // super.catch(...args);\n    return this._registerCallbackInStack(\n      this._settings.triggerOnCatch,\n      ...args\n    );\n  }\n\n  /**\n   * @name                finally\n   * @type                Function\n   *\n   * This method allows the SPromise user to register a function that will be called every time the \"reject\" one is called in the executor\n   * The context of the callback will be the SPromise instance itself so you can call all the methods available like \"resolve\", \"then\", etc using\n   * the \"this.resolve('something')\" statusment. In an arrow function like \"(value) => { ... }\", the \"this\" keyword will be bound to the current context where you define\n   * your function. You can access to the SPromise instance through the last parameter like so \"(value, sPromiseInstance) => { ... }\".\n   *\n   * @param           {Function}        callback        The callback function to register\n   * @return          {SPromise}                  The SPromise instance to maintain chainability\n   *\n   * @example         js\n   * new SPromise((resolve, reject, trigger, cancel) => {\n   *    // do something...\n   *    resolve('hello world');\n   * }).finally(value => {\n   *    // do something with the value that is \"hello world\"\n   * });\n   *\n   * @author \t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  finally(...args) {\n    // super.finally(...args);\n    return this._registerCallbackInStack('finally', ...args);\n  }\n\n  /**\n   * @name                resolved\n   * @type                Function\n   *\n   * This method allows the SPromise user to register a function that will be called every time the \"reject\" one is called in the executor\n   * The context of the callback will be the SPromise instance itself so you can call all the methods available like \"resolve\", \"then\", etc using\n   * the \"this.resolve('something')\" statusment. In an arrow function like \"(value) => { ... }\", the \"this\" keyword will be bound to the current context where you define\n   * your function. You can access to the SPromise instance through the last parameter like so \"(value, sPromiseInstance) => { ... }\".\n   *\n   * @param           {Function}        callback        The callback function to register\n   * @return          {SPromise}                  The SPromise instance to maintain chainability\n   *\n   * @example         js\n   * new SPromise((resolve, reject, trigger, cancel) => {\n   *    // do something...\n   *    resolve('hello world');\n   * }).resolved(value => {\n   *    // do something with the value that is \"hello world\"\n   * });\n   *\n   * @author \t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  resolved(...args) {\n    return this._registerCallbackInStack('resolve', ...args);\n  }\n\n  /**\n   * @name                rejected\n   * @type                Function\n   *\n   * This method allows the SPromise user to register a function that will be called every time the \"reject\" one is called in the executor\n   * The context of the callback will be the SPromise instance itself so you can call all the methods available like \"resolve\", \"then\", etc using\n   * the \"this.resolve('something')\" statusment. In an arrow function like \"(value) => { ... }\", the \"this\" keyword will be bound to the current context where you define\n   * your function. You can access to the SPromise instance through the last parameter like so \"(value, sPromiseInstance) => { ... }\".\n   *\n   * @param           {Function}        callback        The callback function to register\n   * @return          {SPromise}                  The SPromise instance to maintain chainability\n   *\n   * @example         js\n   * new SPromise((resolve, reject, trigger, cancel) => {\n   *    // do something...\n   *    resolve('hello world');\n   * }).rejected(value => {\n   *    // do something with the value that is \"hello world\"\n   * });\n   *\n   * @author \t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  rejected(...args) {\n    return this._registerCallbackInStack('reject', ...args);\n  }\n\n  /**\n   * @name                canceled\n   * @type                Function\n   *\n   * This method allows the SPromise user to register a function that will be called once when the \"revoke\" function has been called\n   * The context of the callback will be the SPromise instance itself so you can call all the methods available like \"resolve\", \"then\", etc using\n   * the \"this.resolve('something')\" statusment. In an arrow function like \"(value) => { ... }\", the \"this\" keyword will be bound to the current context where you define\n   * your function. You can access to the SPromise instance through the last parameter like so \"(value, sPromiseInstance) => { ... }\".\n   *\n   * @param           {Function}        callback        The callback function to register\n   * @return          {Promise}                  A simple promise that will be resolved with the cancel stack result\n   *\n   * @example         js\n   * new SPromise((resolve, reject, trigger, cancel) => {\n   *    // do something...\n   *    cancel('hello world');\n   * }).canceled(value => {\n   *    // do something with the value that is \"hello world\"\n   * });\n   *\n   * @author \t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  canceled(...args) {\n    return this._registerCallbackInStack('cancel', ...args);\n  }\n\n  /**\n   * @name                      _destroy\n   * @type                      Function\n   *\n   * Destroying the SPromise instance by unregister all the callbacks, etc...\n   *\n   * @author \t\tOlivier Bossel<olivier.bossel@gmail.com>\n   */\n  _destroy() {\n    // update the status\n    this._promiseState = 'destroyed';\n\n    // destroying all the callbacks stacks registered\n    delete this._stacks;\n    delete this._masterPromiseResolveFn;\n    delete this._masterPromiseRejectFn;\n    delete this._settings;\n    this._isDestroyed = true;\n  }\n}\n"
    ]
}
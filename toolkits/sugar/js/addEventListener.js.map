{
    "version": 3,
    "sources": [
        "addEventListener.js"
    ],
    "names": [
        "addEventListener",
        "$elm",
        "eventNames",
        "callback",
        "useCapture",
        "Array",
        "isArray",
        "split",
        "map",
        "e",
        "trim",
        "eventsStack",
        "promise",
        "__SPromise",
        "resolve",
        "reject",
        "trigger",
        "cancel",
        "on",
        "forEach",
        "eventName",
        "stack",
        "removeEventListener",
        "internalCallback",
        "event",
        "apply"
    ],
    "mappings": ";;;;;;;AAAA;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8Be,SAASA,gBAAT,CACbC,IADa,EAEbC,UAFa,EAGbC,QAHa,EAIbC,UAJa,EAKb;AAAA,MAFAD,QAEA;AAFAA,IAAAA,QAEA,GAFW,IAEX;AAAA;;AAAA,MADAC,UACA;AADAA,IAAAA,UACA,GADa,KACb;AAAA;;AACA,MAAI,CAACC,KAAK,CAACC,OAAN,CAAcJ,UAAd,CAAL,EACEA,UAAU,GAAGA,UAAU,CAACK,KAAX,CAAiB,GAAjB,EAAsBC,GAAtB,CAA2BC,CAAD,IAAOA,CAAC,CAACC,IAAF,EAAjC,CAAb;AAEF,MAAIP,QAAQ,IAAI,OAAOA,QAAP,KAAoB,UAApC,EAAgDA,QAAQ,GAAGA,QAAX,CAAhD,KACK,IAAIA,QAAQ,IAAI,OAAOA,QAAP,KAAoB,SAApC,EAA+CC,UAAU,GAAGD,QAAb;AAEpD,MAAIQ,WAAW,GAAG,EAAlB;AAEA,MAAMC,OAAO,GAAG,IAAIC,iBAAJ,CAAe,CAACC,OAAD,EAAUC,MAAV,EAAkBC,OAAlB,EAA2BC,MAA3B,KAAsC,CAAE,CAAvD,EAAyDC,EAAzD,CACd,gBADc,EAEd,MAAM;AACJhB,IAAAA,UAAU,CAACiB,OAAX,CAAoBC,SAAD,IAAe;AAChC,UAAMC,KAAK,GAAGV,WAAW,CAACS,SAAD,CAAzB;AACAnB,MAAAA,IAAI,CAACqB,mBAAL,CAAyBF,SAAzB,EAAoCC,KAAK,CAAClB,QAA1C,EAAoDkB,KAAK,CAACjB,UAA1D;AACD,KAHD;AAID,GAPa,CAAhB;AAUAF,EAAAA,UAAU,CAACiB,OAAX,CAAoBC,SAAD,IAAe;AAChC,QAAMG,gBAAgB,GAAIC,KAAD,IAAW;AAClC,UAAIrB,QAAJ,EAAcA,QAAQ,CAACsB,KAAT,CAAe,IAAf,EAAqB,CAACD,KAAD,CAArB;AACdZ,MAAAA,OAAO,CAACI,OAAR,CAAgBI,SAAhB,EAA2BI,KAA3B;AACD,KAHD;;AAKAb,IAAAA,WAAW,CAACS,SAAD,CAAX,GAAyB;AACvBjB,MAAAA,QAAQ,EAAEoB,gBADa;AAEvBnB,MAAAA;AAFuB,KAAzB;AAKAH,IAAAA,IAAI,CAACD,gBAAL,CAAsBoB,SAAtB,EAAiCG,gBAAjC,EAAmDnB,UAAnD;AACD,GAZD;AAcA,SAAOQ,OAAP;AACD",
    "sourcesContent": [
        "import __SPromise from '../promise/SPromise';\n\n/**\n * @name        addEventListener\n * @namespace           sugar.js.dom\n * @type      Function\n *\n * Add an event listener on an element and return the function to remove the event listener\n *\n * @param    {HTMLElement}    $elm    The HTMLElement on which to add the event listener\n * @param    {String}    eventNames    The event names to listen to. Can be a simple string like \"click\", multiple events like \"click,focus\", or an array of events like ['click','hover']\n * @param    {Function}    callback    The callback function to call on event. The passed event\n * @param    {Boolean}    [useCapture=false]    A Boolean value that specifies whether the event should be executed in the capturing or in the bubbling phase\n * @return    {SPromise}                An SPromise instance on which you can listen for events or simply \"cancel\" the listeneing process\n *\n * @example    js\n * import addEventListener from '@coffeekraken/sugar/js/dom/addEventListener'\n * const listener = addEventListener($myCoolElm, 'click', (event) => {\n *    // event.type; // => click\n * });\n * // remove the event listener\n * listener.cancel();\n *\n * // listen for more than one event at a time\n * addEventListener($myCoolElm, 'click,mouseover,mouseout', (event) => {\n *    // do something depending on the event.type property\n * }).on('mouseover', (event) => {\n *    // do something when the event is the mouseover one\n * });\n *\n * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)\n */\nexport default function addEventListener(\n  $elm,\n  eventNames,\n  callback = null,\n  useCapture = false\n) {\n  if (!Array.isArray(eventNames))\n    eventNames = eventNames.split(',').map((e) => e.trim());\n\n  if (callback && typeof callback === 'function') callback = callback;\n  else if (callback && typeof callback === 'boolean') useCapture = callback;\n\n  let eventsStack = {};\n\n  const promise = new __SPromise((resolve, reject, trigger, cancel) => {}).on(\n    'cancel,finally',\n    () => {\n      eventNames.forEach((eventName) => {\n        const stack = eventsStack[eventName];\n        $elm.removeEventListener(eventName, stack.callback, stack.useCapture);\n      });\n    }\n  );\n\n  eventNames.forEach((eventName) => {\n    const internalCallback = (event) => {\n      if (callback) callback.apply(this, [event]);\n      promise.trigger(eventName, event);\n    };\n\n    eventsStack[eventName] = {\n      callback: internalCallback,\n      useCapture\n    };\n\n    $elm.addEventListener(eventName, internalCallback, useCapture);\n  });\n\n  return promise;\n}\n"
    ]
}
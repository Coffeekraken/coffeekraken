{
    "version": 3,
    "sources": [
        "SCodeSplitter.js"
    ],
    "names": [
        "SCodeSplitter",
        "settings",
        "_settings",
        "code",
        "splitters",
        "blocks",
        "thingsToExtract",
        "splittersMatches",
        "forEach",
        "extractorObj",
        "prefix",
        "matches",
        "match",
        "push",
        "index",
        "string",
        "prefixMatchIdx",
        "idx",
        "length",
        "obj",
        "opened",
        "closed",
        "openCount",
        "closeCount",
        "type",
        "data",
        "slice",
        "blockString",
        "i",
        "char",
        "open",
        "close",
        "suffix",
        "suffixMatch",
        "exclude",
        "Array",
        "isArray",
        "k",
        "excludeReg"
    ],
    "mappings": "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",
    "sourcesContent": [
        "import __deepMerge from '../object/deepMerge';\n\n/**\n * @name              SCodeSplitter\n * @namespace         sugar.js.code\n * @type              Class\n *\n * This class allows you to specify some \"splitters\" that will be used to split the code accordingly.\n * A \"splitter\" is an object of these properties:\n * - type (null) {String}: A simple word used as \"type\" to define the splitted blocks\n * - prefix (null) {Regex}: A regex used to detect the start of a block\n * - suffix (null) {Regex}: A regex used to detect what can be after the block\n * - open ('{') {String}: A 1 character string that specify the opening of a code block like \"{\", etc...\n * - close ('}') {String}: A 1 character string that specify the closing of a code block like \"}\", etc...\n * - exclude (null) {Array<Regex>}: An array of regex used to exclude some previously matched blocks of this splitter\n *\n * @param       {Object}      [settings={}]         An object of settings to configure your code splitter instance:\n *\n * @todo        enhance documentation\n *\n * @example       js\n * import SCodeSplitter from '@coffeekraken/sugar/js/code/SCodeSplitter';\n * const splitter = new SCodeSplitter();\n * const splitStack = splitter.split([{\n *    type: 'include',\n *    prefix: /@include\\s[a-zA-Z0-9-_\\.]+/,\n *    suffix: /;/,\n *    open: '(',\n *    close: ')',\n *    exclude: [/@include Sugar\\.setup\\(.*\\);/]\n * }]);\n *\n * @since       2.0.0\n * @author \t\tOlivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)\n */\nexport default class SCodeSplitter {\n  /**\n   * @name        _settings\n   * @type        Object\n   * @private\n   *\n   * Store the instance settings\n   *\n   * @since       2.0.0\n   * @author \t\tOlivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)\n   */\n  _settings = {};\n\n  /**\n   * @name        constructor\n   * @type        Function\n   * @constructor\n   *\n   * Constructor\n   *\n   * @since       2.0.0\n   * @author \t\tOlivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)\n   */\n  constructor(settings = {}) {\n    this._settings = __deepMerge({}, settings);\n  }\n\n  /**\n   * @name            split\n   * @type            Function\n   *\n   * This method is the main one that allows you to actually split the passed code\n   * into small pieces.\n   *\n   * @param       {String}        code        The code you want to split\n   * @param       {Array<Object>}     splitters       An array of splitter objects composed of these properties:\n   * - type (null) {String}: A simple word used as \"type\" to define the splitted blocks\n   * - prefix (null) {Regex}: A regex used to detect the start of a block\n   * - suffix (null) {Regex}: A regex used to detect what can be after the block\n   * - open ('{') {String}: A 1 character string that specify the opening of a code block like \"{\", etc...\n   * - close ('}') {String}: A 1 character string that specify the closing of a code block like \"}\", etc...\n   * - exclude (null) {Array<Regex>}: An array of regex used to exclude some previously matched blocks of this splitter\n   * @param       {Object}        [settings={}]         An object of settings to override the instance ones\n   * @return      {Array<Object>}                       An array of splited code blocks objects\n   *\n   * @since       2.0.0\n   * @author \t\tOlivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)\n   */\n  split(code, splitters = [], settings = {}) {\n    settings = __deepMerge(this._settings, settings);\n\n    const blocks = [];\n    let thingsToExtract = true;\n\n    while (thingsToExtract) {\n      const splittersMatches = [];\n      splitters.forEach((extractorObj) => {\n        if (extractorObj.prefix) {\n          const matches = code.match(extractorObj.prefix);\n          if (matches) {\n            splittersMatches.push({\n              extractorObj,\n              match: {\n                index: matches.index,\n                string: matches[extractorObj.prefixMatchIdx || 0]\n              }\n            });\n          }\n        }\n      });\n\n      let idx = code.length,\n        extractorObj;\n      splittersMatches.forEach((obj) => {\n        if (obj.match.index < idx) {\n          idx = obj.match.index;\n          extractorObj = {\n            opened: false,\n            closed: false,\n            openCount: 0,\n            closeCount: 0,\n            ...obj.extractorObj,\n            match: obj.match\n          };\n        }\n      });\n\n      if (extractorObj) {\n        blocks.push({\n          type: 'string',\n          data: code.slice(0, extractorObj.match.index)\n        });\n        code = code.slice(extractorObj.match.index);\n      } else {\n        blocks.push({\n          type: 'string',\n          data: code\n        });\n\n        thingsToExtract = false;\n        break;\n      }\n\n      let blockString = '';\n      for (let i = extractorObj.match.string.length; i < code.length; i++) {\n        const char = code[i];\n        blockString += char;\n        if (char === extractorObj.open) {\n          if (!extractorObj.opened) {\n            extractorObj.opened = true;\n          }\n          extractorObj.openCount++;\n        } else if (char === extractorObj.close) {\n          extractorObj.closeCount++;\n          if (\n            extractorObj.opened &&\n            extractorObj.closeCount === extractorObj.openCount\n          ) {\n            extractorObj.closed = true;\n\n            // check suffix\n            if (extractorObj.suffix) {\n              const suffixMatch = code.slice(i).match(extractorObj.suffix);\n              if (suffixMatch && suffixMatch.index === 1) {\n                blockString += suffixMatch[0];\n              }\n            }\n\n            blockString = `${extractorObj.match.string}${blockString}`;\n\n            let type = extractorObj.type;\n            if (extractorObj.exclude) {\n              if (!Array.isArray(extractorObj.exclude))\n                extractorObj.exclude = [extractorObj.exclude];\n              for (let k = 0; k < extractorObj.exclude.length; k++) {\n                const excludeReg = extractorObj.exclude[k];\n                if (blockString.match(excludeReg)) {\n                  type = 'string';\n                  break;\n                }\n              }\n            }\n\n            // append the block to the blocks stack\n            blocks.push({\n              type: type,\n              data: blockString\n            });\n\n            // crop the code\n            code = code.slice(blockString.length);\n\n            // stop the loop here\n            break;\n          }\n        }\n      }\n    }\n\n    return blocks;\n  }\n}\n"
    ]
}
{
    "version": 3,
    "sources": [
        "crop.js"
    ],
    "names": [
        "crop",
        "text",
        "length",
        "settings",
        "chars",
        "splitWords",
        "replace",
        "splitReg",
        "parts",
        "split",
        "filter",
        "c",
        "undefined",
        "match",
        "map",
        "result",
        "currentWord",
        "currentLength",
        "openedHtmlTagsArray",
        "i",
        "trim",
        "closingHtmlTagMatch",
        "openingHtmlTagMatch",
        "singleHtmlTagMatch",
        "input",
        "tagName",
        "indexOf",
        "splice",
        "push",
        "forEach",
        "tag"
    ],
    "mappings": "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",
    "sourcesContent": [
        "import __deepMerge from '../object/deepMerge';\nimport __countLine from './countLine';\n\n/**\n * @name                                        crop\n * @namespace           sugar.js.string\n * @type                                        Function\n *\n * Allows you to crop a string at a certain length (this length take care of the croping characters like \"...\")\n *\n * @param               {String}                  text                      The text to crop\n * @param               {Number}                  length                    The text length to have after the croping process\n * @param               {Object}                  [settings={}]             An object of settings described bellow:\n * - chars (...) {String}: The characters to use to signal the crop\n * - splitWords (false) {Boolean}: Specify if you want to split words or not. If not, the function will make sure the final text does not exceeds the wanted length\n * @return              {String}                                            The cropped text\n *\n * @example         js\n * import crop from '@coffeekraken/sugar/js/string/crop';\n * crop('Hello World', 10); // => Hello w...\n *\n * @author \tOlivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)\n */\nexport default function crop(text, length, settings = {}) {\n  settings = __deepMerge(\n    {\n      chars: '...',\n      splitWords: false\n    },\n    settings\n  );\n\n  text = text.replace(/\\s/gm, '¯');\n\n  // split the text on spaces or every characters if the splitWords settings is to true\n  let splitReg = /(<([^>]+)>|\\S|\\s)/gm;\n  const parts = text\n    .split(splitReg)\n    .filter((c) => {\n      return (\n        c !== undefined &&\n        c !== ' ' &&\n        c !== '' &&\n        (c.length === 1 || c.match(/^</))\n      );\n    })\n    .map((c) => {\n      if (c === '¯') return ' ';\n      return c;\n    });\n\n  // init the result text\n  let result = '';\n  let currentWord = '';\n  let currentLength = 0;\n  let openedHtmlTagsArray = [];\n\n  for (let i = 0; i < parts.length; i++) {\n    const c = parts[i];\n\n    if (c.length === 1) {\n      if (settings.splitWords) {\n        if (currentLength + 1 + settings.chars.length <= length) {\n          result += c;\n          currentLength += 1;\n        } else {\n          result += settings.chars;\n          currentLength += settings.chars.length;\n          break;\n        }\n      } else {\n        if (c !== ' ') {\n          currentWord += c;\n        } else {\n          if (\n            __countLine(result) +\n              __countLine(currentWord) +\n              __countLine(settings.chars) <=\n            length\n          ) {\n            result += currentWord;\n          } else {\n            result = result.trim();\n            result += settings.chars;\n            break; // stop the loop execution...\n          }\n\n          // add the space\n          result += ' ';\n\n          // reset currentWord\n          currentWord = '';\n        }\n      }\n\n      // if it's not a character of 1 letter\n      // meaning that it's surely an html tag\n    } else {\n      if (currentWord !== '') {\n        result += currentWord;\n        currentWord = '';\n      }\n\n      // preparing the match regexp\n      const closingHtmlTagMatch = c.match(/^<\\//);\n      const openingHtmlTagMatch = c.match(/^<[a-zA-Z]+.*>$/);\n      const singleHtmlTagMatch = c.match(/^<[a-zA-Z]+.*\\/>$/);\n\n      // if it's a closing html tag\n      if (singleHtmlTagMatch) {\n        // we just add the single tag in the result\n        result += singleHtmlTagMatch.input;\n      } else if (closingHtmlTagMatch) {\n        const tagName = closingHtmlTagMatch.input.match(/^<\\/(.*)>$/)[1];\n        // check if this tag has been opened\n        if (openedHtmlTagsArray.indexOf(tagName) !== -1) {\n          // the tag has been opened so we add it to the close\n          result += closingHtmlTagMatch.input;\n          // remove the tag from the opened array\n          openedHtmlTagsArray.splice(openedHtmlTagsArray.indexOf(tagName), 1);\n        }\n      } else if (openingHtmlTagMatch) {\n        const tagName = openingHtmlTagMatch.input.match(/^<([a-zA-Z]+).*>$/)[1];\n        // add the tag in the result\n        result += openingHtmlTagMatch.input;\n        // add the tag to the openedTagArray\n        openedHtmlTagsArray.push(tagName);\n      }\n    }\n  }\n\n  // console.log(currentLength, result, __countLine(result));\n\n  // if we take care of html, make sure the opened tags are closed\n  openedHtmlTagsArray.forEach((tag) => {\n    result += `</${tag}>`;\n  });\n\n  return result;\n}\n"
    ]
}
{
    "version": 3,
    "sources": [
        "splitLines.js"
    ],
    "names": [
        "splitLines",
        "elm",
        "tag",
        "tagClass",
        "window",
        "addEventListener",
        "e",
        "_splitLines",
        "string",
        "_splitLinesOriginalString",
        "innerHTML",
        "classList",
        "add",
        "words",
        "match",
        "word",
        "join",
        "spans",
        "querySelectorAll",
        "top",
        "lines",
        "line",
        "forEach",
        "call",
        "spanElm",
        "spanTop",
        "getBoundingClientRect",
        "push",
        "trim",
        "map",
        "lineStr"
    ],
    "mappings": ";;;;;;;AAAA;;AACA;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2Be,SAASA,UAAT,CAAoBC,GAApB,EAAyBC,GAAzB,EAAoCC,QAApC,EAA8D;AAAA,MAArCD,GAAqC;AAArCA,IAAAA,GAAqC,GAA/B,GAA+B;AAAA;;AAAA,MAA1BC,QAA0B;AAA1BA,IAAAA,QAA0B,GAAf,aAAe;AAAA;;AAC3E;AACAC,EAAAA,MAAM,CAACC,gBAAP,CACE,QADF,EAEE,uBAAYC,CAAD,IAAO;AAChBC,IAAAA,WAAW,CAACN,GAAD,EAAMC,GAAN,EAAWC,QAAX,CAAX;AACD,GAFD,EAEG,GAFH,CAFF,EAF2E,CAS3E;;AACAI,EAAAA,WAAW,CAACN,GAAD,EAAMC,GAAN,EAAWC,QAAX,CAAX;;AAEA,SAAOF,GAAP;AACD;;AAED,SAASM,WAAT,CAAqBN,GAArB,EAA0BC,GAA1B,EAA+BC,QAA/B,EAAyC;AACvC,MAAIK,MAAM,GAAGP,GAAG,CAACQ,yBAAjB;;AACA,MAAI,CAACD,MAAL,EAAa;AACXA,IAAAA,MAAM,GAAGP,GAAG,CAACS,SAAb;AACAT,IAAAA,GAAG,CAACQ,yBAAJ,GAAgCD,MAAhC;AACD;;AAEDP,EAAAA,GAAG,CAACU,SAAJ,CAAcC,GAAd,CAAkBT,QAAlB,EAPuC,CASvC;;AACA,MAAIU,KAAK,GAAGL,MAAM,CAACM,KAAP,CACV,6DADU,CAAZ;AAGAD,EAAAA,KAAK,GAAG,mBAAKA,KAAL,EAAaE,IAAD,IAAU;AAC5B,mDAAsCA,IAAtC;AACD,GAFO,EAELC,IAFK,CAEA,GAFA,CAAR;AAGAf,EAAAA,GAAG,CAACS,SAAJ,GAAgBG,KAAhB;AAEA,MAAMI,KAAK,GAAGhB,GAAG,CAACiB,gBAAJ,CAAqB,oBAArB,CAAd;AACA,MAAIC,GAAG,GAAG,IAAV;AACA,MAAMC,KAAK,GAAG,EAAd;AACA,MAAIC,IAAI,GAAG,EAAX;AACA,KAAGC,OAAH,CAAWC,IAAX,CAAgBN,KAAhB,EAAwBO,OAAD,IAAa;AAClC,QAAMC,OAAO,GAAGD,OAAO,CAACE,qBAAR,GAAgCP,GAAhD;;AACA,QAAIA,GAAG,IAAIM,OAAO,KAAKN,GAAvB,EAA4B;AAC1BC,MAAAA,KAAK,CAACO,IAAN,CAAWN,IAAI,CAACL,IAAL,CAAU,GAAV,CAAX;AACAK,MAAAA,IAAI,GAAG,EAAP;AACD;;AACDA,IAAAA,IAAI,CAACM,IAAL,CAAUH,OAAO,CAACd,SAAR,CAAkBkB,IAAlB,EAAV;AACAT,IAAAA,GAAG,GAAGM,OAAN;AACD,GARD;AASAL,EAAAA,KAAK,CAACO,IAAN,CAAWN,IAAI,CAACL,IAAL,CAAU,GAAV,CAAX;AAEAf,EAAAA,GAAG,CAACS,SAAJ,GAAgBU,KAAK,CAClBS,GADa,CACRC,OAAD,IAAa;AAChB,sBAAW5B,GAAX,sBAAyBC,QAAzB,sBAA4C2B,OAA5C,eAAwD5B,GAAxD;AACD,GAHa,EAIbc,IAJa,CAIR,EAJQ,CAAhB;AAKD",
    "sourcesContent": [
        "import _map from 'lodash/map';\nimport __throttle from '../function/throttle';\n\n/**\n * @name      splitLines\n * @namespace           sugar.js.dom\n * @type      Function\n *\n * Split each lines inside an HTMLElement by scoping them inside some tags.\n * Here's an result sample for :\n * Hello\n * World\n *\n * ```html\n * <p class=\"s-split-lines\">Hello</p>\n * <p class=\"s-split-lines\">World</p>\n * ```\n *\n * @param \t{HTMLElement} \t\telm \t\t \tThe HTMLElement to split lines in\n * @param \t{String} \t\t\t[tag=\"p\"] \t\tThe tag to use to split the lines\n * @param \t{String} \t\t\t[tagClass=\"s-split-lines\"] \t\tThe class to apply on the tags\n * @return \t{HTMLElement} \t\t\t\t\t\tThe HTMLElement processed\n *\n * @example \tjs\n * import splitLines from '@coffeekraken/sugar/js/dom/splitLines'\n * const myCoolElement = document.querySelector('.my-cool-element');\n * splitLines(myCoolElement);\n *\n * @author \tOlivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)\n */\nexport default function splitLines(elm, tag = 'p', tagClass = 'split-lines') {\n  // apply again on resize\n  window.addEventListener(\n    'resize',\n    __throttle((e) => {\n      _splitLines(elm, tag, tagClass);\n    }, 150)\n  );\n\n  // first call\n  _splitLines(elm, tag, tagClass);\n\n  return elm;\n}\n\nfunction _splitLines(elm, tag, tagClass) {\n  let string = elm._splitLinesOriginalString;\n  if (!string) {\n    string = elm.innerHTML;\n    elm._splitLinesOriginalString = string;\n  }\n\n  elm.classList.add(tagClass);\n\n  // wrap each characters inside two spans\n  let words = string.match(\n    /<\\s*(\\w+\\b)(?:(?!<\\s*\\/\\s*\\1\\b)[\\s\\S])*<\\s*\\/\\s*\\1\\s*>|\\S+/g\n  );\n  words = _map(words, (word) => {\n    return `<span class=\"s-split-lines\">${word}</span>`;\n  }).join(' ');\n  elm.innerHTML = words;\n\n  const spans = elm.querySelectorAll('span.s-split-lines');\n  let top = null;\n  const lines = [];\n  let line = [];\n  [].forEach.call(spans, (spanElm) => {\n    const spanTop = spanElm.getBoundingClientRect().top;\n    if (top && spanTop !== top) {\n      lines.push(line.join(' '));\n      line = [];\n    }\n    line.push(spanElm.innerHTML.trim());\n    top = spanTop;\n  });\n  lines.push(line.join(' '));\n\n  elm.innerHTML = lines\n    .map((lineStr) => {\n      return `<${tag} class=\"${tagClass}__line\">${lineStr}</${tag}>`;\n    })\n    .join('');\n}\n"
    ]
}
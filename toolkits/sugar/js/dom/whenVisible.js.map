{
    "version": 3,
    "sources": [
        "whenVisible.js"
    ],
    "names": [
        "whenVisible",
        "elm",
        "cb",
        "Promise",
        "resolve",
        "reject",
        "isSelfVisible",
        "areParentsVisible",
        "closestNotVisible",
        "selfObserver",
        "parentObserver",
        "_cb",
        "removeEventListener",
        "_eventCb",
        "e",
        "setTimeout",
        "target",
        "disconnect",
        "MutationObserver",
        "mutations",
        "forEach",
        "mutation",
        "attributeName",
        "observe",
        "attributes",
        "addEventListener"
    ],
    "mappings": "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",
    "sourcesContent": [
        "import __isVisible from './isVisible';\nimport __closestNotVisible from './closestNotVisible';\n\n/**\n * @name      whenVisible\n * @namespace           sugar.js.dom\n * @type      Function\n *\n * Monitor an HTMLElement to be notified when it is visible\n *\n * @param \t\t{HTMLElement} \t\t\t\telm \t\tThe element to monitor\n * @param \t\t{Function} \t\t\t\t\t[cb=null] \tAn optional callback to call when the element is visible\n * @return \t\t(Promise) \t\t\t\t\t\t\t\tThe promise that will be resolved when the element is visible\n *\n * @example \tjs\n * import whenVisible from '@coffeekraken/sugar/js/dom/whenVisible'\n * whenVisible(myCoolHTMLElement).then((elm) => {\n * \t\t// do something with your element that is now visible\n * });\n *\n * @author \t\tOlivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)\n */\nexport default function whenVisible(elm, cb = null) {\n  return new Promise((resolve, reject) => {\n    // variables\n    let isSelfVisible = false,\n      areParentsVisible = false,\n      closestNotVisible = null,\n      selfObserver = null,\n      parentObserver = null;\n\n    const _cb = () => {\n      if (isSelfVisible && areParentsVisible) {\n        // process callbacks\n        if (cb) cb(elm);\n        resolve(elm);\n        // remove the event listeners\n        elm.removeEventListener('transitionend', _eventCb);\n        elm.removeEventListener('animationstart', _eventCb);\n        elm.removeEventListener('animationend', _eventCb);\n        // remove the event listeners\n        if (closestNotVisible) {\n          closestNotVisible.removeEventListener('transitionend', _eventCb);\n          closestNotVisible.removeEventListener('animationstart', _eventCb);\n          closestNotVisible.removeEventListener('animationend', _eventCb);\n        }\n      }\n    };\n\n    // function called on each transitionend, start, etc...\n    const _eventCb = (e) => {\n      // wait just a little time to check again\n      setTimeout(() => {\n        if (e.target === elm) {\n          if (__isVisible(elm)) {\n            isSelfVisible = true;\n            if (selfObserver && selfObserver.disconnect) {\n              selfObserver.disconnect();\n            }\n            // remove the event listeners\n            elm.removeEventListener('transitionend', _eventCb);\n            elm.removeEventListener('animationstart', _eventCb);\n            elm.removeEventListener('animationend', _eventCb);\n          }\n        } else if (e.target === closestNotVisible) {\n          if (__isVisible(closestNotVisible)) {\n            areParentsVisible = true;\n            if (parentObserver && parentObserver.disconnect) {\n              parentObserver.disconnect();\n            }\n            // remove the event listeners\n            closestNotVisible.removeEventListener('transitionend', _eventCb);\n            closestNotVisible.removeEventListener('animationstart', _eventCb);\n            closestNotVisible.removeEventListener('animationend', _eventCb);\n          }\n        }\n        // callback\n        _cb();\n      });\n    };\n\n    // check if element itself is not visible\n    if (!__isVisible(elm)) {\n      selfObserver = new MutationObserver((mutations) => {\n        mutations.forEach((mutation) => {\n          // check that is the style whos changed\n          if (\n            mutation.attributeName === 'style' ||\n            mutation.attributeName === 'class'\n          ) {\n            // check if is visible\n            if (__isVisible(mutation.target)) {\n              // update\n              isSelfVisible = true;\n              // callback\n              _cb();\n              // stop observe\n              selfObserver.disconnect();\n            }\n          }\n        });\n      });\n      selfObserver.observe(elm, { attributes: true });\n\n      // listen for animationstart to check if the element is visible\n      elm.addEventListener('animationstart', _eventCb);\n      elm.addEventListener('animationend', _eventCb);\n      elm.addEventListener('transitionend', _eventCb);\n    } else {\n      isSelfVisible = true;\n    }\n\n    // get the closest not visible element\n    // if found, we monitor it to check when it is visible\n    closestNotVisible = __closestNotVisible(elm);\n    if (closestNotVisible) {\n      parentObserver = new MutationObserver((mutations) => {\n        mutations.forEach((mutation) => {\n          // check that is the style whos changed\n          if (\n            mutation.attributeName === 'style' ||\n            mutation.attributeName === 'class'\n          ) {\n            // check if is visible\n            if (__isVisible(mutation.target)) {\n              // update\n              areParentsVisible = true;\n              // callback\n              _cb();\n              // stop observe\n              parentObserver.disconnect();\n            }\n          }\n        });\n      });\n      parentObserver.observe(closestNotVisible, { attributes: true });\n\n      // listen for animationstart to check if the element is visible\n      closestNotVisible.addEventListener('animationstart', _eventCb);\n      closestNotVisible.addEventListener('animationend', _eventCb);\n      closestNotVisible.addEventListener('transitionend', _eventCb);\n    } else {\n      areParentsVisible = true;\n    }\n\n    // callback\n    _cb();\n  });\n}\n"
    ]
}
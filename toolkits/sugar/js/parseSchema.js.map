{
    "version": 3,
    "sources": [
        "parseSchema.js"
    ],
    "names": [
        "parseSchema",
        "url",
        "schema",
        "rawSchemaString",
        "rawUrlString",
        "split",
        "pathname",
        "URL",
        "e",
        "slice",
        "params",
        "errors",
        "match",
        "schemaParts",
        "map",
        "part",
        "isOptional",
        "isType",
        "indexOf",
        "type",
        "name",
        "raw",
        "optional",
        "filter",
        "l",
        "forEach",
        "splitedPathname",
        "i",
        "length",
        "errorObj",
        "description",
        "error",
        "value",
        "requested",
        "passed",
        "Object",
        "keys"
    ],
    "mappings": "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",
    "sourcesContent": [
        "import __parseString from '../string/parse';\n\n/**\n * @name                                parseSchema\n * @namespace           sugar.js.url\n * @type                                Function\n *\n * This function take two arguments. The first one is the url to parse and the second is a schema to scan the url with.\n * The schema describe the pathname of an url and tell's how to analyze it.\n * Here's a little description with some example of schemas:\n * - \"{param1}/{param2}/{param3}\": This schema describe that your Url must have 3 \"values\" named param1, param2 and param3\n *    - If my Url is \"something.com/hello/world/plop\", my schema is respected and I can have access to the values through the \"schema.params.param1\", \"schema.params.param2\", etc...\n * - \"{hello:string}/{world:number}/{?idx:number}\": This schema describe that the Url can have 3 \"values\" but the last one is optional\n *    - If my Url is \"something.com/plop/3/1\", my schema is respected\n *    - If my Url is \"something.com/plop/2\", my schema is respected\n *    - If my Url is \"something.com/plop/hello/2\", my schema is not respected due to the fact that the param named \"world\" has to be a number\n *\n * @param         {String}              url                 The url to parse\n * @param         {String}              schema              The schema with the one we will analyze the url\n * @return        {Object}                                  An object that describe our parsing process result. Here's the structure of the returned object:\n * - errors (null) {Object}: An object with all the params in error with the description of the error for each\n * - params (null) {Object}: An object containing every params grabed from the url with their values for each\n * - match (true) {Object}: A boolean that tells you if the parsed url match the passed schema or not\n *\n * @example       js\n * import parseSchema from '@coffeekraken/sugar/js/url/parseSchema';\n * parseSchema('https://github.com/myApp/master/3', '{project:string}/{?branch:string}/{?idx:number}');\n * // {\n * //   url: 'https://github.com/myApp/master/3',\n * //   schema: '{project:string}/{?branch:string}/{?idx:number}',\n * //   match: true,\n * //   errors: null,\n * //   params: {\n * //     project: {\n * //       optional: false,\n * //       raw: '{project:string}',\n * //       type: 'string',\n * //       value: 'myApp'\n * //     },\n * //     branch: {\n * //       optional: true,\n * //       raw: '{?branch:string},\n * //       type: 'string',\n * //       value: 'master'\n * //     },\n * //     idx: {\n * //       optional: true,\n * //       raw: '{?idx:number}',\n * //       type: 'number',\n * //       value: 3\n * //     }\n * //   }\n * // }\n *\n * @author \t\tOlivier Bossel<olivier.bossel@gmail.com>\n */\nexport default function parseSchema(url, schema) {\n  const rawSchemaString = schema;\n  const rawUrlString = url;\n\n  // remove query string\n  url = url.split('?')[0];\n\n  // get the pathname of the url\n  let pathname;\n  try {\n    pathname = new URL(url).pathname;\n  } catch (e) {\n    pathname = url;\n  }\n  if (pathname.slice(0, 1) === '/') pathname = pathname.slice(1);\n\n  // init the params object\n  const params = {};\n  const errors = {};\n  let match = true;\n\n  // split the schema\n  let schemaParts = schema.split('/');\n\n  // analyze all the schema parts\n  schemaParts = schemaParts\n    .map((part) => {\n      // check if is a param\n      if (part.slice(0, 1) === '{' && part.slice(-1) === '}') {\n        const isOptional = part.slice(0, 2) === '{?' || part.slice(-2) === '?}';\n        const isType = part.indexOf(':') !== -1;\n\n        let type = null;\n        let name = null;\n        if (isType) {\n          name = part.split(':')[0].slice(1);\n          type = part.split(':')[1].slice(0, -1);\n          if (name.slice(0, 1) === '?') name = name.slice(1);\n          if (type.slice(-1) === '?') type = type.slice(0, -1);\n        } else {\n          name = part.slice(1, -1);\n          if (name.slice(-1) === '?') name = name.slice(0, -1);\n          if (name.slice(0, 1) === '?') name = name.slice(1);\n        }\n\n        return {\n          name,\n          type,\n          raw: part,\n          optional: isOptional\n        };\n      }\n\n      // this is not a parameter so return as is\n      return part;\n    })\n    .filter((l) => l !== '');\n\n  schemaParts.forEach((part) => {\n    if (!part.name) return;\n    params[part.name] = {\n      ...part\n    };\n    delete params[part.name].name;\n  });\n\n  // loop on the schema to get the params values\n  // const pathname = url.pathname.slice(1);\n  const splitedPathname = pathname.split('/');\n\n  for (let i = 0; i < schemaParts.length; i++) {\n    // get the schema for this part\n    const schema = schemaParts[i];\n\n    // get the part to check\n    const part = splitedPathname[i];\n\n    // if it's not an object, mean that it's a simple string part\n    if (typeof schema !== 'object') {\n      if (part !== schema) match = false;\n      continue;\n    }\n\n    if (!part && !schema.optional) {\n      let errorObj = {\n        type: 'optional',\n        description: `This param \"${schema.name}\" cannot be null...`\n      };\n      errors[schema.name] = errorObj;\n      params[schema.name].error = errorObj;\n      match = false;\n      continue;\n    } else if (!part && schema.optional) {\n      params[schema.name].value = null;\n      continue;\n    }\n\n    // check that all correspond to the schema\n    if (schema.type) {\n      const type = schema.type;\n      if (type !== typeof __parseString(part)) {\n        match = false;\n        const errorObj = {\n          type: 'type',\n          requested: type,\n          passed: typeof __parseString(part),\n          description: `This param \"${\n            schema.name\n          }\" has to be a \"${type}\" but he's a \"${typeof __parseString(\n            part\n          )}\"...`\n        };\n        errors[schema.name] = errorObj;\n        params[schema.name].error = errorObj;\n        params[schema.name].value = __parseString(part);\n        continue;\n      }\n    }\n\n    // this part match the schema so we add it to the params\n    params[schema.name].value = __parseString(part);\n  }\n  // return the schema result\n  return {\n    errors: !Object.keys(errors).length ? null : errors,\n    params: !Object.keys(params).length ? null : params,\n    match,\n    schema: rawSchemaString,\n    url: rawUrlString\n  };\n}\n"
    ]
}
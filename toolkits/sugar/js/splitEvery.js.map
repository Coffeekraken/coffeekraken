{
    "version": 3,
    "sources": [
        "splitEvery.js"
    ],
    "names": [
        "__countLine",
        "require",
        "module",
        "exports",
        "splitEvery",
        "text",
        "every",
        "splitWords",
        "reg",
        "RegExp",
        "matchAll",
        "map",
        "o",
        "chunks",
        "split",
        "filter",
        "m",
        "undefined",
        "item",
        "finalChunks",
        "forEach",
        "chunk",
        "finalLines",
        "lineCount",
        "lastOpenedTag",
        "test",
        "substr",
        "length",
        "toAdd",
        "rest",
        "replace",
        "restLines",
        "words",
        "lines",
        "currentLine",
        "word",
        "i",
        "push",
        "l",
        "trim"
    ],
    "mappings": ";;AAAA,IAAMA,WAAW,GAAGC,OAAO,CAAC,aAAD,CAA3B;AAEA;;;;;;;;;;;;;;;;;;AAmBA;;;AAEAC,MAAM,CAACC,OAAP,GAAiB,SAASC,UAAT,CAAoBC,IAApB,EAA0BC,KAA1B,EAAiCC,UAAjC,EAAqD;AAAA,MAApBA,UAAoB;AAApBA,IAAAA,UAAoB,GAAP,KAAO;AAAA;;AACpE,MAAIA,UAAJ,EAAgB;AACd,QAAMC,GAAG,GAAG,IAAIC,MAAJ,eAAkBH,KAAlB,QAA4B,GAA5B,CAAZ;AACA,WAAO,CAAC,GAAGD,IAAI,CAACK,QAAL,CAAcF,GAAd,CAAJ,EAAwBG,GAAxB,CAA6BC,CAAD,IAAOA,CAAC,CAAC,CAAD,CAApC,CAAP;AACD,GAHD,MAGO;AACL,QAAMJ,IAAG,GAAG,IAAIC,MAAJ,kDAEV;AACA,OAHU,CAAZ,CADK,CAML;;;AACA,QAAII,MAAM,GAAGR,IAAI,CACdS,KADU,CACJN,IADI,EAEVO,MAFU,CAEFC,CAAD,IAAOA,CAAC,IAAI,EAAL,IAAWA,CAAC,IAAI,IAAhB,IAAwBA,CAAC,IAAIC,SAFjC,EAGVN,GAHU,CAGLO,IAAD,IAAU;AACb,aAAOA,IAAI,CAACJ,KAAL,CAAW,mBAAX,CAAP;AACD,KALU,CAAb;AAMA,QAAIK,WAAW,GAAG,EAAlB;AACAN,IAAAA,MAAM,CAACO,OAAP,CAAgBC,KAAD,IAAW;AACxBF,MAAAA,WAAW,GAAG,CAAC,GAAGA,WAAJ,EAAiB,GAAGE,KAApB,CAAd;AACD,KAFD;AAIA,QAAIC,UAAU,GAAG,CAAC,EAAD,CAAjB;AACA,QAAIC,SAAS,GAAG,CAAhB;AACA,QAAIC,aAAa,GAAG,IAApB;AAEAL,IAAAA,WAAW,CAACC,OAAZ,CAAqBF,IAAD,IAAU;AAC5B,UAAI,CAACA,IAAL,EAAW,OADiB,CAE5B;;AACA,UAAIV,IAAG,CAACiB,IAAJ,CAASP,IAAT,CAAJ,EAAoB;AAClB,YAAIA,IAAI,CAACQ,MAAL,CAAY,CAAZ,EAAe,CAAf,MAAsB,IAAtB,IAA8BR,IAAI,CAACQ,MAAL,CAAY,CAAZ,EAAe,CAAf,MAAsB,MAAxD,EAAgE;AAC9DF,UAAAA,aAAa,GAAGN,IAAhB;;AACA,cAAIA,IAAI,CAACQ,MAAL,CAAY,CAAZ,EAAe,CAAf,MAAsB,GAA1B,EAA+B;AAC7BF,YAAAA,aAAa,iBAAUA,aAAV,CAAb;AACD;AACF;;AAEDF,QAAAA,UAAU,CAACA,UAAU,CAACK,MAAX,GAAoB,CAArB,CAAV,IAAqCT,IAArC;AACA;AACD;;AACD,UAAIK,SAAS,GAAGL,IAAI,CAACS,MAAjB,GAA0BrB,KAA9B,EAAqC;AACnC;AACA,YAAMsB,KAAK,GAAGV,IAAI,CAACQ,MAAL,CAAY,CAAZ,EAAepB,KAAK,GAAGiB,SAAR,GAAoB,CAAnC,CAAd;AACAD,QAAAA,UAAU,CAACA,UAAU,CAACK,MAAX,GAAoB,CAArB,CAAV,IAAqCC,KAArC;AACA,YAAMC,IAAI,GAAGL,aAAa,GAAGN,IAAI,CAACY,OAAL,CAAaF,KAAb,EAAoB,EAApB,CAA7B,CAJmC,CAKnC;AACA;;AACA,YAAMG,SAAS,GAAG3B,UAAU,CAACyB,IAAD,EAAOvB,KAAP,CAA5B;AACAgB,QAAAA,UAAU,GAAG,CAAC,GAAGA,UAAJ,EAAgB,GAAGS,SAAnB,CAAb;AACAR,QAAAA,SAAS,GAAGvB,WAAW,CAACsB,UAAU,CAACA,UAAU,CAACK,MAAX,GAAoB,CAArB,CAAX,CAAvB;AACD,OAVD,MAUO;AACLJ,QAAAA,SAAS,IAAIL,IAAI,CAACS,MAAlB;AACAL,QAAAA,UAAU,CAACA,UAAU,CAACK,MAAX,GAAoB,CAArB,CAAV,IAAqCT,IAArC;AACD;AACF,KA5BD;AA8BA,WAAOI,UAAP,CApDK,CAsDL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAMU,KAAK,GAAG3B,IAAI,CAACS,KAAL,CAAW,GAAX,CAAd;AACA,QAAImB,KAAK,GAAG,EAAZ;AACA,QAAIC,WAAW,GAAG,EAAlB;AACAF,IAAAA,KAAK,CAACZ,OAAN,CAAc,CAACe,IAAD,EAAOC,CAAP,KAAa;AACzB,UAAIF,WAAW,CAACP,MAAZ,GAAqBQ,IAAI,CAACR,MAA1B,IAAoCrB,KAAxC,EAA+C;AAC7C4B,QAAAA,WAAW,IAAIC,IAAI,GAAG,GAAtB;;AACA,YAAIC,CAAC,KAAKJ,KAAK,CAACL,MAAN,GAAe,CAAzB,EAA4B;AAC1BM,UAAAA,KAAK,CAACI,IAAN,CAAWH,WAAX;AACD;AACF,OALD,MAKO,IAAIE,CAAC,GAAGJ,KAAK,CAACL,MAAN,GAAe,CAAvB,EAA0B;AAC/BM,QAAAA,KAAK,CAACI,IAAN,CAAWH,WAAX;AACAA,QAAAA,WAAW,GAAGC,IAAI,GAAG,GAArB;AACD,OAHM,MAGA;AACLF,QAAAA,KAAK,CAACI,IAAN,CAAWH,WAAX;AACAD,QAAAA,KAAK,CAACI,IAAN,CAAWF,IAAX;AACD;AACF,KAbD;AAcAF,IAAAA,KAAK,GAAGA,KAAK,CAACtB,GAAN,CAAW2B,CAAD,IAAOA,CAAC,CAACC,IAAF,EAAjB,CAAR;AACAN,IAAAA,KAAK,GAAGA,KAAK,CAAClB,MAAN,CAAcuB,CAAD,IAAOA,CAAC,KAAK,EAA1B,CAAR;AACA,WAAOL,KAAP;AACD;AACF,CAvFD",
    "sourcesContent": [
        "const __countLine = require('./countLine');\n\n/**\n * @name                          splitEvery\n * @namespace           sugar.js.string\n * @type                          Function\n *\n * Split a string every n chars either by taking care of not spliting the words, or by simply spliting without any attention to that...\n *\n * @param               {String}Â                  text                      The text to split\n * @param               {Number}                  every                     How many characters to split the text\n * @param               {Boolean}                 [splitWords=false]        If you want to split the words or not...\n * @return              {Array}                                             An array of the splited text parts\n *\n * @example           js\n * const splitEvery = require('@coffeekraken/node/string/splitEvery');\n * splitEvery('Hello World', 2, true); // => ['He','ll','o ','Wo','rl','d']\n *\n * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)\n */\n\n// TODO: Add support for special characters like terminal colors, html tags, etc...\n\nmodule.exports = function splitEvery(text, every, splitWords = false) {\n  if (splitWords) {\n    const reg = new RegExp(`.{1,${every}}`, 'g');\n    return [...text.matchAll(reg)].map((o) => o[0]);\n  } else {\n    const reg = new RegExp(\n      `(\\\\x1B\\[[0-9;]+m)|(\\\\x1B\\[39m])|(<[a-zA-Z\\s/]+>)`,\n      // `(?:(?:\\x1B\\[[\\d;]*m)*[^\\x1B]){1,${every}}(?:(?:\\x1B\\[[\\d;]*m)+$)?`,\n      'g'\n    );\n    // const reg = new RegExp(`(?:(?:\\033\\[[0-9;]*m)*.?){1,${every}}`, 'g');\n    let chunks = text\n      .split(reg)\n      .filter((m) => m != '' && m != null && m != undefined)\n      .map((item) => {\n        return item.split(/(\\s{1,99999999})/g);\n      });\n    let finalChunks = [];\n    chunks.forEach((chunk) => {\n      finalChunks = [...finalChunks, ...chunk];\n    });\n\n    let finalLines = [''];\n    let lineCount = 0;\n    let lastOpenedTag = null;\n\n    finalChunks.forEach((item) => {\n      if (!item) return;\n      // console.log(item, reg.test(item));\n      if (reg.test(item)) {\n        if (item.substr(0, 2) !== '</' || item.substr(0, 4) !== '\\x1B') {\n          lastOpenedTag = item;\n          if (item.substr(0, 1) !== '<') {\n            lastOpenedTag = `\\x1B${lastOpenedTag}`;\n          }\n        }\n\n        finalLines[finalLines.length - 1] += item;\n        return;\n      }\n      if (lineCount + item.length > every) {\n        // console.log('CHECK', item);\n        const toAdd = item.substr(0, every - lineCount - 1);\n        finalLines[finalLines.length - 1] += toAdd;\n        const rest = lastOpenedTag + item.replace(toAdd, '');\n        // if (toAdd.slice(-1) !== ' ' && rest.slice(0, 1) !== ' ')\n        //   finalLines[finalLines.length - 1] += '-';\n        const restLines = splitEvery(rest, every);\n        finalLines = [...finalLines, ...restLines];\n        lineCount = __countLine(finalLines[finalLines.length - 1]);\n      } else {\n        lineCount += item.length;\n        finalLines[finalLines.length - 1] += item;\n      }\n    });\n\n    return finalLines;\n\n    // const arr = [];\n    // [].forEach.call(chunks, function (a) {\n    //   if (!/^(?:\\033\\[[0-9;]*m)*$/.test(a)) {\n    //     arr.push(a);\n    //   }\n    // });\n    // console.log(arr);\n\n    const words = text.split(' ');\n    let lines = [];\n    let currentLine = '';\n    words.forEach((word, i) => {\n      if (currentLine.length + word.length <= every) {\n        currentLine += word + ' ';\n        if (i === words.length - 1) {\n          lines.push(currentLine);\n        }\n      } else if (i < words.length - 1) {\n        lines.push(currentLine);\n        currentLine = word + ' ';\n      } else {\n        lines.push(currentLine);\n        lines.push(word);\n      }\n    });\n    lines = lines.map((l) => l.trim());\n    lines = lines.filter((l) => l !== '');\n    return lines;\n  }\n};\n"
    ]
}
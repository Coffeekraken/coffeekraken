@use 'sass:meta';
@use 'sass:math';

@mixin init-font() {

  $fonts: setting("fonts");

  @each $font-name, $font in $fonts {
    @if meta.type-of($font) == string {
      $font: map-get($fonts, $font);
    }
    @if not map-get($font, family) {
      $font: map-set($font, family, $font-name);
    }
    $font: map-remove($font, cap-height);
    @if map-get($font, import) {
      @import url('#{map-get($font, import)}');
    } @else if map-get($font, src) {
      @include font-face(
        $font-family: map-get($font, font-family),
        $src: map-get($font, src),
        $extensions: map-get($font, extensions),
        $font-weight: map-get($font, font-weight),
        $font-style: map-get($font, font-style),
        $font-display: map-get($font, font-display)
      );
    } @else {
      $ff: map-get($font, font-family);
      $fs: map-get($font, font-style);
      $fw: map-get($font, font-weight);
      $fd: map-get($font, font-display);
      /**
       * @name   			#{$font-name}
       * @styleguide 		Fonts / Faces
       * @display 		font
       * @font-family 	#{$ff}
       * @font-style 		#{$fs}
       * @font-weight 	#{$fw}
       * @font-display    #{$fd}
       */
    }
  }

  html {
    $base-font-size: setting("typography.font-size");
    $base-font-sizes: setting("typography.font-sizes");
    font-size: $base-font-size;
    color: color(text);
    @if meta.type-of($base-font-sizes) == map {
      @each $size, $media in $base-font-sizes {
        @include media($media...) {
          font-size: $size;
        }
      }
    }
  }

}

@mixin createCss(
  $lineHeight,
  $fontSize,
  $fontMetrics  
) {

  // $toScale: (value: number) => value / fontSize;

  $absoluteDescent: Math.abs(fontMetrics.descent);
  $capHeightScale: fontMetrics.capHeight / fontMetrics.unitsPerEm;
  $descentScale: absoluteDescent / fontMetrics.unitsPerEm;
  $ascentScale: fontMetrics.ascent / fontMetrics.unitsPerEm;
  $lineGapScale: fontMetrics.lineGap / fontMetrics.unitsPerEm;

  $contentArea =
    fontMetrics.ascent + fontMetrics.lineGap + absoluteDescent;
  $lineHeightScale: contentArea / fontMetrics.unitsPerEm;
  $lineHeightNormal: lineHeightScale * fontSize;

  $specifiedLineHeightOffset: lineHeight
    ? (lineHeightNormal - lineHeight) / 2
    : 0;

  $leadingTrim: (value: number) =>
    value - toScale(specifiedLineHeightOffset) + toScale(preventCollapse);

  return {
    fontSize: `${roundTo(fontSize, PRECISION)}px`,
    lineHeight: lineHeight ? `${roundTo(lineHeight, PRECISION)}px` : 'normal',
    padding: `${preventCollapse}px 0`,
    '::before': {
      content: "''",
      marginTop: `${roundTo(
        leadingTrim(ascentScale - capHeightScale + lineGapScale / 2) * -1,
        PRECISION,
      )}em`,
      display: 'block',
      height: 0,
    },
    '::after': {
      content: "''",
      marginBottom: `${roundTo(
        leadingTrim(descentScale + lineGapScale / 2) * -1,
        PRECISION,
      )}em`,
      display: 'block',
      height: 0,
    },
  };
}

@mixin capsize(
  $capHeight,
  $leading,
  $fontMetrics,
  $fontSize,
  $lineGap
) {

  @if $leading and $lineGap {
    @error 'Only a single line height style can be provided. Please pass either `lineGap` OR `leading`.';
  }

  @if $capHeight and $fontSize {
    @error 'Please pass either `capHeight` OR `fontSize`, not both.';
  }

  $capHeightScale: map-get($fontMetrics, capHeight) / map-get($fontMetrics, .unitsPerEm);

  $specifiedFontSize;
  $specifiedCapHeight;

  @if $capHeight {
    $specifiedFontSize: $capHeight / $capHeightScale;
    $specifiedCapHeight: $capHeight;
  } @else if $fontSize {
    $specifiedFontSize: $fontSize;
    $specifiedCapHeight: $fontSize * $capHeightScale;
  } @else {
    @error 'Please pass either `capHeight` OR `fontSize`.';
  }

  $specifiedLineHeight;

  @if $lineGap {
    $specifiedLineHeight: $specifiedCapHeight + $lineGap;
  } @else if $leading {
    $specifiedLineHeight: $leading;
  }

  // return createCss({
  //   lineHeight: specifiedLineHeight,
  //   fontSize: specifiedFontSize,
  //   fontMetrics,
  // });

}
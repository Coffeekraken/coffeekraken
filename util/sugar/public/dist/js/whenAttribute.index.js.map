{"version":3,"sources":["webpack:///./src/js/dom/whenAttribute.js","webpack:///./src/js/string/autoCast.js"],"names":["whenAttribute","elm","attrName","checkFn","Promise","resolve","reject","hasAttribute","value","getAttribute","obs","subscribe","mutation","attributeName","target","oldValue","unsubscribe","autoCast","string","substr","length","presumedNumber","parseFloat","isNaN","toString","window","obj","eval","e"],"mappings":";;;;;;;;;;;;;;;;;AAAA;;AACA;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2Be,SAASA,aAAT,CAAuBC,GAAvB,EAA4BC,QAA5B,EAAsCC,OAAO,GAAG,IAAhD,EAAsD;AACnE,SAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,QAAIL,GAAG,CAACM,YAAJ,CAAiBL,QAAjB,CAAJ,EAAgC;AAC9B,YAAMM,KAAK,GAAG,uBAAWP,GAAG,CAACQ,YAAJ,CAAiBP,QAAjB,CAAX,CAAd;;AACA,UAAIC,OAAO,IAAIA,OAAO,CAACK,KAAD,EAAQA,KAAR,CAAtB,EAAsC;AACpCH,eAAO,CAACG,KAAD,CAAP;AACA;AACD,OAHD,MAGO,IAAI,CAACL,OAAL,EAAc;AACnBE,eAAO,CAACG,KAAD,CAAP;AACA;AACD;AACF;;AAED,UAAME,GAAG,GAAG,mCAAuBT,GAAvB,EAA4BU,SAA5B,CAAsCC,QAAQ,IAAI;AAC5D,UAAIA,QAAQ,CAACC,aAAT,KAA2BX,QAA/B,EAAyC;AACvC,cAAMM,KAAK,GAAG,uBACZI,QAAQ,CAACE,MAAT,CAAgBL,YAAhB,CAA6BG,QAAQ,CAACC,aAAtC,CADY,CAAd;;AAGA,YAAIV,OAAO,IAAIA,OAAO,CAACK,KAAD,EAAQI,QAAQ,CAACG,QAAjB,CAAtB,EAAkD;AAChDV,iBAAO,CAACG,KAAD,CAAP;AACAE,aAAG,CAACM,WAAJ;AACD,SAHD,MAGO,IAAI,CAACb,OAAL,EAAc;AACnBE,iBAAO,CAACG,KAAD,CAAP;AACAE,aAAG,CAACM,WAAJ;AACD;AACF;AACF,KAbW,CAAZ;AAcD,GA1BM,CAAP;AA2BD;;;;;;;;;;;;;;;;;;;;;AC1DD;;;;;;;;;;;;;;;;;;AAkBe,SAASC,QAAT,CAAkBC,MAAlB,EAA0B;AACvC;AACA,MAAI,OAAOA,MAAP,KAAkB,QAAtB,EAAgC,OAAOA,MAAP,CAFO,CAIvC;;AACA,MAAIA,MAAM,CAACC,MAAP,CAAc,CAAd,EAAiB,CAAjB,MAAwB,GAAxB,IAA+BD,MAAM,CAACC,MAAP,CAAc,CAAC,CAAf,MAAsB,GAAzD,EAA8D;AAC5D,WAAOD,MAAM,CAACC,MAAP,CAAc,CAAd,EAAiBD,MAAM,CAACE,MAAP,GAAgB,CAAjC,CAAP;AACD,GAPsC,CASvC;AACA;;;AACA,QAAMC,cAAc,GAAGC,UAAU,CAACJ,MAAD,CAAjC;;AACA,MAAI,CAACK,KAAK,CAACF,cAAD,CAAV,EAA4B;AAC1B,QAAIA,cAAc,CAACG,QAAf,OAA8BN,MAAlC,EAA0C;AACxC,aAAOG,cAAP;AACD;AACF,GAhBsC,CAkBvC;;;AACA,MAAII,MAAM,CAACP,MAAD,CAAV,EAAoB;AAClB,WAAOA,MAAP;AACD,GArBsC,CAuBvC;AACA;AACA;;;AACA,MAAI;AACF,UAAMQ,GAAG,GAAGC,IAAI,CAAE,IAAGT,MAAO,GAAZ,CAAhB;AACA,WAAOQ,GAAP;AACD,GAHD,CAGE,OAAOE,CAAP,EAAU;AACV;AACA,WAAOV,MAAP;AACD;AACF","file":"whenAttribute.index.js","sourcesContent":["import __attributesObservable from \"./attributesObservable\";\nimport __autoCast from \"../string/autoCast\";\n\n/**\n * @name      whenAttribute\n * @namespace     sugar.js.dom\n * @type      Function\n *\n * Resolve a promise when the wanted attribute on the passed HTMLElement exist or pass the check function provided\n *\n * @param \t\t{HTMLElement} \t\t\t\telm \t\t\t\tThe HTMLElement on which to monitor the property\n * @param \t\t{String} \t\t\t\t\tattribute \t\t\tThe attribute to monitor\n * @param \t\t{Function} \t\t\t\t\t[checkFn=null] \t\tAn optional function to check the attribute. The promise is resolved when this function return true\n * @return \t\t(Promise) \t\t\t\t\t\t\t\t\t\tThe promise that will be resolved when the attribute exist on the element (and that it passes the checkFn)\n *\n * @example \tjs\n * import whenAttribute from '@coffeekraken/sugar/js/dom/whenAttribute'\n * whenAttribute(myCoolHTMLElement, 'value').then((value) => {\n * \t\t// the value attribute exist on the element\n * });\n * // with a checkFn\n * whenAttribute(myCoolHTMLElement, 'value', (newVal, oldVal) => {\n * \t\t// make sure the value is a number\n * \t\treturn typeof(newVal) === 'number';\n * }).then((value) => {\n * \t\t// do something with your number value...\n * });\n *\n * @author \t\tOlivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)\n */\nexport default function whenAttribute(elm, attrName, checkFn = null) {\n  return new Promise((resolve, reject) => {\n    if (elm.hasAttribute(attrName)) {\n      const value = __autoCast(elm.getAttribute(attrName));\n      if (checkFn && checkFn(value, value)) {\n        resolve(value);\n        return;\n      } else if (!checkFn) {\n        resolve(value);\n        return;\n      }\n    }\n\n    const obs = __attributesObservable(elm).subscribe(mutation => {\n      if (mutation.attributeName === attrName) {\n        const value = __autoCast(\n          mutation.target.getAttribute(mutation.attributeName)\n        );\n        if (checkFn && checkFn(value, mutation.oldValue)) {\n          resolve(value);\n          obs.unsubscribe();\n        } else if (!checkFn) {\n          resolve(value);\n          obs.unsubscribe();\n        }\n      }\n    });\n  });\n}\n","/**\n * @name        autoCast\n * @namespace       sugar.js.string\n * @type      Function\n *\n * Auto cast the string into the correct variable type\n *\n * @param    {String}    string    The string to auto cast\n * @return    {Mixed}    The casted value\n *\n * @example    js\n * import autoCast from '@coffeekraken/sugar/js/strings/autoCast'\n * autoCast('12') // => 12\n * autoCast('window.HTMLElement') // => HTMLElement\n * autoCast('{\"hello\":\"world\"}') // {hello:'world'}\n *\n * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)\n */\nexport default function autoCast(string) {\n  // if the passed string is not a string, return the value\n  if (typeof string !== \"string\") return string;\n\n  // handle the single quotes strings like '\"hello world\"'\n  if (string.substr(0, 1) === \"'\" && string.substr(-1) === \"'\") {\n    return string.substr(1, string.length - 2);\n  }\n\n  // number\n  // before the window check cause window['0'] correspond to something\n  const presumedNumber = parseFloat(string);\n  if (!isNaN(presumedNumber)) {\n    if (presumedNumber.toString() === string) {\n      return presumedNumber;\n    }\n  }\n\n  // avoid getting item from the window object\n  if (window[string]) {\n    return string;\n  }\n\n  // try to eval the passed string\n  // if no exception, mean that it's a valid\n  // js variable type\n  try {\n    const obj = eval(`(${string})`);\n    return obj;\n  } catch (e) {\n    // assume that the string passed is a string\n    return string;\n  }\n}\n"],"sourceRoot":""}
{"version":3,"sources":["webpack:////Users/olivierbossel/data/web/coffeekraken/coffeekraken/util/sugar/src/js/dom/observeAttributes.js","webpack:////Users/olivierbossel/data/web/coffeekraken/coffeekraken/util/sugar/src/js/dom/whenAttribute.js","webpack:////Users/olivierbossel/data/web/coffeekraken/coffeekraken/util/sugar/src/js/string/autoCast.js"],"names":["target","settings","__SPromise","resolve","reject","trigger","cancel","mutationObserver","MutationObserver","mutations","mutedAttrs","forEach","mutation","attributeName","observe","attributes","on","disconnect","start","whenAttribute","elm","attrName","checkFn","Promise","hasAttribute","value","__autoCast","getAttribute","obs","__observeAttribute","then","oldValue","autoCast","string","substr","length","presumedNumber","parseFloat","isNaN","toString","window","obj","eval","e"],"mappings":"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","file":"whenAttribute.index.js","sourcesContent":["import __SPromise from '../promise/SPromise';\n\n/**\n * @name        observeAttributes\n * @namespace       sugar.js.dom\n * @type      Function\n *\n * Observe attributes on an HTMLElement and get mutations through the SPromise instance\n *\n * @param \t\t{HTMLElement} \t\t\t\t\ttarget \t\tThe element to observe\n * @param \t\t{MutationObserverInit} \t\t\tsettings \tThe mutation observer settings\n * @return \t\t{SPromise} \t\t\t\t\t\t\t\tThe SPromise throught which you can have the mutations using the \"then\" callback\n *\n * @example  \tjs\n * import observeAttributes from 'sugarcss/js/dom/observeAttributes'\n * const observer = observeAttributes(myCoolHTMLElement).then(mutation => {\n * \t\t// do something with the mutation\n * });\n * // cancel the observer\n * observer.cancel();\n *\n * @see \t\thttps://developer.mozilla.org/en/docs/Web/API/MutationObserver\n * @author \t\tOlivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)\n */\nexport default function (target, settings = {}) {\n  return new __SPromise((resolve, reject, trigger, cancel) => {\n\n    // create a new observer\n    const mutationObserver = new MutationObserver(mutations => {\n      let mutedAttrs = {};\n      // loop on mutations\n      mutations.forEach(mutation => {\n        // push mutation\n        if (!mutedAttrs[mutation.attributeName]) {\n          trigger('then', mutation);\n          mutedAttrs[mutation.attributeName] = true;\n        }\n      });\n      mutedAttrs = {};\n    });\n    mutationObserver.observe(target, {\n      attributes: true,\n      // characterData : true,\n      ...settings\n    });\n  }).on('cancel,finally', () => {\n    mutationObserver.disconnect();\n  }).start();\n}\n\n/**\n * List of attributes to observe\n * @setting\n * @name \t\tattributes\n * @type \t\t{Array}\n * @default \tnull\n */\n","import __autoCast from '../string/autoCast';\nimport __observeAttribute from './observeAttributes';\n\n/**\n * @name      whenAttribute\n * @namespace     sugar.js.dom\n * @type      Function\n *\n * Resolve a promise when the wanted attribute on the passed HTMLElement exist or pass the check function provided\n *\n * @param \t\t{HTMLElement} \t\t\t\telm \t\t\t\tThe HTMLElement on which to monitor the property\n * @param \t\t{String} \t\t\t\t\tattribute \t\t\tThe attribute to monitor\n * @param \t\t{Function} \t\t\t\t\t[checkFn=null] \t\tAn optional function to check the attribute. The promise is resolved when this function return true\n * @return \t\t(Promise) \t\t\t\t\t\t\t\t\t\tThe promise that will be resolved when the attribute exist on the element (and that it passes the checkFn)\n *\n * @example \tjs\n * import whenAttribute from '@coffeekraken/sugar/js/dom/whenAttribute'\n * whenAttribute(myCoolHTMLElement, 'value').then((value) => {\n * \t\t// the value attribute exist on the element\n * });\n * // with a checkFn\n * whenAttribute(myCoolHTMLElement, 'value', (newVal, oldVal) => {\n * \t\t// make sure the value is a number\n * \t\treturn typeof(newVal) === 'number';\n * }).then((value) => {\n * \t\t// do something with your number value...\n * });\n *\n * @author \t\tOlivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)\n */\nexport default function whenAttribute(elm, attrName, checkFn = null) {\n  return new Promise((resolve, reject) => {\n    if (elm.hasAttribute(attrName)) {\n      const value = __autoCast(elm.getAttribute(attrName));\n      if (checkFn && checkFn(value, value)) {\n        resolve(value);\n        return;\n      } else if (!checkFn) {\n        resolve(value);\n        return;\n      }\n    }\n\n    const obs = __observeAttribute(elm).then((mutation) => {\n      if (mutation.attributeName === attrName) {\n        const value = __autoCast(\n          mutation.target.getAttribute(mutation.attributeName)\n        );\n        if (checkFn && checkFn(value, mutation.oldValue)) {\n          resolve(value);\n          obs.cancel();\n        } else if (!checkFn) {\n          resolve(value);\n          obs.cancel();\n        }\n      }\n    });\n  });\n}\n","/**\n * @name        autoCast\n * @namespace       sugar.js.string\n * @type      Function\n *\n * Auto cast the string into the correct variable type\n *\n * @param    {String}    string    The string to auto cast\n * @return    {Mixed}    The casted value\n *\n * @example    js\n * import autoCast from '@coffeekraken/sugar/js/strings/autoCast'\n * autoCast('12') // => 12\n * autoCast('window.HTMLElement') // => HTMLElement\n * autoCast('{\"hello\":\"world\"}') // {hello:'world'}\n *\n * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)\n */\nexport default function autoCast(string) {\n  // if the passed string is not a string, return the value\n  if (typeof string !== \"string\") return string;\n\n  // handle the single quotes strings like '\"hello world\"'\n  if (string.substr(0, 1) === \"'\" && string.substr(-1) === \"'\") {\n    return string.substr(1, string.length - 2);\n  }\n\n  // number\n  // before the window check cause window['0'] correspond to something\n  const presumedNumber = parseFloat(string);\n  if (!isNaN(presumedNumber)) {\n    if (presumedNumber.toString() === string) {\n      return presumedNumber;\n    }\n  }\n\n  // avoid getting item from the window object\n  if (window[string]) {\n    return string;\n  }\n\n  // try to eval the passed string\n  // if no exception, mean that it's a valid\n  // js variable type\n  try {\n    const obj = eval(`(${string})`);\n    return obj;\n  } catch (e) {\n    // assume that the string passed is a string\n    return string;\n  }\n}\n"],"sourceRoot":""}